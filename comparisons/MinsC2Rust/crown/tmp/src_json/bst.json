{
    "bst_remove": "void bst_remove(int val, struct bst* bst) {\n\n  assert(bst);\n\n  /*\n   * We remove val by using our subtree removal function starting with the\n   * subtree rooted at bst->root (i.e. the whole tree).\n   */\n  bst->root = _bst_subtree_remove(val, bst->root);\n\n",
    "_bst_subtree_insert": "struct bst_node* _bst_subtree_insert(int val, struct bst_node* n) {\n\n  if (n == NULL) {\n\n    /*\n     * If n is NULL, we know we've reached a place to insert val, so we\n     * create a new node holding val and return it.\n     */\n    return _bst_node_create(val);\n\n  } else if (val < n->val) {\n\n    /*\n     * If val is less than the value at n, we insert val in n's left subtree\n     * (somewhere) and update n->left to point to the modified subtree (with\n     * val inserted).\n     */\n    n->left = _bst_subtree_insert(val, n->left);\n\n  } else {\n\n    /*\n     * If val is greater than or equal to the value at n, we insert val in n's\n     * right subtree (somewhere) and update n->right to point to the modified\n     * subtree (with val inserted).\n     */\n    n->right = _bst_subtree_insert(val, n->right);\n\n  }\n\n  /*\n   * For the else if and else conditions, the subtree rooted at n has already\n   * been modified (by setting n->left or n->right above), so we can just\n   * return n here.\n   */\n  return n;\n\n",
    "bst_create": "struct bst* bst_create() {\n  struct bst* bst = malloc(sizeof(struct bst));\n  assert(bst);\n  bst->root = NULL;\n  return bst;\n}\n",
    "bst_free": "void bst_free(struct bst* bst) {\n  assert(bst);\n\n  /*\n   * Assume that bst_remove() frees each node it removes and use it to free\n   * all of the nodes in the tree.\n   */\n  while (!bst_isempty(bst)) {\n    bst_remove(bst->root->val, bst);\n  }\n\n  free(bst);\n}\n",
    "_bst_node_create": "struct bst_node* _bst_node_create(int val) {\n  struct bst_node* n = malloc(sizeof(struct bst_node));\n  assert(n);\n  n->val = val;\n  n->left = n->right = NULL;\n  return n;\n}\n",
    "bst_contains": "int bst_contains(int val, struct bst* bst) {\n\n  assert(bst);\n\n  // Iteratively search for val in bst.\n  struct bst_node* cur = bst->root;\n  while (cur != NULL) {\n\n    if (val == cur->val) {\n\n      // We found the value we're looking for in cur.\n      return 1;\n\n    } else if (val < cur->val) {\n\n      /*\n       * The value we're looking for is less than the value at cur, so we\n       * branch left.\n       */\n      cur = cur->left;\n\n    } else {\n\n      /*\n       * The value we're looking for is greater than or equal to the value at\n       * cur, so we branch right.\n       */\n       cur = cur->right;\n\n    }\n\n  }\n\n  /*\n   * If we make it to a leaf node (i.e. cur is NULL), we didn't find what we\n   * were looking for.\n   */\n  return 0;\n}\n",
    "bst_isempty": "int bst_isempty(struct bst* bst) {\n  assert(bst);\n  return bst->root == NULL;\n}\n",
    "_bst_subtree_min_val": "int _bst_subtree_min_val(struct bst_node* n) {\n  /*\n   * The minimum value in any subtree is just the leftmost value.  Keep going\n   * left till we get there.\n   */\n  while (n->left != NULL) {\n    n = n->left;\n  }\n  return n->val;\n}\n",
    "bst_insert": "void bst_insert(int val, struct bst* bst) {\n\n  assert(bst);\n\n  /*\n   * We insert val by using our subtree insertion function starting with the\n   * subtree rooted at bst->root (i.e. the whole tree).\n   */\n  bst->root = _bst_subtree_insert(val, bst->root);\n\n",
    "_bst_subtree_remove": "struct bst_node* _bst_subtree_remove(int val, struct bst_node* n) {\n\n  if (n == NULL) {\n\n    /*\n     * If n is NULL, that means we've reached a leaf node without finding\n     * the value we wanted to remove.  The tree won't be modified.\n     */\n    return NULL;\n\n  } else if (val < n->val) {\n\n    /*\n     * If val is less than n, remove val from n's left subtree and update\n     * n->left to point to the modified subtree (with val removed).  Return n,\n     * whose subtree itself has now been modified.\n     */\n    n->left = _bst_subtree_remove(val, n->left);\n    return n;\n\n  } else if (val > n->val) {\n\n    /*\n     * If val is greater than n, remove val from n's right subtree and update\n     * n->right to point to the modified subtree (with val removed).  Return n,\n     * whose subtree itself has now been modified.\n     */\n    n->right = _bst_subtree_remove(val, n->right);\n    return n;\n\n  } else {\n\n    /*\n     * If we've reached this point, we've found a node with value val.  We\n     * need to remove this node from the tree, and the way we do that will\n     * differ based on whether the node has 0, 1, or 2 children.\n     */\n    if (n->left != NULL && n->right != NULL) {\n\n      /*\n       * If n has 2 children, we replace the value at n with the value at n's\n       * in-order successor node, which is the minimum value in n's right\n       * subtree.  Then we recursively remove n's in-order successor node from\n       * the tree (specifically from n's right subtree).\n       */\n      n->val = _bst_subtree_min_val(n->right);\n      n->right = _bst_subtree_remove(n->val, n->right);\n      return n;\n\n    } else if (n->left != NULL) {\n\n      /*\n       * If n has only a left child, we simply delete n by freeing it and\n       * returning the left child node so that it becomes the new child of\n       * n's parent via the recursion.\n       */\n      struct bst_node* left_child = n->left;\n      free(n);\n      return left_child;\n\n    } else if (n->right != NULL) {\n\n      /*\n       * If n has only a right child, we simply delete n by freeing it and\n       * returning the right child node so that it becomes the new child of\n       * n's parent via the recursion.\n       */\n      struct bst_node* right_child = n->right;\n      free(n);\n      return right_child;\n\n    } else {\n\n      /*\n       * Otherwise, n has no children, and we can simply free it and return\n       * NULL so that n's parent will lose n as a child via the recursion.\n       */\n      free(n);\n      return NULL;\n\n",
    "extra": "{'bst': 'struct bst {\\n  struct bst_node* root;\\n};', 'bst_node': 'struct bst_node {\\n  int val;\\n  struct bst_node* left;\\n  struct bst_node* right;\\n};', '__BST_H': '#define __BST_H'} extract_info: [#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\n/*\n * A definition for a binary search tree implementation.\n */\n\n#ifndef __BST_H\n#define __BST_H\n\n/*\n * Structure used to represent a binary search tree.\n */\nstruct bst;\n\n/*\n * Creates a new, empty binary search tree and returns a pointer to it.\n */\nstruct bst* bst_create();\n\n/*\n * Free the memory associated with a binary search tree.\n *\n * Params:\n *   bst - the binary search tree to be destroyed\n */\nvoid bst_free(struct bst* bst);\n\n/*\n * Returns 1 if the given binary search tree is empty or 0 otherwise.\n *\n * Params:\n *   bst - the binary search tree whose emptiness is to be checked\n */\nint bst_isempty(struct bst* bst);\n\n/*\n * Inserts a given value into an existing binary search tree.\n *\n * Params:\n *   val - the value to be inserted into the tree\n *   bst - the binary search tree into which to insert val\n */\nvoid bst_insert(int val, struct bst* bst);\n\n/*\n * Removes a given value from an existing binary search tree.  If the\n * specified value is not contained in the specified tree, the tree is not\n * modified.\n *\n * Params:\n *   val - the value to be removed from the tree\n *   bst - the binary search tree from which to remove val\n */\nvoid bst_remove(int val, struct bst* bst);\n\n/*\n * Determines whether a binary search tree contains a given value.\n *\n * Params:\n *   val - the value to be found in the tree\n *   bst - the binary search tree in which to search for val\n *\n * Return:\n *   Returns 1 if bst contains val or 0 otherwise.\n */\nint bst_contains(int val, struct bst* bst);\n\n\n#endif\n\n/*\n * This structure represents a single node in a BST.\n */\nstruct bst_node {\n  int val;\n  struct bst_node* left;\n  struct bst_node* right;\n};\n\n\n/*\n * This structure represents an entire BST.  Note that we only need a\n * reference to the root node of the tree.\n */\nstruct bst {\n  struct bst_node* root;\n};\n\n\n\n\n\n\n\n\n/*\n * Helper function to generate a single BST node containing a given value.\n */\n\n\n/*\n * Helper function to insert a given value into a subtree of a BST rooted at\n * a given node.  Operates recursively by determining into which subtree (left\n * or right) under the given node the value should be inserted and performing\n * the insertion on that subtree.\n *\n * Returns the root of the given subtree, modified to contain a new node with\n * the specified value.\n */\n}\n\n\n}\n\n\n/*\n * Helper function to return the minimum value in a subtree of a BST.\n */\n\n\n/*\n * Helper function to remove a given value from a subtree of a BST rooted at\n * a specified node.  Operates recursively by figuring out whether val is in\n * the left or the right subtree of the specified node and performing the\n * remove operation on that subtree.\n *\n * Returns the potentially new root of the given subtree, modified to have\n * the specified value removed.\n */\n    }\n\n  }\n\n}\n\n\n}\n\n\n]"
}