{
    "test_parse_url": "void test_parse_url() {\n    URL_PARTS url_parts;\n\n    // Test case 1: Basic HTTP URL\n    assert(ParseURL(\"http://sullewarehouse.com/login\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"http\") == 0);\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strlen(url_parts.port) == 0); // No port specified\n    assert(strcmp(url_parts.path, \"/login\") == 0);\n    assert(strlen(url_parts.query) == 0); // No query\n    assert(strlen(url_parts.fragment) == 0); // No fragment\n\n    // Test case 2: HTTPS URL with port\n    assert(ParseURL(\"https://sullewarehouse.com:1000/login\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"https\") == 0);\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strcmp(url_parts.port, \"1000\") == 0);\n    assert(strcmp(url_parts.path, \"/login\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 3: URL with query parameters\n    assert(ParseURL(\"https://sullewarehouse.com:1000/api/get?username=myuser\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"https\") == 0);\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strcmp(url_parts.port, \"1000\") == 0);\n    assert(strcmp(url_parts.path, \"/api/get\") == 0);\n    assert(strcmp(url_parts.query, \"?username=myuser\") == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 4: URL without scheme\n    assert(ParseURL(\"sullewarehouse.com/register\", &url_parts));\n    assert(strlen(url_parts.scheme) == 0); // No scheme\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strlen(url_parts.port) == 0);\n    assert(strcmp(url_parts.path, \"/register\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 5: IPv6 URL\n    assert(ParseURL(\"http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]/newpage\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"http\") == 0);\n    assert(strcmp(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\") == 0);\n    assert(strlen(url_parts.port) == 0);\n    assert(strcmp(url_parts.path, \"/newpage\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 6: IPv6 URL with port\n    assert(ParseURL(\"https://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:2678/blog\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"https\") == 0);\n    assert(strcmp(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\") == 0);\n    assert(strcmp(url_parts.port, \"2678\") == 0);\n    assert(strcmp(url_parts.path, \"/blog\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    printf(\"All tests passed!\\n\");\n}\n",
    "main": "int main() {\n    test_parse_url();\n    return 0;\n}",
    "extra": "{'URL_PARTS': '} URL_PARTS;', 'MAX_URL_AUTHORITY_LEN': '#define MAX_URL_AUTHORITY_LEN 512', 'MAX_URL_FRAGMENT_LEN': '#define MAX_URL_FRAGMENT_LEN 256', 'MAX_URL_PATH_LEN': '#define MAX_URL_PATH_LEN 1024', 'MAX_URL_PORT_LEN': '#define MAX_URL_PORT_LEN 64', 'MAX_URL_QUERY_LEN': '#define MAX_URL_QUERY_LEN 1024', 'MAX_URL_SCHEME_LEN': '#define MAX_URL_SCHEME_LEN 32', 'URL_PARSER_H': '#define URL_PARSER_H'} extract_info: [#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n//\n// Copyright (c) 2023 Brian Sullender\n// All rights reserved.\n//\n// This source code is licensed under the terms provided in the README file.\n//\n// https://github.com/b-sullender/url-parser\n//\n\n#ifndef URL_PARSER_H\n#define URL_PARSER_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n// Maximum scheme length\n#define MAX_URL_SCHEME_LEN 32\n// Maximum authority length\n#define MAX_URL_AUTHORITY_LEN 512\n// Maximum port length\n#define MAX_URL_PORT_LEN 64\n// Maximum path length\n#define MAX_URL_PATH_LEN 1024\n// Maximum query length\n#define MAX_URL_QUERY_LEN 1024\n// Maximum fragment length\n#define MAX_URL_FRAGMENT_LEN 256\n\ntypedef struct URL_PARTS {\n    char scheme[MAX_URL_SCHEME_LEN];\n    char authority[MAX_URL_AUTHORITY_LEN];\n    char port[MAX_URL_PORT_LEN];\n    char path[MAX_URL_PATH_LEN];\n    char query[MAX_URL_QUERY_LEN];\n    char fragment[MAX_URL_FRAGMENT_LEN];\n} URL_PARTS;\n\n// ParseURL\n// This function parses a URL string\n// @URL: The URL string the parse\n// @pURL_Parts: A pointer to a URL_PARTS struct to fill\n// @return: true on success, false otherwise\nbool ParseURL(char* URL, URL_PARTS* pURL_Parts);\n\n// PrintURL\n// This function prints each part of a URL_PARTS struct individually,\n// and the entire URL on a single line. For testing purposes only\n// @pURL_Parts: A pointer to a URL_PARTS struct to print\nvoid PrintURL(struct URL_PARTS* pURL_Parts);\n\n#endif // !URL_PARSER_H\n\n\n]"
}