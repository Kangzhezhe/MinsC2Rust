{
    "test_ht_create_and_destroy": "void test_ht_create_and_destroy() {\n    ht* table = ht_create();\n    assert(table != NULL);\n    assert(ht_length(table) == 0);\n    ht_destroy(table);\n}\n",
    "main": "int main() {\n    test_ht_create_and_destroy();\n    test_ht_set_and_get();\n    test_ht_update_value();\n    test_ht_iterator();\n    test_ht_memory_management();\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "test_ht_set_and_get": "void test_ht_set_and_get() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Insert a key-value pair\n    int value1 = 42;\n    const char* key1 = \"key1\";\n    assert(ht_set(table, key1, &value1) != NULL);\n\n    // Retrieve the value\n    int* retrieved_value = (int*)ht_get(table, key1);\n    assert(retrieved_value != NULL);\n    assert(*retrieved_value == value1);\n\n    // Insert another key-value pair\n    int value2 = 84;\n    const char* key2 = \"key2\";\n    assert(ht_set(table, key2, &value2) != NULL);\n\n    // Retrieve the second value\n    retrieved_value = (int*)ht_get(table, key2);\n    assert(retrieved_value != NULL);\n    assert(*retrieved_value == value2);\n\n    // Check the length of the hash table\n    assert(ht_length(table) == 2);\n\n    ht_destroy(table);\n}\n",
    "test_ht_update_value": "void test_ht_update_value() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Insert a key-value pair\n    int value1 = 42;\n    const char* key = \"key\";\n    assert(ht_set(table, key, &value1) != NULL);\n\n    // Update the value for the same key\n    int value2 = 84;\n    assert(ht_set(table, key, &value2) != NULL);\n\n    // Retrieve the updated value\n    int* retrieved_value = (int*)ht_get(table, key);\n    assert(retrieved_value != NULL);\n    assert(*retrieved_value == value2);\n\n    // Check the length of the hash table (should still be 1)\n    assert(ht_length(table) == 1);\n\n    ht_destroy(table);\n}\n",
    "test_ht_iterator": "void test_ht_iterator() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Insert multiple key-value pairs\n    int value1 = 1, value2 = 2, value3 = 3;\n    assert(ht_set(table, \"key1\", &value1) != NULL);\n    assert(ht_set(table, \"key2\", &value2) != NULL);\n    assert(ht_set(table, \"key3\", &value3) != NULL);\n\n    // Iterate through the hash table\n    hti it = ht_iterator(table);\n    int count = 0;\n    while (ht_next(&it)) {\n        assert(it.key != NULL);\n        assert(it.value != NULL);\n        count++;\n    }\n\n    // Ensure all items were iterated\n    assert(count == 3);\n\n    ht_destroy(table);\n}\n",
    "test_ht_memory_management": "void test_ht_memory_management() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Dynamically allocate memory for values\n    int* value1 = malloc(sizeof(int));\n    int* value2 = malloc(sizeof(int));\n    *value1 = 42;\n    *value2 = 84;\n\n    assert(ht_set(table, \"key1\", value1) != NULL);\n    assert(ht_set(table, \"key2\", value2) != NULL);\n\n    // Free values during iteration\n    hti it = ht_iterator(table);\n    while (ht_next(&it)) {\n        free(it.value);\n    }\n\n    ht_destroy(table);\n}\n",
    "extra": "{'__anon564d233c0108': \"typedef struct {\\n    const char* key;  // current key\\n    void* value;      // current value\\n\\n    // Don't use these fields directly.\\n    ht* _table;       // reference to hash table being iterated\\n    size_t _index;    // current index into ht._entries\\n};\", '_HT_H': '#define _HT_H', 'ht': 'typedef struct ht ht;', 'hti': '} hti;'} extract_info: [#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// Simple hash table implemented in C.\n\n#ifndef _HT_H\n#define _HT_H\n\n#include <stdbool.h>\n#include <stddef.h>\n\n// Hash table structure: create with ht_create, free with ht_destroy.\ntypedef struct ht ht;\n\n// Create hash table and return pointer to it, or NULL if out of memory.\nht* ht_create(void);\n\n// Free memory allocated for hash table, including allocated keys.\nvoid ht_destroy(ht* table);\n\n// Get item with given key (NUL-terminated) from hash table. Return\n// value (which was set with ht_set), or NULL if key not found.\nvoid* ht_get(ht* table, const char* key);\n\n// Set item with given key (NUL-terminated) to value (which must not\n// be NULL). If not already present in table, key is copied to newly\n// allocated memory (keys are freed automatically when ht_destroy is\n// called). Return address of copied key, or NULL if out of memory.\nconst char* ht_set(ht* table, const char* key, void* value);\n\n// Return number of items in hash table.\nsize_t ht_length(ht* table);\n\n// Hash table iterator: create with ht_iterator, iterate with ht_next.\ntypedef struct {\n    const char* key;  // current key\n    void* value;      // current value\n\n    // Don't use these fields directly.\n    ht* _table;       // reference to hash table being iterated\n    size_t _index;    // current index into ht._entries\n} hti;\n\n// Return new hash table iterator (for use with ht_next).\nhti ht_iterator(ht* table);\n\n// Move iterator to next item in hash table, update iterator's key\n// and value to current item, and return true. If there are no more\n// items, return false. Don't call ht_set during iteration.\nbool ht_next(hti* it);\n\n#endif // _HT_H\n\n\n\n\n\n\n]"
}