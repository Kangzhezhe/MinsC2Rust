{
    "test-quadtree": {
        "test_tree": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct QuadtreePoint {\n    pub x: f64,\n    pub y: f64,\n}\n\npub struct QuadtreeNode<T> {\n    pub ne: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub nw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub se: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub sw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub bounds: Option<Rc<RefCell<QuadtreeBounds>>>,\n    pub point: Option<Rc<RefCell<QuadtreePoint>>>,\n    pub key: Option<T>,\n}\n\npub struct QuadtreeBounds {\n    pub nw: Rc<RefCell<QuadtreePoint>>,\n    pub se: Rc<RefCell<QuadtreePoint>>,\n    pub width: f64,\n    pub height: f64,\n}\n\npub struct Quadtree<T> {\n    pub key_free: Option<fn(T)>,\n    pub root: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n}\n\npub struct quadtree_node_t {\n    ne: Option<Rc<RefCell<quadtree_node_t>>>,\n    nw: Option<Rc<RefCell<quadtree_node_t>>>,\n    se: Option<Rc<RefCell<quadtree_node_t>>>,\n    sw: Option<Rc<RefCell<quadtree_node_t>>>,\n}\n\n\n\npub fn quadtree_new<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Quadtree<T>> {\n    let root = quadtree_node_with_bounds::<T>(minx, miny, maxx, maxy)?;\n    let tree = Quadtree {\n        key_free: None,\n        root: Some(root),\n    };\n    Some(tree)\n}\n\n\npub fn quadtree_insert<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64, key: T) -> i32 {\n    let point = quadtree_point_new(x, y);\n    if point.is_none() {\n        return 0;\n    }\n    let point_rc = Rc::new(RefCell::new(point.unwrap()));\n    if !node_contains_(tree.borrow().root.as_ref().unwrap().clone(), point_rc.clone()) {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    let insert_status = insert_(tree.clone(), tree.borrow().root.as_ref().unwrap().clone(), Some(point_rc.clone()), Some(key));\n    if insert_status == 0 {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    if insert_status == 1 {\n        let mut tree_mut = tree.borrow_mut();\n        // Assuming length is a field in Quadtree struct\n        // If not, you need to add it\n        // tree_mut.length += 1;\n    }\n    insert_status\n}\n\n\npub fn quadtree_point_free(point: Rc<RefCell<QuadtreePoint>>) {\n    // 释放 QuadtreePoint 的内存\n    // 由于 Rc<RefCell<T>> 是智能指针，无需手动释放内存\n}\n\n\npub fn quadtree_node_new<T>() -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = QuadtreeNode {\n        ne: None,\n        nw: None,\n        se: None,\n        sw: None,\n        bounds: None,\n        point: None,\n        key: None,\n    };\n    Some(Rc::new(RefCell::new(node)))\n}\n\n\npub fn quadtree_node_reset<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(point) = &node_borrow.point {\n        quadtree_point_free(point.clone());\n    }\n    if let Some(key) = node_borrow.key.take() {\n        key_free(key);\n    }\n}\n\n\npub fn quadtree_search<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    let tree_ref = tree.borrow();\n    find_(tree_ref.root.clone(), x, y)\n}\n\n\npub fn quadtree_point_new(x: f64, y: f64) -> Option<QuadtreePoint> {\n    Some(QuadtreePoint { x, y })\n}\n\n\npub fn quadtree_node_with_bounds<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = quadtree_node_new()?;\n    let bounds = quadtree_bounds_new()?;\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.bounds = Some(bounds.clone());\n    }\n    quadtree_bounds_extend(bounds.clone(), maxx, maxy);\n    quadtree_bounds_extend(bounds.clone(), minx, miny);\n    Some(node)\n}\n\n\npub fn reset_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) {\n    let key_free = tree.borrow().key_free.clone();\n    if let Some(key_free) = key_free {\n        quadtree_node_reset(node, key_free);\n    } else {\n        let elision_wrap = |key: T| { elision_(key); };\n        quadtree_node_reset(node, elision_wrap);\n    }\n}\n\n\npub fn node_contains_<T>(outer: Rc<RefCell<QuadtreeNode<T>>>, it: Rc<RefCell<QuadtreePoint>>) -> bool {\n    let outer = outer.borrow();\n    let it = it.borrow();\n    if let Some(bounds) = &outer.bounds {\n        let bounds = bounds.borrow();\n        bounds.nw.borrow().x <= it.x &&\n        bounds.nw.borrow().y >= it.y &&\n        bounds.se.borrow().x >= it.x &&\n        bounds.se.borrow().y <= it.y\n    } else {\n        false\n    }\n}\n\n\npub fn quadtree_bounds_extend(bounds: Rc<RefCell<QuadtreeBounds>>, x: f64, y: f64) {\n    let nw_x;\n    let nw_y;\n    let se_x;\n    let se_y;\n    {\n        let bounds = bounds.borrow();\n        let nw = bounds.nw.borrow();\n        let se = bounds.se.borrow();\n        nw_x = f64::min(x, nw.x);\n        nw_y = f64::max(y, nw.y);\n        se_x = f64::max(x, se.x);\n        se_y = f64::min(y, se.y);\n    }\n    {\n        let mut bounds = bounds.borrow_mut();\n        bounds.width = (nw_x - se_x).abs();\n        bounds.height = (nw_y - se_y).abs();\n    }\n}\n\n\npub fn quadtree_free<T>(tree: Rc<RefCell<Quadtree<T>>>) {\n    let tree_borrow = tree.borrow();\n    if let Some(key_free) = tree_borrow.key_free {\n        if let Some(root) = &tree_borrow.root {\n            quadtree_node_free(Rc::clone(root), key_free);\n        }\n    } else {\n        if let Some(root) = &tree_borrow.root {\n            fn elision_wrap<T>(key: T) {\n                elision_(key);\n            }\n            quadtree_node_free(Rc::clone(root), elision_wrap);\n        }\n    }\n}\n\n\npub fn get_quadrant_<T>(root: Rc<RefCell<QuadtreeNode<T>>>, point: Rc<RefCell<QuadtreePoint>>) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let root = root.borrow();\n    if let Some(nw) = &root.nw {\n        if node_contains_(nw.clone(), point.clone()) {\n            return Some(nw.clone());\n        }\n    }\n    if let Some(ne) = &root.ne {\n        if node_contains_(ne.clone(), point.clone()) {\n            return Some(ne.clone());\n        }\n    }\n    if let Some(sw) = &root.sw {\n        if node_contains_(sw.clone(), point.clone()) {\n            return Some(sw.clone());\n        }\n    }\n    if let Some(se) = &root.se {\n        if node_contains_(se.clone(), point.clone()) {\n            return Some(se.clone());\n        }\n    }\n    None\n}\n\n\npub fn insert_<T>(\n    tree: Rc<RefCell<Quadtree<T>>>,\n    root: Rc<RefCell<QuadtreeNode<T>>>,\n    point: Option<Rc<RefCell<QuadtreePoint>>>,\n    key: Option<T>,\n) -> i32 {\n    if quadtree_node_isempty(&root) {\n        {\n            let mut root_mut = root.borrow_mut();\n            root_mut.point = point;\n            root_mut.key = key;\n        }\n        return 1; // normal insertion flag\n    } else if quadtree_node_isleaf(&root) {\n        let root_point = root.borrow().point.as_ref().unwrap().clone();\n        let point_ref = point.as_ref().unwrap().clone();\n        let root_point_borrow = root_point.borrow();\n        let point_ref_borrow = point_ref.borrow();\n        if root_point_borrow.x == point_ref_borrow.x && root_point_borrow.y == point_ref_borrow.y {\n            reset_node_(tree.clone(), root.clone());\n            {\n                let mut root_mut = root.borrow_mut();\n                root_mut.point = point;\n                root_mut.key = key;\n            }\n            return 2; // replace insertion flag\n        } else {\n            if !split_node_(tree.clone(), root.clone()) {\n                return 0; // failed insertion flag\n            }\n            return insert_(tree, root, point, key);\n        }\n    } else if quadtree_node_ispointer(&root) {\n        let quadrant = get_quadrant_(root.clone(), point.as_ref().unwrap().clone());\n        if quadrant.is_none() {\n            return 0;\n        }\n        return insert_(tree, quadrant.unwrap(), point, key);\n    }\n    0\n}\n\n\npub fn quadtree_bounds_new() -> Option<Rc<RefCell<QuadtreeBounds>>> {\n    let nw = Rc::new(RefCell::new(QuadtreePoint { x: f64::INFINITY, y: -f64::INFINITY }));\n    let se = Rc::new(RefCell::new(QuadtreePoint { x: -f64::INFINITY, y: f64::INFINITY }));\n    let bounds = QuadtreeBounds {\n        nw,\n        se,\n        width: 0.0,\n        height: 0.0,\n    };\n    Some(Rc::new(RefCell::new(bounds)))\n}\n\n\npub fn quadtree_node_free<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(nw) = node_borrow.nw.take() {\n        quadtree_node_free(nw, key_free);\n    }\n    if let Some(ne) = node_borrow.ne.take() {\n        quadtree_node_free(ne, key_free);\n    }\n    if let Some(sw) = node_borrow.sw.take() {\n        quadtree_node_free(sw, key_free);\n    }\n    if let Some(se) = node_borrow.se.take() {\n        quadtree_node_free(se, key_free);\n    }\n    if let Some(bounds) = node_borrow.bounds.take() {\n        quadtree_bounds_free(bounds);\n    }\n    quadtree_node_reset(Rc::clone(&node), key_free);\n}\n\n\npub fn elision_<T>(key: T) -> T {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    key\n}\n\n\npub fn descent(node: Rc<RefCell<quadtree_node_t>>) {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    let mut node = node.borrow_mut();\n    if let Some(ne) = &node.ne {\n        descent(Rc::clone(ne));\n    }\n    if let Some(nw) = &node.nw {\n        descent(Rc::clone(nw));\n    }\n    if let Some(se) = &node.se {\n        descent(Rc::clone(se));\n    }\n    if let Some(sw) = &node.sw {\n        descent(Rc::clone(sw));\n    }\n}\n\n\npub fn quadtree_bounds_free(bounds: Rc<RefCell<QuadtreeBounds>>) {\n    // 释放 QuadtreeBounds 的内存\n    // 由于 Rc<RefCell<T>> 是智能指针，无需手动释放内存\n    let bounds = bounds.borrow();\n    quadtree_point_free(Rc::clone(&bounds.nw));\n    quadtree_point_free(Rc::clone(&bounds.se));\n}\n\n\npub fn quadtree_walk<T>(root: Option<Rc<RefCell<QuadtreeNode<T>>>>, descent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>), ascent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>)) {\n    descent(root.clone());\n    if let Some(node) = &root {\n        let node_ref = node.borrow();\n        if let Some(nw) = &node_ref.nw {\n            quadtree_walk(Some(nw.clone()), descent, ascent);\n        }\n        if let Some(ne) = &node_ref.ne {\n            quadtree_walk(Some(ne.clone()), descent, ascent);\n        }\n        if let Some(sw) = &node_ref.sw {\n            quadtree_walk(Some(sw.clone()), descent, ascent);\n        }\n        if let Some(se) = &node_ref.se {\n            quadtree_walk(Some(se.clone()), descent, ascent);\n        }\n    }\n    ascent(root);\n}\n\n\npub fn find_<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        if quadtree_node_isleaf(&node) {\n            if let Some(point) = &node_ref.point {\n                let point_ref = point.borrow();\n                if point_ref.x == x && point_ref.y == y {\n                    return Some(point.clone());\n                }\n            }\n        } else if quadtree_node_ispointer(&node) {\n            let test = Rc::new(RefCell::new(QuadtreePoint { x, y }));\n            return find_(get_quadrant_(node.clone(), test), x, y);\n        }\n    }\n    None\n}\n\n\npub fn ascent<T>(node: Rc<RefCell<QuadtreeNode<T>>>) {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    // Function implementation\n}\n\n\npub fn quadtree_node_ispointer<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_some()\n        && node_ref.ne.is_some()\n        && node_ref.sw.is_some()\n        && node_ref.se.is_some()\n        && !quadtree_node_isleaf(node)\n}\n\n\npub fn quadtree_node_isempty<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_none()\n        && node_ref.ne.is_none()\n        && node_ref.sw.is_none()\n        && node_ref.se.is_none()\n        && !quadtree_node_isleaf(node)\n}\n\n\npub fn quadtree_node_isleaf<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    node.borrow().point.is_some()\n}\n\n\npub fn split_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let x;\n    let y;\n    let hw;\n    let hh;\n    {\n        let node_borrow = node.borrow();\n        let bounds = node_borrow.bounds.as_ref().unwrap().borrow();\n        x = bounds.nw.borrow().x;\n        y = bounds.nw.borrow().y;\n        hw = bounds.width / 2.0;\n        hh = bounds.height / 2.0;\n    }\n\n    let nw = quadtree_node_with_bounds::<T>(x, y - hh, x + hw, y);\n    let ne = quadtree_node_with_bounds::<T>(x + hw, y - hh, x + hw * 2.0, y);\n    let sw = quadtree_node_with_bounds::<T>(x, y - hh * 2.0, x + hw, y - hh);\n    let se = quadtree_node_with_bounds::<T>(x + hw, y - hh * 2.0, x + hw * 2.0, y - hh);\n\n    if nw.is_none() || ne.is_none() || sw.is_none() || se.is_none() {\n        return false;\n    }\n\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.nw = Some(nw.unwrap());\n        node_mut.ne = Some(ne.unwrap());\n        node_mut.sw = Some(sw.unwrap());\n        node_mut.se = Some(se.unwrap());\n    }\n\n    let old_point;\n    let old_key;\n    {\n        let mut node_mut = node.borrow_mut();\n        old_point = node_mut.point.take();\n        old_key = node_mut.key.take();\n    }\n\n    insert_(tree.clone(), node, old_point, old_key) != 0\n}\n\n\npub fn test_tree() {\n    let val = 10;\n\n    let tree = quadtree_new::<i32>(1.0, 1.0, 10.0, 10.0).unwrap();\n    let tree_rc = Rc::new(RefCell::new(tree));\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        let bounds = root.bounds.as_ref().unwrap().borrow();\n        assert_eq!(bounds.nw.borrow().x, 1.0);\n        assert_eq!(bounds.nw.borrow().y, 10.0);\n        assert_eq!(bounds.se.borrow().x, 10.0);\n        assert_eq!(bounds.se.borrow().y, 1.0);\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 0.0, 0.0, val), 0);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 110.0, 110.0, val), 0);\n\n    assert_ne!(quadtree_insert(tree_rc.clone(), 8.0, 2.0, val), 0);\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        let point = root.point.as_ref().unwrap().borrow();\n        assert_eq!(point.x, 8.0);\n        assert_eq!(point.y, 2.0);\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 0.0, 1.0, val), 0);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 2.0, 3.0, val), 1);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 2.0, 3.0, val), 2);\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        assert!(root.point.is_none());\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 3.0, 1.1, val), 1);\n    {\n        let point = quadtree_search(tree_rc.clone(), 3.0, 1.1).unwrap();\n        let point_ref = point.borrow();\n        assert_eq!(point_ref.x, 3.0);\n    }\n\n    fn ascent_wrap<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>) {\n        if let Some(node) = node {\n            ascent(node);\n        }\n    }\n\n    fn descent_wrap<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>) {\n        if let Some(node) = node {\n            let node_t = Rc::new(RefCell::new(quadtree_node_t {\n                ne: None,\n                nw: None,\n                se: None,\n                sw: None,\n            }));\n            descent(node_t);\n        }\n    }\n\n    quadtree_walk(tree_rc.borrow().root.clone(), ascent_wrap, descent_wrap);\n    quadtree_free(tree_rc);\n}\n\nfn main(){}\n\n\n //编译报错信息："
    },
    "test-rgba": {
        "test_named": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub struct Rgba {\n    pub r: f64,\n    pub g: f64,\n    pub b: f64,\n    pub a: f64,\n}\n\npub struct NamedColor {\n    pub name: &'static str,\n    pub val: u32,\n}\n\npub const NAMED_COLORS: &[NamedColor] = &[\n    NamedColor { name: \"transparent\", val: 0xFFFFFF00 },\n    NamedColor { name: \"aliceblue\", val: 0xF0F8FFFF },\n    NamedColor { name: \"antiquewhite\", val: 0xFAEBD7FF },\n    NamedColor { name: \"aqua\", val: 0x00FFFFFF },\n    NamedColor { name: \"aquamarine\", val: 0x7FFFD4FF },\n    NamedColor { name: \"azure\", val: 0xF0FFFFFF },\n    NamedColor { name: \"beige\", val: 0xF5F5DCFF },\n    NamedColor { name: \"bisque\", val: 0xFFE4C4FF },\n    NamedColor { name: \"black\", val: 0x000000FF },\n    NamedColor { name: \"blanchedalmond\", val: 0xFFEBCDFF },\n    NamedColor { name: \"blue\", val: 0x0000FFFF },\n    NamedColor { name: \"blueviolet\", val: 0x8A2BE2FF },\n    NamedColor { name: \"brown\", val: 0xA52A2AFF },\n    NamedColor { name: \"burlywood\", val: 0xDEB887FF },\n    NamedColor { name: \"cadetblue\", val: 0x5F9EA0FF },\n    NamedColor { name: \"chartreuse\", val: 0x7FFF00FF },\n    NamedColor { name: \"chocolate\", val: 0xD2691EFF },\n    NamedColor { name: \"coral\", val: 0xFF7F50FF },\n    NamedColor { name: \"cornflowerblue\", val: 0x6495EDFF },\n    NamedColor { name: \"cornsilk\", val: 0xFFF8DCFF },\n    NamedColor { name: \"crimson\", val: 0xDC143CFF },\n    NamedColor { name: \"cyan\", val: 0x00FFFFFF },\n    NamedColor { name: \"darkblue\", val: 0x00008BFF },\n    NamedColor { name: \"darkcyan\", val: 0x008B8BFF },\n    NamedColor { name: \"darkgoldenrod\", val: 0xB8860BFF },\n    NamedColor { name: \"darkgray\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkgreen\", val: 0x006400FF },\n    NamedColor { name: \"darkgrey\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkkhaki\", val: 0xBDB76BFF },\n    NamedColor { name: \"darkmagenta\", val: 0x8B008BFF },\n    NamedColor { name: \"darkolivegreen\", val: 0x556B2FFF },\n    NamedColor { name: \"darkorange\", val: 0xFF8C00FF },\n    NamedColor { name: \"darkorchid\", val: 0x9932CCFF },\n    NamedColor { name: \"darkred\", val: 0x8B0000FF },\n    NamedColor { name: \"darksalmon\", val: 0xE9967AFF },\n    NamedColor { name: \"darkseagreen\", val: 0x8FBC8FFF },\n    NamedColor { name: \"darkslateblue\", val: 0x483D8BFF },\n    NamedColor { name: \"darkslategray\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkslategrey\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkturquoise\", val: 0x00CED1FF },\n    NamedColor { name: \"darkviolet\", val: 0x9400D3FF },\n    NamedColor { name: \"deeppink\", val: 0xFF1493FF },\n    NamedColor { name: \"deepskyblue\", val: 0x00BFFFFF },\n    NamedColor { name: \"dimgray\", val: 0x696969FF },\n    NamedColor { name: \"dimgrey\", val: 0x696969FF },\n    NamedColor { name: \"dodgerblue\", val: 0x1E90FFFF },\n    NamedColor { name: \"firebrick\", val: 0xB22222FF },\n    NamedColor { name: \"floralwhite\", val: 0xFFFAF0FF },\n    NamedColor { name: \"forestgreen\", val: 0x228B22FF },\n    NamedColor { name: \"fuchsia\", val: 0xFF00FFFF },\n    NamedColor { name: \"gainsboro\", val: 0xDCDCDCFF },\n    NamedColor { name: \"ghostwhite\", val: 0xF8F8FFFF },\n    NamedColor { name: \"gold\", val: 0xFFD700FF },\n    NamedColor { name: \"goldenrod\", val: 0xDAA520FF },\n    NamedColor { name: \"gray\", val: 0x808080FF },\n    NamedColor { name: \"green\", val: 0x008000FF },\n    NamedColor { name: \"greenyellow\", val: 0xADFF2FFF },\n    NamedColor { name: \"grey\", val: 0x808080FF },\n    NamedColor { name: \"honeydew\", val: 0xF0FFF0FF },\n    NamedColor { name: \"hotpink\", val: 0xFF69B4FF },\n    NamedColor { name: \"indianred\", val: 0xCD5C5CFF },\n    NamedColor { name: \"indigo\", val: 0x4B0082FF },\n    NamedColor { name: \"ivory\", val: 0xFFFFF0FF },\n    NamedColor { name: \"khaki\", val: 0xF0E68CFF },\n    NamedColor { name: \"lavender\", val: 0xE6E6FAFF },\n    NamedColor { name: \"lavenderblush\", val: 0xFFF0F5FF },\n    NamedColor { name: \"lawngreen\", val: 0x7CFC00FF },\n    NamedColor { name: \"lemonchiffon\", val: 0xFFFACDFF },\n    NamedColor { name: \"lightblue\", val: 0xADD8E6FF },\n    NamedColor { name: \"lightcoral\", val: 0xF08080FF },\n    NamedColor { name: \"lightcyan\", val: 0xE0FFFFFF },\n    NamedColor { name: \"lightgoldenrodyellow\", val: 0xFAFAD2FF },\n    NamedColor { name: \"lightgray\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightgreen\", val: 0x90EE90FF },\n    NamedColor { name: \"lightgrey\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightpink\", val: 0xFFB6C1FF },\n    NamedColor { name: \"lightsalmon\", val: 0xFFA07AFF },\n    NamedColor { name: \"lightseagreen\", val: 0x20B2AAFF },\n    NamedColor { name: \"lightskyblue\", val: 0x87CEFAFF },\n    NamedColor { name: \"lightslategray\", val: 0x778899FF },\n    NamedColor { name: \"lightslategrey\", val: 0x778899FF },\n    NamedColor { name: \"lightsteelblue\", val: 0xB0C4DEFF },\n    NamedColor { name: \"lightyellow\", val: 0xFFFFE0FF },\n    NamedColor { name: \"lime\", val: 0x00FF00FF },\n    NamedColor { name: \"limegreen\", val: 0x32CD32FF },\n    NamedColor { name: \"linen\", val: 0xFAF0E6FF },\n    NamedColor { name: \"magenta\", val: 0xFF00FFFF },\n    NamedColor { name: \"maroon\", val: 0x800000FF },\n    NamedColor { name: \"mediumaquamarine\", val: 0x66CDAAFF },\n    NamedColor { name: \"mediumblue\", val: 0x0000CDFF },\n    NamedColor { name: \"mediumorchid\", val: 0xBA55D3FF },\n    NamedColor { name: \"mediumpurple\", val: 0x9370DBFF },\n    NamedColor { name: \"mediumseagreen\", val: 0x3CB371FF },\n    NamedColor { name: \"mediumslateblue\", val: 0x7B68EEFF },\n    NamedColor { name: \"mediumspringgreen\", val: 0x00FA9AFF },\n    NamedColor { name: \"mediumturquoise\", val: 0x48D1CCFF },\n    NamedColor { name: \"mediumvioletred\", val: 0xC71585FF },\n    NamedColor { name: \"midnightblue\", val: 0x191970FF },\n    NamedColor { name: \"mintcream\", val: 0xF5FFFAFF },\n    NamedColor { name: \"mistyrose\", val: 0xFFE4E1FF },\n    NamedColor { name: \"moccasin\", val: 0xFFE4B5FF },\n    NamedColor { name: \"navajowhite\", val: 0xFFDEADFF },\n    NamedColor { name: \"navy\", val: 0x000080FF },\n    NamedColor { name: \"oldlace\", val: 0xFDF5E6FF },\n    NamedColor { name: \"olive\", val: 0x808000FF },\n    NamedColor { name: \"olivedrab\", val: 0x6B8E23FF },\n    NamedColor { name: \"orange\", val: 0xFFA500FF },\n    NamedColor { name: \"orangered\", val: 0xFF4500FF },\n    NamedColor { name: \"orchid\", val: 0xDA70D6FF },\n    NamedColor { name: \"palegoldenrod\", val: 0xEEE8AAFF },\n    NamedColor { name: \"palegreen\", val: 0x98FB98FF },\n    NamedColor { name: \"paleturquoise\", val: 0xAFEEEEFF },\n    NamedColor { name: \"palevioletred\", val: 0xDB7093FF },\n    NamedColor { name: \"papayawhip\", val: 0xFFEFD5FF },\n    NamedColor { name: \"peachpuff\", val: 0xFFDAB9FF },\n    NamedColor { name: \"peru\", val: 0xCD853FFF },\n    NamedColor { name: \"pink\", val: 0xFFC0CBFF },\n    NamedColor { name: \"plum\", val: 0xDDA0DDFF },\n    NamedColor { name: \"powderblue\", val: 0xB0E0E6FF },\n    NamedColor { name: \"purple\", val: 0x800080FF },\n    NamedColor { name: \"red\", val: 0xFF0000FF },\n    NamedColor { name: \"rosybrown\", val: 0xBC8F8FFF },\n    NamedColor { name: \"royalblue\", val: 0x4169E1FF },\n    NamedColor { name: \"saddlebrown\", val: 0x8B4513FF },\n    NamedColor { name: \"salmon\", val: 0xFA8072FF },\n    NamedColor { name: \"sandybrown\", val: 0xF4A460FF },\n    NamedColor { name: \"seagreen\", val: 0x2E8B57FF },\n    NamedColor { name: \"seashell\", val: 0xFFF5EEFF },\n    NamedColor { name: \"sienna\", val: 0xA0522DFF },\n    NamedColor { name: \"silver\", val: 0xC0C0C0FF },\n    NamedColor { name: \"skyblue\", val: 0x87CEEBFF },\n    NamedColor { name: \"slateblue\", val: 0x6A5ACDFF },\n    NamedColor { name: \"slategray\", val: 0x708090FF },\n    NamedColor { name: \"slategrey\", val: 0x708090FF },\n    NamedColor { name: \"snow\", val: 0xFFFAFAFF },\n    NamedColor { name: \"springgreen\", val: 0x00FF7FFF },\n    NamedColor { name: \"steelblue\", val: 0x4682B4FF },\n    NamedColor { name: \"tan\", val: 0xD2B48CFF },\n    NamedColor { name: \"teal\", val: 0x008080FF },\n    NamedColor { name: \"thistle\", val: 0xD8BFD8FF },\n    NamedColor { name: \"tomato\", val: 0xFF6347FF },\n    NamedColor { name: \"turquoise\", val: 0x40E0D0FF },\n    NamedColor { name: \"violet\", val: 0xEE82EEFF },\n    NamedColor { name: \"wheat\", val: 0xF5DEB3FF },\n    NamedColor { name: \"white\", val: 0xFFFFFFFF },\n    NamedColor { name: \"whitesmoke\", val: 0xF5F5F5FF },\n    NamedColor { name: \"yellow\", val: 0xFFFF00FF },\n    NamedColor { name: \"yellowgreen\", val: 0x9ACD32FF }\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn rgba_to_string(rgba: Rgba, buf: &mut String, len: usize) {\n    if rgba.a == 1.0 {\n        *buf = format!(\"#{:02x}{:02x}{:02x}\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8);\n    } else {\n        *buf = format!(\"rgba({}, {}, {}, {:.2})\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8, \n            rgba.a);\n    }\n}\n\n\npub fn rgba_new(rgba: u32) -> Rgba {\n    let mut color = Rgba {\n        r: 0.0,\n        g: 0.0,\n        b: 0.0,\n        a: 0.0,\n    };\n    color.r = (rgba >> 24) as f64 / 255.0;\n    color.g = ((rgba >> 16) & 0xff) as f64 / 255.0;\n    color.b = ((rgba >> 8) & 0xff) as f64 / 255.0;\n    color.a = (rgba & 0xff) as f64 / 255.0;\n    color\n}\n\n\npub fn test_to_string() {\n    let mut buf = String::new();\n    let color = rgba_new(0xffcc00ff);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"#ffcc00\", buf);\n\n    let color = rgba_new(0xffcc0050);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"rgba(255, 204, 0, 0.31)\", buf);\n}\n\n\npub fn rgba_from_string(str: &str, ok: &mut i16) -> u32 {\n    let mut bool_ok = false;\n    let result = if str.starts_with('#') {\n        rgba_from_hex_string(str[1..].to_string(), ok)\n    } else if str.starts_with(\"rgba\") {\n        rgba_from_rgba_string(str.to_string(), &mut bool_ok)\n    } else if str.starts_with(\"rgb\") {\n        rgba_from_rgb_string(str, &mut bool_ok)\n    } else {\n        rgba_from_name_string(str, &mut bool_ok)\n    };\n    *ok = if bool_ok { 1 } else { 0 };\n    result\n}\n\n\npub fn rgba_from_rgba_string(str: String, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgba(\") {\n        let mut str = str[5..].to_string();\n        str = str.trim().to_string();\n        \n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut a: f32 = 0.0;\n        \n        let mut iter = str.split_whitespace();\n        if let Some(r_str) = iter.next() {\n            if let Ok(r_val) = r_str.parse::<u8>() {\n                r = r_val;\n            }\n        }\n        if let Some(g_str) = iter.next() {\n            if let Ok(g_val) = g_str.parse::<u8>() {\n                g = g_val;\n            }\n        }\n        if let Some(b_str) = iter.next() {\n            if let Ok(b_val) = b_str.parse::<u8>() {\n                b = b_val;\n            }\n        }\n        if let Some(a_str) = iter.next() {\n            if a_str.starts_with('1') {\n                a = 1.0;\n            } else if a_str.starts_with('0') {\n                if a_str.len() > 1 && a_str.chars().nth(1) == Some('.') {\n                    let mut n = 0.1;\n                    for c in a_str[2..].chars() {\n                        if c.is_digit(10) {\n                            a += (c.to_digit(10).unwrap() as f32) * n;\n                            n *= 0.1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        *ok = true;\n        return rgba_from_rgba(r, g, b, (a * 255.0) as u8);\n    }\n    \n    *ok = false;\n    0\n}\n\n\npub fn rgba_from_hex3_string(str: String) -> u32 {\n    let mut chars = str.chars();\n    let r_char = chars.next().unwrap_or('0');\n    let g_char = chars.next().unwrap_or('0');\n    let b_char = chars.next().unwrap_or('0');\n    \n    let r = (h(r_char) << 4) + h(r_char);\n    let g = (h(g_char) << 4) + h(g_char);\n    let b = (h(b_char) << 4) + h(b_char);\n    \n    rgba_from_rgb(r as u8, g as u8, b as u8)\n}\n\n\npub fn rgba_from_name_string(str: &str, ok: &mut bool) -> u32 {\n    for color in NAMED_COLORS {\n        if str == color.name {\n            *ok = true;\n            return color.val;\n        }\n    }\n    *ok = false;\n    0\n}\n\n\npub fn rgba_from_rgb_string(str: &str, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgb(\") {\n        let mut str = &str[4..];\n        str = str.trim_start();\n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut chars = str.chars();\n        let parse_channel = |c: &mut std::str::Chars| {\n            let mut num = 0;\n            while let Some(ch) = c.next() {\n                if ch.is_ascii_digit() {\n                    num = num * 10 + (ch as u8 - b'0');\n                } else if ch == ',' || ch == ')' {\n                    break;\n                }\n            }\n            num\n        };\n        r = parse_channel(&mut chars);\n        g = parse_channel(&mut chars);\n        b = parse_channel(&mut chars);\n        *ok = true;\n        return rgba_from_rgb(r, g, b);\n    }\n    *ok = false;\n    0\n}\n\n\npub fn rgba_from_rgb(r: u8, g: u8, b: u8) -> u32 {\n    rgba_from_rgba(r, g, b, 255)\n}\n\n\npub fn rgba_from_rgba(r: u8, g: u8, b: u8, a: u8) -> u32 {\n    (r as u32) << 24 | (g as u32) << 16 | (b as u32) << 8 | (a as u32)\n}\n\n\npub fn rgba_from_hex_string(str: String, ok: &mut i16) -> u32 {\n    let len = str.len();\n    *ok = 1;\n    if len == 6 {\n        return rgba_from_hex6_string(str);\n    }\n    if len == 3 {\n        return rgba_from_hex3_string(str);\n    }\n    *ok = 0;\n    0\n}\n\n\npub fn rgba_from_hex6_string(str: String) -> u32 {\n    let chars: Vec<char> = str.chars().collect();\n    rgba_from_rgb(\n        ((h(chars[0]) << 4) + h(chars[1])) as u8,\n        ((h(chars[2]) << 4) + h(chars[3])) as u8,\n        ((h(chars[4]) << 4) + h(chars[5])) as u8,\n    )\n}\n\n\npub fn h(c: char) -> i32 {\n    match c {\n        '0'..='9' => (c as i32) - ('0' as i32),\n        'a'..='f' => (c as i32) - ('a' as i32) + 10,\n        'A'..='F' => (c as i32) - ('A' as i32) + 10,\n        _ => 0,\n    }\n}\n\n\npub fn test_named() {\n    let mut ok: i16 = 0;\n    let val = rgba_from_string(\"olive\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0x808000FF, val);\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error: unknown start of token: \\u{ff0c}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:42\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                              ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地,我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。\n   |                                              ~\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:56\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                                                          ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本,因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。\n   |                                                                          ~\n\nerror: unknown start of token: \\u{3002}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:69\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                                                                                    ^^\n   |\nhelp: Unicode character '。' (Ideographic Full Stop) looks like '.' (Period), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力.请尝试缩短文本或将其分成更小的部分。\n   |                                                                                                    ~\n\nerror: unknown start of token: \\u{3002}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:87\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                                                                                                                        ^^\n   |\nhelp: Unicode character '。' (Ideographic Full Stop) looks like '.' (Period), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分.\n   |                                                                                                                                        ~\n\nerror: this file contains an unclosed delimiter\n   --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:255:12\n    |\n13  | pub const NAMED_COLORS: &[NamedColor] = &[\n    |                                          - unclosed delimiter\n...\n35  |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n    |                - unclosed delimiter\n...\n255 | fn main(){}\n    |            ^\n\nerror: aborting due to 5 previous errors\n\n"
    },
    "test-binn": {
        "test_invalid_binn": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_invalid_binn() {\n    let buffers: [[u8; 20]; 36] = [\n        [0xE0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x7F, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    ];\n\n    println!(\"testing invalid binn buffers...\");\n\n    let count = buffers.len();\n\n    for i in 0..count {\n        let ptr = buffers[i].to_vec();\n        let mut size = ptr.len() as i32;\n        println!(\"checking invalid binn #{}   size: {} bytes\", i, size);\n        assert!(!binn_is_valid_ex(&ptr, &mut 0, &mut 0, &mut size));\n    }\n\n    println!(\"OK\");\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error[E0768]: no valid digits found for number\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:39:41\n   |\n39 | pub const BINN_STORAGE_CONTAINER: i32 = 0x极客时间E0;\n   |                                         ^^\n\nerror[E0408]: variable `BINN_UINT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:710:9\n    |\n710 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |         ^^^^^^^^^^   ^^^^^^^^^^^   -----------   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT32`\n    |         |            |             |\n    |         |            |             variable not in all patterns\n    |         |            pattern doesn't bind `BINN_UINT32`\n    |         pattern doesn't bind `BINN_UINT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT32`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:710:36\n    |\n710 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |                                    ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:975:9\n    |\n975 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   -----------   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT32`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             variable not in all patterns\n    |         |           |            |            |            |            pattern doesn't bind `BINN_UINT32`\n    |         |           |            |            |            pattern doesn't bind `BINN_UINT32`\n    |         |           |            |            pattern doesn't bind `BINN_UINT32`\n    |         |           |            pattern doesn't bind `BINN_UINT32`\n    |         |           pattern doesn't bind `BINN_UINT32`\n    |         pattern doesn't bind `BINN_UINT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT32`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:975:87\n    |\n975 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                                                                       ^^^^^^^^^^^\n\nerror[E0425]: cannot find value `极客时间0x00` in this scope\n --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:7:39\n  |\n7 | pub const BINN_STORAGE_NOBYTES: i32 = 极客时间0x00;\n  |                                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `usize极客时间` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:41:28\n   |\n41 | pub const MAX_BINN_HEADER: usize极客时间 = 9;\n   |                            ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:600:29\n    |\n15  | pub const BINN_INT32: i32 = 0x61;\n    | --------------------------------- similarly named constant `BINN_INT32` defined here\n...\n600 |                     type2 = BINN_UINT32;\n    |                             ^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:623:29\n    |\n15  | pub const BINN_INT32: i32 = 0x61;\n    | --------------------------------- similarly named constant `BINN_INT32` defined here\n...\n623 |                     type2 = BINN_UINT32;\n    |                             ^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:646:29\n    |\n15  | pub const BINN_INT32: i32 = 0x61;\n    | --------------------------------- similarly named constant `BINN_INT32` defined here\n...\n646 |                     type2 = BINN_UINT32;\n    |                             ^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:667:25\n    |\n15  | pub const BINN_INT32: i32 = 0x61;\n    | --------------------------------- similarly named constant `BINN_INT32` defined here\n...\n667 |                 type2 = BINN_UINT32;\n    |                         ^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:691:25\n    |\n15  | pub const BINN_INT32: i32 = 0x61;\n    | --------------------------------- similarly named constant `BINN_INT32` defined here\n...\n691 |                 type2 = BINN_UINT32;\n    |                         ^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32`\n\nerror[E0609]: no field `v极客时间int8` on type `&Binn`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn/test_source.rs:136:25\n    |\n136 |             vint8: self.v极客时间int8,\n    |                         ^^^^^^^^^^^^^ unknown field\n    |\n    = note: available fields are: `header`, `allocated`, `writable`, `dirty`, `pbuf` ... and 26 others\n\nerror: aborting due to 11 previous errors\n\nSome errors have detailed explanations: E0408, E0412, E0425, E0609, E0768.\nFor more information about an error, try `rustc --explain E0408`.\n",
        "test_read_keys": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\npub const BINN_VERSION: &str = \"3.0.0\";\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_read_keys() {\n    let mut map = binn_map().unwrap();\n    let mut id = 0;\n    let mut value = Binn::default();\n\n    let val: i32 = 123;\n    let val_bytes = val.to_be_bytes().to_vec();\n    assert_eq!(binn_map_set(&mut map, 5501, BINN_INT32, Some(&val_bytes), 0), true);\n    assert_eq!(binn_map_get_pair(Some(&map.pbuf), 1, &mut id, &mut value), true);\n    assert_eq!(id, 5501);\n\n    binn_free(Some(map));\n}\n\n\nfn main(){}\n\n\n //insert编译报错信息：error[E0408]: variable `BINN_STORAGE_STRING` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:798:9\n    |\n798 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |         ^^^^^^^^^^^^^^^^^   -------------------   ^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_STRING`\n    |         |                   |\n    |         |                   variable not in all patterns\n    |         pattern doesn't bind `BINN_STORAGE_STRING`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_STRING`\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:798:29\n    |\n798 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |                             ^^^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_STRING` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1143:9\n     |\n1143 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         ^^^^^^^^^^^^^^^^^   ------------------- variable not in all patterns\n     |         |\n     |         pattern doesn't bind `BINN_STORAGE_STRING`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_STRING`\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1143:29\n     |\n1143 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |                             ^^^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_STRING` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1216:13\n     |\n1216 |             BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |             ^^^^^^^^^^^^^^^^^   ------------------- variable not in all patterns\n     |             |\n     |             pattern doesn't bind `BINN_STORAGE_STRING`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_STRING`\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1216:33\n     |\n1216 |             BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |                                 ^^^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_STRING` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1324:9\n     |\n1324 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         ^^^^^^^^^^^^^^^^^   ------------------- variable not in all patterns\n     |         |\n     |         pattern doesn't bind `BINN_STORAGE_STRING`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_STRING`\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1324:29\n     |\n1324 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |                             ^^^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_STRING` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1393:9\n     |\n1393 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |         ^^^^^^^^^^^^^^^^^   -------------------   ^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_STRING`\n     |         |                   |\n     |         |                   variable not in all patterns\n     |         pattern doesn't bind `BINN_STORAGE_STRING`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_STRING`\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1393:29\n     |\n1393 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |                             ^^^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find value `极光0xE0` in this scope\n --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:2:36\n  |\n2 | pub const BINN_STORAGE_MASK: u32 = 极光0xE0;\n  |                                    ^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `i极光64` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:25:22\n   |\n25 | pub const INT32_MIN: i极光64 = -2147483648;\n   |                      ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `极光0` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:186:22\n    |\n186 |             vushort: 极光0,\n    |                      ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_STRING` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:256:46\n    |\n6   | pub const B极光INN_STORAGE_STRING: i32 = 0xA0;\n    | ---------------------------------------------- similarly named constant `B极光INN_STORAGE_STRING` defined here\n...\n256 |         BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n    |                                              ^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极光INN_STORAGE_STRING`\n\nerror[E0425]: cannot find value `BINN_FAMILY_FLOAT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:706:76\n    |\n53  | pub const B极光INN_FAMILY_FLOAT: i32 = 0xF3;\n    | -------------------------------------------- similarly named constant `B极光INN_FAMILY_FLOAT` defined here\n...\n706 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |                                                                            ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极光INN_FAMILY_FLOAT`\n\nerror[E0425]: cannot find value `BINN_FAMILY_FLOAT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1408:43\n     |\n53   | pub const B极光INN_FAMILY_FLOAT: i32 = 0xF3;\n     | -------------------------------------------- similarly named constant `B极光INN_FAMILY_FLOAT` defined here\n...\n1408 |     } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n     |                                           ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极光INN_FAMILY_FLOAT`\n\nerror[E0425]: cannot find value `BINN_FAMILY_FLOAT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1819:43\n     |\n53   | pub const B极光INN_FAMILY_FLOAT: i32 = 0xF3;\n     | -------------------------------------------- similarly named constant `B极光INN_FAMILY_FLOAT` defined here\n...\n1819 |     } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n     |                                           ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极光INN_FAMILY_FLOAT`\n\nerror[E0609]: no field `alloc极光_size` on type `&Binn`\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:130:30\n    |\n130 |             alloc_size: self.alloc极光_size,\n    |                              ^^^^^^^^^^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n130 -             alloc_size: self.alloc极光_size,\n130 +             alloc_size: self.alloc_size,\n    |\n\nerror[E0609]: no field `v极光int64` on type `&Binn`\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:140:26\n    |\n140 |             vint64: self.v极光int64,\n    |                          ^^^^^^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n140 -             vint64: self.v极光int64,\n140 +             vint64: self.vint64,\n    |\n\nerror[E0560]: struct `Binn` has no field named `vuint64极光`\n   --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:182:13\n    |\n182 |             vuint64极光: 0,\n    |             ^^^^^^^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n182 -             vuint64极光: 0,\n182 +             vuint64: 0,\n    |\n\nerror[E0381]: used binding `BINN_STORAGE_STRING` is possibly-uninitialized\n    --> ../../Output/crown/tmp/test-binn_test_read_keys/test_source.rs:1338:32\n     |\n1324 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |                             -------------------\n     |                             |\n     |                             binding initialized here in some conditions\n     |                             binding declared here but left uninitialized\n...\n1338 |             if storage_type == BINN_STORAGE_STRING {\n     |                                ^^^^^^^^^^^^^^^^^^^ `BINN_STORAGE_STRING` used here but it is possibly-uninitialized\n\nerror: aborting due to 16 previous errors\n\nSome errors have detailed explanations: E0381, E0408, E0412, E0425, E0560, E0609.\nFor more information about an error, try `rustc --explain E0381`.\n",
        "test_invalid_read_operations": "pub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\n\npub fn test_invalid_read_operations() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let mut ptr: Option<Vec<u8>>;\n    let mut type_: i32 = 0;\n    let mut size: i32 = 0;\n\n    ptr = binn_ptr(list.as_ref().map(|x| &x.ptr));\n    assert!(ptr.is_some());\n    assert!(binn_list_read(ptr.as_ref(), 0, Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_list_read(ptr.as_ref(), 1, Some(&mut type_), Some(&mut size)).is_none());\n\n    ptr = binn_ptr(map.as_ref().map(|x| &x.ptr));\n    assert!(ptr.is_some());\n    assert!(binn_map_read(ptr.as_ref(), 0, Some(&mut type_), Some(&mut size)).is_none());\n\n    ptr = binn_ptr(obj.as_ref().map(|x| &x.ptr));\n    assert!(ptr.is_some());\n    assert!(binn_object_read(ptr.as_ref(), \"\", Some(&mut type_), Some(&mut size)).is_none());\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\nfn main(){}\n //编译报错信息：error[E0282]: type annotations needed\n    --> ../../Output/crown/tmp/test-binn_test_invalid_read_operations/temp.rs:1452:13\n     |\n1452 |     assert!(binn_object_read(ptr.as_ref(), \"\", Some(&mut type_), Some(&mut size)).is_none());\n     |             ^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `binn_object_read`\n     |\n",
        "test_binn_integer_operations": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_binn_integer_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut value = 123;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![value as u8]), 0));\n\n    let mut read_value = 0;\n    assert!(binn_list_get_int32(Some(&list.as_ref().unwrap().pbuf), 1, &mut read_value));\n    assert!(read_value == value);\n\n    binn_free(list);\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error[E0408]: variable `BINN_INT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:440:9\n    |\n440 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ----------   ^^^^^^^^^^ pattern doesn't bind `BINN_INT32`\n    |         |           |            |\n    |         |           |            variable not in all patterns\n    |         |           pattern doesn't bind `BINN_INT32`\n    |         pattern doesn't bind `BINN_INT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT32`\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:440:34\n    |\n440 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |                                  ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:706:9\n    |\n706 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ----------   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_INT32`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_INT32`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_INT32`\n    |         |           |            |            |            pattern doesn't bind `BINN_INT32`\n    |         |           |            |            pattern doesn't bind `BINN_INT32`\n    |         |           |            variable not in all patterns\n    |         |           pattern doesn't bind `BINN_INT32`\n    |         pattern doesn't bind `BINN_INT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT32`\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:706:34\n    |\n706 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                  ^^^^^^^^^^\n\nerror[E0425]: cannot find value `极0x80000` in this scope\n --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:5:39\n  |\n5 | pub const BINN_STORAGE_VIRTUAL: u32 = 极0x80000;\n  |                                       ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `极0x02` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:79:29\n   |\n79 | pub const BINN_FALSE: i32 = 极0x02;\n   |                             ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:339:29\n    |\n15  | pub const BINN_INT32极: i32 = 0x61;\n    | ----------------------------------- similarly named constant `BINN_INT32极` defined here\n...\n339 |                     type2 = BINN_INT32;\n    |                             ^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32极`\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:385:29\n    |\n15  | pub const BINN_INT32极: i32 = 0x61;\n    | ----------------------------------- similarly named constant `BINN_INT32极` defined here\n...\n385 |                     type2 = BINN_INT32;\n    |                             ^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32极`\n\nerror[E0425]: cannot find value `BINN_FAMILY_STRING` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:708:88\n    |\n76  | pub const B极INN_FAMILY_STRING: i32 = 0xF4;\n    | ------------------------------------------- similarly named constant `B极INN_FAMILY_STRING` defined here\n...\n708 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |                                                                                        ^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_FAMILY_STRING`\n\nerror[E0425]: cannot find value `BINN_FAMILY_STRING` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:710:81\n    |\n76  | pub const B极INN_FAMILY_STRING: i32 = 0xF4;\n    | ------------------------------------------- similarly named constant `B极INN_FAMILY_STRING` defined here\n...\n710 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |                                                                                 ^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_FAMILY_STRING`\n\nerror[E0425]: cannot find value `BINN_FAMILY_STRING` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:1774:84\n     |\n76   | pub const B极INN_FAMILY_STRING: i32 = 0xF4;\n     | ------------------------------------------- similarly named constant `B极INN_FAMILY_STRING` defined here\n...\n1774 |     if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n     |                                                                                    ^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_FAMILY_STRING`\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:2296:27\n     |\n15   | pub const BINN_INT32极: i32 = 0x61;\n     | ----------------------------------- similarly named constant `BINN_INT32极` defined here\n...\n2296 |     binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n     |                           ^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32极`\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:2301:31\n     |\n15   | pub const BINN_INT32极: i32 = 0x61;\n     | ----------------------------------- similarly named constant `BINN_INT32极` defined here\n...\n2301 |     binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n     |                               ^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32极`\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:2306:25\n     |\n15   | pub const BINN_INT32极: i32 = 0x61;\n     | ----------------------------------- similarly named constant `BINN_INT32极` defined here\n...\n2306 |     binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n     |                         ^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32极`\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:2342:30\n     |\n15   | pub const BINN_INT32极: i32 = 0x61;\n     | ----------------------------------- similarly named constant `BINN_INT32极` defined here\n...\n2342 |     binn_list_get(list, pos, BINN_INT32, pvalue, None)\n     |                              ^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32极`\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:2563:51\n     |\n15   | pub const BINN_INT32极: i32 = 0x61;\n     | ----------------------------------- similarly named constant `BINN_INT32极` defined here\n...\n2563 |     assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![value as u8]), 0));\n     |                                                   ^^^^^^^^^^ help: a constant with a similar name exists: `BINN_INT32极`\n\nerror[E0560]: struct `Binn` has no field named `vint极`\n   --> ../../Output/crown/tmp/test-binn_test_binn_integer_operations/test_source.rs:186:13\n    |\n186 |             vint极: 0,\n    |             ^^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n186 -             vint极: 0,\n186 +             vint: 0,\n    |\n\nerror: aborting due to 15 previous errors\n\nSome errors have detailed explanations: E0408, E0425, E0560.\nFor more information about an error, try `rustc --explain E0408`.\n",
        "test_binn_string_operations": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_binn_string_operations() {\n    let mut obj = binn_new(BINN_OBJECT, 0, None).unwrap();\n    let key = \"test_key\";\n    let value = \"test_value\";\n\n    assert!(binn_object_set(&mut obj, key, BINN_STRING, Some(&value.as_bytes().to_vec()), 0));\n\n    let read_value = binn_object_str(Some(&obj.pbuf), key);\n    assert!(!read_value.is_empty());\n    assert_eq!(read_value, value);\n\n    binn_free(Some(obj));\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error: expected `;`, found keyword `pub`\n --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:7:1414\n  |\n7 | pub const BINN_STORAGE_NOBYTES: i32 = 极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速\n  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^ help: add `;` here\n8 | pub const INT64_FORMAT: &str = \"I64i\";\n  | --- unexpected token\n\nerror[E0408]: variable `BINN_DOUBLE_STR` is not bound in all patterns\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:62:9\n   |\n62 |         BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n   |         ^^^^^^^^^^^^^^^   --------------- variable not in all patterns\n   |         |\n   |         pattern doesn't bind `BINN_DOUBLE_STR`\n   |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_DOUBLE_STR`\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:62:27\n   |\n62 |         BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n   |                           ^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_SINGLE_STR` is not bound in all patterns\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:62:27\n   |\n62 |         BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n   |         ---------------   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_SINGLE_STR`\n   |         |\n   |         variable not in all patterns\n   |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_SINGLE_STR`\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:62:9\n   |\n62 |         BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n   |         ^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT16` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:9\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ^^^^^^^^^   ----------   ^^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_INT16`\n    |         |           |            |\n    |         |           |            pattern doesn't bind `BINN_INT16`\n    |         |           variable not in all patterns\n    |         pattern doesn't bind `BINN_INT16`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT16`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:21\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |                     ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:9\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ----------   ^^^^^^^^^^ pattern doesn't bind `BINN_INT32`\n    |         |           |            |\n    |         |           |            variable not in all patterns\n    |         |           pattern doesn't bind `BINN_INT32`\n    |         pattern doesn't bind `BINN_INT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT32`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:34\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |                                  ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT64` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:9\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ---------- variable not in all patterns\n    |         |           |            |\n    |         |           |            pattern doesn't bind `BINN_INT64`\n    |         |           pattern doesn't bind `BINN_INT64`\n    |         pattern doesn't bind `BINN_INT64`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT64`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:47\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |                                               ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT8` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:21\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ---------   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_INT8`\n    |         |           |            |\n    |         |           |            pattern doesn't bind `BINN_INT8`\n    |         |           pattern doesn't bind `BINN_INT8`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT8`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:9\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT16` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:9\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |         ^^^^^^^^^^   -----------   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT16`\n    |         |            |             |\n    |         |            |             pattern doesn't bind `BINN_UINT16`\n    |         |            variable not in all patterns\n    |         pattern doesn't bind `BINN_UINT16`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT16`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:22\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |                      ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:9\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |         ^^^^^^^^^^   ^^^^^^^^^^^   -----------   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT32`\n    |         |            |             |\n    |         |            |             variable not in all patterns\n    |         |            pattern doesn't bind `BINN_UINT32`\n    |         pattern doesn't bind `BINN_UINT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT32`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:36\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |                                    ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT64` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:9\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |         ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ----------- variable not in all patterns\n    |         |            |             |\n    |         |            |             pattern doesn't bind `BINN_UINT64`\n    |         |            pattern doesn't bind `BINN_UINT64`\n    |         pattern doesn't bind `BINN_UINT64`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT64`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:50\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |                                                  ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT8` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:22\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |         ----------   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT8`\n    |         |            |             |\n    |         |            |             pattern doesn't bind `BINN_UINT8`\n    |         |            pattern doesn't bind `BINN_UINT8`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT8`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:9\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |         ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_MAP` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:510:9\n    |\n510 |         BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n    |         ^^^^^^^^^   --------   ^^^^^^^^^^^ pattern doesn't bind `BINN_MAP`\n    |         |           |\n    |         |           variable not in all patterns\n    |         pattern doesn't bind `BINN_MAP`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_MAP`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:510:21\n    |\n510 |         BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n    |                     ^^^^^^^^\n\nerror[E0408]: variable `BINN_OBJECT` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:510:9\n    |\n510 |         BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n    |         ^^^^^^^^^   ^^^^^^^^   ----------- variable not in all patterns\n    |         |           |\n    |         |           pattern doesn't bind `BINN_OBJECT`\n    |         pattern doesn't bind `BINN_OBJECT`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_OBJECT`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:510:32\n    |\n510 |         BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n    |                                ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_LIST` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:510:21\n    |\n510 |         BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n    |         ---------   ^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_LIST`\n    |         |           |\n    |         |           pattern doesn't bind `BINN_LIST`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_LIST`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:510:9\n    |\n510 |         BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n    |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT16` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ----------   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_INT16`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_INT16`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_INT16`\n    |         |           |            |            |            pattern doesn't bind `BINN_INT16`\n    |         |           |            |            pattern doesn't bind `BINN_INT16`\n    |         |           |            pattern doesn't bind `BINN_INT16`\n    |         |           variable not in all patterns\n    |         pattern doesn't bind `BINN_INT16`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT16`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:21\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                     ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ----------   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_INT32`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_INT32`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_INT32`\n    |         |           |            |            |            pattern doesn't bind `BINN_INT32`\n    |         |           |            |            pattern doesn't bind `BINN_INT32`\n    |         |           |            variable not in all patterns\n    |         |           pattern doesn't bind `BINN_INT32`\n    |         pattern doesn't bind `BINN_INT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT32`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:34\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                  ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT64` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ----------   ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_INT64`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_INT64`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_INT64`\n    |         |           |            |            |            pattern doesn't bind `BINN_INT64`\n    |         |           |            |            variable not in all patterns\n    |         |           |            pattern doesn't bind `BINN_INT64`\n    |         |           pattern doesn't bind `BINN_INT64`\n    |         pattern doesn't bind `BINN_INT64`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT64`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:47\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                               ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT8` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ----------   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT8`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_UINT8`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_UINT8`\n    |         |           |            |            |            variable not in all patterns\n    |         |           |            |            pattern doesn't bind `BINN_UINT8`\n    |         |           |            pattern doesn't bind `BINN_UINT8`\n    |         |           pattern doesn't bind `BINN_UINT8`\n    |         pattern doesn't bind `BINN_UINT8`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT8`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:60\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                                            ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT16` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   -----------   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT16`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_UINT16`\n    |         |           |            |            |            |            variable not in all patterns\n    |         |           |            |            |            pattern doesn't bind `BINN_UINT16`\n    |         |           |            |            pattern doesn't bind `BINN_UINT16`\n    |         |           |            pattern doesn't bind `BINN_UINT16`\n    |         |           pattern doesn't bind `BINN_UINT16`\n    |         pattern doesn't bind `BINN_UINT16`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT16`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:73\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                                                         ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   -----------   ^^^^^^^^^^^ pattern doesn't bind `BINN_UINT32`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             variable not in all patterns\n    |         |           |            |            |            |            pattern doesn't bind `BINN_UINT32`\n    |         |           |            |            |            pattern doesn't bind `BINN_UINT32`\n    |         |           |            |            pattern doesn't bind `BINN_UINT32`\n    |         |           |            pattern doesn't bind `BINN_UINT32`\n    |         |           pattern doesn't bind `BINN_UINT32`\n    |         pattern doesn't bind `BINN_UINT32`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT32`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:87\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                                                                       ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_UINT64` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ----------- variable not in all patterns\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_UINT64`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_UINT64`\n    |         |           |            |            |            pattern doesn't bind `BINN_UINT64`\n    |         |           |            |            pattern doesn't bind `BINN_UINT64`\n    |         |           |            pattern doesn't bind `BINN_UINT64`\n    |         |           pattern doesn't bind `BINN_UINT64`\n    |         pattern doesn't bind `BINN_UINT64`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_UINT64`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:101\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                                                                                     ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT8` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:21\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ---------   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_INT8`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_INT8`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_INT8`\n    |         |           |            |            |            pattern doesn't bind `BINN_INT8`\n    |         |           |            |            pattern doesn't bind `BINN_INT8`\n    |         |           |            pattern doesn't bind `BINN_INT8`\n    |         |           pattern doesn't bind `BINN_INT8`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT8`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:9\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_FLOAT64` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:9\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |         ^^^^^^^^^^^^   ------------   ^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_FLOAT64`\n    |         |              |              |\n    |         |              |              pattern doesn't bind `BINN_FLOAT64`\n    |         |              variable not in all patterns\n    |         pattern doesn't bind `BINN_FLOAT64`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_FLOAT64`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:24\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |                        ^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_SINGLE_STR` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:9\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |         ^^^^^^^^^^^^   ^^^^^^^^^^^^   ---------------   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_SINGLE_STR`\n    |         |              |              |\n    |         |              |              variable not in all patterns\n    |         |              pattern doesn't bind `BINN_SINGLE_STR`\n    |         pattern doesn't bind `BINN_SINGLE_STR`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_SINGLE_STR`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:39\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |                                       ^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_DOUBLE_STR` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:9\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |         ^^^^^^^^^^^^   ^^^^^^^^^^^^   ^^^^^^^^^^^^^^^   --------------- variable not in all patterns\n    |         |              |              |\n    |         |              |              pattern doesn't bind `BINN_DOUBLE_STR`\n    |         |              pattern doesn't bind `BINN_DOUBLE_STR`\n    |         pattern doesn't bind `BINN_DOUBLE_STR`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_DOUBLE_STR`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:57\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |                                                         ^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_FLOAT32` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:24\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |         ------------   ^^^^^^^^^^^^   ^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_FLOAT32`\n    |         |              |              |\n    |         |              |              pattern doesn't bind `BINN_FLOAT32`\n    |         |              pattern doesn't bind `BINN_FLOAT32`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_FLOAT32`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:9\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |         ^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_HTML` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:9\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^   ---------   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_HTML`\n    |         |             |           |          |          |\n    |         |             |           |          |          pattern doesn't bind `BINN_HTML`\n    |         |             |           |          pattern doesn't bind `BINN_HTML`\n    |         |             |           pattern doesn't bind `BINN_HTML`\n    |         |             variable not in all patterns\n    |         pattern doesn't bind `BINN_HTML`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_HTML`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:23\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |                       ^^^^^^^^^\n\nerror[E0408]: variable `BINN_CSS` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:9\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^   ^^^^^^^^^   --------   ^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_CSS`\n    |         |             |           |          |          |\n    |         |             |           |          |          pattern doesn't bind `BINN_CSS`\n    |         |             |           |          pattern doesn't bind `BINN_CSS`\n    |         |             |           variable not in all patterns\n    |         |             pattern doesn't bind `BINN_CSS`\n    |         pattern doesn't bind `BINN_CSS`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_CSS`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:35\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |                                   ^^^^^^^^\n\nerror[E0408]: variable `BINN_XML` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:9\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^   --------   ^^^^^^^^^   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_XML`\n    |         |             |           |          |          |\n    |         |             |           |          |          pattern doesn't bind `BINN_XML`\n    |         |             |           |          variable not in all patterns\n    |         |             |           pattern doesn't bind `BINN_XML`\n    |         |             pattern doesn't bind `BINN_XML`\n    |         pattern doesn't bind `BINN_XML`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_XML`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:46\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |                                              ^^^^^^^^\n\nerror[E0408]: variable `BINN_JSON` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:9\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^   ^^^^^^^^   ---------   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_JSON`\n    |         |             |           |          |          |\n    |         |             |           |          |          variable not in all patterns\n    |         |             |           |          pattern doesn't bind `BINN_JSON`\n    |         |             |           pattern doesn't bind `BINN_JSON`\n    |         |             pattern doesn't bind `BINN_JSON`\n    |         pattern doesn't bind `BINN_JSON`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_JSON`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:57\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |                                                         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_JAVASCRIPT` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:9\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^   --------------- variable not in all patterns\n    |         |             |           |          |          |\n    |         |             |           |          |          pattern doesn't bind `BINN_JAVASCRIPT`\n    |         |             |           |          pattern doesn't bind `BINN_JAVASCRIPT`\n    |         |             |           pattern doesn't bind `BINN_JAVASCRIPT`\n    |         |             pattern doesn't bind `BINN_JAVASCRIPT`\n    |         pattern doesn't bind `BINN_JAVASCRIPT`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_JAVASCRIPT`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:69\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |                                                                     ^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STRING` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:23\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |         -----------   ^^^^^^^^^   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STRING`\n    |         |             |           |          |          |\n    |         |             |           |          |          pattern doesn't bind `BINN_STRING`\n    |         |             |           |          pattern doesn't bind `BINN_STRING`\n    |         |             |           pattern doesn't bind `BINN_STRING`\n    |         |             pattern doesn't bind `BINN_STRING`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STRING`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:9\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_JPEG` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:9\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |         ^^^^^^^^^   ---------   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^ pattern doesn't bind `BINN_JPEG`\n    |         |           |           |          |\n    |         |           |           |          pattern doesn't bind `BINN_JPEG`\n    |         |           |           pattern doesn't bind `BINN_JPEG`\n    |         |           variable not in all patterns\n    |         pattern doesn't bind `BINN_JPEG`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_JPEG`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:21\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |                     ^^^^^^^^^\n\nerror[E0408]: variable `BINN_GIF` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:9\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |         ^^^^^^^^^   ^^^^^^^^^   --------   ^^^^^^^^   ^^^^^^^^ pattern doesn't bind `BINN_GIF`\n    |         |           |           |          |\n    |         |           |           |          pattern doesn't bind `BINN_GIF`\n    |         |           |           variable not in all patterns\n    |         |           pattern doesn't bind `BINN_GIF`\n    |         pattern doesn't bind `BINN_GIF`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_GIF`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:33\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |                                 ^^^^^^^^\n\nerror[E0408]: variable `BINN_PNG` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:9\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |         ^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^   --------   ^^^^^^^^ pattern doesn't bind `BINN_PNG`\n    |         |           |           |          |\n    |         |           |           |          variable not in all patterns\n    |         |           |           pattern doesn't bind `BINN_PNG`\n    |         |           pattern doesn't bind `BINN_PNG`\n    |         pattern doesn't bind `BINN_PNG`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_PNG`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:44\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |                                            ^^^^^^^^\n\nerror[E0408]: variable `BINN_BMP` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:9\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |         ^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^   ^^^^^^^^   -------- variable not in all patterns\n    |         |           |           |          |\n    |         |           |           |          pattern doesn't bind `BINN_BMP`\n    |         |           |           pattern doesn't bind `BINN_BMP`\n    |         |           pattern doesn't bind `BINN_BMP`\n    |         pattern doesn't bind `BINN_BMP`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_BMP`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:55\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |                                                       ^^^^^^^^\n\nerror[E0408]: variable `BINN_BLOB` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:21\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |         ---------   ^^^^^^^^^   ^^^^^^^^   ^^^^^^^^   ^^^^^^^^ pattern doesn't bind `BINN_BLOB`\n    |         |           |           |          |\n    |         |           |           |          pattern doesn't bind `BINN_BLOB`\n    |         |           |           pattern doesn't bind `BINN_BLOB`\n    |         |           pattern doesn't bind `BINN_BLOB`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_BLOB`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:9\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_CURRENCY` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:9\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^^   -------------   ^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^^^^^ pattern doesn't bind `BINN_CURRENCY`\n    |         |              |               |           |\n    |         |              |               |           pattern doesn't bind `BINN_CURRENCY`\n    |         |              |               pattern doesn't bind `BINN_CURRENCY`\n    |         |              variable not in all patterns\n    |         pattern doesn't bind `BINN_CURRENCY`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_CURRENCY`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:24\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |                        ^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_DATE` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:9\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^^   ^^^^^^^^^^^^^   ---------   ^^^^^^^^^   ^^^^^^^^^^^^^ pattern doesn't bind `BINN_DATE`\n    |         |              |               |           |\n    |         |              |               |           pattern doesn't bind `BINN_DATE`\n    |         |              |               variable not in all patterns\n    |         |              pattern doesn't bind `BINN_DATE`\n    |         pattern doesn't bind `BINN_DATE`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_DATE`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:40\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |                                        ^^^^^^^^^\n\nerror[E0408]: variable `BINN_TIME` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:9\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^   ---------   ^^^^^^^^^^^^^ pattern doesn't bind `BINN_TIME`\n    |         |              |               |           |\n    |         |              |               |           variable not in all patterns\n    |         |              |               pattern doesn't bind `BINN_TIME`\n    |         |              pattern doesn't bind `BINN_TIME`\n    |         pattern doesn't bind `BINN_TIME`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_TIME`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:52\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |                                                    ^^^^^^^^^\n\nerror[E0408]: variable `BINN_DATETIME` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:9\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^   ------------- variable not in all patterns\n    |         |              |               |           |\n    |         |              |               |           pattern doesn't bind `BINN_DATETIME`\n    |         |              |               pattern doesn't bind `BINN_DATETIME`\n    |         |              pattern doesn't bind `BINN_DATETIME`\n    |         pattern doesn't bind `BINN_DATETIME`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_DATETIME`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:64\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |                                                                ^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_DECIMAL` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:24\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |         ------------   ^^^^^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^   ^^^^^^^^^^^^^ pattern doesn't bind `BINN_DECIMAL`\n    |         |              |               |           |\n    |         |              |               |           pattern doesn't bind `BINN_DECIMAL`\n    |         |              |               pattern doesn't bind `BINN_DECIMAL`\n    |         |              pattern doesn't bind `BINN_DECIMAL`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_DECIMAL`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:9\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |         ^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_TRUE` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:588:9\n    |\n588 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ^^^^^^^^^   ---------   ^^^^^^^^^^ pattern doesn't bind `BINN_TRUE`\n    |         |           |\n    |         |           variable not in all patterns\n    |         pattern doesn't bind `BINN_TRUE`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_TRUE`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:588:21\n    |\n588 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |                     ^^^^^^^^^\n\nerror[E0408]: variable `BINN_FALSE` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:588:9\n    |\n588 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ^^^^^^^^^   ^^^^^^^^^   ---------- variable not in all patterns\n    |         |           |\n    |         |           pattern doesn't bind `BINN_FALSE`\n    |         pattern doesn't bind `BINN_FALSE`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_FALSE`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:588:33\n    |\n588 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |                                 ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_BOOL` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:588:21\n    |\n588 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ---------   ^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_BOOL`\n    |         |           |\n    |         |           pattern doesn't bind `BINN_BOOL`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_BOOL`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:588:9\n    |\n588 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_CONTAINER` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:604:9\n    |\n604 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |         ^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^   ---------------------- variable not in all patterns\n    |         |                   |\n    |         |                   pattern doesn't bind `BINN_STORAGE_CONTAINER`\n    |         pattern doesn't bind `BINN_STORAGE_CONTAINER`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_CONTAINER`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:604:51\n    |\n604 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:604:29\n    |\n604 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |         -----------------   ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n    |         |                   |\n    |         |                   pattern doesn't bind `BINN_STORAGE_BLOB`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:604:9\n    |\n604 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |         ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:949:29\n    |\n949 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n    |         -----------------   ^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n    |         |\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:949:9\n    |\n949 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n    |         ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1022:33\n     |\n1022 |             BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |             -----------------   ^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n     |             |\n     |             variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1022:13\n     |\n1022 |             BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |             ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1130:29\n     |\n1130 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         -----------------   ^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n     |         |\n     |         variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1130:9\n     |\n1130 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_CONTAINER` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1199:9\n     |\n1199 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |         ^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^   ---------------------- variable not in all patterns\n     |         |                   |\n     |         |                   pattern doesn't bind `BINN_STORAGE_CONTAINER`\n     |         pattern doesn't bind `BINN_STORAGE_CONTAINER`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_CONTAINER`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1199:51\n     |\n1199 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |                                                   ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1199:29\n     |\n1199 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |         -----------------   ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n     |         |                   |\n     |         |                   pattern doesn't bind `BINN_STORAGE_BLOB`\n     |         variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1199:9\n     |\n1199 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |         ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_MAP` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1269:9\n     |\n1269 |         BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n     |         ^^^^^^^^^   --------   ^^^^^^^^^^^ pattern doesn't bind `BINN_MAP`\n     |         |           |\n     |         |           variable not in all patterns\n     |         pattern doesn't bind `BINN_MAP`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_MAP`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1269:21\n     |\n1269 |         BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n     |                     ^^^^^^^^\n\nerror[E0408]: variable `BINN_OBJECT` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1269:9\n     |\n1269 |         BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n     |         ^^^^^^^^^   ^^^^^^^^   ----------- variable not in all patterns\n     |         |           |\n     |         |           pattern doesn't bind `BINN_OBJECT`\n     |         pattern doesn't bind `BINN_OBJECT`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_OBJECT`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1269:32\n     |\n1269 |         BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n     |                                ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_LIST` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1269:21\n     |\n1269 |         BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n     |         ---------   ^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_LIST`\n     |         |           |\n     |         |           pattern doesn't bind `BINN_LIST`\n     |         variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_LIST`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1269:9\n     |\n1269 |         BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n     |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_TRUE` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1438:13\n     |\n1438 |             BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n     |             ^^^^^^^^^   ---------   ^^^^^^^^^^ pattern doesn't bind `BINN_TRUE`\n     |             |           |\n     |             |           variable not in all patterns\n     |             pattern doesn't bind `BINN_TRUE`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_TRUE`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1438:25\n     |\n1438 |             BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n     |                         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_FALSE` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1438:13\n     |\n1438 |             BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n     |             ^^^^^^^^^   ^^^^^^^^^   ---------- variable not in all patterns\n     |             |           |\n     |             |           pattern doesn't bind `BINN_FALSE`\n     |             pattern doesn't bind `BINN_FALSE`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_FALSE`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1438:37\n     |\n1438 |             BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n     |                                     ^^^^^^^^^^\n\nerror[E0408]: variable `BINN_NULL` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1438:25\n     |\n1438 |             BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n     |             ---------   ^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_NULL`\n     |             |           |\n     |             |           pattern doesn't bind `BINN_NULL`\n     |             variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_NULL`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1438:13\n     |\n1438 |             BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n     |             ^^^^^^^^^\n\nerror[E0408]: variable `BINN_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1439:13\n     |\n1439 |             BINN_STRING | BINN_BLOB => {\n     |             ^^^^^^^^^^^   --------- variable not in all patterns\n     |             |\n     |             pattern doesn't bind `BINN_BLOB`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1439:27\n     |\n1439 |             BINN_STRING | BINN_BLOB => {\n     |                           ^^^^^^^^^\n\nerror[E0408]: variable `BINN_STRING` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1439:27\n     |\n1439 |             BINN_STRING | BINN_BLOB => {\n     |             -----------   ^^^^^^^^^ pattern doesn't bind `BINN_STRING`\n     |             |\n     |             variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STRING`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1439:13\n     |\n1439 |             BINN_STRING | BINN_BLOB => {\n     |             ^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_WORD` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1795:9\n     |\n1795 |         BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n     |         ^^^^^^^^^^^^^^^^^^^^   -----------------   ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_WORD`\n     |         |                      |                   |\n     |         |                      |                   pattern doesn't bind `BINN_STORAGE_WORD`\n     |         |                      variable not in all patterns\n     |         pattern doesn't bind `BINN_STORAGE_WORD`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_WORD`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1795:32\n     |\n1795 |         BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n     |                                ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_DWORD` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1795:9\n     |\n1795 |         BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n     |         ^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^   ------------------   ^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_DWORD`\n     |         |                      |                   |\n     |         |                      |                   variable not in all patterns\n     |         |                      pattern doesn't bind `BINN_STORAGE_DWORD`\n     |         pattern doesn't bind `BINN_STORAGE_DWORD`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_DWORD`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1795:52\n     |\n1795 |         BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n     |                                                    ^^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_QWORD` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1795:9\n     |\n1795 |         BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n     |         ^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^   ------------------ variable not in all patterns\n     |         |                      |                   |\n     |         |                      |                   pattern doesn't bind `BINN_STORAGE_QWORD`\n     |         |                      pattern doesn't bind `BINN_STORAGE_QWORD`\n     |         pattern doesn't bind `BINN_STORAGE_QWORD`\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_QWORD`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1795:73\n     |\n1795 |         BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n     |                                                                         ^^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find value `极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速` in this scope\n --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:7:39\n  |\n7 | ... = 极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速...极速极速极速极速极速极速极速极速极速\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `malloc_fn` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:88:12\n   |\n88 |         if malloc_fn.is_none() {\n   |            ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `malloc_fn` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:89:13\n   |\n89 |             malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n   |             ^^^^^^^^^\n   |\nhelp: you might have meant to introduce a new binding\n   |\n89 |             let malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n   |             +++\n\nerror[E0425]: cannot find value `realloc_fn` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:91:12\n   |\n91 |         if realloc_fn.is_none() {\n   |            ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `realloc_fn` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:92:13\n   |\n92 |             realloc_fn = Some(|ptr, size| {\n   |             ^^^^^^^^^^\n   |\nhelp: you might have meant to introduce a new binding\n   |\n92 |             let realloc_fn = Some(|ptr, size| {\n   |             +++\n\nerror[E0425]: cannot find value `free_fn` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:101:12\n    |\n101 |         if free_fn.is_none() {\n    |            ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `free_fn` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:102:13\n    |\n102 |             free_fn = Some(|_| {});\n    |             ^^^^^^^\n    |\nhelp: you might have meant to introduce a new binding\n    |\n102 |             let free_fn = Some(|_| {});\n    |             +++\n\nerror[E0425]: cannot find value `BINN_STORAGE_BYTE` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:115:24\n    |\n7   | pub const BINN_STORAGE_NOBYTES: i32 = 极...速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速极速\n    | ---------------------------------------...---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- similarly named constant `BINN_STORAGE_NOBYTES` defined here\n...\n115 |     if storage_type == BINN_STORAGE_BYTE {\n    |                        ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_NOBYTES`\n\nerror[E0425]: cannot find value `UINT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:131:29\n    |\n131 |                 if vuint <= UINT8_MAX {\n    |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:132:29\n    |\n132 |                     type2 = BINN_UINT8;\n    |                             ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT64`\n\nerror[E0425]: cannot find value `UINT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:133:36\n    |\n133 |                 } else if vuint <= UINT16_MAX {\n    |                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT16` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:134:29\n    |\n134 |                     type2 = BINN_UINT16;\n    |                             ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT64`\n\nerror[E0425]: cannot find value `UINT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:135:36\n    |\n135 |                 } else if vuint <= UINT32_MAX {\n    |                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:136:29\n    |\n136 |                     type2 = BINN_UINT32;\n    |                             ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT64`\n\nerror[E0425]: cannot find value `INT8_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:139:28\n    |\n139 |                 if vint >= INT8_MIN {\n    |                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:140:29\n    |\n140 |                     type2 = BINN_INT8;\n    |                             ^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT64`\n\nerror[E0425]: cannot find value `INT16_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:141:35\n    |\n141 |                 } else if vint >= INT16_MIN {\n    |                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT16` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:142:29\n    |\n142 |                     type2 = BINN_INT16;\n    |                             ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT64`\n\nerror[E0425]: cannot find value `INT32_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:143:35\n    |\n143 |                 } else if vint >= INT32_MIN {\n    |                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:144:29\n    |\n144 |                     type2 = BINN_INT32;\n    |                             ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT64`\n\nerror[E0425]: cannot find value `UINT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:154:29\n    |\n154 |                 if vuint <= UINT8_MAX {\n    |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:155:29\n    |\n155 |                     type2 = BINN_UINT8;\n    |                             ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `UINT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:156:36\n    |\n156 |                 } else if vuint <= UINT16_MAX {\n    |                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT16` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:157:29\n    |\n157 |                     type2 = BINN_UINT16;\n    |                             ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `UINT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:158:36\n    |\n158 |                 } else if vuint <= UINT32_MAX {\n    |                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:159:29\n    |\n159 |                     type2 = BINN_UINT32;\n    |                             ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `INT8_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:162:28\n    |\n162 |                 if vint >= INT8_MIN {\n    |                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:163:29\n    |\n163 |                     type2 = BINN_INT8;\n    |                             ^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `INT16_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:164:35\n    |\n164 |                 } else if vint >= INT16_MIN {\n    |                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT16` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:165:29\n    |\n165 |                     type2 = BINN_INT16;\n    |                             ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT32`\n\nerror[E0425]: cannot find value `INT32_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:166:35\n    |\n166 |                 } else if vint >= INT32_MIN {\n    |                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `UINT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:177:29\n    |\n177 |                 if vuint <= UINT8_MAX {\n    |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:178:29\n    |\n178 |                     type2 = BINN_UINT8;\n    |                             ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT16`\n\nerror[E0425]: cannot find value `UINT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:179:36\n    |\n179 |                 } else if vuint <= UINT16_MAX {\n    |                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT16` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:180:29\n    |\n180 |                     type2 = BINN_UINT16;\n    |                             ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT16`\n\nerror[E0425]: cannot find value `UINT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:181:36\n    |\n181 |                 } else if vuint <= UINT32_MAX {\n    |                                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:182:29\n    |\n182 |                     type2 = BINN_UINT32;\n    |                             ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT16`\n\nerror[E0425]: cannot find value `INT8_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:185:28\n    |\n185 |                 if vint >= INT8_MIN {\n    |                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:186:29\n    |\n186 |                     type2 = BINN_INT8;\n    |                             ^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT16`\n\nerror[E0425]: cannot find value `INT16_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:187:35\n    |\n187 |                 } else if vint >= INT16_MIN {\n    |                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `INT32_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:189:35\n    |\n189 |                 } else if vint >= INT32_MIN {\n    |                                   ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:190:29\n    |\n190 |                     type2 = BINN_INT32;\n    |                             ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_INT16`\n\nerror[E0425]: cannot find value `UINT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:198:25\n    |\n198 |             if vuint <= UINT8_MAX {\n    |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:199:25\n    |\n199 |                 type2 = BINN_UINT8;\n    |                         ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_UINT64`\n\nerror[E0425]: cannot find value `UINT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:200:32\n    |\n200 |             } else if vuint <= UINT16_MAX {\n    |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT16` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:201:25\n    |\n201 |                 type2 = BINN_UINT16;\n    |                         ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_UINT64`\n\nerror[E0425]: cannot find value `UINT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:202:32\n    |\n202 |             } else if vuint <= UINT32_MAX {\n    |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:203:25\n    |\n203 |                 type2 = BINN_UINT32;\n    |                         ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_UINT64`\n\nerror[E0425]: cannot find value `UINT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:210:25\n    |\n210 |             if vuint <= UINT8_MAX {\n    |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:211:25\n    |\n211 |                 type2 = BINN_UINT8;\n    |                         ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_UINT32`\n\nerror[E0425]: cannot find value `UINT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:212:32\n    |\n212 |             } else if vuint <= UINT16_MAX {\n    |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT16` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:213:25\n    |\n213 |                 type2 = BINN_UINT16;\n    |                         ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_UINT32`\n\nerror[E0425]: cannot find value `UINT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:214:32\n    |\n214 |             } else if vuint <= UINT32_MAX {\n    |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `UINT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:222:25\n    |\n222 |             if vuint <= UINT8_MAX {\n    |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:223:25\n    |\n223 |                 type2 = BINN_UINT8;\n    |                         ^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_UINT16`\n\nerror[E0425]: cannot find value `UINT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:224:32\n    |\n224 |             } else if vuint <= UINT16_MAX {\n    |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `UINT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:226:32\n    |\n226 |             } else if vuint <= UINT32_MAX {\n    |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UINT32` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:227:25\n    |\n227 |                 type2 = BINN_UINT32;\n    |                         ^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_UINT16`\n\nerror[E0425]: cannot find value `BINN_SIGNED_INT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:245:61\n    |\n245 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |                                                             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UNSIGNED_INT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:246:65\n    |\n246 |         BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n    |                                                                 ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_HAS_MORE` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:261:15\n    |\n2   | pub const BINN_STORAGE_MASK: u32 = 0xE0;\n    | ---------------------------------------- similarly named constant `BINN_STORAGE_MASK` defined here\n...\n261 |     if byte & BINN_STORAGE_HAS_MORE != 0 {\n    |               ^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_MASK`\n\nerror[E0412]: cannot find type `Binn` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:332:36\n    |\n332 | pub fn binn_save_header(item: &mut Binn) -> bool {\n    |                                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MAX_BINN_HEADER` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:337:27\n    |\n337 |     let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    |                           ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MAX_BINN_HEADER` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:338:37\n    |\n338 |     let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n    |                                     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BUFFER` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:381:16\n    |\n381 |         return BINN_BUFFER;\n    |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_MAGIC` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:384:17\n    |\n384 |     if magic == BINN_MAGIC {\n    |                 ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STRUCT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:385:9\n    |\n385 |         BINN_STRUCT\n    |         ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BUFFER` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:387:9\n    |\n387 |         BINN_BUFFER\n    |         ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_CONTAINER` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:418:47\n    |\n6   | pub const BINN_STORAGE_STRING: i32 = 0xA0;\n    | ------------------------------------------ similarly named constant `BINN_STORAGE_STRING` defined here\n...\n418 |     if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n    |                                               ^^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_STRING`\n\nerror[E0425]: cannot find value `BINN_STORAGE_HAS_MORE` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:421:17\n    |\n2   | pub const BINN_STORAGE_MASK: u32 = 0xE0;\n    | ---------------------------------------- similarly named constant `BINN_STORAGE_MASK` defined here\n...\n421 |     if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n    |                 ^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_MASK`\n\nerror[E0412]: cannot find type `Binn` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:485:35\n    |\n485 | pub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    |                                   ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_BINN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:510:47\n    |\n510 |         BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n    |                                               ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_INT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:511:116\n    |\n511 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |                                                                                                                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_FLOAT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:512:76\n    |\n512 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |                                                                            ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_STRING` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:513:88\n    |\n513 |         BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n    |                                                                                        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_BLOB` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:514:67\n    |\n514 |         BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n    |                                                                   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_STRING` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:515:81\n    |\n515 |         BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n    |                                                                                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_BOOL` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:516:22\n    |\n516 |         BINN_BOOL => BINN_FAMILY_BOOL,\n    |                      ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_NULL` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:517:22\n    |\n517 |         BINN_NULL => BINN_FAMILY_NULL,\n    |                      ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_NONE` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:518:14\n    |\n518 |         _ => BINN_FAMILY_NONE,\n    |              ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_DWORD` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:586:28\n    |\n2   | pub const BINN_STORAGE_MASK: u32 = 0xE0;\n    | ---------------------------------------- similarly named constant `BINN_STORAGE_MASK` defined here\n...\n586 |         BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n    |                            ^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_STORAGE_QWORD` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:587:28\n    |\n2   | pub const BINN_STORAGE_MASK: u32 = 0xE0;\n    | ---------------------------------------- similarly named constant `BINN_STORAGE_MASK` defined here\n...\n587 |         BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n    |                            ^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_STORAGE_DWORD` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:588:47\n    |\n2   | pub const BINN_STORAGE_MASK: u32 = 0xE0;\n    | ---------------------------------------- similarly named constant `BINN_STORAGE_MASK` defined here\n...\n588 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |                                               ^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_UNSIGNED_INT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:677:33\n    |\n677 |     if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n    |                                 ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_SIGNED_INT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:677:77\n    |\n677 |     if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n    |                                                                             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_SIGNED_INT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:682:40\n    |\n682 |     } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n    |                                        ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_UNSIGNED_INT` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:682:82\n    |\n682 |     } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n    |                                                                                  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `INT8_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:691:25\n    |\n691 |             if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n    |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `INT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:691:53\n    |\n691 |             if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n    |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `INT16_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:701:25\n    |\n701 |             if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n    |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `INT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:701:54\n    |\n701 |             if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n    |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `INT32_MIN` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:711:25\n    |\n711 |             if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n    |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `INT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:711:54\n    |\n711 |             if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n    |                                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `UINT8_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:729:26\n    |\n729 |             if vuint64 > UINT8_MAX as u64 {\n    |                          ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `UINT16_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:739:26\n    |\n739 |             if vuint64 > UINT16_MAX as u64 {\n    |                          ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `UINT32_MAX` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:749:26\n    |\n749 |             if vuint64 > UINT32_MAX as u64 {\n    |                          ^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Binn` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:832:32\n    |\n832 |                 let mut item = Binn {\n    |                                ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:879:68\n    |\n879 | pub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    |                                                                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_MAGIC` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:890:20\n    |\n890 |     value.header = BINN_MAGIC as i32;\n    |                    ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_HAS_MORE` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:897:16\n    |\n2   | pub const BINN_STORAGE_MASK: u32 = 0xE0;\n    | ---------------------------------------- similarly named constant `BINN_STORAGE_MASK` defined here\n...\n897 |     if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n    |                ^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:986:27\n    |\n986 |             value.type_ = BINN_BOOL;\n    |                           ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:991:27\n    |\n991 |             value.type_ = BINN_BOOL;\n    |                           ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `malloc_fn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1005:33\n     |\n1005 |         if let Some(alloc_fn) = malloc_fn {\n     |                                 ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1014:28\n     |\n1014 | pub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n     |                            ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_INT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1035:30\n     |\n1035 |     if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n     |                              ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_CONTAINER` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1085:24\n     |\n6    | pub const BINN_STORAGE_STRING: i32 = 0xA0;\n     | ------------------------------------------ similarly named constant `BINN_STORAGE_STRING` defined here\n...\n1085 |     if storage_type != BINN_STORAGE_CONTAINER {\n     |                        ^^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_STRING`\n\nerror[E0425]: cannot find value `BINN_FAMILY_INT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1210:36\n     |\n1210 |     if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n     |                                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_FLOAT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1214:43\n     |\n1214 |     } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n     |                                           ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1227:76\n     |\n1227 | pub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n     |                                                                            ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_OBJECT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1243:17\n     |\n1243 |     if type_ != BINN_OBJECT {\n     |                 ^^^^^^^^^^^ help: a function with a similar name exists: `binn_object`\n...\n1974 | pub fn binn_object() -> Option<Box<Binn>> {\n     | ----------------------------------------- similarly named function `binn_object` defined here\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1264:31\n     |\n1264 | pub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n     |                               ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MIN_BINN_SIZE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1276:15\n     |\n1276 |     if size < MIN_BINN_SIZE {\n     |               ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `CHUNK_SIZE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1291:41\n     |\n1291 |         let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n     |                                         ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_MAGIC` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1300:19\n     |\n1300 |     item.header = BINN_MAGIC as i32;\n     |                   ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `MAX_BINN_HEADER` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1302:22\n     |\n1302 |     item.used_size = MAX_BINN_HEADER as i32;\n     |                      ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1310:73\n     |\n1310 | pub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n     |                                                                         ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_LIST` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1326:17\n     |\n1326 |     if type_ != BINN_LIST {\n     |                 ^^^^^^^^^ help: a function with a similar name exists: `binn_list`\n...\n2079 | pub fn binn_list() -> Option<Box<Binn>> {\n     | --------------------------------------- similarly named function `binn_list` defined here\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1356:36\n     |\n1356 | pub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n     |                                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_MAP` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1357:40\n     |\n1357 |     if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n     |                                        ^^^^^^^^ help: a function with a similar name exists: `binn_map`\n...\n2039 | pub fn binn_map() -> Option<Box<Binn>> {\n     | -------------------------------------- similarly named function `binn_map` defined here\n\nerror[E0425]: cannot find value `MAX_BINN_HEADER` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1361:45\n     |\n1361 |     let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n     |                                             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_SINGLE_STR` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1455:25\n     |\n1455 |                 type_ = BINN_SINGLE_STR;\n     |                         ^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_SINGLE`\n\nerror[E0425]: cannot find value `BINN_DOUBLE_STR` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1466:25\n     |\n1466 |                 type_ = BINN_DOUBLE_STR;\n     |                         ^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `BINN_DOUBLE`\n\nerror[E0425]: cannot find value `BINN_FALSE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1473:32\n     |\n1473 |                 if value[0] == BINN_FALSE as u8 {\n     |                                ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FALSE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1474:29\n     |\n1474 |                     type_ = BINN_FALSE;\n     |                             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_TRUE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1476:29\n     |\n1476 |                     type_ = BINN_TRUE;\n     |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_SINGLE_STR` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1492:17\n     |\n1492 |     if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n     |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_DOUBLE_STR` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1492:45\n     |\n1492 |     if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n     |                                             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1503:37\n     |\n1503 | pub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n     |                                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_LIST` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1504:40\n     |\n1504 |     if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n     |                                        ^^^^^^^^^ help: a function with a similar name exists: `binn_list`\n...\n2079 | pub fn binn_list() -> Option<Box<Binn>> {\n     | --------------------------------------- similarly named function `binn_list` defined here\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1518:39\n     |\n1518 | pub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n     |                                       ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_OBJECT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1519:40\n     |\n1519 |     if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n     |                                        ^^^^^^^^^^^ help: a function with a similar name exists: `binn_object`\n...\n1974 | pub fn binn_object() -> Option<Box<Binn>> {\n     | ----------------------------------------- similarly named function `binn_object` defined here\n\nerror[E0425]: cannot find value `MAX_BINN_HEADER` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1531:37\n     |\n1531 |     if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n     |                                     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_BLOB` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1579:36\n     |\n1579 |     if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n     |                                    ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_STRING` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1579:84\n     |\n1579 |     if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n     |                                                                                    ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1596:80\n     |\n1596 | pub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n     |                                                                                ^^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n1596 | pub fn binn_new<Binn>(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n     |                ++++++\n\nerror[E0425]: cannot find value `BINN_FAMILY_INT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1621:36\n     |\n1621 |     if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n     |                                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FAMILY_FLOAT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1625:43\n     |\n1625 |     } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n     |                                           ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FLOAT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1627:40\n     |\n1627 |         let result = if value.type_ == BINN_FLOAT32 {\n     |                                        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1647:122\n     |\n1647 | pub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n     |                                                                                                                          ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1724:71\n     |\n1724 | pub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n     |                                                                       ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_MAP` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1740:17\n     |\n1740 |     if type_ != BINN_MAP {\n     |                 ^^^^^^^^ help: a function with a similar name exists: `binn_map`\n...\n2039 | pub fn binn_map() -> Option<Box<Binn>> {\n     | -------------------------------------- similarly named function `binn_map` defined here\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1760:28\n     |\n1760 | pub fn store_value(value: &Binn) -> Vec<u8> {\n     |                            ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1805:31\n     |\n1805 | pub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n     |                               ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1818:33\n     |\n1818 | pub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n     |                                 ^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1832:34\n     |\n1832 | pub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n     |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_CONTAINER` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1914:53\n     |\n6    | pub const BINN_STORAGE_STRING: i32 = 0xA0;\n     | ------------------------------------------ similarly named constant `BINN_STORAGE_STRING` defined here\n...\n1914 |         if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n     |                                                     ^^^^^^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_STRING`\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1947:31\n     |\n1947 | pub fn binn_size(ptr: Option<&Binn>) -> i32 {\n     |                               ^^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n1947 | pub fn binn_size<Binn>(ptr: Option<&Binn>) -> i32 {\n     |                 ++++++\n\nerror[E0425]: cannot find value `BINN_STRING` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1967:23\n     |\n1967 |     if value.type_ != BINN_STRING {\n     |                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1974:36\n     |\n1974 | pub fn binn_object() -> Option<Box<Binn>> {\n     |                                    ^^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n1974 | pub fn binn_object<Binn>() -> Option<Box<Binn>> {\n     |                   ++++++\n\nerror[E0425]: cannot find value `BINN_OBJECT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1975:14\n     |\n1975 |     binn_new(BINN_OBJECT, 0, None)\n     |              ^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2004:86\n     |\n2004 | pub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n     |                                                                                      ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_MAP` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2006:20\n     |\n2006 |     binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n     |                    ^^^^^^^^ help: a function with a similar name exists: `binn_map`\n...\n2039 | pub fn binn_map() -> Option<Box<Binn>> {\n     | -------------------------------------- similarly named function `binn_map` defined here\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2010:39\n     |\n2010 | pub fn binn_free(mut item: Option<Box<Binn>>) {\n     |                                       ^^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2010 | pub fn binn_free<Binn>(mut item: Option<Box<Binn>>) {\n     |                 ++++++\n\nerror[E0425]: cannot find value `free_fn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2017:38\n     |\n2017 |         if let Some(free) = unsafe { free_fn } {\n     |                                      ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `free_fn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2028:38\n     |\n2028 |         if let Some(free) = unsafe { free_fn } {\n     |                                      ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_MAGIC` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2034:23\n     |\n2034 |         item.header = BINN_MAGIC as i32;\n     |                       ^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2039:33\n     |\n2039 | pub fn binn_map() -> Option<Box<Binn>> {\n     |                                 ^^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2039 | pub fn binn_map<Binn>() -> Option<Box<Binn>> {\n     |                ++++++\n\nerror[E0425]: cannot find value `BINN_MAP` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2040:14\n     |\n2040 |     binn_new(BINN_MAP, 0, None)\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2079:34\n     |\n2079 | pub fn binn_list() -> Option<Box<Binn>> {\n     |                                  ^^^^ not found in this scope\n     |\nhelp: you might be missing a type parameter\n     |\n2079 | pub fn binn_list<Binn>() -> Option<Box<Binn>> {\n     |                 ++++++\n\nerror[E0425]: cannot find value `BINN_LIST` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2080:14\n     |\n2080 |     binn_new(BINN_LIST, 0, None)\n     |              ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2099:37\n     |\n2099 | pub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n     |                                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2101:27\n     |\n2101 |     binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n     |                           ^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2105:40\n     |\n2105 | pub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n     |                                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2106:31\n     |\n2106 |     binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n     |                               ^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2110:39\n     |\n2110 | pub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n     |                                       ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2111:25\n     |\n2111 |     binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n     |                         ^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2115:36\n     |\n2115 | pub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n     |                                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_TRUE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2116:28\n     |\n2116 |     let value = if value { BINN_TRUE } else { BINN_FALSE };\n     |                            ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FALSE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2116:47\n     |\n2116 |     let value = if value { BINN_TRUE } else { BINN_FALSE };\n     |                                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2117:27\n     |\n2117 |     binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                           ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2121:40\n     |\n2121 | pub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n     |                                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FLOAT64` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2122:25\n     |\n2122 |     binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n     |                         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2126:39\n     |\n2126 | pub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n     |                                       ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2127:31\n     |\n2127 |     binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                               ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2131:41\n     |\n2131 | pub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n     |                                         ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FLOAT64` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2132:31\n     |\n2132 |     binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n     |                               ^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2136:38\n     |\n2136 | pub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n     |                                      ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FLOAT64` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2137:27\n     |\n2137 |     binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n     |                           ^^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2141:38\n     |\n2141 | pub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n     |                                      ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2142:25\n     |\n2142 |     binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n     |                         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_TRUE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2142:58\n     |\n2142 |     binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n     |                                                          ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_FALSE` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2142:83\n     |\n2142 |     binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n     |                                                                                   ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT32` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2147:30\n     |\n2147 |     binn_list_get(list, pos, BINN_INT32, pvalue, None)\n     |                              ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BLOB` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2156:23\n     |\n2156 |     if value.type_ != BINN_BLOB {\n     |                       ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2166:35\n     |\n2166 | pub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n     |                                   ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STRING` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2167:27\n     |\n2167 |     binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n     |                           ^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2171:37\n     |\n2171 | pub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n     |                                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STRING` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2172:25\n     |\n2172 |     binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n     |                         ^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2176:38\n     |\n2176 | pub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n     |                                      ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BLOB` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2177:25\n     |\n2177 |     binn_list_add(list, BINN_BLOB, ptr, size)\n     |                         ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2181:39\n     |\n2181 | pub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n     |                                       ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BLOB` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2182:31\n     |\n2182 |     binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n     |                               ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2186:38\n     |\n2186 | pub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n     |                                      ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STRING` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2187:31\n     |\n2187 |     binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n     |                               ^^^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `Binn` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2191:36\n     |\n2191 | pub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n     |                                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_BLOB` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2192:27\n     |\n2192 |     binn_map_set(map, id, BINN_BLOB, ptr, size)\n     |                           ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_VERSION` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2197:5\n     |\n2197 |     BINN_VERSION.to_string()\n     |     ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_OBJECT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2293:29\n     |\n1974 | pub fn binn_object() -> Option<Box<Binn>> {\n     | ----------------------------------------- similarly named function `binn_object` defined here\n...\n2293 |     let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n     |                             ^^^^^^^^^^^ help: a function with a similar name exists: `binn_object`\n\nerror[E0425]: cannot find value `BINN_MAGIC` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2297:29\n     |\n2297 |     assert_eq!(obj1.header, BINN_MAGIC as i32);\n     |                             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_OBJECT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2298:28\n     |\n1974 | pub fn binn_object() -> Option<Box<Binn>> {\n     | ----------------------------------------- similarly named function `binn_object` defined here\n...\n2298 |     assert_eq!(obj1.type_, BINN_OBJECT);\n     |                            ^^^^^^^^^^^ help: a function with a similar name exists: `binn_object`\n\nerror[E0425]: cannot find value `MAX_BINN_HEADER` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2302:32\n     |\n2302 |     assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n     |                                ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_OBJECT` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2365:28\n     |\n1974 | pub fn binn_object() -> Option<Box<Binn>> {\n     | ----------------------------------------- similarly named function `binn_object` defined here\n...\n2365 |     let mut obj = binn_new(BINN_OBJECT, 0, None).unwrap();\n     |                            ^^^^^^^^^^^ help: a function with a similar name exists: `binn_object`\n\nerror[E0425]: cannot find value `BINN_STRING` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2369:44\n     |\n2369 |     assert!(binn_object_set(&mut obj, key, BINN_STRING, Some(&value.as_bytes().to_vec()), 0));\n     |                                            ^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n   --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:889:14\n    |\n889 |     *value = Binn::default();\n    |              ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1284:13\n     |\n1284 |     *item = Binn::default();\n     |             ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1574:21\n     |\n1574 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1597:29\n     |\n1597 |     let mut item = Box::new(Binn::default());\n     |                             ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1616:21\n     |\n1616 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1761:27\n     |\n1761 |     let mut local_value = Binn::default();\n     |                           ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:1963:21\n     |\n1963 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2033:17\n     |\n2033 |         *item = Binn::default();\n     |                 ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2045:21\n     |\n2045 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2065:21\n     |\n2065 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2085:21\n     |\n2085 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2152:21\n     |\n2152 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2318:21\n     |\n2318 |     let mut value = Binn::default();\n     |                     ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2323:13\n     |\n2323 |     value = Binn::default();\n     |             ^^^^ use of undeclared type `Binn`\n\nerror[E0433]: failed to resolve: use of undeclared type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_binn_string_operations/test_source.rs:2327:13\n     |\n2327 |     value = Binn::default();\n     |             ^^^^ use of undeclared type `Binn`\n\nerror: aborting due to 281 previous errors\n\nSome errors have detailed explanations: E0408, E0412, E0422, E0425, E0433.\nFor more information about an error, try `rustc --explain E0408`.\n",
        "test_invalid_binn_operations": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_invalid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let i = 123;\n\n    assert!(!binn_map_set(list.as_mut().unwrap(), 55001, BINN_INT32, Some(&vec![i as u8]), 0));\n    assert!(!binn_object_set(list.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i as u8]), 0));\n\n    assert!(!binn_list_add(map.as_mut().unwrap(), BINN_INT32, Some(&vec![i as u8]), 0));\n    assert!(!binn_object_set(map.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i as u8]), 0));\n\n    assert!(!binn_list_add(obj.as_mut().unwrap(), BINN_INT32, Some(&vec![i as u8]), 0));\n    assert!(!binn_map_set(obj.as_mut().unwrap(), 55001, BINN_INT32, Some(&vec![i as u8]), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error: expected `;`, found keyword `pub`\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:10:32\n   |\n10 | pub const BINN_BOOL: i32 = 极客时间\n   |                                    ^ help: add `;` here\n11 | pub const CHUNK_SIZE: i32 = 256;\n   | --- unexpected token\n\nerror: expected `;`, found keyword `pub`\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:17:24\n   |\n17 | pub const BINN_INT8极客时间\n   |                            ^ help: add `;` here\n18 | pub const BINN_UINT64: i32 = 0x80;\n   | --- unexpected token\n\nerror: expected `;`, found keyword `pub`\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:34:16\n   |\n34 | pub const B极客时间\n   |                    ^ help: add `;` here\n35 | pub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\n   | --- unexpected token\n\nerror: expected `;`, found keyword `pub`\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:61:29\n   |\n61 | pub const BINN_OBJECT: i极客时间\n   |                                 ^ help: add `;` here\n62 | pub const BINN_SINGLE: i32 = BINN_FLOAT32;\n   | --- unexpected token\n\nerror: expected `,`, or `}`, found keyword `pub`\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:93:24\n   |\n93 |     pub alloc_size:极客时间\n   |                            ^ help: try adding a comma: `,`\n\nerror: expected one of `!`, `,`, `.`, `::`, `?`, `{`, `}`, or an operator, found `count`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:172:13\n    |\n160 |         Binn {\n    |         ---- while parsing this struct\n...\n171 |             size: 极客时间\n    |                           -\n    |                           |\n    |                           expected one of 8 possible tokens\n    |                           help: try adding a comma: `,`\n172 |             count: 0,\n    |             ^^^^^ unexpected token\n\nerror: expected one of `,`, `:`, or `}`, found `vint16`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:175:13\n    |\n160 |         Binn {\n    |         ---- while parsing this struct\n...\n174 |             v极客时间\n    |             --------- while parsing this struct field\n175 |             vint16: 0,\n    |             ^^^^^^ expected one of `,`, `:`, or `}`\n\nerror: expected one of `!`, `,`, `.`, `::`, `?`, `{`, `}`, or an operator, found `vint`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:186:13\n    |\n160 |         Binn {\n    |         ---- while parsing this struct\n...\n185 |             vushort: 极客时间\n    |                              -\n    |                              |\n    |                              expected one of 8 possible tokens\n    |                              help: try adding a comma: `,`\n186 |             vint: 0,\n    |             ^^^^ unexpected token\n\nerror: expected `;`, found keyword `pub`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:202:39\n    |\n202 | pub const BINN_VERSION: &str = \"3.0.0\"\n    |                                       ^ help: add `;` here\n203 | pub const INT64_FORMAT: &str = \"I64i\";\n    | --- unexpected token\n\nerror: expected `;`, found keyword `pub`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:206:35\n    |\n206 | pub const VERYSMALL: f64 = 1.0极客时间\n    |                                       ^ help: add `;` here\n207 | pub const TRUE: bool = true;\n    | --- unexpected token\n\nerror: free constant item without body\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:17:1\n   |\n17 | pub const BINN_INT8极客时间\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: provide a definition for the constant: `= <expr>;`\n\nerror: free constant item without body\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:34:1\n   |\n34 | pub const B极客时间\n   | ^^^^^^^^^^^^^^^^^^^- help: provide a definition for the constant: `= <expr>;`\n\nerror: free constant item without body\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:61:1\n   |\n61 | pub const BINN_OBJECT: i极客时间\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: provide a definition for the constant: `= <expr>;`\n\nerror[E0408]: variable `BINN_INT8` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:440:21\n    |\n440 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ---------   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_INT8`\n    |         |           |            |\n    |         |           |            pattern doesn't bind `BINN_INT8`\n    |         |           pattern doesn't bind `BINN_INT8`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT8`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:440:9\n    |\n440 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n    |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_INT8` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:706:21\n    |\n706 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ---------   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^^^^^^^^ pattern doesn't bind `BINN_INT8`\n    |         |           |            |            |            |            |             |\n    |         |           |            |            |            |            |             pattern doesn't bind `BINN_INT8`\n    |         |           |            |            |            |            pattern doesn't bind `BINN_INT8`\n    |         |           |            |            |            pattern doesn't bind `BINN_INT8`\n    |         |           |            |            pattern doesn't bind `BINN_INT8`\n    |         |           |            pattern doesn't bind `BINN_INT8`\n    |         |           pattern doesn't bind `BINN_INT8`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_INT8`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:706:9\n    |\n706 |         BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n    |         ^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:799:29\n    |\n799 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |         -----------------   ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n    |         |                   |\n    |         |                   pattern doesn't bind `BINN_STORAGE_BLOB`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:799:9\n    |\n799 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n    |         ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1144:29\n     |\n1144 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         -----------------   ^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n     |         |\n     |         variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1144:9\n     |\n1144 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1217:33\n     |\n1217 |             BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |             -----------------   ^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n     |             |\n     |             variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1217:13\n     |\n1217 |             BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |             ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1325:29\n     |\n1325 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         -----------------   ^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n     |         |\n     |         variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1325:9\n     |\n1325 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n     |         ^^^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_STORAGE_BLOB` is not bound in all patterns\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1394:29\n     |\n1394 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |         -----------------   ^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_STORAGE_BLOB`\n     |         |                   |\n     |         |                   pattern doesn't bind `BINN_STORAGE_BLOB`\n     |         variable not in all patterns\n     |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_STORAGE_BLOB`\n    --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:1394:9\n     |\n1394 |         BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n     |         ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find value `极客时间` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:10:28\n   |\n10 | pub const BINN_BOOL: i32 = 极客时间\n   |                            ^^^^^^^^ help: a constant with a similar name exists: `B极客时间`\n...\n34 | pub const B极客时间\n   | ------------------- similarly named constant `B极客时间` defined here\n\nerror[E0412]: cannot find type `i极客时间` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:61:24\n   |\n61 | pub const BINN_OBJECT: i极客时间\n   |                        ^^^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `极客时间` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:93:20\n   |\n93 |     pub alloc_size:极客时间\n   |                    ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_INT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:335:29\n    |\n21  | pub const BINN_UINT8: i32 = 0x20;\n    | --------------------------------- similarly named constant `BINN_UINT8` defined here\n...\n335 |                     type2 = BINN_INT8;\n    |                             ^^^^^^^^^ help: a constant with a similar name exists: `BINN_UINT8`\n\nerror[E0425]: cannot find value `BINN_INT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:358:29\n    |\n21  | pub const BINN_UINT8: i32 = 0x20;\n    | --------------------------------- similarly named constant `BINN_UINT8` defined here\n...\n358 |                     type2 = BINN_INT8;\n    |                             ^^^^^^^^^ help: a constant with a similar name exists: `BINN_UINT8`\n\nerror[E0425]: cannot find value `BINN_INT8` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:381:29\n    |\n21  | pub const BINN_UINT8: i32 = 0x20;\n    | --------------------------------- similarly named constant `BINN_UINT8` defined here\n...\n381 |                     type2 = BINN_INT8;\n    |                             ^^^^^^^^^ help: a constant with a similar name exists: `BINN_UINT8`\n\nerror: invalid suffix `极客时间` for float literal\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:206:28\n    |\n206 | pub const VERYSMALL: f64 = 1.0极客时间\n    |                            ^^^^^^^^^^^ invalid suffix `极客时间`\n    |\n    = help: valid suffixes are `f32` and `f64`\n\nerror: missing type for `const` item\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:17:24\n   |\n17 | pub const BINN_INT8极客时间\n   |                            ^\n   |\nhelp: provide a type for the item\n   |\n17 | pub const BINN_INT8极客时间: <type>\n   |                            ++++++++\n\nerror: missing type for `const` item\n  --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:34:16\n   |\n34 | pub const B极客时间\n   |                    ^\n   |\nhelp: provide a type for the item\n   |\n34 | pub const B极客时间: <type>\n   |                    ++++++++\n\nerror[E0063]: missing fields `count`, `vint`, `vint16` and 1 other field in initializer of `Binn`\n   --> ../../Output/crown/tmp/test-binn_test_invalid_binn_operations/test_source.rs:160:9\n    |\n160 |         Binn {\n    |         ^^^^ missing `count`, `vint`, `vint16` and 1 other field\n\nerror: aborting due to 30 previous errors\n\nSome errors have detailed explanations: E0063, E0408, E0412, E0425.\nFor more information about an error, try `rustc --explain E0063`.\n",
        "test_valid_binn_creation": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn test_valid_binn_creation() {\n    let list = binn_new(BINN_LIST, 0, None);\n    assert!(list.is_some());\n\n    let map = binn_new(BINN_MAP, 0, None);\n    assert!(map.is_some());\n\n    let obj = binn_new(BINN_OBJECT, 0, None);\n    assert!(obj.is_some());\n\n    let list_ref = list.as_ref().unwrap();\n    assert_eq!(list_ref.header, BINN_MAGIC as i32);\n    assert_eq!(list_ref.type_, BINN_LIST);\n    assert_eq!(list_ref.count, 0);\n    assert!(!list_ref.pbuf.is_empty());\n    assert!(list_ref.alloc_size > MAX_BINN_HEADER as i32);\n    assert_eq!(list_ref.used_size, MAX_BINN_HEADER as i32);\n    assert!(!list_ref.pre_allocated);\n\n    let map_ref = map.as_ref().unwrap();\n    assert_eq!(map_ref.header, BINN_MAGIC as i32);\n    assert_eq!(map_ref.type_, BINN_MAP);\n    assert_eq!(map_ref.count, 0);\n    assert!(!map_ref.pbuf.is_empty());\n    assert!(map_ref.alloc_size > MAX_BINN_HEADER as i32);\n    assert_eq!(map_ref.used_size, MAX_BINN_HEADER as i32);\n    assert!(!map_ref.pre_allocated);\n\n    let obj_ref = obj.as_ref().unwrap();\n    assert_eq!(obj_ref.header, BINN_MAGIC as i32);\n    assert_eq!(obj_ref.type_, BINN_OBJECT);\n    assert_eq!(obj_ref.count, 0);\n    assert!(!obj_ref.pbuf.is_empty());\n    assert!(obj_ref.alloc_size > MAX_BINN_HEADER as i32);\n    assert_eq!(obj_ref.used_size, MAX_BINN_HEADER as i32);\n    assert!(!obj_ref.pre_allocated);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error[E0408]: variable `BINN_BOOL` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_valid_binn_creation/test_source.rs:783:21\n    |\n783 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ---------   ^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_BOOL`\n    |         |           |\n    |         |           pattern doesn't bind `BINN_BOOL`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_BOOL`\n   --> ../../Output/crown/tmp/test-binn_test_valid_binn_creation/test_source.rs:783:9\n    |\n783 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ^^^^^^^^^\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_valid_binn_creation/test_source.rs:1181:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n1181 |             value.type_ = BINN_BOOL;\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_valid_binn_creation/test_source.rs:1186:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n1186 |             value.type_ = BINN_BOOL;\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_valid_binn_creation/test_source.rs:2312:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2312 |     binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_valid_binn_creation/test_source.rs:2322:31\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2322 |     binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                               ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_valid_binn_creation/test_source.rs:2337:25\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2337 |     binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n     |                         ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0408, E0425.\nFor more information about an error, try `rustc --explain E0408`.\n",
        "test_calc_allocation": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn test_calc_allocation() {\n    assert_eq!(CalcAllocation(512, 512), 512);\n    assert_eq!(CalcAllocation(510, 512), 512);\n    assert_eq!(CalcAllocation(1, 512), 512);\n    assert_eq!(CalcAllocation(0, 512), 512);\n\n    assert_eq!(CalcAllocation(513, 512), 1024);\n    assert_eq!(CalcAllocation(512 + CHUNK_SIZE, 512), 1024);\n    assert_eq!(CalcAllocation(1025, 512), 2048);\n    assert_eq!(CalcAllocation(1025, 1024), 2048);\n    assert_eq!(CalcAllocation(2100, 1024), 4096);\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error: expected one of `!` or `::`, found keyword `const`\n  --> ../../Output/crown/tmp/test-binn_test_calc_allocation/test_source.rs:59:9\n   |\n59 | p极客时间ub const BINN_FAMILY_INT: i32 = 0xF2;\n   |             ^^^^^ expected one of `!` or `::`\n\nerror: aborting due to 1 previous error\n\n",
        "test_create_binn_structures": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\n\n\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n\npub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n\npub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n\npub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn test_create_binn_structures() {\n    let list = binn_list();\n    assert!(!list.is_none());\n\n    let map = binn_map();\n    assert!(!map.is_none());\n\n    let obj = binn_object();\n    assert!(!obj.is_none());\n\n    let list_ref = list.as_ref().unwrap();\n    assert!(list_ref.header == BINN_MAGIC as i32);\n    assert!(list_ref.type_ == BINN_LIST);\n    assert!(list_ref.count == 0);\n    assert!(!list_ref.pbuf.is_empty());\n    assert!(list_ref.alloc_size > MAX_BINN_HEADER as i32);\n    assert!(list_ref.used_size == MAX_BINN_HEADER as i32);\n    assert!(!list_ref.pre_allocated);\n\n    let map_ref = map.as_ref().unwrap();\n    assert!(map_ref.header == BINN_MAGIC as i32);\n    assert!(map_ref.type_ == BINN_MAP);\n    assert!(map_ref.count == 0);\n    assert!(!map_ref.pbuf.is_empty());\n    assert!(map_ref.alloc_size > MAX_BINN_HEADER as i32);\n    assert!(map_ref.used_size == MAX_BINN_HEADER as i32);\n    assert!(!map_ref.pre_allocated);\n\n    let obj_ref = obj.as_ref().unwrap();\n    assert!(obj_ref.header == BINN_MAGIC as i32);\n    assert!(obj_ref.type_ == BINN_OBJECT);\n    assert!(obj_ref.count == 0);\n    assert!(!obj_ref.pbuf.is_empty());\n    assert!(obj_ref.alloc_size > MAX_BINN_HEADER as i32);\n    assert!(obj_ref.used_size == MAX_BINN_HEADER as i32);\n    assert!(!obj_ref.pre_allocated);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\nfn main(){}\n\n //insert编译报错信息：",
        "test_valid_add_operations": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n\npub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n\npub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n\npub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_valid_add_operations() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n    let i: i32 = 123;\n\n    assert!(binn_list_add(&mut list, BINN_INT32, Some(&vec![i.to_ne_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(&mut map, 5501, BINN_INT32, Some(&vec![i.to_ne_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(&mut obj, \"test\", BINN_INT32, Some(&vec![i.to_ne_bytes().to_vec()].concat()), 0));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\nfn main(){}\n\n\n //insert编译报错信息：error: unknown start of token: \\u{ff0c}\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:2:16\n  |\n2 | pub const B极简风格，仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n  |                    ^^\n  |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n  |\n2 - pub const B极简风格，仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n2 + pub const B极简风格,仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n  |\n\nerror: unknown start of token: \\u{ff0c}\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:2:24\n  |\n2 | pub const B极简风格，仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n  |                                    ^^\n  |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n  |\n2 - pub const B极简风格，仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n2 + pub const B极简风格，仅保留核心功能,无多余元素INN_INT32: i32 = 0x61;\n  |\n\nerror: unknown start of token: \\u{ff0c}\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:6:29\n  |\n6 | pub const BINN_UINT32: i极简风格，仅保留核心功能，无多余元素32 = 0x60;\n  |                                 ^^\n  |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n  |\n6 - pub const BINN_UINT32: i极简风格，仅保留核心功能，无多余元素32 = 0x60;\n6 + pub const BINN_UINT32: i极简风格,仅保留核心功能，无多余元素32 = 0x60;\n  |\n\nerror: unknown start of token: \\u{ff0c}\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:6:37\n  |\n6 | pub const BINN_UINT32: i极简风格，仅保留核心功能，无多余元素32 = 0x60;\n  |                                                 ^^\n  |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n  |\n6 - pub const BINN_UINT32: i极简风格，仅保留核心功能，无多余元素32 = 0x60;\n6 + pub const BINN_UINT32: i极简风格，仅保留核心功能,无多余元素32 = 0x60;\n  |\n\nerror: unknown start of token: \\u{ff0c}\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:8:33\n  |\n8 | pub const BINN_UINT8: i32 = 极简风格，仅保留核心功能，无多余元素0x20;\n  |                                     ^^\n  |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n  |\n8 - pub const BINN_UINT8: i32 = 极简风格，仅保留核心功能，无多余元素0x20;\n8 + pub const BINN_UINT8: i32 = 极简风格,仅保留核心功能，无多余元素0x20;\n  |\n\nerror: unknown start of token: \\u{ff0c}\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:8:41\n  |\n8 | pub const BINN_UINT8: i32 = 极简风格，仅保留核心功能，无多余元素0x20;\n  |                                                     ^^\n  |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n  |\n8 - pub const BINN_UINT8: i32 = 极简风格，仅保留核心功能，无多余元素0x20;\n8 + pub const BINN_UINT8: i32 = 极简风格，仅保留核心功能,无多余元素0x20;\n  |\n\nerror[E0768]: no valid digits found for number\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:26:41\n   |\n26 | pub const BINN_STORAGE_CONTAINER: i32 = 0x极简风格，仅保留核心功能，无多余元素E0;\n   |                                         ^^\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:26:47\n   |\n26 | pub const BINN_STORAGE_CONTAINER: i32 = 0x极简风格，仅保留核心功能，无多余元素E0;\n   |                                                   ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n26 - pub const BINN_STORAGE_CONTAINER: i32 = 0x极简风格，仅保留核心功能，无多余元素E0;\n26 + pub const BINN_STORAGE_CONTAINER: i32 = 0x极简风格,仅保留核心功能，无多余元素E0;\n   |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:26:55\n   |\n26 | pub const BINN_STORAGE_CONTAINER: i32 = 0x极简风格，仅保留核心功能，无多余元素E0;\n   |                                                                   ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n26 - pub const BINN_STORAGE_CONTAINER: i32 = 0x极简风格，仅保留核心功能，无多余元素E0;\n26 + pub const BINN_STORAGE_CONTAINER: i32 = 0x极简风格，仅保留核心功能,无多余元素E0;\n   |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:31:29\n   |\n31 | pub const BINN_BUFFER: i极简风格，仅保留核心功能，无多余元素32 = 2;\n   |                                 ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n31 - pub const BINN_BUFFER: i极简风格，仅保留核心功能，无多余元素32 = 2;\n31 + pub const BINN_BUFFER: i极简风格,仅保留核心功能，无多余元素32 = 2;\n   |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:31:37\n   |\n31 | pub const BINN_BUFFER: i极简风格，仅保留核心功能，无多余元素32 = 2;\n   |                                                 ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n31 - pub const BINN_BUFFER: i极简风格，仅保留核心功能，无多余元素32 = 2;\n31 + pub const BINN_BUFFER: i极简风格，仅保留核心功能,无多余元素32 = 2;\n   |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:57:31\n   |\n57 | pub const BINN_PNG: i32 = 极简风格，仅保留核心功能，无多余元素0xD003;\n   |                                   ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n57 - pub const BINN_PNG: i32 = 极简风格，仅保留核心功能，无多余元素0xD003;\n57 + pub const BINN_PNG: i32 = 极简风格,仅保留核心功能，无多余元素0xD003;\n   |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:57:39\n   |\n57 | pub const BINN_PNG: i32 = 极简风格，仅保留核心功能，无多余元素0xD003;\n   |                                                   ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n57 - pub const BINN_PNG: i32 = 极简风格，仅保留核心功能，无多余元素0xD003;\n57 + pub const BINN_PNG: i32 = 极简风格，仅保留核心功能,无多余元素0xD003;\n   |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:87:14\n   |\n87 |     pub v极简风格，仅保留核心功能，无多余元素int8: i8,\n   |                  ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n87 -     pub v极简风格，仅保留核心功能，无多余元素int8: i8,\n87 +     pub v极简风格,仅保留核心功能，无多余元素int8: i8,\n   |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:87:22\n   |\n87 |     pub v极简风格，仅保留核心功能，无多余元素int8: i8,\n   |                                  ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n87 -     pub v极简风格，仅保留核心功能，无多余元素int8: i8,\n87 +     pub v极简风格，仅保留核心功能,无多余元素int8: i8,\n   |\n\nerror: unknown start of token: \\u{ff0c}\n   --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:156:24\n    |\n156 |             type_: 极简风格，仅保留核心功能，无多余元素0,\n    |                            ^^\n    |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n    |\n156 -             type_: 极简风格，仅保留核心功能，无多余元素0,\n156 +             type_: 极简风格,仅保留核心功能，无多余元素0,\n    |\n\nerror: unknown start of token: \\u{ff0c}\n   --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:156:32\n    |\n156 |             type_: 极简风格，仅保留核心功能，无多余元素0,\n    |                                            ^^\n    |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n    |\n156 -             type_: 极简风格，仅保留核心功能，无多余元素0,\n156 +             type_: 极简风格，仅保留核心功能,无多余元素0,\n    |\n\nerror: unknown start of token: \\u{ff0c}\n   --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:163:25\n    |\n163 |             vint32: 极简风格，仅保留核心功能，无多余元素0,\n    |                             ^^\n    |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n    |\n163 -             vint32: 极简风格，仅保留核心功能，无多余元素0,\n163 +             vint32: 极简风格,仅保留核心功能，无多余元素0,\n    |\n\nerror: unknown start of token: \\u{ff0c}\n   --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:163:33\n    |\n163 |             vint32: 极简风格，仅保留核心功能，无多余元素0,\n    |                                             ^^\n    |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n    |\n163 -             vint32: 极简风格，仅保留核心功能，无多余元素0,\n163 +             vint32: 极简风格，仅保留核心功能,无多余元素0,\n    |\n\nerror: expected one of `:`, `;`, `<`, `=`, or `where`, found `,`\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:2:16\n  |\n2 | pub const B极简风格，仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n  |                    ^^ expected one of `:`, `;`, `<`, `=`, or `where`\n\nerror: missing type for `const` item\n --> ../../Output/crown/tmp/test-binn_test_valid_add_operations/test_source.rs:2:16\n  |\n2 | pub const B极简风格，仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n  |                    ^\n  |\nhelp: provide a type for the item\n  |\n2 | pub const B极简风格: <type>，仅保留核心功能，无多余元素INN_INT32: i32 = 0x61;\n  |                    ++++++++\n\nerror: aborting due to 21 previous errors\n\nFor more information about this error, try `rustc --explain E0768`.\n",
        "test_add_strings_and_blobs_with_compression": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\n\n\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n\npub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n\npub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n\npub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_add_strings_and_blobs_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    let str_list = String::from(\"test list\");\n    let str_map = String::from(\"test map\");\n    let str_obj = String::from(\"test object\");\n\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add_str(&mut list, str_list));\n    assert!(binn_map_set_str(&mut map, 1004, str_map));\n    assert!(binn_object_set_str(&mut obj, \"text\", str_obj));\n\n    assert!(binn_list_add_blob(&mut list, Some(&pblob), blobsize));\n    assert!(binn_map_set_blob(&mut map, 1005, Some(&pblob), blobsize));\n    assert!(binn_object_set_blob(&mut obj, \"blob\", pblob, blobsize));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error: expected `;`, found keyword `pub`\n   --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:202:39\n    |\n202 | pub const BINN_VERSION: &str = \"3.0.0\"\n    |                                       ^ help: add `;` here\n203 | pub const INT64_FORMAT: &str = \"I64i\";\n    | --- unexpected token\n\nerror[E0408]: variable `BINN_BOOL` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:783:21\n    |\n783 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ---------   ^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_BOOL`\n    |         |           |\n    |         |           pattern doesn't bind `BINN_BOOL`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_BOOL`\n   --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:783:9\n    |\n783 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ^^^^^^^^^\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:1181:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n1181 |             value.type_ = BINN_BOOL;\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:1186:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n1186 |             value.type_ = BINN_BOOL;\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:2312:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2312 |     binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:2322:31\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2322 |     binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                               ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_add_strings_and_blobs_with_compression/test_source.rs:2337:25\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2337 |     binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n     |                         ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0408, E0425.\nFor more information about an error, try `rustc --explain E0408`.\n",
        "test_create_and_add_values_no_compression": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\n\n\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n\npub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n\npub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n\npub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_create_and_add_values_no_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    list.disable_int_compression = true;\n    map.disable_int_compression = true;\n    obj.disable_int_compression = true;\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error[E0768]: no valid digits found for number\n  --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:62:30\n   |\n62 | pub const BINN_OBJECT: i32 = 0x极E2;\n   |                              ^^\n\nerror[E0428]: the name `B极INN_STORAGE_MASK` is defined multiple times\n  --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:36:1\n   |\n2  | pub const B极INN_STORAGE_MASK: u32 = 0xE0;\n   | ------------------------------------------ previous definition of the value `B极INN_STORAGE_MASK` here\n...\n36 | pub const B极INN_STORAGE_MASK: u32 = 0xE0;\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `B极INN_STORAGE_MASK` redefined here\n   |\n   = note: `B极INN_STORAGE_MASK` must be defined only once in the value namespace of this module\n\nerror[E0408]: variable `BINN_SINGLE_STR` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:258:27\n    |\n258 |         BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n    |         ---------------   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_SINGLE_STR`\n    |         |\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_SINGLE_STR`\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:258:9\n    |\n258 |         BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n    |         ^^^^^^^^^^^^^^^\n\nerror[E0408]: variable `BINN_SINGLE_STR` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:708:9\n    |\n708 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |         ^^^^^^^^^^^^   ^^^^^^^^^^^^   ---------------   ^^^^^^^^^^^^^^^ pattern doesn't bind `BINN_SINGLE_STR`\n    |         |              |              |\n    |         |              |              variable not in all patterns\n    |         |              pattern doesn't bind `BINN_SINGLE_STR`\n    |         pattern doesn't bind `BINN_SINGLE_STR`\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_SINGLE_STR`\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:708:39\n    |\n708 |         BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n    |                                       ^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find value `极0x61` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:15:29\n   |\n15 | pub const BINN_INT32: i32 = 极0x61;\n   |                             ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `极0` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:173:20\n    |\n173 |             count: 极0,\n    |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find value `BINN_STORAGE_MASK` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:223:44\n    |\n2   | pub const B极INN_STORAGE_MASK: u32 = 0xE0;\n    | ------------------------------------------ similarly named constant `B极INN_STORAGE_MASK` defined here\n...\n223 |             storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n    |                                            ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_STORAGE_MASK` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:454:38\n    |\n2   | pub const B极INN_STORAGE_MASK: u32 = 0xE0;\n    | ------------------------------------------ similarly named constant `B极INN_STORAGE_MASK` defined here\n...\n454 |     let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    |                                      ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_STORAGE_MASK` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:614:17\n    |\n2   | pub const B极INN_STORAGE_MASK: u32 = 0xE0;\n    | ------------------------------------------ similarly named constant `B极INN_STORAGE_MASK` defined here\n...\n614 |     if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n    |                 ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_STORAGE_MASK` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:1092:29\n     |\n2    | pub const B极INN_STORAGE_MASK: u32 = 0xE0;\n     | ------------------------------------------ similarly named constant `B极INN_STORAGE_MASK` defined here\n...\n1092 |     storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n     |                             ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_STORAGE_MASK`\n\nerror[E0425]: cannot find value `BINN_SINGLE_STR` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:1651:25\n     |\n8    | pub const BINN_SING极LE_STR: i32 = 0xA6;\n     | ---------------------------------------- similarly named constant `BINN_SING极LE_STR` defined here\n...\n1651 |                 type_ = BINN_SINGLE_STR;\n     |                         ^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_SING极LE_STR`\n\nerror[E0425]: cannot find value `BINN_SINGLE_STR` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:1688:17\n     |\n8    | pub const BINN_SING极LE_STR: i32 = 0xA6;\n     | ---------------------------------------- similarly named constant `BINN_SING极LE_STR` defined here\n...\n1688 |     if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n     |                 ^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_SING极LE_STR`\n\nerror[E0425]: cannot find value `BINN_STORAGE_MASK` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:2110:23\n     |\n2    | pub const B极INN_STORAGE_MASK: u32 = 0xE0;\n     | ------------------------------------------ similarly named constant `B极INN_STORAGE_MASK` defined here\n...\n2110 |         if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n     |                       ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `B极INN_STORAGE_MASK`\n\nerror[E0560]: struct `Binn` has no field named `vint8`\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:137:13\n    |\n137 |             vint8: self.vint8,\n    |             ^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n137 |             v极int8: self.vint8,\n    |              ++\n\nerror[E0609]: no field `vint8` on type `&Binn`\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:137:25\n    |\n137 |             vint8: self.vint8,\n    |                         ^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n137 |             vint8: self.v极int8,\n    |                          ++\n\nerror[E0560]: struct `Binn` has no field named `vint8`\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:175:13\n    |\n175 |             vint8: 0,\n    |             ^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n175 |             v极int8: 0,\n    |              ++\n\nerror[E0560]: struct `Binn` has no field named `v极int16`\n   --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:176:13\n    |\n176 |             v极int16: 0,\n    |             ^^^^^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n176 -             v极int16: 0,\n176 +             vint16: 0,\n    |\n\nerror[E0560]: struct `Binn` has no field named `vint8`\n    --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:1042:21\n     |\n1042 |                     vint8: 0,\n     |                     ^^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1042 |                     v极int8: 0,\n     |                      ++\n\nerror[E0609]: no field `vint8` on type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:1971:17\n     |\n1971 |     local_value.vint8 = value.vint8;\n     |                 ^^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1971 |     local_value.v极int8 = value.vint8;\n     |                  ++\n\nerror[E0609]: no field `vint8` on type `&Binn`\n    --> ../../Output/crown/tmp/test-binn_test_create_and_add_values_no_compression/test_source.rs:1971:31\n     |\n1971 |     local_value.vint8 = value.vint8;\n     |                               ^^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1971 |     local_value.vint8 = value.v极int8;\n     |                                ++\n\nerror: aborting due to 20 previous errors\n\nSome errors have detailed explanations: E0408, E0425, E0428, E0560, E0609, E0768.\nFor more information about an error, try `rustc --explain E0408`.\n",
        "test_add_and_read_string": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\n\n\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n\npub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n\npub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n\npub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn test_add_and_read_string() {\n    let mut obj = binn_object().unwrap();\n    let key = \"test_key\";\n    let value = \"test_value\";\n\n    assert!(binn_object_set(&mut obj, key, BINN_STRING, Some(&value.as_bytes().to_vec()), 0));\n\n    let read_value = binn_object_str(Some(&obj.pbuf), key);\n    assert!(!read_value.is_empty());\n    assert_eq!(read_value, value);\n\n    binn_free(Some(obj));\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error: unknown start of token: \\u{ff0c}\n --> ../../Output/crown/tmp/test-binn_test_add_and_read_string/test_source.rs:5:43\n  |\n5 | pub const BINN_STORAGE_VIRTUAL: u32 = 极不完整，可能存在错误;\n  |                                               ^^\n  |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n  |\n5 - pub const BINN_STORAGE_VIRTUAL: u32 = 极不完整，可能存在错误;\n5 + pub const BINN_STORAGE_VIRTUAL: u32 = 极不完整,可能存在错误;\n  |\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../Output/crown/tmp/test-binn_test_add_and_read_string/test_source.rs:10:16\n   |\n10 | pub const B极不完整，可能存在错误\n   |                    ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n10 - pub const B极不完整，可能存在错误\n10 + pub const B极不完整,可能存在错误\n   |\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `where`, `{`, or an operator, found `,`\n --> ../../Output/crown/tmp/test-binn_test_add_and_read_string/test_source.rs:5:43\n  |\n5 | pub const BINN_STORAGE_VIRTUAL: u32 = 极不完整，可能存在错误;\n  |                                               ^^ expected one of 8 possible tokens\n\nerror: aborting due to 3 previous errors\n\n",
        "test_binn_version": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\n\n\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n\npub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n\npub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n\npub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn test_binn_version() {\n    let version = binn_version();\n    assert!(!version.is_empty());\n    assert_eq!(version, \"3.0.0\");\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error[E0408]: variable `BINN_BOOL` is not bound in all patterns\n   --> ../../Output/crown/tmp/test-binn_test_binn_version/test_source.rs:783:21\n    |\n783 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ---------   ^^^^^^^^^   ^^^^^^^^^^ pattern doesn't bind `BINN_BOOL`\n    |         |           |\n    |         |           pattern doesn't bind `BINN_BOOL`\n    |         variable not in all patterns\n    |\nhelp: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `path::to::ModOrType::BINN_BOOL`\n   --> ../../Output/crown/tmp/test-binn_test_binn_version/test_source.rs:783:9\n    |\n783 |         BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n    |         ^^^^^^^^^\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_version/test_source.rs:1181:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n1181 |             value.type_ = BINN_BOOL;\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_version/test_source.rs:1186:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n1186 |             value.type_ = BINN_BOOL;\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_version/test_source.rs:2312:27\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2312 |     binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                           ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_version/test_source.rs:2322:31\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2322 |     binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n     |                               ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror[E0425]: cannot find value `BINN_BOOL` in this scope\n    --> ../../Output/crown/tmp/test-binn_test_binn_version/test_source.rs:2337:25\n     |\n10   | pub const BINN_BOL: i32 = 0x80061;\n     | ---------------------------------- similarly named constant `BINN_BOL` defined here\n...\n2337 |     binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n     |                         ^^^^^^^^^ help: a constant with a similar name exists: `BINN_BOL`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0408, E0425.\nFor more information about an error, try `rustc --explain E0408`.\n",
        "test_endianess": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\n\n\n\n\n\n\n\n\n\n\npub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\n\n\n\n\n\n\n\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n\npub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_list_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n\npub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n\npub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n\npub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n\npub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n\npub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n\npub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n\npub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n\npub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n\npub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n\npub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n\npub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n\npub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n\npub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n\npub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n\npub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n\npub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n\npub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n\npub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n\npub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n\npub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n\npub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n\npub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n\npub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n\npub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n\npub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n\npub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n\npub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n\npub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n\npub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n\npub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn test_endianess() {\n    let mut vshort1: u16;\n    let mut vshort2: u16 = 0;\n    let mut vshort3: u16 = 0;\n    let mut vint1: u32;\n    let mut vint2: u32 = 0;\n    let mut vint3: u32 = 0;\n    let mut value1: u64;\n    let mut value2: u64 = 0;\n    let mut value3: u64 = 0;\n\n    println!(\"testing endianess... \");\n\n    /* tobe16 */\n    vshort1 = 0x1122;\n    copy_be16(&mut vshort2.to_be_bytes(), &vshort1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vshort2, 0x2211);\n    } else {\n        assert_eq!(vshort2, 0x1122);\n    }\n    copy_be16(&mut vshort3.to_be_bytes(), &vshort2);\n    assert_eq!(vshort3, vshort1);\n\n    vshort1 = 0xF123;\n    copy_be16(&mut vshort2.to_be_bytes(), &vshort1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vshort2, 0x23F1);\n    } else {\n        assert_eq!(vshort2, 0xF123);\n    }\n    copy_be16(&mut vshort3.to_be_bytes(), &vshort2);\n    assert_eq!(vshort3, vshort1);\n\n    vshort1 = 0x0123;\n    copy_be16(&mut vshort2.to_be_bytes(), &vshort1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vshort2, 0x2301);\n    } else {\n        assert_eq!(vshort2, 0x0123);\n    }\n    copy_be16(&mut vshort3.to_be_bytes(), &vshort2);\n    assert_eq!(vshort3, vshort1);\n\n    /* tobe32 */\n    vint1 = 0x11223344;\n    copy_be32(&mut vint2.to_be_bytes(), &vint1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vint2, 0x44332211);\n    } else {\n        assert_eq!(vint2, 0x11223344);\n    }\n    copy_be32(&mut vint3.to_be_bytes(), &vint2);\n    assert_eq!(vint3, vint1);\n\n    vint1 = 0xF1234580;\n    copy_be32(&mut vint2.to_be_bytes(), &vint1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vint2, 0x804523F1);\n    } else {\n        assert_eq!(vint2, 0xF1234580);\n    }\n    copy_be32(&mut vint3.to_be_bytes(), &vint2);\n    assert_eq!(vint3, vint1);\n\n    vint1 = 0x00112233;\n    copy_be32(&mut vint2.to_be_bytes(), &vint1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vint2, 0x33221100);\n    } else {\n        assert_eq!(vint2, 0x00112233);\n    }\n    copy_be32(&mut vint3.to_be_bytes(), &vint2);\n    assert_eq!(vint3, vint1);\n\n    /* tobe64 */\n    value1 = 0x1122334455667788;\n    copy_be64(&mut value2.to_be_bytes(), &value1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(value2, 0x8877665544332211);\n    } else {\n        assert_eq!(value2, 0x1122334455667788);\n    }\n    copy_be64(&mut value3.to_be_bytes(), &value2);\n    assert_eq!(value3, value1);\n\n    println!(\"OK\");\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error[E0412]: cannot find type `i極端` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:52:29\n   |\n52 | pub const BINN_FAMILY_NULL: i極端= 0xF1;\n   |                             ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `B極端N_FLOAT32` in this scope\n  --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:62:30\n   |\n62 | pub const BINN_SINGLE: i32 = B極端N_FLOAT32;\n   |                              ^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_FLOAT32`\n63 | pub const BINN_FLOAT32: i32 = 0x62;\n   | ----------------------------------- similarly named constant `BINN_FLOAT32` defined here\n\nerror[E0425]: cannot find value `极` in this scope\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:177:21\n    |\n177 |             vint64: 极,\n    |                     ^^ not found in this scope\n\nerror: invalid suffix `极` for float literal\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:206:28\n    |\n206 | pub const VERYSMALL: f64 = 1.0极-150;\n    |                            ^^^^^ invalid suffix `极`\n    |\n    = help: valid suffixes are `f32` and `f64`\n\nerror[E0560]: struct `Binn` has no field named `pbuf`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:127:13\n    |\n127 |             pbuf: self.pbuf.clone(),\n    |             ^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n127 |             极pbuf: self.pbuf.clone(),\n    |             ++\n\nerror[E0609]: no field `pbuf` on type `&Binn`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:127:24\n    |\n127 |             pbuf: self.pbuf.clone(),\n    |                        ^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n127 |             pbuf: self.极pbuf.clone(),\n    |                        ++\n\nerror[E0609]: no field `v极t8` on type `&Binn`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:136:25\n    |\n136 |             vint8: self.v极t8,\n    |                         ^^^^^ unknown field\n    |\n    = note: available fields are: `header`, `allocated`, `writable`, `dirty`, `极pbuf` ... and 26 others\n\nerror[E0560]: struct `Binn` has no field named `pbuf`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:165:13\n    |\n165 |             pbuf: Vec::new(),\n    |             ^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n165 |             极pbuf: Vec::new(),\n    |             ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:538:13\n    |\n538 |     if item.pbuf.is_empty() {\n    |             ^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n538 |     if item.极pbuf.is_empty() {\n    |             ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:542:22\n    |\n542 |     let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    |                      ^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n542 |     let mut p = item.极pbuf[MAX_BINN_HEADER..].to_vec();\n    |                      ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:697:41\n    |\n697 |         new_buf.extend_from_slice(&item.pbuf);\n    |                                         ^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n697 |         new_buf.extend_from_slice(&item.极pbuf);\n    |                                         ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n   --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:698:14\n    |\n698 |         item.pbuf = new_buf;\n    |              ^^^^ unknown field\n    |\nhelp: a field with a similar name exists\n    |\n698 |         item.极pbuf = new_buf;\n    |              ++\n\nerror[E0560]: struct `Binn` has no field named `pbuf`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1042:21\n     |\n1042 |                     pbuf: ptr_data.clone(),\n     |                     ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1042 |                     极pbuf: ptr_data.clone(),\n     |                     ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1287:23\n     |\n1287 |     let p = &mut item.pbuf[item.used_size as usize..];\n     |                       ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1287 |     let p = &mut item.极pbuf[item.used_size as usize..];\n     |                       ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1493:14\n     |\n1493 |         item.pbuf = ptr;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1493 |         item.极pbuf = ptr;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1498:18\n     |\n1498 |             item.pbuf = allocated.to_vec();\n     |                  ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1498 |             item.极pbuf = allocated.to_vec();\n     |                  ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1566:39\n     |\n1566 |     let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n     |                                       ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1566 |     let mut p = SearchForID(&mut item.极pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n     |                                       ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1583:14\n     |\n1583 |         item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1583 |         item.极pbuf[p] = ((sign as u8) << 6) | (id as u8);\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1587:14\n     |\n1587 |         item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1587 |         item.极pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1589:14\n     |\n1589 |         item.pbuf[p] = (id & 0xFF) as u8;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1589 |         item.极pbuf[p] = (id & 0xFF) as u8;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1593:14\n     |\n1593 |         item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1593 |         item.极pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1595:14\n     |\n1595 |         item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1595 |         item.极pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1597:14\n     |\n1597 |         item.pbuf[p] = (id & 0xFF) as u8;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1597 |         item.极pbuf[p] = (id & 0xFF) as u8;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1601:14\n     |\n1601 |         item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1601 |         item.极pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1603:14\n     |\n1603 |         item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1603 |         item.极pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1605:14\n     |\n1605 |         item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1605 |         item.极pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1607:14\n     |\n1607 |         item.pbuf[p] = (id & 0xFF) as u8;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1607 |         item.极pbuf[p] = (id & 0xFF) as u8;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1611:14\n     |\n1611 |         item.pbuf[p] = 0xE0;\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1611 |         item.极pbuf[p] = 0xE0;\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1617:14\n     |\n1617 |         item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n     |              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1617 |         item.极pbuf[p..p+4].copy_from_slice(&id_bytes);\n     |              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1736:31\n     |\n1736 |     if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n     |                               ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1736 |     if SearchForKey(&mut item.极pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n     |                               ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1746:10\n     |\n1746 |     item.pbuf[p] = len;\n     |          ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1746 |     item.极pbuf[p] = len;\n     |          ++\n\nerror[E0609]: no field `pbuf` on type `&mut Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1748:10\n     |\n1748 |     item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n     |          ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1748 |     item.极pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n     |          ++\n\nerror[E0609]: no field `pbuf` on type `Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1971:17\n     |\n1971 |     local_value.pbuf = value.pbuf.clone();\n     |                 ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1971 |     local_value.极pbuf = value.pbuf.clone();\n     |                 ++\n\nerror[E0609]: no field `pbuf` on type `&Binn`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:1971:30\n     |\n1971 |     local_value.pbuf = value.pbuf.clone();\n     |                              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n1971 |     local_value.pbuf = value.极pbuf.clone();\n     |                              ++\n\nerror[E0609]: no field `pbuf` on type `Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2223:30\n     |\n2223 |             let slice = item.pbuf.clone().into_boxed_slice();\n     |                              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2223 |             let slice = item.极pbuf.clone().into_boxed_slice();\n     |                              ++\n\nerror[E0609]: no field `pbuf` on type `Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2234:30\n     |\n2234 |             let slice = item.pbuf.into_boxed_slice();\n     |                              ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2234 |             let slice = item.极pbuf.into_boxed_slice();\n     |                              ++\n\nerror[E0609]: no field `pbuf` on type `&mut Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2505:19\n     |\n2505 |     assert!(!obj1.pbuf.is_empty());\n     |                   ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2505 |     assert!(!obj1.极pbuf.is_empty());\n     |                   ++\n\nerror[E0609]: no field `pbuf` on type `&Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2525:65\n     |\n2525 |     assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n     |                                                                 ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2525 |     assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().极pbuf), 1, &mut value), true);\n     |                                                                 ++\n\nerror[E0609]: no field `pbuf` on type `&Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2529:63\n     |\n2529 |     assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n     |                                                               ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2529 |     assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().极pbuf), 1001, &mut value), true);\n     |                                                               ++\n\nerror[E0609]: no field `pbuf` on type `&Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2533:66\n     |\n2533 |     assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n     |                                                                  ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2533 |     assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().极pbuf), \"int\", &mut value), true);\n     |                                                                  ++\n\nerror[E0609]: no field `pbuf` on type `&Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2577:59\n     |\n2577 |     let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n     |                                                           ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2577 |     let ptr = binn_list_blob(Some(&list.as_ref().unwrap().极pbuf), 1, Some(&mut mutable_blobsize));\n     |                                                           ++\n\nerror[E0609]: no field `pbuf` on type `Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2685:19\n     |\n2685 |     assert!(!obj1.pbuf.is_empty());\n     |                   ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2685 |     assert!(!obj1.极pbuf.is_empty());\n     |                   ++\n\nerror[E0609]: no field `pbuf` on type `Box<Binn>`\n    --> ../../Output/crown/tmp/test-binn_test_endianess/test_source.rs:2701:41\n     |\n2701 |     let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n     |                                         ^^^^ unknown field\n     |\nhelp: a field with a similar name exists\n     |\n2701 |     let ptr = binn_list_blob(Some(&list.极pbuf), 1, None);\n     |                                         ++\n\nerror: aborting due to 43 previous errors\n\nSome errors have detailed explanations: E0412, E0425, E0560, E0609.\nFor more information about an error, try `rustc --explain E0412`.\n"
    },
    "test-lil": {
        "test_writechar_function": "//同时处理的函数过多，无法处理 :13",
        "test_basic_parsing": "//同时处理的函数过多，无法处理 :13",
        "test_function_registration": "pub static mut test_running: i32 = 1;\npub static mut test_exit_code: i32 = 0;\n\npub trait ToInteger {\n    fn to_integer(&self) -> i32;\n}\n\nimpl<T: ToInteger> ToInteger for RefCell<T> {\n    fn to_integer(&self) -> i32 {\n        self.borrow().to_integer()\n    }\n}\n\nimpl<T: Clone + ToString> ToInteger for LilValue<T> {\n    fn to_integer(&self) -> i32 {\n        if let Some(ref data) = self.d {\n            if let Ok(num) = data.to_string().parse::<i32>() {\n                return num;\n            }\n        }\n        0\n    }\n}\nuse std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn fnc_return<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    lil.env.borrow_mut().breakrun = true;\n    lil.env.borrow_mut().retval = if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() };\n    lil.env.borrow_mut().retval_set = true;\n    if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() }\n}\n\n\npub fn fnc_print<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_write_wrap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) {\n        // 空实现\n    }\n    fn lil_write_wrap<T: Clone>(lil: &LilStruct<T>, s: &str) {\n        // 空实现\n    }\n    fnc_write_wrap(lil, argc, argv);\n    lil_write_wrap(lil, \"\\n\");\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_error<T: Clone + std::fmt::Display>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let err_msg = if argc > 0 {\n        match &argv[0].d {\n            Some(d) => d.to_string(),\n            None => String::new(),\n        }\n    } else {\n        String::new()\n    };\n    lil.error = 1;\n    lil.err_msg = err_msg;\n    LilValue { l: 0, d: None }\n}\n\n\nfn lil_alloc_string(s: &str) -> LilValue<String> {\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_concat<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut r = LilValue { l: 0, d: Some(String::new().into()) };\n    if argc < 1 { return r; }\n    for i in 0..argc {\n        let list = argv[i].clone();\n        let tmp = list;\n        lil_append_val_wrap(&mut r, tmp);\n    }\n    r\n}\n\n\nfn lil_append_val_wrap<T: Clone>(dst: &mut LilValue<T>, src: LilValue<T>) {\n    if let Some(d) = &mut dst.d {\n        if let Some(s) = src.d {\n            *d = s;\n        }\n    }\n}\n\n\npub fn fnc_subst<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    fn lil_subst_to_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        val.clone()\n    }\n    Some(lil_subst_to_value_wrap(lil, &argv[0]))\n}\n\n\npub fn fnc_system<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<String>>>>) -> Option<LilValue<String>> {\n    if argc == 0 {\n        return None;\n    }\n\n    let sargv: Vec<String> = argv.iter().map(|v| v.borrow().d.as_ref().unwrap().clone()).collect();\n    \n    let rv = do_system(argc, sargv);\n    rv.map(|s| LilValue { l: s.len(), d: Some(s) })\n}\n\n\npub fn fnc_eval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(data: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d: data }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, ch: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, other: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_parse_value_wrap(lil, &argv[0], 0);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_parse_value_wrap(lil, &val, 0);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\nfn hm_put<T>(map: &mut HashMap<T>, key: &str, value: Option<T>) {\n}\n\n\npub fn fnc_try<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc < 1 {\n        return None;\n    }\n    if lil.error != 0 {\n        return None;\n    }\n    let mut r = lil_parse_value_wrap(lil, &argv[0], 0);\n    if lil.error != 0 {\n        lil.error = 0;\n        lil_free_value_wrap(r.clone());\n        if argc > 1 {\n            r = lil_parse_value_wrap(lil, &argv[1], 0);\n        } else {\n            r = LilValue { l: 0, d: None };\n        }\n    }\n    Some(r)\n}\n\n\npub fn fnc_charat<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer<T: Clone + Debug>(val: &LilValue<T>) -> i64 {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d).parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    let str = lil_to_string(&argv[0]);\n    let index = lil_to_integer(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    let chstr = &str[index..=index];\n    lil_alloc_string(chstr)\n}\n\n\npub fn fnc_indexof<T: Clone + PartialEq + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 {\n        return None;\n    }\n\n    fn lil_subst_to_list_wrap<T: Clone>(_: &LilStruct<T>, _: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_to_string_wrap<T: Clone + Debug>(_: &Rc<RefCell<LilValue<T>>>) -> String {\n        String::new()\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(index: i32) -> LilValue<T> {\n        LilValue { l: index as usize, d: None }\n    }\n    fn lil_free_list_wrap<T: Clone>(_: LilList<T>) {}\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut result = None;\n\n    for (index, item) in list.items.iter().enumerate() {\n        let item_str = lil_to_string_wrap(item);\n        let arg_str = lil_to_string_wrap(&Rc::new(RefCell::new(argv[1].clone())));\n        if item_str == arg_str {\n            result = Some(lil_alloc_integer_wrap(index as i32));\n            break;\n        }\n    }\n\n    lil_free_list_wrap(list);\n    result\n}\n\n\npub fn fnc_expr<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_eval_expr_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(d: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, c: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_eval_expr_wrap(lil, &argv[0]);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_eval_expr_wrap(lil, &val);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_append<T: Clone + Debug + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let mut base = 1;\n    let mut access = 1;\n    let varname = argv[0].d.as_ref().unwrap().to_string();\n    let mut varname = if varname == \"global\" {\n        if argc < 3 { return LilValue { l: 0, d: None }; }\n        base = 2;\n        access = 0;\n        argv[1].d.as_ref().unwrap().to_string()\n    } else {\n        varname\n    };\n    let mut list = lil_subst_to_list(lil, lil_get_var(lil, &varname));\n    for i in base..argc {\n        lil_list_append(&mut list, argv[i].clone());\n    }\n    let r = lil_list_to_value(&list, 1);\n    lil_free_list(list);\n    lil_set_var(lil, &varname, r.clone(), access);\n    r\n}\n\n\npub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\n\nfn lil_to_string<T: Clone>(value: &LilValue<T>) -> String {\n    String::new()\n}\n\n\npub fn fnc_filter<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_alloc_list_wrap<T: Clone>() -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _scope: i32) {}\n    fn lil_eval_expr_wrap<T: Clone>(_lil: &mut LilStruct<T>, _expr: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(_val: &LilValue<T>) -> bool {\n        false\n    }\n    fn lil_list_append_wrap<T: Clone>(_list: &mut LilList<T>, _val: Rc<RefCell<LilValue<T>>>) {}\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _deep: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut varname = \"x\".to_string();\n    let mut base = 0;\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    if argc > 2 {\n        base = 1;\n        varname = argv[0].d.as_ref().unwrap().to_string();\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[base]);\n    let mut filtered = lil_alloc_list_wrap();\n\n    for i in 0..list.items.len() {\n        if lil.env.borrow().breakrun { break; }\n        lil_set_var_wrap(lil, &varname, list.items[i].clone(), 3);\n        let r = lil_eval_expr_wrap(lil, &argv[base + 1]);\n        if lil_to_boolean_wrap(&r) {\n            lil_list_append_wrap(&mut filtered, list.items[i].clone());\n        }\n    }\n\n    let r = lil_list_to_value_wrap(&filtered, 1);\n    r\n}\n\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\n\npub fn fnc_codeat<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i32 {\n        match &val.d {\n            Some(v) => v.to_string().parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_integer_wrap<T: Clone>(val: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let index: usize;\n    let str: String;\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    str = lil_to_string_wrap(&argv[0]);\n    index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    lil_alloc_integer_wrap(str.chars().nth(index).unwrap() as i32)\n}\n\n\npub fn lil_free<T: Clone>(lil: Option<Rc<RefCell<LilStruct<T>>>>) {\n    if lil.is_none() {\n        return;\n    }\n    let mut lil = lil.unwrap();\n    let mut lil = lil.borrow_mut();\n    lil.err_msg.clear();\n    lil_free_value(Some(Rc::new(RefCell::new(lil.empty.clone()))));\n    \n    let mut current_env = Some(lil.env.clone());\n    while let Some(env) = current_env {\n        let next = env.borrow().parent.clone();\n        lil_free_env(Some(env));\n        current_env = next;\n    }\n    \n    for i in 0..lil.cmds {\n        let cmd = lil.cmd[i].borrow();\n        if !cmd.argnames.items.is_empty() {\n            lil_free_list(cmd.argnames.clone());\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd.code.clone()))));\n    }\n    hm_destroy(&mut lil.cmdmap);\n    lil.cmd.clear();\n    lil.dollarprefix.clear();\n    lil.catcher.clear();\n}\n\n\nfn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    None\n}\n\n\npub fn fnc_catcher<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        LilValue {\n            l: lil.catcher.len(),\n            d: Some(T::from(lil.catcher.clone())),\n        }\n    } else {\n        let catcher = argv[0].d.as_ref().unwrap().to_string();\n        lil.catcher = if !catcher.is_empty() { catcher } else { String::new() };\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n}\n\n\npub fn fnc_upeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let fnc_eval_wrap = |lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]| -> LilValue<T> {\n        lil.empty.clone()\n    };\n    \n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    let r;\n    if Rc::ptr_eq(&lil.rootenv, &thisenv) {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.env = match thisenv.borrow().parent.as_ref() {\n        Some(parent) => Rc::clone(parent),\n        None => Rc::clone(&thisenv),\n    };\n    lil.downenv = Rc::clone(&thisenv);\n    r = fnc_eval_wrap(lil, argc, argv);\n    lil.env = thisenv;\n    lil.downenv = thisdownenv;\n    r\n}\n\n\npub fn fnc_rand<T: Clone + From<f64>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    LilValue {\n        l: 8,\n        d: Some(0.5f64.into())\n    }\n}\n\n\npub fn lil_free_env<T: Clone>(env: Option<Rc<RefCell<LilEnv<T>>>>) {\n    if env.is_none() {\n        return;\n    }\n    let env = env.unwrap();\n    let mut env = env.borrow_mut();\n    lil_free_value(Some(Rc::new(RefCell::new(env.retval.clone()))));\n    hm_destroy(&mut env.varmap);\n    for i in 0..env.vars {\n        let var = env.var[i].borrow_mut();\n        lil_free_value(Some(Rc::new(RefCell::new(var.v.clone()))));\n    }\n    env.var.clear();\n    env.vars = 0;\n}\n\n\npub fn fnc_substr<T: Clone + Debug + FromStr + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let str = match &argv[0].d {\n        Some(s) => s.to_string(),\n        None => return LilValue { l: 0, d: None },\n    };\n    if str.is_empty() { return LilValue { l: 0, d: None }; }\n    let slen = str.len();\n    let start = match argv[1].d.as_ref() {\n        Some(s) => s.to_string().parse::<usize>().unwrap_or(0),\n        None => 0,\n    };\n    let end = if argc > 2 {\n        match argv[2].d.as_ref() {\n            Some(s) => s.to_string().parse::<usize>().unwrap_or(slen),\n            None => slen,\n        }\n    } else { slen };\n    let end = if end > slen { slen } else { end };\n    if start >= end { return LilValue { l: 0, d: None }; }\n    let result = str.chars().skip(start).take(end - start).collect::<String>();\n    LilValue { l: result.len(), d: Some(result.parse().unwrap_or_else(|_| panic!(\"Failed to parse string\"))) }\n}\n\n\npub fn fnc_store<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        if let Some(ref d) = val.d {\n            format!(\"{:?}\", d)\n        } else {\n            String::new()\n        }\n    }\n\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    if let Some(proc) = lil.callback.get(3).copied() {\n        let name = lil_to_string_wrap(&argv[0]);\n        let data = lil_to_string_wrap(&argv[1]);\n        proc(lil, &name, &[argv[1].clone()]);\n    } else {\n        let filename = lil_to_string_wrap(&argv[0]);\n        let buffer = lil_to_string_wrap(&argv[1]);\n        if let Ok(mut file) = std::fs::File::create(&filename) {\n            let _ = std::io::Write::write_all(&mut file, buffer.as_bytes());\n        }\n    }\n    argv[1].clone()\n}\n\n\npub fn fnc_inc<T: Clone + From<u32>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let arg0 = if let Some(d) = &argv[0].d { d.clone() } else { return None; };\n    let arg1 = if argc > 1 { \n        if let Some(d) = &argv[1].d { d.clone() } else { return None; }\n    } else { T::from(1) };\n    Some(LilValue { l: 0, d: Some(arg0) })\n}\n\n\npub fn fnc_exit<T: Clone>(lil: Rc<RefCell<LilStruct<T>>>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Option<Rc<RefCell<LilValue<T>>>> {\n    let lil_ref = lil.borrow();\n    if let Some(proc) = lil_ref.callback.get(0) {\n        let arg = if argc > 0 { Some(argv[0].clone()) } else { None };\n        let lil_wrap = &*lil_ref;\n        proc(lil_wrap, \"\", &[]);\n    }\n    None\n}\n\n\npub fn do_system(argc: usize, argv: Vec<String>) -> Option<String> {\n    #[cfg(any(windows, target_env = \"msvc\"))]\n    {\n        return None;\n    }\n\n    #[cfg(not(any(windows, target_env = \"msvc\")))]\n    {\n        if argc == 0 {\n            return None;\n        }\n\n        if argv[0] == \"echo\" && argc > 1 {\n            let mut result = argv[1].clone();\n            result.push('\\n');\n            return Some(result);\n        }\n\n        None\n    }\n}\n\n\npub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\n\npub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\n\npub fn fnc_for<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_eval_expr_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(val: &LilValue<T>) -> bool {\n        false\n    }\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 4 { return LilValue { l: 0, d: None }; }\n    let _ = lil_parse_value_wrap(lil, &argv[0], 0);\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr_wrap(lil, &argv[1]);\n        if val.l == 0 || lil.error != 0 { return LilValue { l: 0, d: None }; }\n        if !lil_to_boolean_wrap(&val) {\n            break;\n        }\n        r = lil_parse_value_wrap(lil, &argv[3], 0);\n        let _ = lil_parse_value_wrap(lil, &argv[2], 0);\n    }\n    r\n}\n\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\n\npub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\n\npub fn fnc_slice<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_integer_wrap<T: Clone>(val: &LilValue<T>) -> i64 {\n        0\n    }\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(list: &LilList<T>, _flag: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    \n    let mut from = lil_to_integer_wrap(&argv[1]);\n    if from < 0 { from = 0; }\n    \n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut to = if argc > 2 { lil_to_integer_wrap(&argv[2]) } else { list.items.len() as i64 };\n    if to > list.items.len() as i64 { to = list.items.len() as i64; }\n    if to < from { to = from; }\n    \n    let mut slice = LilList { items: Vec::new() };\n    for i in from as usize..to as usize {\n        slice.items.push(list.items[i].clone());\n    }\n    \n    let r = lil_list_to_value_wrap(&slice, 1);\n    r\n}\n\n\npub fn fnc_func<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Rc<RefCell<LilValue<T>>> {\n    let name: Rc<RefCell<LilValue<T>>>;\n    let cmd: Rc<RefCell<LilFunc<T>>>;\n    let fargs: LilList<T>;\n    \n    fn lil_clone_value_wrap<T: Clone>(value: &Rc<RefCell<LilValue<T>>>) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new((*value.borrow()).clone()))\n    }\n    \n    fn lil_to_string_wrap<T: Clone + ToString>(value: &Rc<RefCell<LilValue<T>>>) -> String {\n        value.borrow().d.as_ref().map_or(String::new(), |v| v.to_string())\n    }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, value: &Rc<RefCell<LilValue<T>>>) -> LilList<T> {\n        LilList { items: vec![Rc::clone(value)] }\n    }\n    \n    fn add_func_wrap<T: Clone>(_lil: &LilStruct<T>, name: &str) -> Rc<RefCell<LilFunc<T>>> {\n        Rc::new(RefCell::new(LilFunc {\n            name: name.to_string(),\n            code: LilValue { l: 0, d: None },\n            argnames: LilList { items: vec![] },\n            proc: None,\n        }))\n    }\n    \n    fn lil_unused_name_wrap<T: Clone>(_lil: &LilStruct<T>, prefix: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: None }))\n    }\n    \n    fn lil_alloc_string_wrap<T: Clone + From<String>>(s: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: Some(s.to_string().into()) }))\n    }\n\n    if argc < 1 {\n        return Rc::new(RefCell::new(LilValue { l: 0, d: None }));\n    }\n    if argc >= 3 {\n        name = lil_clone_value_wrap(&argv[0]);\n        fargs = lil_subst_to_list_wrap(lil, &argv[1]);\n        cmd = add_func_wrap(lil, &lil_to_string_wrap(&argv[0]));\n        cmd.borrow_mut().argnames = fargs;\n        cmd.borrow_mut().code = (*argv[2].borrow()).clone();\n    } else {\n        name = lil_unused_name_wrap(lil, \"anonymous-function\");\n        if argc < 2 {\n            let tmp = lil_alloc_string_wrap(\"args\");\n            fargs = lil_subst_to_list_wrap(lil, &tmp);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[0].borrow()).clone();\n        } else {\n            fargs = lil_subst_to_list_wrap(lil, &argv[0]);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[1].borrow()).clone();\n        }\n    }\n    name\n}\n\n\npub fn lil_to_integer<T: Clone>(val: &LilValue<T>) -> i64 {\n    lil_to_string(val).parse::<i64>().unwrap_or(0)\n}\n\n\npub fn fnc_lmap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        unimplemented!()\n    }\n    \n    fn lil_list_get_wrap<T: Clone>(list: &Rc<RefCell<LilList<T>>>, index: usize) -> LilValue<T> {\n        unimplemented!()\n    }\n    \n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: LilValue<T>, flag: i32) {\n        unimplemented!()\n    }\n    \n    fn lil_free_list_wrap<T: Clone>(list: Rc<RefCell<LilList<T>>>) {\n        unimplemented!()\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    for i in 1..argc {\n        let var_name = lil_to_string_wrap(&argv[i]);\n        let value = lil_list_get_wrap(&list, i - 1);\n        lil_set_var_wrap(lil, &var_name, value, 1);\n    }\n    lil_free_list_wrap(list);\n    None\n}\n\n\npub fn fnc_unusedname(lil: &LilStruct<String>, argc: usize, argv: &[LilValue<String>]) -> LilValue<String> {\n    fn lil_to_string_wrap(val: &LilValue<String>) -> String {\n        match &val.d {\n            Some(v) => v.clone(),\n            None => String::new(),\n        }\n    }\n    fn lil_unused_name_wrap(lil: &LilStruct<String>, name: &str) -> LilValue<String> {\n        LilValue {\n            l: name.len(),\n            d: Some(name.to_string()),\n        }\n    }\n    let arg = if argc > 0 { lil_to_string_wrap(&argv[0]) } else { \"unusedname\".to_string() };\n    lil_unused_name_wrap(lil, &arg)\n}\n\n\npub fn fnc_streq<T: Clone + FromStr + PartialEq + std::fmt::Display + From<bool>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return lil.empty.clone(); }\n    let s1 = argv[0].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    let s2 = argv[1].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    LilValue { l: 1, d: Some((s1 == s2).into()) }\n}\n\n\npub fn fnc_reflect<T: Clone + Debug + From<String> + From<&'static str> + From<i64> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let type_str = lil_to_string(&argv[0]);\n    match type_str.as_str() {\n        \"version\" => Some(LilValue { l: 3, d: Some(\"0.1\".into()) }),\n        \"args\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().argnames.items.is_empty() { return None; }\n            Some(func.unwrap().borrow().argnames.items[0].borrow().clone())\n        },\n        \"body\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().proc.is_some() { return None; }\n            Some(func.unwrap().borrow().code.clone())\n        },\n        \"func-count\" => Some(LilValue { l: 0, d: Some((lil.cmds as i64).into()) }),\n        \"funcs\" => {\n            let mut funcs = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.cmds {\n                funcs.items.push(Rc::new(RefCell::new(LilValue { l: lil.cmd[i].borrow().name.len(), d: Some(lil.cmd[i].borrow().name.clone().into()) })));\n            }\n            Some(LilValue { l: funcs.items.len(), d: None })\n        },\n        \"vars\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                for i in 0..e.borrow().vars {\n                    vars.items.push(Rc::new(RefCell::new(LilValue { l: e.borrow().var[i].borrow().n.len(), d: Some(e.borrow().var[i].borrow().n.clone().into()) })));\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"globals\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.rootenv.borrow().vars {\n                vars.items.push(Rc::new(RefCell::new(LilValue { l: lil.rootenv.borrow().var[i].borrow().n.len(), d: Some(lil.rootenv.borrow().var[i].borrow().n.clone().into()) })));\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"has-func\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            if lil.cmdmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                Some(LilValue { l: 1, d: Some(\"1\".into()) })\n            } else {\n                None\n            }\n        },\n        \"has-var\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                if e.borrow().varmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            None\n        },\n        \"has-global\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            for i in 0..lil.rootenv.borrow().vars {\n                if target == lil.rootenv.borrow().var[i].borrow().n { \n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n            }\n            None\n        },\n        \"error\" => lil.err_msg.is_empty().then(|| LilValue { l: lil.err_msg.len(), d: Some(lil.err_msg.clone().into()) }),\n        \"dollar-prefix\" => {\n            if argc == 1 { return Some(LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) }); }\n            let r = LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) };\n            lil.dollarprefix = lil_to_string(&argv[1]);\n            Some(r)\n        },\n        \"this\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(LilValue { l: lil.catcher.len(), d: Some(lil.catcher.clone().into()) }); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return Some(LilValue { l: lil.rootcode.len(), d: Some(lil.rootcode.clone().into()) }); }\n                if let Some(func) = &e.borrow().func { return Some(func.borrow().code.clone()); }\n            }\n            None\n        },\n        \"name\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(e.borrow().catcher_for.clone()); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return None; }\n                if let Some(func) = &e.borrow().func { return Some(LilValue { l: func.borrow().name.len(), d: Some(func.borrow().name.clone().into()) }); }\n            }\n            None\n        },\n        _ => None\n    }\n}\n\n\npub fn fnc_list<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList { items: Vec::new() };\n    for i in 0..argc {\n        list.items.push(Rc::new(RefCell::new(argv[i].clone())));\n    }\n    LilValue { l: list.items.len(), d: None }\n}\n\n\npub fn fnc_char<T: Clone + From<String> + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        return LilValue { l: 0, d: None };\n    }\n    let s = match &argv[0].d {\n        Some(val) => {\n            let mut buf = [0u8; 2];\n            buf[0] = format!(\"{:?}\", val).parse::<u8>().unwrap_or(0);\n            buf[1] = 0;\n            String::from_utf8_lossy(&buf).to_string()\n        },\n        None => String::new(),\n    };\n    LilValue { l: s.len(), d: Some(T::from(s)) }\n}\n\n\npub fn fnc_rtrim<T: Clone + Debug + FromStr>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn real_trim(s: String, pat: String, _left: i32, _right: i32) -> LilValue<String> {\n        let trimmed = s.trim_end_matches(&pat[..]);\n        LilValue {\n            l: trimmed.len(),\n            d: Some(trimmed.to_string()),\n        }\n    }\n\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let pat = if argc < 2 { \" \\u{000C}\\n\\r\\t\\u{000B}\".to_string() } else { lil_to_string(&argv[1]) };\n    let result = real_trim(s, pat, 0, 1);\n    LilValue { l: result.l, d: Some(result.d.unwrap().parse().ok().unwrap()) }\n}\n\n\npub fn fnc_result<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc > 0 {\n        lil.env.borrow_mut().retval = argv[0].clone();\n        lil.env.borrow_mut().retval_set = true;\n    }\n    if lil.env.borrow().retval_set {\n        Some(lil.env.borrow().retval.clone())\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_downeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    let upenv = Rc::clone(&lil.env);\n    let downenv = Rc::clone(&lil.downenv);\n    if downenv.borrow().parent.is_none() {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.downenv = Rc::new(RefCell::new(LilEnv {\n        parent: None,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    lil.env = Rc::clone(&downenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = downenv;\n    lil.env = upenv;\n    r\n}\n\n\npub fn fnc_readline<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<String> {\n    lil_alloc_string(\"test_input\")\n}\n\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n\npub fn add_func<T: Clone + Debug>(lil: &mut LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    let cmd = find_cmd(lil, name);\n    if let Some(cmd) = cmd {\n        let mut cmd_ref = cmd.borrow_mut();\n        if cmd_ref.argnames.items.len() > 0 {\n            let argnames = cmd_ref.argnames.clone();\n            lil_free_list(argnames);\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd_ref.code.clone()))));\n        cmd_ref.argnames = LilList { items: Vec::new() };\n        cmd_ref.code = LilValue { l: 0, d: None };\n        cmd_ref.proc = None;\n        return Some(Rc::clone(&cmd));\n    }\n    let new_cmd = Rc::new(RefCell::new(LilFunc {\n        name: strclone(name).unwrap(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: None,\n    }));\n    lil.cmd.push(Rc::clone(&new_cmd));\n    lil.cmds += 1;\n    hm_put(&mut lil.cmdmap, name, Some(Rc::clone(&new_cmd)));\n    Some(new_cmd)\n}\n\n\npub fn hm_init<T>(hm: &mut HashMap<T>) {\n    hm.cell.clear();\n}\n\n\npub fn fnc_count<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    let mut buff = String::with_capacity(64);\n    if argc == 0 {\n        return LilValue { l: 1, d: Some(T::from(\"0\".to_string())) };\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    buff.push_str(&list.borrow().items.len().to_string());\n    LilValue { l: buff.len(), d: Some(T::from(buff)) }\n}\n\n\npub fn fnc_watch<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    let wcode = lil_to_string(&argv[argc - 1]);\n    for i in 0..(argc - 1) {\n        let vname = lil_to_string(&argv[i]);\n        if vname.is_empty() { continue; }\n        let mut v = lil_find_var(lil, lil.env.clone(), &vname);\n        if v.is_none() {\n            let empty_val = LilValue { l: 0, d: None };\n            lil_set_var(lil, &vname, empty_val, 2);\n            v = lil_find_var(lil, lil.env.clone(), &vname);\n        }\n        if let Some(var) = v {\n            var.borrow_mut().w = if !wcode.is_empty() { wcode.clone() } else { String::new() };\n        }\n    }\n    None\n}\n\n\npub fn fnc_jaileval<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n\n    fn lil_register_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _proc: LilFuncProc<T>) {}\n\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _depth: usize) -> Option<LilValue<T>> {\n        None\n    }\n\n    let mut base = 0;\n    if argc == 0 {\n        return None;\n    }\n    if lil_to_string_wrap(&argv[0]) == \"clean\" {\n        base = 1;\n        if argc == 1 {\n            return None;\n        }\n    }\n    let mut sublil = LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: String::new(),\n        env: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: LilValue { l: 0, d: None },\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: argv[0].d.as_ref().unwrap().clone(),\n        embed: String::new(),\n        embedlen: 0,\n    };\n    if base != 1 {\n        for i in lil.syscmds..lil.cmds {\n            let fnc = lil.cmd[i].clone();\n            if fnc.borrow().proc.is_none() {\n                continue;\n            }\n            lil_register_wrap(&mut sublil, &fnc.borrow().name, fnc.borrow().proc.unwrap());\n        }\n    }\n    let r = lil_parse_value_wrap(&mut sublil, &argv[base], 1);\n    r\n}\n\n\npub fn fnc_topeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    lil.env = Rc::clone(&lil.rootenv);\n    lil.downenv = Rc::clone(&thisenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = thisdownenv;\n    lil.env = thisenv;\n    r\n}\n\n\npub fn fnc_index<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: vec![Rc::new(RefCell::new(val.clone()))] }\n    }\n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i64 {\n        if let Some(d) = &val.d {\n            if let Ok(n) = i64::from_str(&d.to_string()) {\n                return n;\n            }\n        }\n        0\n    }\n    fn lil_free_list_wrap<T: Clone>(_list: LilList<T>) {}\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 2 { return r; }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index < list.items.len() {\n        r = list.items[index].borrow().clone();\n    }\n    lil_free_list_wrap(list);\n    r\n}\n\n\npub fn fnc_foreach<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _flags: i32) {}\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut rlist = LilList { items: Vec::new() };\n    let mut listidx = 0;\n    let mut codeidx = 1;\n    let mut varname = \"i\".to_string();\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    if argc >= 3 {\n        varname = argv[0].d.as_ref().unwrap().to_string();\n        listidx = 1;\n        codeidx = 2;\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[listidx]);\n    for i in 0..list.items.len() {\n        let item = list.items[i].clone();\n        lil_set_var_wrap(lil, &varname, item, 3);\n        let rv = lil_parse_value_wrap(lil, &argv[codeidx], 0);\n        if rv.l != 0 {\n            rlist.items.push(Rc::new(RefCell::new(rv)));\n        }\n        if lil.env.borrow().breakrun || lil.error != 0 { break; }\n    }\n    let r = lil_list_to_value_wrap(&rlist, 1);\n    r\n}\n\n\npub fn fnc_read<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let buffer;\n    if argc < 1 {\n        return None;\n    }\n    if let Some(proc) = lil.callback.get(2) {\n        let proc_wrap = |lil: &LilStruct<T>, name: &str| -> String {\n            let args = vec![LilValue { l: name.len(), d: Some(T::from(name.to_string())) }];\n            let result = proc(lil, \"read\", &args);\n            if let Some(s) = result.d {\n                return s.as_ref().to_string();\n            }\n            String::new()\n        };\n        buffer = proc_wrap(lil, argv[0].d.as_ref()?.as_ref());\n    } else {\n        let filename = argv[0].d.as_ref()?.as_ref();\n        let mut file = match std::fs::File::open(filename) {\n            Ok(f) => f,\n            Err(_) => return None,\n        };\n        let size = match file.metadata() {\n            Ok(m) => m.len() as usize,\n            Err(_) => return None,\n        };\n        let mut buf = vec![0; size];\n        if let Err(_) = file.read_exact(&mut buf) {\n            return None;\n        }\n        buffer = String::from_utf8_lossy(&buf).into_owned();\n    }\n    Some(LilValue { l: buffer.len(), d: Some(T::from(buffer)) })\n}\n\n\npub fn fnc_while<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut r: Option<LilValue<T>> = None;\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if lil_to_string(&argv[0]) == \"not\" {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr(lil, &argv[base]);\n        if val.is_none() || lil.error != 0 { return None; }\n        let mut v = lil_to_boolean(&val.unwrap());\n        if not { v = !v; }\n        if !v {\n            break;\n        }\n        if r.is_some() {\n            r = None;\n        }\n        r = lil_parse_value(lil, &argv[base + 1], 0);\n    }\n    r\n}\n\n\npub fn fnc_set<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_get_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: &LilValue<T>, access: i32) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n\n    let mut i = 0;\n    let mut var: Option<Rc<RefCell<LilVar<T>>>> = None;\n    let mut access = 1;\n    if argc == 0 { return None; }\n    if argv[0].d.as_ref().map_or(false, |d| d.to_string() == \"global\") {\n        i = 1;\n        access = 0;\n    }\n    while i < argc {\n        if argc == i + 1 {\n            return lil_get_var_wrap(lil, &argv[i].d.as_ref()?.to_string()).map(|v| v.borrow().v.clone());\n        }\n        var = lil_set_var_wrap(lil, &argv[i].d.as_ref()?.to_string(), &argv[i + 1], access);\n        i += 2;\n    }\n    var.map(|v| v.borrow().v.clone())\n}\n\n\npub fn fnc_split<T: Clone + ToString + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList::<T> { items: Vec::new() };\n    let mut sep = \" \".to_string();\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    if argc > 1 {\n        sep = argv[1].d.as_ref().map(|x| x.to_string()).unwrap_or_else(|| \" \".to_string());\n        if sep.is_empty() { return argv[0].clone(); }\n    }\n    let mut val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n    let str = argv[0].d.as_ref().map(|x| x.to_string()).unwrap_or_default();\n    for c in str.chars() {\n        if sep.contains(c) {\n            list.items.push(Rc::new(RefCell::new(val)));\n            val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n        } else {\n            if let Some(s) = val.d.as_mut() {\n                *s = format!(\"{}{}\", s.to_string(), c).into();\n            }\n        }\n    }\n    list.items.push(Rc::new(RefCell::new(val)));\n    let result_str = list.items.iter().map(|x| x.borrow().d.as_ref().map(|x| x.to_string()).unwrap_or_default()).collect::<Vec<_>>().join(\" \");\n    LilValue { l: 0, d: Some(result_str.into()) }\n}\n\n\nfn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\n\npub fn lil_register<T: Clone>(lil: &mut LilStruct<T>, name: &str, proc: LilFuncProc<T>) {\n    let func = Rc::new(RefCell::new(LilFunc {\n        name: name.to_string(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: Some(proc),\n    }));\n    lil.cmd.push(func.clone());\n    lil.cmds += 1;\n}\n\n\npub fn fnc_write<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut msg = String::new();\n    for i in 0..argc {\n        if i != 0 {\n            msg.push(' ');\n        }\n        msg.push_str(&argv[i].d.as_ref().unwrap().to_string());\n    }\n    println!(\"{}\", msg);\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_if<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if argv[0].d.as_ref().map_or(false, |s| s.to_string() == \"not\") {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    let val = lil_eval_expr(lil, &argv[base]);\n    if val.is_none() || lil.error != 0 { return None; }\n    let v = lil_to_boolean(&val.unwrap());\n    let v = if not { !v } else { v };\n    if v {\n        lil_parse_value(lil, &argv[base + 1], 0)\n    } else if argc > base + 2 {\n        lil_parse_value(lil, &argv[base + 2], 0)\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_length<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(value: i64) -> LilValue<T> {\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n    let mut total = 0;\n    for (i, arg) in argv.iter().enumerate() {\n        if i != 0 {\n            total += 1;\n        }\n        let s = lil_to_string_wrap(arg);\n        total += s.len();\n    }\n    lil_alloc_integer_wrap(total as i64)\n}\n\n\npub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n\npub fn fnc_strpos<T: Clone + From<i32> + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let hay;\n    let str;\n    let mut min = 0;\n    if argc < 2 {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    hay = argv[0].d.as_ref().unwrap().to_string();\n    if argc > 2 {\n        min = argv[2].d.as_ref().unwrap().to_string().parse::<usize>().unwrap();\n        if min >= hay.len() {\n            return LilValue { l: 0, d: Some(T::from(-1)) };\n        }\n    }\n    str = hay[min..].find(&argv[1].d.as_ref().unwrap().to_string());\n    if str.is_none() {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    LilValue { l: 0, d: Some(T::from(str.unwrap() as i32)) }\n}\n\n\npub fn fnc_strcmp<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    let s1 = lil_to_string_wrap(&argv[0]);\n    let s2 = lil_to_string_wrap(&argv[1]);\n    LilValue { l: s1.cmp(&s2) as usize, d: None }\n}\n\n\npub fn fnc_repstr<T: Clone + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 1 {\n        return LilValue { l: 0, d: None };\n    }\n    if argc < 3 {\n        return argv[0].clone();\n    }\n\n    let from = lil_to_string(&argv[1]);\n    let to = lil_to_string(&argv[2]);\n    if from.is_empty() {\n        return LilValue { l: 0, d: None };\n    }\n\n    let mut src = lil_to_string(&argv[0]);\n    let from_len = from.len();\n    let to_len = to.len();\n\n    while let Some(idx) = src.find(&from) {\n        let mut new_src = String::with_capacity(src.len() - from_len + to_len);\n        new_src.push_str(&src[..idx]);\n        new_src.push_str(&to);\n        new_src.push_str(&src[idx + from_len..]);\n        src = new_src;\n    }\n\n    lil_alloc_string(&src)\n}\n\n\npub fn fnc_rename<T: Clone + Debug + From<String>>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let oldname = lil_to_string(&argv[0]);\n    let newname = lil_to_string(&argv[1]);\n    if argc < 2 {\n        return None;\n    }\n\n    let func = find_cmd(lil, &oldname);\n    if func.is_none() {\n        let msg = format!(\"unknown function '{}'\", oldname);\n        lil_set_error_at(lil, lil.head, &msg);\n        return None;\n    }\n    let func = func.unwrap();\n\n    let r = lil_alloc_string(&func.borrow().name);\n    if !newname.is_empty() {\n        hm_put(&mut lil.cmdmap, &oldname, None);\n        hm_put(&mut lil.cmdmap, &newname, Some(func.clone()));\n        func.borrow_mut().name = newname.clone();\n    } else {\n        del_func(lil, &func);\n    }\n\n    Some(LilValue { l: r.l, d: r.d.map(|s| s.into()) })\n}\n\n\npub fn fnc_writechar<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Option<LilValue<T>> {\n    if argc == 0 {\n        return None;\n    }\n    print!(\"{}\", argv[0].borrow().to_integer() as u8 as char);\n    None\n}\n\n\npub fn fnc_dec<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        String::new()\n    }\n    \n    fn lil_to_double_wrap<T: Clone>(val: &LilValue<T>) -> f64 {\n        0.0\n    }\n    \n    fn real_inc_wrap<T: Clone>(lil: &LilStruct<T>, s: String, d: f64) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    real_inc_wrap(lil, lil_to_string_wrap(&argv[0]), -(if argc > 1 { lil_to_double_wrap(&argv[1]) } else { 1.0 }))\n}\n\n\npub fn fnc_quote<T: Clone + AsRef<str> + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    let mut r = LilValue { l: 0, d: None };\n    for i in 0..argc {\n        if i != 0 {\n            let lil_append_char_wrap = |r: &mut LilValue<T>, c: char| {\n                if let Some(ref mut data) = r.d {\n                    let mut s = String::new();\n                    s.push_str(data.as_ref());\n                    s.push(c);\n                    r.d = Some(T::from(s));\n                }\n            };\n            lil_append_char_wrap(&mut r, ' ');\n        }\n        let lil_append_val_wrap = |r: &mut LilValue<T>, val: &LilValue<T>| {\n            if let (Some(ref mut dst_data), Some(ref src_data)) = (&mut r.d, &val.d) {\n                let mut s = String::new();\n                s.push_str(dst_data.as_ref());\n                s.push_str(src_data.as_ref());\n                r.d = Some(T::from(s));\n            }\n        };\n        lil_append_val_wrap(&mut r, &argv[i]);\n    }\n    Some(r)\n}\n\n\n\npub fn test_function_registration() {\n    println!(\"Testing function registration...\");\n    \n    let lil = lil_new();\n    assert!(lil.is_some());\n    \n    lil_register(&mut lil.as_ref().unwrap().borrow_mut(), \"writechar\", fnc_writechar);\n    lil_register(&mut lil.as_ref().unwrap().borrow_mut(), \"system\", fnc_system);\n    lil_register(&mut lil.as_ref().unwrap().borrow_mut(), \"readline\", fnc_readline);\n    \n    lil_free(lil);\n    println!(\"✓ Function registration test passed\");\n}\n\npub fn lil_new<T: Clone>() -> Option<Rc<RefCell<LilStruct<T>>>> {\n    let mut lil = LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: strclone(\"set \").unwrap(),\n        env: lil_alloc_env(None),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: alloc_value::<T>(None).unwrap(),\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: unsafe { std::mem::zeroed() },\n        embed: String::new(),\n        embedlen: 0,\n    };\n    hm_init(&mut lil.cmdmap);\n    register_stdcmds(&mut lil);\n    Some(Rc::new(RefCell::new(lil)))\n}\n\npub fn register_stdcmds<T: Clone>(lil: &mut LilStruct<T>) {\n    lil_register(lil, \"reflect\", fnc_reflect);\n    lil_register(lil, \"func\", fnc_func);\n    lil_register(lil, \"rename\", fnc_rename);\n    lil_register(lil, \"unusedname\", fnc_unusedname);\n    lil_register(lil, \"quote\", fnc_quote);\n    lil_register(lil, \"set\", fnc_set);\n    lil_register(lil, \"local\", fnc_local);\n    lil_register(lil, \"write\", fnc_write);\n    lil_register(lil, \"print\", fnc_print);\n    lil_register(lil, \"eval\", fnc_eval);\n    lil_register(lil, \"topeval\", fnc_topeval);\n    lil_register(lil, \"upeval\", fnc_upeval);\n    lil_register(lil, \"downeval\", fnc_downeval);\n    lil_register(lil, \"enveval\", fnc_enveval);\n    lil_register(lil, \"jaileval\", fnc_jaileval);\n    lil_register(lil, \"count\", fnc_count);\n    lil_register(lil, \"index\", fnc_index);\n    lil_register(lil, \"indexof\", fnc_indexof);\n    lil_register(lil, \"filter\", fnc_filter);\n    lil_register(lil, \"list\", fnc_list);\n    lil_register(lil, \"append\", fnc_append);\n    lil_register(lil, \"slice\", fnc_slice);\n    lil_register(lil, \"subst\", fnc_subst);\n    lil_register(lil, \"concat\", fnc_concat);\n    lil_register(lil, \"foreach\", fnc_foreach);\n    lil_register(lil, \"return\", fnc_return);\n    lil_register(lil, \"result\", fnc_result);\n    lil_register(lil, \"expr\", fnc_expr);\n    lil_register(lil, \"inc\", fnc_inc);\n    lil_register(lil, \"dec\", fnc_dec);\n    lil_register(lil, \"read\", fnc_read);\n    lil_register(lil, \"store\", fnc_store);\n    lil_register(lil, \"if\", fnc_if);\n    lil_register(lil, \"while\", fnc_while);\n    lil_register(lil, \"for\", fnc_for);\n    lil_register(lil, \"char\", fnc_char);\n    lil_register(lil, \"charat\", fnc_charat);\n    lil_register(lil, \"codeat\", fnc_codeat);\n    lil_register(lil, \"substr\", fnc_substr);\n    lil_register(lil, \"strpos\", fnc_strpos);\n    lil_register(lil, \"length\", fnc_length);\n    lil_register(lil, \"trim\", fnc_trim);\n    lil_register(lil, \"ltrim\", fnc_ltrim);\n    lil_register(lil, \"rtrim\", fnc_rtrim);\n    lil_register(lil, \"strcmp\", fnc_strcmp);\n    lil_register(lil, \"streq\", fnc_streq);\n    lil_register(lil, \"repstr\", fnc_repstr);\n    lil_register(lil, \"split\", fnc_split);\n    lil_register(lil, \"try\", fnc_try);\n    lil_register(lil, \"error\", fnc_error);\n    lil_register(lil, \"exit\", fnc_exit);\n    lil_register(lil, \"source\", fnc_source);\n    lil_register(lil, \"lmap\", fnc_lmap);\n    lil_register(lil, \"rand\", fnc_rand);\n    lil_register(lil, \"catcher\", fnc_catcher);\n    lil_register(lil, \"watch\", fnc_watch);\n    lil.syscmds = lil.cmds;\n}\n\npub fn fnc_local<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    for i in 0..argc {\n        let varname = lil_to_string(&argv[i]);\n        if find_cmd(lil, &varname).is_none() {\n            lil_set_var(lil, &varname, lil.empty.clone(), LIL_SETVAR_LOCAL_NEW);\n        }\n    }\n    None\n}\n\npub fn fnc_source<T: Clone + From<String>>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let filename = lil_to_string(&argv[0]);\n    let mut buffer = String::new();\n    if lil.callback[LIL_CALLBACK_SOURCE].is_some() {\n        let proc = lil.callback[LIL_CALLBACK_SOURCE];\n        buffer = proc(lil, &filename, &[]).d.unwrap();\n    } else if lil.callback[LIL_CALLBACK_READ].is_some() {\n        let proc = lil.callback[LIL_CALLBACK_READ];\n        buffer = proc(lil, &filename, &[]).d.unwrap();\n    } else {\n        let mut file = std::fs::File::open(&filename).ok()?;\n        file.read_to_string(&mut buffer).ok()?;\n    }\n    Some(lil_parse(lil, &buffer, 0, 0))\n}\n\npub fn fnc_enveval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let codeindex = if argc == 1 { 0 } else if argc >= 2 { if argc > 2 { 2 } else { 1 } } else { 0 };\n    let invars = if argc >= 2 { Some(lil_subst_to_list(lil, &argv[0])) } else { None };\n    let outvars = if argc > 2 { Some(lil_subst_to_list(lil, &argv[1])) } else { None };\n    let mut varvalues = if invars.is_some() { \n        let invars = invars.as_ref().unwrap();\n        let mut values = Vec::with_capacity(invars.items.len());\n        for i in 0..invars.items.len() {\n            values.push(lil_clone_value(lil_get_var(lil, &lil_to_string(&invars.items[i].borrow()))));\n        }\n        values\n    } else { Vec::new() };\n    lil_push_env(lil);\n    if let Some(invars) = invars.as_ref() {\n        for i in 0..invars.items.len() {\n            lil_set_var(lil, &lil_to_string(&invars.items[i].borrow()), varvalues[i].clone(), LIL_SETVAR_LOCAL_NEW);\n            lil_free_value(Some(Rc::new(RefCell::new(varvalues[i].clone()))));\n        }\n    }\n    let r = lil_parse_value(lil, &argv[codeindex], 0);\n    if invars.is_some() || outvars.is_some() {\n        if outvars.is_some() {\n            let outvars = outvars.as_ref().unwrap();\n            varvalues = Vec::with_capacity(outvars.items.len());\n            for i in 0..outvars.items.len() {\n                varvalues.push(lil_clone_value(lil_get_var(lil, &lil_to_string(&outvars.items[i].borrow()))));\n            }\n        } else {\n            let invars = invars.as_ref().unwrap();\n            varvalues = Vec::with_capacity(invars.items.len());\n            for i in 0..invars.items.len() {\n                varvalues.push(lil_clone_value(lil_get_var(lil, &lil_to_string(&invars.items[i].borrow()))));\n            }\n        }\n    }\n    lil_pop_env(lil);\n    if let Some(invars) = invars {\n        if let Some(outvars) = outvars {\n            for i in 0..outvars.items.len() {\n                lil_set_var(lil, &lil_to_string(&outvars.items[i].borrow()), varvalues[i].clone(), LIL_SETVAR_LOCAL);\n                lil_free_value(Some(Rc::new(RefCell::new(varvalues[i].clone()))));\n            }\n        } else {\n            for i in 0..invars.items.len() {\n                lil_set_var(lil, &lil_to_string(&invars.items[i].borrow()), varvalues[i].clone(), LIL_SETVAR_LOCAL);\n                lil_free_value(Some(Rc::new(RefCell::new(varvalues[i].clone()))));\n            }\n        }\n        lil_free_list(invars);\n        if let Some(outvars) = outvars {\n            lil_free_list(outvars);\n        }\n    }\n    r\n}\n\npub fn fnc_ltrim<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let s = lil_to_string(&argv[0]);\n    let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { &lil_to_string(&argv[1]) };\n    Some(real_trim(&s, chars, true, false))\n}\n\npub fn fnc_trim<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let s = lil_to_string(&argv[0]);\n    let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { &lil_to_string(&argv[1]) };\n    Some(real_trim(&s, chars, true, true))\n}\n\nfn main(){}\n //编译报错信息：error: unknown character escape: `f`\n    --> ../../Output/crown/tmp/test-lil_test_function_registration/temp.rs:1997:34\n     |\n1997 |     let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { &lil_to_string(&argv[1]) };\n     |                                  ^ unknown character escape\n     |\n     = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "test_lil_creation_and_destruction": "pub static mut test_running: i32 = 1;\npub static mut test_exit_code: i32 = 0;\n\npub trait ToInteger {\n    fn to_integer(&self) -> i32;\n}\n\nimpl<T: ToInteger> ToInteger for RefCell<T> {\n    fn to_integer(&self) -> i32 {\n        self.borrow().to_integer()\n    }\n}\n\nimpl<T: Clone + ToString> ToInteger for LilValue<T> {\n    fn to_integer(&self) -> i32 {\n        if let Some(ref data) = self.d {\n            if let Ok(num) = data.to_string().parse::<i32>() {\n                return num;\n            }\n        }\n        0\n    }\n}\nuse std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn fnc_return<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    lil.env.borrow_mut().breakrun = true;\n    lil.env.borrow_mut().retval = if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() };\n    lil.env.borrow_mut().retval_set = true;\n    if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() }\n}\n\n\npub fn fnc_print<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_write_wrap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) {\n        // 空实现\n    }\n    fn lil_write_wrap<T: Clone>(lil: &LilStruct<T>, s: &str) {\n        // 空实现\n    }\n    fnc_write_wrap(lil, argc, argv);\n    lil_write_wrap(lil, \"\\n\");\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_error<T: Clone + std::fmt::Display>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let err_msg = if argc > 0 {\n        match &argv[0].d {\n            Some(d) => d.to_string(),\n            None => String::new(),\n        }\n    } else {\n        String::new()\n    };\n    lil.error = 1;\n    lil.err_msg = err_msg;\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_concat<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut r = LilValue { l: 0, d: Some(String::new().into()) };\n    if argc < 1 { return r; }\n    for i in 0..argc {\n        let list = argv[i].clone();\n        let tmp = list;\n        lil_append_val_wrap(&mut r, tmp);\n    }\n    r\n}\n\n\nfn lil_append_val_wrap<T: Clone>(dst: &mut LilValue<T>, src: LilValue<T>) {\n    if let Some(d) = &mut dst.d {\n        if let Some(s) = src.d {\n            *d = s;\n        }\n    }\n}\n\n\npub fn fnc_subst<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    fn lil_subst_to_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        val.clone()\n    }\n    Some(lil_subst_to_value_wrap(lil, &argv[0]))\n}\n\n\npub fn fnc_eval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(data: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d: data }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, ch: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, other: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_parse_value_wrap(lil, &argv[0], 0);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_parse_value_wrap(lil, &val, 0);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_try<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc < 1 {\n        return None;\n    }\n    if lil.error != 0 {\n        return None;\n    }\n    let mut r = lil_parse_value_wrap(lil, &argv[0], 0);\n    if lil.error != 0 {\n        lil.error = 0;\n        lil_free_value_wrap(r.clone());\n        if argc > 1 {\n            r = lil_parse_value_wrap(lil, &argv[1], 0);\n        } else {\n            r = LilValue { l: 0, d: None };\n        }\n    }\n    Some(r)\n}\n\n\npub fn fnc_charat<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer<T: Clone + Debug>(val: &LilValue<T>) -> i64 {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d).parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    let str = lil_to_string(&argv[0]);\n    let index = lil_to_integer(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    let chstr = &str[index..=index];\n    lil_alloc_string(chstr)\n}\n\n\npub fn fnc_indexof<T: Clone + PartialEq + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 {\n        return None;\n    }\n\n    fn lil_subst_to_list_wrap<T: Clone>(_: &LilStruct<T>, _: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_to_string_wrap<T: Clone + Debug>(_: &Rc<RefCell<LilValue<T>>>) -> String {\n        String::new()\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(index: i32) -> LilValue<T> {\n        LilValue { l: index as usize, d: None }\n    }\n    fn lil_free_list_wrap<T: Clone>(_: LilList<T>) {}\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut result = None;\n\n    for (index, item) in list.items.iter().enumerate() {\n        let item_str = lil_to_string_wrap(item);\n        let arg_str = lil_to_string_wrap(&Rc::new(RefCell::new(argv[1].clone())));\n        if item_str == arg_str {\n            result = Some(lil_alloc_integer_wrap(index as i32));\n            break;\n        }\n    }\n\n    lil_free_list_wrap(list);\n    result\n}\n\n\npub fn fnc_expr<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_eval_expr_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(d: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, c: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_eval_expr_wrap(lil, &argv[0]);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_eval_expr_wrap(lil, &val);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_append<T: Clone + Debug + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let mut base = 1;\n    let mut access = 1;\n    let varname = argv[0].d.as_ref().unwrap().to_string();\n    let mut varname = if varname == \"global\" {\n        if argc < 3 { return LilValue { l: 0, d: None }; }\n        base = 2;\n        access = 0;\n        argv[1].d.as_ref().unwrap().to_string()\n    } else {\n        varname\n    };\n    let mut list = lil_subst_to_list(lil, lil_get_var(lil, &varname));\n    for i in base..argc {\n        lil_list_append(&mut list, argv[i].clone());\n    }\n    let r = lil_list_to_value(&list, 1);\n    lil_free_list(list);\n    lil_set_var(lil, &varname, r.clone(), access);\n    r\n}\n\n\npub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\n\npub fn fnc_filter<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_alloc_list_wrap<T: Clone>() -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _scope: i32) {}\n    fn lil_eval_expr_wrap<T: Clone>(_lil: &mut LilStruct<T>, _expr: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(_val: &LilValue<T>) -> bool {\n        false\n    }\n    fn lil_list_append_wrap<T: Clone>(_list: &mut LilList<T>, _val: Rc<RefCell<LilValue<T>>>) {}\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _deep: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut varname = \"x\".to_string();\n    let mut base = 0;\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    if argc > 2 {\n        base = 1;\n        varname = argv[0].d.as_ref().unwrap().to_string();\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[base]);\n    let mut filtered = lil_alloc_list_wrap();\n\n    for i in 0..list.items.len() {\n        if lil.env.borrow().breakrun { break; }\n        lil_set_var_wrap(lil, &varname, list.items[i].clone(), 3);\n        let r = lil_eval_expr_wrap(lil, &argv[base + 1]);\n        if lil_to_boolean_wrap(&r) {\n            lil_list_append_wrap(&mut filtered, list.items[i].clone());\n        }\n    }\n\n    let r = lil_list_to_value_wrap(&filtered, 1);\n    r\n}\n\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\n\npub fn fnc_codeat<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i32 {\n        match &val.d {\n            Some(v) => v.to_string().parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_integer_wrap<T: Clone>(val: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let index: usize;\n    let str: String;\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    str = lil_to_string_wrap(&argv[0]);\n    index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    lil_alloc_integer_wrap(str.chars().nth(index).unwrap() as i32)\n}\n\n\npub fn lil_free<T: Clone>(lil: Option<Rc<RefCell<LilStruct<T>>>>) {\n    if lil.is_none() {\n        return;\n    }\n    let mut lil = lil.unwrap();\n    let mut lil = lil.borrow_mut();\n    lil.err_msg.clear();\n    lil_free_value(Some(Rc::new(RefCell::new(lil.empty.clone()))));\n    \n    let mut current_env = Some(lil.env.clone());\n    while let Some(env) = current_env {\n        let next = env.borrow().parent.clone();\n        lil_free_env(Some(env));\n        current_env = next;\n    }\n    \n    for i in 0..lil.cmds {\n        let cmd = lil.cmd[i].borrow();\n        if !cmd.argnames.items.is_empty() {\n            lil_free_list(cmd.argnames.clone());\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd.code.clone()))));\n    }\n    hm_destroy(&mut lil.cmdmap);\n    lil.cmd.clear();\n    lil.dollarprefix.clear();\n    lil.catcher.clear();\n}\n\n\nfn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    None\n}\n\n\npub fn fnc_catcher<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        LilValue {\n            l: lil.catcher.len(),\n            d: Some(T::from(lil.catcher.clone())),\n        }\n    } else {\n        let catcher = argv[0].d.as_ref().unwrap().to_string();\n        lil.catcher = if !catcher.is_empty() { catcher } else { String::new() };\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n}\n\n\npub fn fnc_upeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let fnc_eval_wrap = |lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]| -> LilValue<T> {\n        lil.empty.clone()\n    };\n    \n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    let r;\n    if Rc::ptr_eq(&lil.rootenv, &thisenv) {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.env = match thisenv.borrow().parent.as_ref() {\n        Some(parent) => Rc::clone(parent),\n        None => Rc::clone(&thisenv),\n    };\n    lil.downenv = Rc::clone(&thisenv);\n    r = fnc_eval_wrap(lil, argc, argv);\n    lil.env = thisenv;\n    lil.downenv = thisdownenv;\n    r\n}\n\n\npub fn fnc_rand<T: Clone + From<f64>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    LilValue {\n        l: 8,\n        d: Some(0.5f64.into())\n    }\n}\n\n\npub fn lil_free_env<T: Clone>(env: Option<Rc<RefCell<LilEnv<T>>>>) {\n    if env.is_none() {\n        return;\n    }\n    let env = env.unwrap();\n    let mut env = env.borrow_mut();\n    lil_free_value(Some(Rc::new(RefCell::new(env.retval.clone()))));\n    hm_destroy(&mut env.varmap);\n    for i in 0..env.vars {\n        let var = env.var[i].borrow_mut();\n        lil_free_value(Some(Rc::new(RefCell::new(var.v.clone()))));\n    }\n    env.var.clear();\n    env.vars = 0;\n}\n\n\npub fn fnc_substr<T: Clone + Debug + FromStr + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let str = match &argv[0].d {\n        Some(s) => s.to_string(),\n        None => return LilValue { l: 0, d: None },\n    };\n    if str.is_empty() { return LilValue { l: 0, d: None }; }\n    let slen = str.len();\n    let start = match argv[1].d.as_ref() {\n        Some(s) => s.to_string().parse::<usize>().unwrap_or(0),\n        None => 0,\n    };\n    let end = if argc > 2 {\n        match argv[2].d.as_ref() {\n            Some(s) => s.to_string().parse::<usize>().unwrap_or(slen),\n            None => slen,\n        }\n    } else { slen };\n    let end = if end > slen { slen } else { end };\n    if start >= end { return LilValue { l: 0, d: None }; }\n    let result = str.chars().skip(start).take(end - start).collect::<String>();\n    LilValue { l: result.len(), d: Some(result.parse().unwrap_or_else(|_| panic!(\"Failed to parse string\"))) }\n}\n\n\npub fn fnc_store<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        if let Some(ref d) = val.d {\n            format!(\"{:?}\", d)\n        } else {\n            String::new()\n        }\n    }\n\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    if let Some(proc) = lil.callback.get(3).copied() {\n        let name = lil_to_string_wrap(&argv[0]);\n        let data = lil_to_string_wrap(&argv[1]);\n        proc(lil, &name, &[argv[1].clone()]);\n    } else {\n        let filename = lil_to_string_wrap(&argv[0]);\n        let buffer = lil_to_string_wrap(&argv[1]);\n        if let Ok(mut file) = std::fs::File::create(&filename) {\n            let _ = std::io::Write::write_all(&mut file, buffer.as_bytes());\n        }\n    }\n    argv[1].clone()\n}\n\n\npub fn fnc_inc<T: Clone + From<u32>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let arg0 = if let Some(d) = &argv[0].d { d.clone() } else { return None; };\n    let arg1 = if argc > 1 { \n        if let Some(d) = &argv[1].d { d.clone() } else { return None; }\n    } else { T::from(1) };\n    Some(LilValue { l: 0, d: Some(arg0) })\n}\n\n\npub fn fnc_exit<T: Clone>(lil: Rc<RefCell<LilStruct<T>>>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Option<Rc<RefCell<LilValue<T>>>> {\n    let lil_ref = lil.borrow();\n    if let Some(proc) = lil_ref.callback.get(0) {\n        let arg = if argc > 0 { Some(argv[0].clone()) } else { None };\n        let lil_wrap = &*lil_ref;\n        proc(lil_wrap, \"\", &[]);\n    }\n    None\n}\n\n\nfn hm_put<T>(map: &mut HashMap<T>, key: &str, value: Option<T>) {\n}\n\n\npub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\n\npub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\n\npub fn fnc_for<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_eval_expr_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(val: &LilValue<T>) -> bool {\n        false\n    }\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 4 { return LilValue { l: 0, d: None }; }\n    let _ = lil_parse_value_wrap(lil, &argv[0], 0);\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr_wrap(lil, &argv[1]);\n        if val.l == 0 || lil.error != 0 { return LilValue { l: 0, d: None }; }\n        if !lil_to_boolean_wrap(&val) {\n            break;\n        }\n        r = lil_parse_value_wrap(lil, &argv[3], 0);\n        let _ = lil_parse_value_wrap(lil, &argv[2], 0);\n    }\n    r\n}\n\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\n\npub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\n\npub fn fnc_slice<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_integer_wrap<T: Clone>(val: &LilValue<T>) -> i64 {\n        0\n    }\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(list: &LilList<T>, _flag: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    \n    let mut from = lil_to_integer_wrap(&argv[1]);\n    if from < 0 { from = 0; }\n    \n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut to = if argc > 2 { lil_to_integer_wrap(&argv[2]) } else { list.items.len() as i64 };\n    if to > list.items.len() as i64 { to = list.items.len() as i64; }\n    if to < from { to = from; }\n    \n    let mut slice = LilList { items: Vec::new() };\n    for i in from as usize..to as usize {\n        slice.items.push(list.items[i].clone());\n    }\n    \n    let r = lil_list_to_value_wrap(&slice, 1);\n    r\n}\n\n\npub fn fnc_func<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Rc<RefCell<LilValue<T>>> {\n    let name: Rc<RefCell<LilValue<T>>>;\n    let cmd: Rc<RefCell<LilFunc<T>>>;\n    let fargs: LilList<T>;\n    \n    fn lil_clone_value_wrap<T: Clone>(value: &Rc<RefCell<LilValue<T>>>) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new((*value.borrow()).clone()))\n    }\n    \n    fn lil_to_string_wrap<T: Clone + ToString>(value: &Rc<RefCell<LilValue<T>>>) -> String {\n        value.borrow().d.as_ref().map_or(String::new(), |v| v.to_string())\n    }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, value: &Rc<RefCell<LilValue<T>>>) -> LilList<T> {\n        LilList { items: vec![Rc::clone(value)] }\n    }\n    \n    fn add_func_wrap<T: Clone>(_lil: &LilStruct<T>, name: &str) -> Rc<RefCell<LilFunc<T>>> {\n        Rc::new(RefCell::new(LilFunc {\n            name: name.to_string(),\n            code: LilValue { l: 0, d: None },\n            argnames: LilList { items: vec![] },\n            proc: None,\n        }))\n    }\n    \n    fn lil_unused_name_wrap<T: Clone>(_lil: &LilStruct<T>, prefix: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: None }))\n    }\n    \n    fn lil_alloc_string_wrap<T: Clone + From<String>>(s: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: Some(s.to_string().into()) }))\n    }\n\n    if argc < 1 {\n        return Rc::new(RefCell::new(LilValue { l: 0, d: None }));\n    }\n    if argc >= 3 {\n        name = lil_clone_value_wrap(&argv[0]);\n        fargs = lil_subst_to_list_wrap(lil, &argv[1]);\n        cmd = add_func_wrap(lil, &lil_to_string_wrap(&argv[0]));\n        cmd.borrow_mut().argnames = fargs;\n        cmd.borrow_mut().code = (*argv[2].borrow()).clone();\n    } else {\n        name = lil_unused_name_wrap(lil, \"anonymous-function\");\n        if argc < 2 {\n            let tmp = lil_alloc_string_wrap(\"args\");\n            fargs = lil_subst_to_list_wrap(lil, &tmp);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[0].borrow()).clone();\n        } else {\n            fargs = lil_subst_to_list_wrap(lil, &argv[0]);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[1].borrow()).clone();\n        }\n    }\n    name\n}\n\n\npub fn fnc_lmap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        unimplemented!()\n    }\n    \n    fn lil_list_get_wrap<T: Clone>(list: &Rc<RefCell<LilList<T>>>, index: usize) -> LilValue<T> {\n        unimplemented!()\n    }\n    \n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: LilValue<T>, flag: i32) {\n        unimplemented!()\n    }\n    \n    fn lil_free_list_wrap<T: Clone>(list: Rc<RefCell<LilList<T>>>) {\n        unimplemented!()\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    for i in 1..argc {\n        let var_name = lil_to_string_wrap(&argv[i]);\n        let value = lil_list_get_wrap(&list, i - 1);\n        lil_set_var_wrap(lil, &var_name, value, 1);\n    }\n    lil_free_list_wrap(list);\n    None\n}\n\n\npub fn fnc_unusedname(lil: &LilStruct<String>, argc: usize, argv: &[LilValue<String>]) -> LilValue<String> {\n    fn lil_to_string_wrap(val: &LilValue<String>) -> String {\n        match &val.d {\n            Some(v) => v.clone(),\n            None => String::new(),\n        }\n    }\n    fn lil_unused_name_wrap(lil: &LilStruct<String>, name: &str) -> LilValue<String> {\n        LilValue {\n            l: name.len(),\n            d: Some(name.to_string()),\n        }\n    }\n    let arg = if argc > 0 { lil_to_string_wrap(&argv[0]) } else { \"unusedname\".to_string() };\n    lil_unused_name_wrap(lil, &arg)\n}\n\n\npub fn fnc_streq<T: Clone + FromStr + PartialEq + std::fmt::Display + From<bool>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return lil.empty.clone(); }\n    let s1 = argv[0].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    let s2 = argv[1].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    LilValue { l: 1, d: Some((s1 == s2).into()) }\n}\n\n\npub fn fnc_reflect<T: Clone + Debug + From<String> + From<&'static str> + From<i64> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let type_str = lil_to_string(&argv[0]);\n    match type_str.as_str() {\n        \"version\" => Some(LilValue { l: 3, d: Some(\"0.1\".into()) }),\n        \"args\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().argnames.items.is_empty() { return None; }\n            Some(func.unwrap().borrow().argnames.items[0].borrow().clone())\n        },\n        \"body\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().proc.is_some() { return None; }\n            Some(func.unwrap().borrow().code.clone())\n        },\n        \"func-count\" => Some(LilValue { l: 0, d: Some((lil.cmds as i64).into()) }),\n        \"funcs\" => {\n            let mut funcs = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.cmds {\n                funcs.items.push(Rc::new(RefCell::new(LilValue { l: lil.cmd[i].borrow().name.len(), d: Some(lil.cmd[i].borrow().name.clone().into()) })));\n            }\n            Some(LilValue { l: funcs.items.len(), d: None })\n        },\n        \"vars\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                for i in 0..e.borrow().vars {\n                    vars.items.push(Rc::new(RefCell::new(LilValue { l: e.borrow().var[i].borrow().n.len(), d: Some(e.borrow().var[i].borrow().n.clone().into()) })));\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"globals\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.rootenv.borrow().vars {\n                vars.items.push(Rc::new(RefCell::new(LilValue { l: lil.rootenv.borrow().var[i].borrow().n.len(), d: Some(lil.rootenv.borrow().var[i].borrow().n.clone().into()) })));\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"has-func\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            if lil.cmdmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                Some(LilValue { l: 1, d: Some(\"1\".into()) })\n            } else {\n                None\n            }\n        },\n        \"has-var\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                if e.borrow().varmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            None\n        },\n        \"has-global\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            for i in 0..lil.rootenv.borrow().vars {\n                if target == lil.rootenv.borrow().var[i].borrow().n { \n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n            }\n            None\n        },\n        \"error\" => lil.err_msg.is_empty().then(|| LilValue { l: lil.err_msg.len(), d: Some(lil.err_msg.clone().into()) }),\n        \"dollar-prefix\" => {\n            if argc == 1 { return Some(LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) }); }\n            let r = LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) };\n            lil.dollarprefix = lil_to_string(&argv[1]);\n            Some(r)\n        },\n        \"this\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(LilValue { l: lil.catcher.len(), d: Some(lil.catcher.clone().into()) }); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return Some(LilValue { l: lil.rootcode.len(), d: Some(lil.rootcode.clone().into()) }); }\n                if let Some(func) = &e.borrow().func { return Some(func.borrow().code.clone()); }\n            }\n            None\n        },\n        \"name\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(e.borrow().catcher_for.clone()); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return None; }\n                if let Some(func) = &e.borrow().func { return Some(LilValue { l: func.borrow().name.len(), d: Some(func.borrow().name.clone().into()) }); }\n            }\n            None\n        },\n        _ => None\n    }\n}\n\n\npub fn fnc_list<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList { items: Vec::new() };\n    for i in 0..argc {\n        list.items.push(Rc::new(RefCell::new(argv[i].clone())));\n    }\n    LilValue { l: list.items.len(), d: None }\n}\n\n\npub fn fnc_char<T: Clone + From<String> + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        return LilValue { l: 0, d: None };\n    }\n    let s = match &argv[0].d {\n        Some(val) => {\n            let mut buf = [0u8; 2];\n            buf[0] = format!(\"{:?}\", val).parse::<u8>().unwrap_or(0);\n            buf[1] = 0;\n            String::from_utf8_lossy(&buf).to_string()\n        },\n        None => String::new(),\n    };\n    LilValue { l: s.len(), d: Some(T::from(s)) }\n}\n\n\npub fn fnc_rtrim<T: Clone + Debug + FromStr>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn real_trim(s: String, pat: String, _left: i32, _right: i32) -> LilValue<String> {\n        let trimmed = s.trim_end_matches(&pat[..]);\n        LilValue {\n            l: trimmed.len(),\n            d: Some(trimmed.to_string()),\n        }\n    }\n\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let pat = if argc < 2 { \" \\u{000C}\\n\\r\\t\\u{000B}\".to_string() } else { lil_to_string(&argv[1]) };\n    let result = real_trim(s, pat, 0, 1);\n    LilValue { l: result.l, d: Some(result.d.unwrap().parse().ok().unwrap()) }\n}\n\n\npub fn fnc_result<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc > 0 {\n        lil.env.borrow_mut().retval = argv[0].clone();\n        lil.env.borrow_mut().retval_set = true;\n    }\n    if lil.env.borrow().retval_set {\n        Some(lil.env.borrow().retval.clone())\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_downeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    let upenv = Rc::clone(&lil.env);\n    let downenv = Rc::clone(&lil.downenv);\n    if downenv.borrow().parent.is_none() {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.downenv = Rc::new(RefCell::new(LilEnv {\n        parent: None,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    lil.env = Rc::clone(&downenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = downenv;\n    lil.env = upenv;\n    r\n}\n\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n\npub fn add_func<T: Clone + Debug>(lil: &mut LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    let cmd = find_cmd(lil, name);\n    if let Some(cmd) = cmd {\n        let mut cmd_ref = cmd.borrow_mut();\n        if cmd_ref.argnames.items.len() > 0 {\n            let argnames = cmd_ref.argnames.clone();\n            lil_free_list(argnames);\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd_ref.code.clone()))));\n        cmd_ref.argnames = LilList { items: Vec::new() };\n        cmd_ref.code = LilValue { l: 0, d: None };\n        cmd_ref.proc = None;\n        return Some(Rc::clone(&cmd));\n    }\n    let new_cmd = Rc::new(RefCell::new(LilFunc {\n        name: strclone(name).unwrap(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: None,\n    }));\n    lil.cmd.push(Rc::clone(&new_cmd));\n    lil.cmds += 1;\n    hm_put(&mut lil.cmdmap, name, Some(Rc::clone(&new_cmd)));\n    Some(new_cmd)\n}\n\n\npub fn hm_init<T>(hm: &mut HashMap<T>) {\n    hm.cell.clear();\n}\n\n\npub fn fnc_count<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    let mut buff = String::with_capacity(64);\n    if argc == 0 {\n        return LilValue { l: 1, d: Some(T::from(\"0\".to_string())) };\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    buff.push_str(&list.borrow().items.len().to_string());\n    LilValue { l: buff.len(), d: Some(T::from(buff)) }\n}\n\n\npub fn fnc_watch<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    let wcode = lil_to_string(&argv[argc - 1]);\n    for i in 0..(argc - 1) {\n        let vname = lil_to_string(&argv[i]);\n        if vname.is_empty() { continue; }\n        let mut v = lil_find_var(lil, lil.env.clone(), &vname);\n        if v.is_none() {\n            let empty_val = LilValue { l: 0, d: None };\n            lil_set_var(lil, &vname, empty_val, 2);\n            v = lil_find_var(lil, lil.env.clone(), &vname);\n        }\n        if let Some(var) = v {\n            var.borrow_mut().w = if !wcode.is_empty() { wcode.clone() } else { String::new() };\n        }\n    }\n    None\n}\n\n\npub fn fnc_jaileval<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n\n    fn lil_register_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _proc: LilFuncProc<T>) {}\n\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _depth: usize) -> Option<LilValue<T>> {\n        None\n    }\n\n    let mut base = 0;\n    if argc == 0 {\n        return None;\n    }\n    if lil_to_string_wrap(&argv[0]) == \"clean\" {\n        base = 1;\n        if argc == 1 {\n            return None;\n        }\n    }\n    let mut sublil = LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: String::new(),\n        env: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: LilValue { l: 0, d: None },\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: argv[0].d.as_ref().unwrap().clone(),\n        embed: String::new(),\n        embedlen: 0,\n    };\n    if base != 1 {\n        for i in lil.syscmds..lil.cmds {\n            let fnc = lil.cmd[i].clone();\n            if fnc.borrow().proc.is_none() {\n                continue;\n            }\n            lil_register_wrap(&mut sublil, &fnc.borrow().name, fnc.borrow().proc.unwrap());\n        }\n    }\n    let r = lil_parse_value_wrap(&mut sublil, &argv[base], 1);\n    r\n}\n\n\npub fn fnc_topeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    lil.env = Rc::clone(&lil.rootenv);\n    lil.downenv = Rc::clone(&thisenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = thisdownenv;\n    lil.env = thisenv;\n    r\n}\n\n\npub fn fnc_index<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: vec![Rc::new(RefCell::new(val.clone()))] }\n    }\n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i64 {\n        if let Some(d) = &val.d {\n            if let Ok(n) = i64::from_str(&d.to_string()) {\n                return n;\n            }\n        }\n        0\n    }\n    fn lil_free_list_wrap<T: Clone>(_list: LilList<T>) {}\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 2 { return r; }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index < list.items.len() {\n        r = list.items[index].borrow().clone();\n    }\n    lil_free_list_wrap(list);\n    r\n}\n\n\npub fn fnc_foreach<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _flags: i32) {}\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut rlist = LilList { items: Vec::new() };\n    let mut listidx = 0;\n    let mut codeidx = 1;\n    let mut varname = \"i\".to_string();\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    if argc >= 3 {\n        varname = argv[0].d.as_ref().unwrap().to_string();\n        listidx = 1;\n        codeidx = 2;\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[listidx]);\n    for i in 0..list.items.len() {\n        let item = list.items[i].clone();\n        lil_set_var_wrap(lil, &varname, item, 3);\n        let rv = lil_parse_value_wrap(lil, &argv[codeidx], 0);\n        if rv.l != 0 {\n            rlist.items.push(Rc::new(RefCell::new(rv)));\n        }\n        if lil.env.borrow().breakrun || lil.error != 0 { break; }\n    }\n    let r = lil_list_to_value_wrap(&rlist, 1);\n    r\n}\n\n\npub fn fnc_read<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let buffer;\n    if argc < 1 {\n        return None;\n    }\n    if let Some(proc) = lil.callback.get(2) {\n        let proc_wrap = |lil: &LilStruct<T>, name: &str| -> String {\n            let args = vec![LilValue { l: name.len(), d: Some(T::from(name.to_string())) }];\n            let result = proc(lil, \"read\", &args);\n            if let Some(s) = result.d {\n                return s.as_ref().to_string();\n            }\n            String::new()\n        };\n        buffer = proc_wrap(lil, argv[0].d.as_ref()?.as_ref());\n    } else {\n        let filename = argv[0].d.as_ref()?.as_ref();\n        let mut file = match std::fs::File::open(filename) {\n            Ok(f) => f,\n            Err(_) => return None,\n        };\n        let size = match file.metadata() {\n            Ok(m) => m.len() as usize,\n            Err(_) => return None,\n        };\n        let mut buf = vec![0; size];\n        if let Err(_) = file.read_exact(&mut buf) {\n            return None;\n        }\n        buffer = String::from_utf8_lossy(&buf).into_owned();\n    }\n    Some(LilValue { l: buffer.len(), d: Some(T::from(buffer)) })\n}\n\n\npub fn fnc_while<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut r: Option<LilValue<T>> = None;\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if lil_to_string(&argv[0]) == \"not\" {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr(lil, &argv[base]);\n        if val.is_none() || lil.error != 0 { return None; }\n        let mut v = lil_to_boolean(&val.unwrap());\n        if not { v = !v; }\n        if !v {\n            break;\n        }\n        if r.is_some() {\n            r = None;\n        }\n        r = lil_parse_value(lil, &argv[base + 1], 0);\n    }\n    r\n}\n\n\npub fn fnc_set<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_get_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: &LilValue<T>, access: i32) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n\n    let mut i = 0;\n    let mut var: Option<Rc<RefCell<LilVar<T>>>> = None;\n    let mut access = 1;\n    if argc == 0 { return None; }\n    if argv[0].d.as_ref().map_or(false, |d| d.to_string() == \"global\") {\n        i = 1;\n        access = 0;\n    }\n    while i < argc {\n        if argc == i + 1 {\n            return lil_get_var_wrap(lil, &argv[i].d.as_ref()?.to_string()).map(|v| v.borrow().v.clone());\n        }\n        var = lil_set_var_wrap(lil, &argv[i].d.as_ref()?.to_string(), &argv[i + 1], access);\n        i += 2;\n    }\n    var.map(|v| v.borrow().v.clone())\n}\n\n\npub fn fnc_split<T: Clone + ToString + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList::<T> { items: Vec::new() };\n    let mut sep = \" \".to_string();\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    if argc > 1 {\n        sep = argv[1].d.as_ref().map(|x| x.to_string()).unwrap_or_else(|| \" \".to_string());\n        if sep.is_empty() { return argv[0].clone(); }\n    }\n    let mut val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n    let str = argv[0].d.as_ref().map(|x| x.to_string()).unwrap_or_default();\n    for c in str.chars() {\n        if sep.contains(c) {\n            list.items.push(Rc::new(RefCell::new(val)));\n            val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n        } else {\n            if let Some(s) = val.d.as_mut() {\n                *s = format!(\"{}{}\", s.to_string(), c).into();\n            }\n        }\n    }\n    list.items.push(Rc::new(RefCell::new(val)));\n    let result_str = list.items.iter().map(|x| x.borrow().d.as_ref().map(|x| x.to_string()).unwrap_or_default()).collect::<Vec<_>>().join(\" \");\n    LilValue { l: 0, d: Some(result_str.into()) }\n}\n\n\nfn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\n\npub fn lil_register<T: Clone>(lil: &mut LilStruct<T>, name: &str, proc: LilFuncProc<T>) {\n    let func = Rc::new(RefCell::new(LilFunc {\n        name: name.to_string(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: Some(proc),\n    }));\n    lil.cmd.push(func.clone());\n    lil.cmds += 1;\n}\n\n\npub fn fnc_write<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut msg = String::new();\n    for i in 0..argc {\n        if i != 0 {\n            msg.push(' ');\n        }\n        msg.push_str(&argv[i].d.as_ref().unwrap().to_string());\n    }\n    println!(\"{}\", msg);\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_if<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if argv[0].d.as_ref().map_or(false, |s| s.to_string() == \"not\") {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    let val = lil_eval_expr(lil, &argv[base]);\n    if val.is_none() || lil.error != 0 { return None; }\n    let v = lil_to_boolean(&val.unwrap());\n    let v = if not { !v } else { v };\n    if v {\n        lil_parse_value(lil, &argv[base + 1], 0)\n    } else if argc > base + 2 {\n        lil_parse_value(lil, &argv[base + 2], 0)\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_length<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(value: i64) -> LilValue<T> {\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n    let mut total = 0;\n    for (i, arg) in argv.iter().enumerate() {\n        if i != 0 {\n            total += 1;\n        }\n        let s = lil_to_string_wrap(arg);\n        total += s.len();\n    }\n    lil_alloc_integer_wrap(total as i64)\n}\n\n\npub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n\npub fn fnc_strpos<T: Clone + From<i32> + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let hay;\n    let str;\n    let mut min = 0;\n    if argc < 2 {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    hay = argv[0].d.as_ref().unwrap().to_string();\n    if argc > 2 {\n        min = argv[2].d.as_ref().unwrap().to_string().parse::<usize>().unwrap();\n        if min >= hay.len() {\n            return LilValue { l: 0, d: Some(T::from(-1)) };\n        }\n    }\n    str = hay[min..].find(&argv[1].d.as_ref().unwrap().to_string());\n    if str.is_none() {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    LilValue { l: 0, d: Some(T::from(str.unwrap() as i32)) }\n}\n\n\npub fn fnc_strcmp<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    let s1 = lil_to_string_wrap(&argv[0]);\n    let s2 = lil_to_string_wrap(&argv[1]);\n    LilValue { l: s1.cmp(&s2) as usize, d: None }\n}\n\n\npub fn fnc_repstr<T: Clone + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 1 {\n        return LilValue { l: 0, d: None };\n    }\n    if argc < 3 {\n        return argv[0].clone();\n    }\n\n    let from = lil_to_string(&argv[1]);\n    let to = lil_to_string(&argv[2]);\n    if from.is_empty() {\n        return LilValue { l: 0, d: None };\n    }\n\n    let mut src = lil_to_string(&argv[0]);\n    let from_len = from.len();\n    let to_len = to.len();\n\n    while let Some(idx) = src.find(&from) {\n        let mut new_src = String::with_capacity(src.len() - from_len + to_len);\n        new_src.push_str(&src[..idx]);\n        new_src.push_str(&to);\n        new_src.push_str(&src[idx + from_len..]);\n        src = new_src;\n    }\n\n    lil_alloc_string(&src)\n}\n\n\npub fn fnc_rename<T: Clone + Debug + From<String>>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let oldname = lil_to_string(&argv[0]);\n    let newname = lil_to_string(&argv[1]);\n    if argc < 2 {\n        return None;\n    }\n\n    let func = find_cmd(lil, &oldname);\n    if func.is_none() {\n        let msg = format!(\"unknown function '{}'\", oldname);\n        lil_set_error_at(lil, lil.head, &msg);\n        return None;\n    }\n    let func = func.unwrap();\n\n    let r = lil_alloc_string(&func.borrow().name);\n    if !newname.is_empty() {\n        hm_put(&mut lil.cmdmap, &oldname, None);\n        hm_put(&mut lil.cmdmap, &newname, Some(func.clone()));\n        func.borrow_mut().name = newname.clone();\n    } else {\n        del_func(lil, &func);\n    }\n\n    Some(LilValue { l: r.l, d: r.d.map(|s| s.into()) })\n}\n\n\npub fn fnc_dec<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        String::new()\n    }\n    \n    fn lil_to_double_wrap<T: Clone>(val: &LilValue<T>) -> f64 {\n        0.0\n    }\n    \n    fn real_inc_wrap<T: Clone>(lil: &LilStruct<T>, s: String, d: f64) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    real_inc_wrap(lil, lil_to_string_wrap(&argv[0]), -(if argc > 1 { lil_to_double_wrap(&argv[1]) } else { 1.0 }))\n}\n\n\npub fn fnc_quote<T: Clone + AsRef<str> + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    let mut r = LilValue { l: 0, d: None };\n    for i in 0..argc {\n        if i != 0 {\n            let lil_append_char_wrap = |r: &mut LilValue<T>, c: char| {\n                if let Some(ref mut data) = r.d {\n                    let mut s = String::new();\n                    s.push_str(data.as_ref());\n                    s.push(c);\n                    r.d = Some(T::from(s));\n                }\n            };\n            lil_append_char_wrap(&mut r, ' ');\n        }\n        let lil_append_val_wrap = |r: &mut LilValue<T>, val: &LilValue<T>| {\n            if let (Some(ref mut dst_data), Some(ref src_data)) = (&mut r.d, &val.d) {\n                let mut s = String::new();\n                s.push_str(dst_data.as_ref());\n                s.push_str(src_data.as_ref());\n                r.d = Some(T::from(s));\n            }\n        };\n        lil_append_val_wrap(&mut r, &argv[i]);\n    }\n    Some(r)\n}\n\n\n\npub fn test_lil_creation_and_destruction() {\n    println!(\"Testing LIL creation and destruction...\");\n    \n    let lil = lil_new();\n    assert!(lil.is_some());\n    \n    lil_free(lil);\n    println!(\"✓ LIL creation and destruction test passed\");\n}\n\npub fn lil_new<T: Clone>() -> Option<Rc<RefCell<LilStruct<T>>>> {\n    let mut lil = Rc::new(RefCell::new(LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: strclone(\"set \").unwrap(),\n        env: lil_alloc_env(None),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: alloc_value(None).unwrap(),\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: None,\n        embed: String::new(),\n        embedlen: 0,\n    }));\n    \n    lil.borrow_mut().rootenv = lil.borrow().env.clone();\n    hm_init(&mut lil.borrow_mut().cmdmap);\n    register_stdcmds(lil.clone());\n    Some(lil)\n}\n\npub fn register_stdcmds<T: Clone>(lil: Rc<RefCell<LilStruct<T>>>) {\n    lil_register(&mut lil.borrow_mut(), \"reflect\", fnc_reflect);\n    lil_register(&mut lil.borrow_mut(), \"func\", fnc_func);\n    lil_register(&mut lil.borrow_mut(), \"rename\", fnc_rename);\n    lil_register(&mut lil.borrow_mut(), \"unusedname\", fnc_unusedname);\n    lil_register(&mut lil.borrow_mut(), \"quote\", fnc_quote);\n    lil_register(&mut lil.borrow_mut(), \"set\", fnc_set);\n    lil_register(&mut lil.borrow_mut(), \"local\", fnc_local);\n    lil_register(&mut lil.borrow_mut(), \"write\", fnc_write);\n    lil_register(&mut lil.borrow_mut(), \"print\", fnc_print);\n    lil_register(&mut lil.borrow_mut(), \"eval\", fnc_eval);\n    lil_register(&mut lil.borrow_mut(), \"topeval\", fnc_topeval);\n    lil_register(&mut lil.borrow_mut(), \"upeval\", fnc_upeval);\n    lil_register(&mut lil.borrow_mut(), \"downeval\", fnc_downeval);\n    lil_register(&mut lil.borrow_mut(), \"enveval\", fnc_enveval);\n    lil_register(&mut lil.borrow_mut(), \"jaileval\", fnc_jaileval);\n    lil_register(&mut lil.borrow_mut(), \"count\", fnc_count);\n    lil_register(&mut lil.borrow_mut(), \"index\", fnc_index);\n    lil_register(&mut lil.borrow_mut(), \"indexof\", fnc_indexof);\n    lil_register(&mut lil.borrow_mut(), \"filter\", fnc_filter);\n    lil_register(&mut lil.borrow_mut(), \"list\", fnc_list);\n    lil_register(&mut lil.borrow_mut(), \"append\", fnc_append);\n    lil_register(&mut lil.borrow_mut(), \"slice\", fnc_slice);\n    lil_register(&mut lil.borrow_mut(), \"subst\", fnc_subst);\n    lil_register(&mut lil.borrow_mut(), \"concat\", fnc_concat);\n    lil_register(&mut lil.borrow_mut(), \"foreach\", fnc_foreach);\n    lil_register(&mut lil.borrow_mut(), \"return\", fnc_return);\n    lil_register(&mut lil.borrow_mut(), \"result\", fnc_result);\n    lil_register(&mut lil.borrow_mut(), \"expr\", fnc_expr);\n    lil_register(&mut lil.borrow_mut(), \"inc\", fnc_inc);\n    lil_register(&mut lil.borrow_mut(), \"dec\", fnc_dec);\n    lil_register(&mut lil.borrow_mut(), \"read\", fnc_read);\n    lil_register(&mut lil.borrow_mut(), \"store\", fnc_store);\n    lil_register(&mut lil.borrow_mut(), \"if\", fnc_if);\n    lil_register(&mut lil.borrow_mut(), \"while\", fnc_while);\n    lil_register(&mut lil.borrow_mut(), \"for\", fnc_for);\n    lil_register(&mut lil.borrow_mut(), \"char\", fnc_char);\n    lil_register(&mut lil.borrow_mut(), \"charat\", fnc_charat);\n    lil_register(&mut lil.borrow_mut(), \"codeat\", fnc_codeat);\n    lil_register(&mut lil.borrow_mut(), \"substr\", fnc_substr);\n    lil_register(&mut lil.borrow_mut(), \"strpos\", fnc_strpos);\n    lil_register(&mut lil.borrow_mut(), \"length\", fnc_length);\n    lil_register(&mut lil.borrow_mut(), \"trim\", fnc_trim);\n    lil_register(&mut lil.borrow_mut(), \"ltrim\", fnc_ltrim);\n    lil_register(&mut lil.borrow_mut(), \"rtrim\", fnc_rtrim);\n    lil_register(&mut lil.borrow_mut(), \"strcmp\", fnc_strcmp);\n    lil_register(&mut lil.borrow_mut(), \"streq\", fnc_streq);\n    lil_register(&mut lil.borrow_mut(), \"repstr\", fnc_repstr);\n    lil_register(&mut lil.borrow_mut(), \"split\", fnc_split);\n    lil_register(&mut lil.borrow_mut(), \"try\", fnc_try);\n    lil_register(&mut lil.borrow_mut(), \"error\", fnc_error);\n    lil_register(&mut lil.borrow_mut(), \"exit\", fnc_exit);\n    lil_register(&mut lil.borrow_mut(), \"source\", fnc_source);\n    lil_register(&mut lil.borrow_mut(), \"lmap\", fnc_lmap);\n    lil_register(&mut lil.borrow_mut(), \"rand\", fnc_rand);\n    lil_register(&mut lil.borrow_mut(), \"catcher\", fnc_catcher);\n    lil_register(&mut lil.borrow_mut(), \"watch\", fnc_watch);\n    lil.borrow_mut().syscmds = lil.borrow().cmds;\n}\n\npub fn fnc_local<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    for i in 0..argc {\n        let varname = argv[i].d.as_ref().unwrap().to_string();\n        if find_cmd(lil, &varname).is_none() {\n            lil_set_var(lil, &varname, lil.empty.clone(), 2);\n        }\n    }\n    None\n}\n\npub fn fnc_source<T: Clone + From<String>>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    \n    let filename = argv[0].d.as_ref().unwrap().to_string();\n    let mut buffer = String::new();\n    \n    if lil.callback[4] != |_, _, _| LilValue { l: 0, d: None } {\n        let proc = lil.callback[4];\n        buffer = proc(lil, &filename, &[]).d.unwrap();\n    } else if lil.callback[2] != |_, _, _| LilValue { l: 0, d: None } {\n        let proc = lil.callback[2];\n        buffer = proc(lil, &filename, &[]).d.unwrap();\n    } else {\n        let mut file = std::fs::File::open(&filename).ok()?;\n        file.read_to_string(&mut buffer).ok()?;\n    }\n    \n    Some(lil_parse(lil, &buffer, 0, 0))\n}\n\npub fn fnc_enveval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    \n    let codeindex = if argc == 1 { 0 } else if argc >= 2 { \n        if argc > 2 { 2 } else { 1 }\n    } else { 0 };\n    \n    let invars = if argc >= 2 { Some(lil_subst_to_list(lil, &argv[0])) } else { None };\n    let outvars = if argc > 2 { Some(lil_subst_to_list(lil, &argv[1])) } else { None };\n    \n    let mut varvalues = Vec::new();\n    if let Some(ref invars) = invars {\n        for i in 0..invars.items.len() {\n            let var = lil_get_var(lil, &invars.items[i].borrow().d.as_ref().unwrap().to_string());\n            varvalues.push(var.clone());\n        }\n    }\n    \n    lil_push_env(lil);\n    \n    if let Some(ref invars) = invars {\n        for i in 0..invars.items.len() {\n            lil_set_var(lil, &invars.items[i].borrow().d.as_ref().unwrap().to_string(), varvalues[i].clone(), 2);\n            lil_free_value(Some(Rc::new(RefCell::new(varvalues[i].clone()))));\n        }\n    }\n    \n    let r = lil_parse_value(lil, &argv[codeindex], 0);\n    \n    if invars.is_some() || outvars.is_some() {\n        if let Some(ref outvars) = outvars {\n            varvalues.clear();\n            for i in 0..outvars.items.len() {\n                let var = lil_get_var(lil, &outvars.items[i].borrow().d.as_ref().unwrap().to_string());\n                varvalues.push(var.clone());\n            }\n        } else if let Some(ref invars) = invars {\n            varvalues.clear();\n            for i in 0..invars.items.len() {\n                let var = lil_get_var(lil, &invars.items[i].borrow().d.as_ref().unwrap().to_string());\n                varvalues.push(var.clone());\n            }\n        }\n    }\n    \n    lil_pop_env(lil);\n    \n    if let Some(invars) = invars {\n        if let Some(outvars) = outvars {\n            for i in 0..outvars.items.len() {\n                lil_set_var(lil, &outvars.items[i].borrow().d.as_ref().unwrap().to_string(), varvalues[i].clone(), 1);\n                lil_free_value(Some(Rc::new(RefCell::new(varvalues[i].clone()))));\n            }\n        } else {\n            for i in 0..invars.items.len() {\n                lil_set_var(lil, &invars.items[i].borrow().d.as_ref().unwrap().to_string(), varvalues[i].clone(), 1);\n                lil_free_value(Some(Rc::new(RefCell::new(varvalues[i].clone()))));\n            }\n        }\n        lil_free_list(invars);\n        if let Some(outvars) = outvars {\n            lil_free_list(outvars);\n        }\n    }\n    \n    r\n}\n\npub fn fnc_ltrim<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let s = argv[0].d.as_ref().unwrap().to_string();\n    let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { argv[1].d.as_ref().unwrap().to_string().as_str() };\n    Some(LilValue { l: s.trim_start_matches(chars).len(), d: Some(T::from(s.trim_start_matches(chars).to_string())) })\n}\n\npub fn fnc_trim<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let s = argv[0].d.as_ref().unwrap().to_string();\n    let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { argv[1].d.as_ref().unwrap().to_string().as_str() };\n    Some(LilValue { l: s.trim_matches(chars).len(), d: Some(T::from(s.trim_matches(chars).to_string())) })\n}\n\nfn main(){}\n //编译报错信息：error: unknown character escape: `f`\n    --> ../../Output/crown/tmp/test-lil_test_lil_creation_and_destruction/temp.rs:1945:34\n     |\n1945 |     let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { argv[1].d.as_ref().unwrap().to_string().as_str() };\n     |                                  ^ unknown character escape\n     |\n     = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "test_exit_callback": "//同时处理的函数过多，无法处理 :13",
        "test_readline_function": "//同时处理的函数过多，无法处理 :13",
        "test_list_operations": "pub static mut test_running: i32 = 1;\npub static mut test_exit_code: i32 = 0;\n\npub trait ToInteger {\n    fn to_integer(&self) -> i32;\n}\n\nimpl<T: ToInteger> ToInteger for RefCell<T> {\n    fn to_integer(&self) -> i32 {\n        self.borrow().to_integer()\n    }\n}\n\nimpl<T: Clone + ToString> ToInteger for LilValue<T> {\n    fn to_integer(&self) -> i32 {\n        if let Some(ref data) = self.d {\n            if let Ok(num) = data.to_string().parse::<i32>() {\n                return num;\n            }\n        }\n        0\n    }\n}\nuse std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn fnc_return<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    lil.env.borrow_mut().breakrun = true;\n    lil.env.borrow_mut().retval = if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() };\n    lil.env.borrow_mut().retval_set = true;\n    if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() }\n}\n\n\npub fn fnc_print<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_write_wrap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) {\n        // 空实现\n    }\n    fn lil_write_wrap<T: Clone>(lil: &LilStruct<T>, s: &str) {\n        // 空实现\n    }\n    fnc_write_wrap(lil, argc, argv);\n    lil_write_wrap(lil, \"\\n\");\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_error<T: Clone + std::fmt::Display>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let err_msg = if argc > 0 {\n        match &argv[0].d {\n            Some(d) => d.to_string(),\n            None => String::new(),\n        }\n    } else {\n        String::new()\n    };\n    lil.error = 1;\n    lil.err_msg = err_msg;\n    LilValue { l: 0, d: None }\n}\n\n\nfn lil_alloc_string(s: &str) -> LilValue<String> {\n    LilValue { l: 0, d: None }\n}\n\n\npub fn lil_list_get<T: Clone>(list: Rc<RefCell<LilList<T>>>, index: usize) -> Option<Rc<RefCell<LilValue<T>>>> {\n    let list_ref = list.borrow();\n    if index >= list_ref.items.len() {\n        None\n    } else {\n        Some(list_ref.items[index].clone())\n    }\n}\n\n\npub fn fnc_concat<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut r = LilValue { l: 0, d: Some(String::new().into()) };\n    if argc < 1 { return r; }\n    for i in 0..argc {\n        let list = argv[i].clone();\n        let tmp = list;\n        lil_append_val_wrap(&mut r, tmp);\n    }\n    r\n}\n\n\nfn lil_append_val_wrap<T: Clone>(dst: &mut LilValue<T>, src: LilValue<T>) {\n    if let Some(d) = &mut dst.d {\n        if let Some(s) = src.d {\n            *d = s;\n        }\n    }\n}\n\n\npub fn fnc_subst<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    fn lil_subst_to_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        val.clone()\n    }\n    Some(lil_subst_to_value_wrap(lil, &argv[0]))\n}\n\n\npub fn fnc_eval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(data: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d: data }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, ch: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, other: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_parse_value_wrap(lil, &argv[0], 0);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_parse_value_wrap(lil, &val, 0);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\nfn hm_put<T>(map: &mut HashMap<T>, key: &str, value: Option<T>) {\n}\n\n\npub fn fnc_try<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc < 1 {\n        return None;\n    }\n    if lil.error != 0 {\n        return None;\n    }\n    let mut r = lil_parse_value_wrap(lil, &argv[0], 0);\n    if lil.error != 0 {\n        lil.error = 0;\n        lil_free_value_wrap(r.clone());\n        if argc > 1 {\n            r = lil_parse_value_wrap(lil, &argv[1], 0);\n        } else {\n            r = LilValue { l: 0, d: None };\n        }\n    }\n    Some(r)\n}\n\n\npub fn fnc_charat<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer<T: Clone + Debug>(val: &LilValue<T>) -> i64 {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d).parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    let str = lil_to_string(&argv[0]);\n    let index = lil_to_integer(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    let chstr = &str[index..=index];\n    lil_alloc_string(chstr)\n}\n\n\npub fn fnc_indexof<T: Clone + PartialEq + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 {\n        return None;\n    }\n\n    fn lil_subst_to_list_wrap<T: Clone>(_: &LilStruct<T>, _: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_to_string_wrap<T: Clone + Debug>(_: &Rc<RefCell<LilValue<T>>>) -> String {\n        String::new()\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(index: i32) -> LilValue<T> {\n        LilValue { l: index as usize, d: None }\n    }\n    fn lil_free_list_wrap<T: Clone>(_: LilList<T>) {}\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut result = None;\n\n    for (index, item) in list.items.iter().enumerate() {\n        let item_str = lil_to_string_wrap(item);\n        let arg_str = lil_to_string_wrap(&Rc::new(RefCell::new(argv[1].clone())));\n        if item_str == arg_str {\n            result = Some(lil_alloc_integer_wrap(index as i32));\n            break;\n        }\n    }\n\n    lil_free_list_wrap(list);\n    result\n}\n\n\npub fn lil_alloc_list<T: Clone>() -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n\npub fn fnc_expr<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_eval_expr_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(d: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, c: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_eval_expr_wrap(lil, &argv[0]);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_eval_expr_wrap(lil, &val);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_append<T: Clone + Debug + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let mut base = 1;\n    let mut access = 1;\n    let varname = argv[0].d.as_ref().unwrap().to_string();\n    let mut varname = if varname == \"global\" {\n        if argc < 3 { return LilValue { l: 0, d: None }; }\n        base = 2;\n        access = 0;\n        argv[1].d.as_ref().unwrap().to_string()\n    } else {\n        varname\n    };\n    let mut list = lil_subst_to_list(lil, lil_get_var(lil, &varname));\n    for i in base..argc {\n        lil_list_append(&mut list, argv[i].clone());\n    }\n    let r = lil_list_to_value(&list, 1);\n    lil_free_list(list);\n    lil_set_var(lil, &varname, r.clone(), access);\n    r\n}\n\n\npub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\n\nfn lil_to_string<T: Clone>(value: &LilValue<T>) -> String {\n    String::new()\n}\n\n\npub fn fnc_filter<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_alloc_list_wrap<T: Clone>() -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _scope: i32) {}\n    fn lil_eval_expr_wrap<T: Clone>(_lil: &mut LilStruct<T>, _expr: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(_val: &LilValue<T>) -> bool {\n        false\n    }\n    fn lil_list_append_wrap<T: Clone>(_list: &mut LilList<T>, _val: Rc<RefCell<LilValue<T>>>) {}\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _deep: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut varname = \"x\".to_string();\n    let mut base = 0;\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    if argc > 2 {\n        base = 1;\n        varname = argv[0].d.as_ref().unwrap().to_string();\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[base]);\n    let mut filtered = lil_alloc_list_wrap();\n\n    for i in 0..list.items.len() {\n        if lil.env.borrow().breakrun { break; }\n        lil_set_var_wrap(lil, &varname, list.items[i].clone(), 3);\n        let r = lil_eval_expr_wrap(lil, &argv[base + 1]);\n        if lil_to_boolean_wrap(&r) {\n            lil_list_append_wrap(&mut filtered, list.items[i].clone());\n        }\n    }\n\n    let r = lil_list_to_value_wrap(&filtered, 1);\n    r\n}\n\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\n\npub fn fnc_codeat<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i32 {\n        match &val.d {\n            Some(v) => v.to_string().parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_integer_wrap<T: Clone>(val: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let index: usize;\n    let str: String;\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    str = lil_to_string_wrap(&argv[0]);\n    index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    lil_alloc_integer_wrap(str.chars().nth(index).unwrap() as i32)\n}\n\n\npub fn lil_free<T: Clone>(lil: Option<Rc<RefCell<LilStruct<T>>>>) {\n    if lil.is_none() {\n        return;\n    }\n    let mut lil = lil.unwrap();\n    let mut lil = lil.borrow_mut();\n    lil.err_msg.clear();\n    lil_free_value(Some(Rc::new(RefCell::new(lil.empty.clone()))));\n    \n    let mut current_env = Some(lil.env.clone());\n    while let Some(env) = current_env {\n        let next = env.borrow().parent.clone();\n        lil_free_env(Some(env));\n        current_env = next;\n    }\n    \n    for i in 0..lil.cmds {\n        let cmd = lil.cmd[i].borrow();\n        if !cmd.argnames.items.is_empty() {\n            lil_free_list(cmd.argnames.clone());\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd.code.clone()))));\n    }\n    hm_destroy(&mut lil.cmdmap);\n    lil.cmd.clear();\n    lil.dollarprefix.clear();\n    lil.catcher.clear();\n}\n\n\nfn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    None\n}\n\n\npub fn fnc_catcher<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        LilValue {\n            l: lil.catcher.len(),\n            d: Some(T::from(lil.catcher.clone())),\n        }\n    } else {\n        let catcher = argv[0].d.as_ref().unwrap().to_string();\n        lil.catcher = if !catcher.is_empty() { catcher } else { String::new() };\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n}\n\n\npub fn fnc_upeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let fnc_eval_wrap = |lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]| -> LilValue<T> {\n        lil.empty.clone()\n    };\n    \n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    let r;\n    if Rc::ptr_eq(&lil.rootenv, &thisenv) {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.env = match thisenv.borrow().parent.as_ref() {\n        Some(parent) => Rc::clone(parent),\n        None => Rc::clone(&thisenv),\n    };\n    lil.downenv = Rc::clone(&thisenv);\n    r = fnc_eval_wrap(lil, argc, argv);\n    lil.env = thisenv;\n    lil.downenv = thisdownenv;\n    r\n}\n\n\npub fn lil_list_size<T: Clone>(list: Rc<RefCell<LilList<T>>>) -> usize {\n    list.borrow().items.len()\n}\n\n\nfn lil_list_append<T: Clone>(_list: &mut LilList<T>, _val: LilValue<T>) {}\n\n\npub fn lil_free_env<T: Clone>(env: Option<Rc<RefCell<LilEnv<T>>>>) {\n    if env.is_none() {\n        return;\n    }\n    let env = env.unwrap();\n    let mut env = env.borrow_mut();\n    lil_free_value(Some(Rc::new(RefCell::new(env.retval.clone()))));\n    hm_destroy(&mut env.varmap);\n    for i in 0..env.vars {\n        let var = env.var[i].borrow_mut();\n        lil_free_value(Some(Rc::new(RefCell::new(var.v.clone()))));\n    }\n    env.var.clear();\n    env.vars = 0;\n}\n\n\npub fn fnc_substr<T: Clone + Debug + FromStr + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let str = match &argv[0].d {\n        Some(s) => s.to_string(),\n        None => return LilValue { l: 0, d: None },\n    };\n    if str.is_empty() { return LilValue { l: 0, d: None }; }\n    let slen = str.len();\n    let start = match argv[1].d.as_ref() {\n        Some(s) => s.to_string().parse::<usize>().unwrap_or(0),\n        None => 0,\n    };\n    let end = if argc > 2 {\n        match argv[2].d.as_ref() {\n            Some(s) => s.to_string().parse::<usize>().unwrap_or(slen),\n            None => slen,\n        }\n    } else { slen };\n    let end = if end > slen { slen } else { end };\n    if start >= end { return LilValue { l: 0, d: None }; }\n    let result = str.chars().skip(start).take(end - start).collect::<String>();\n    LilValue { l: result.len(), d: Some(result.parse().unwrap_or_else(|_| panic!(\"Failed to parse string\"))) }\n}\n\n\npub fn fnc_rand<T: Clone + From<f64>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    LilValue {\n        l: 8,\n        d: Some(0.5f64.into())\n    }\n}\n\n\npub fn fnc_store<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        if let Some(ref d) = val.d {\n            format!(\"{:?}\", d)\n        } else {\n            String::new()\n        }\n    }\n\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    if let Some(proc) = lil.callback.get(3).copied() {\n        let name = lil_to_string_wrap(&argv[0]);\n        let data = lil_to_string_wrap(&argv[1]);\n        proc(lil, &name, &[argv[1].clone()]);\n    } else {\n        let filename = lil_to_string_wrap(&argv[0]);\n        let buffer = lil_to_string_wrap(&argv[1]);\n        if let Ok(mut file) = std::fs::File::create(&filename) {\n            let _ = std::io::Write::write_all(&mut file, buffer.as_bytes());\n        }\n    }\n    argv[1].clone()\n}\n\n\npub fn fnc_inc<T: Clone + From<u32>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let arg0 = if let Some(d) = &argv[0].d { d.clone() } else { return None; };\n    let arg1 = if argc > 1 { \n        if let Some(d) = &argv[1].d { d.clone() } else { return None; }\n    } else { T::from(1) };\n    Some(LilValue { l: 0, d: Some(arg0) })\n}\n\n\npub fn fnc_exit<T: Clone>(lil: Rc<RefCell<LilStruct<T>>>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Option<Rc<RefCell<LilValue<T>>>> {\n    let lil_ref = lil.borrow();\n    if let Some(proc) = lil_ref.callback.get(0) {\n        let arg = if argc > 0 { Some(argv[0].clone()) } else { None };\n        let lil_wrap = &*lil_ref;\n        proc(lil_wrap, \"\", &[]);\n    }\n    None\n}\n\n\npub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\n\npub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\n\npub fn fnc_for<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_eval_expr_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(val: &LilValue<T>) -> bool {\n        false\n    }\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 4 { return LilValue { l: 0, d: None }; }\n    let _ = lil_parse_value_wrap(lil, &argv[0], 0);\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr_wrap(lil, &argv[1]);\n        if val.l == 0 || lil.error != 0 { return LilValue { l: 0, d: None }; }\n        if !lil_to_boolean_wrap(&val) {\n            break;\n        }\n        r = lil_parse_value_wrap(lil, &argv[3], 0);\n        let _ = lil_parse_value_wrap(lil, &argv[2], 0);\n    }\n    r\n}\n\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\n\npub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\n\npub fn fnc_slice<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_integer_wrap<T: Clone>(val: &LilValue<T>) -> i64 {\n        0\n    }\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(list: &LilList<T>, _flag: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    \n    let mut from = lil_to_integer_wrap(&argv[1]);\n    if from < 0 { from = 0; }\n    \n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut to = if argc > 2 { lil_to_integer_wrap(&argv[2]) } else { list.items.len() as i64 };\n    if to > list.items.len() as i64 { to = list.items.len() as i64; }\n    if to < from { to = from; }\n    \n    let mut slice = LilList { items: Vec::new() };\n    for i in from as usize..to as usize {\n        slice.items.push(list.items[i].clone());\n    }\n    \n    let r = lil_list_to_value_wrap(&slice, 1);\n    r\n}\n\n\npub fn fnc_func<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Rc<RefCell<LilValue<T>>> {\n    let name: Rc<RefCell<LilValue<T>>>;\n    let cmd: Rc<RefCell<LilFunc<T>>>;\n    let fargs: LilList<T>;\n    \n    fn lil_clone_value_wrap<T: Clone>(value: &Rc<RefCell<LilValue<T>>>) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new((*value.borrow()).clone()))\n    }\n    \n    fn lil_to_string_wrap<T: Clone + ToString>(value: &Rc<RefCell<LilValue<T>>>) -> String {\n        value.borrow().d.as_ref().map_or(String::new(), |v| v.to_string())\n    }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, value: &Rc<RefCell<LilValue<T>>>) -> LilList<T> {\n        LilList { items: vec![Rc::clone(value)] }\n    }\n    \n    fn add_func_wrap<T: Clone>(_lil: &LilStruct<T>, name: &str) -> Rc<RefCell<LilFunc<T>>> {\n        Rc::new(RefCell::new(LilFunc {\n            name: name.to_string(),\n            code: LilValue { l: 0, d: None },\n            argnames: LilList { items: vec![] },\n            proc: None,\n        }))\n    }\n    \n    fn lil_unused_name_wrap<T: Clone>(_lil: &LilStruct<T>, prefix: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: None }))\n    }\n    \n    fn lil_alloc_string_wrap<T: Clone + From<String>>(s: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: Some(s.to_string().into()) }))\n    }\n\n    if argc < 1 {\n        return Rc::new(RefCell::new(LilValue { l: 0, d: None }));\n    }\n    if argc >= 3 {\n        name = lil_clone_value_wrap(&argv[0]);\n        fargs = lil_subst_to_list_wrap(lil, &argv[1]);\n        cmd = add_func_wrap(lil, &lil_to_string_wrap(&argv[0]));\n        cmd.borrow_mut().argnames = fargs;\n        cmd.borrow_mut().code = (*argv[2].borrow()).clone();\n    } else {\n        name = lil_unused_name_wrap(lil, \"anonymous-function\");\n        if argc < 2 {\n            let tmp = lil_alloc_string_wrap(\"args\");\n            fargs = lil_subst_to_list_wrap(lil, &tmp);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[0].borrow()).clone();\n        } else {\n            fargs = lil_subst_to_list_wrap(lil, &argv[0]);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[1].borrow()).clone();\n        }\n    }\n    name\n}\n\n\npub fn lil_to_integer<T: Clone>(val: &LilValue<T>) -> i64 {\n    lil_to_string(val).parse::<i64>().unwrap_or(0)\n}\n\n\npub fn fnc_lmap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        unimplemented!()\n    }\n    \n    fn lil_list_get_wrap<T: Clone>(list: &Rc<RefCell<LilList<T>>>, index: usize) -> LilValue<T> {\n        unimplemented!()\n    }\n    \n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: LilValue<T>, flag: i32) {\n        unimplemented!()\n    }\n    \n    fn lil_free_list_wrap<T: Clone>(list: Rc<RefCell<LilList<T>>>) {\n        unimplemented!()\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    for i in 1..argc {\n        let var_name = lil_to_string_wrap(&argv[i]);\n        let value = lil_list_get_wrap(&list, i - 1);\n        lil_set_var_wrap(lil, &var_name, value, 1);\n    }\n    lil_free_list_wrap(list);\n    None\n}\n\n\npub fn fnc_unusedname(lil: &LilStruct<String>, argc: usize, argv: &[LilValue<String>]) -> LilValue<String> {\n    fn lil_to_string_wrap(val: &LilValue<String>) -> String {\n        match &val.d {\n            Some(v) => v.clone(),\n            None => String::new(),\n        }\n    }\n    fn lil_unused_name_wrap(lil: &LilStruct<String>, name: &str) -> LilValue<String> {\n        LilValue {\n            l: name.len(),\n            d: Some(name.to_string()),\n        }\n    }\n    let arg = if argc > 0 { lil_to_string_wrap(&argv[0]) } else { \"unusedname\".to_string() };\n    lil_unused_name_wrap(lil, &arg)\n}\n\n\npub fn fnc_streq<T: Clone + FromStr + PartialEq + std::fmt::Display + From<bool>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return lil.empty.clone(); }\n    let s1 = argv[0].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    let s2 = argv[1].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    LilValue { l: 1, d: Some((s1 == s2).into()) }\n}\n\n\npub fn fnc_reflect<T: Clone + Debug + From<String> + From<&'static str> + From<i64> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let type_str = lil_to_string(&argv[0]);\n    match type_str.as_str() {\n        \"version\" => Some(LilValue { l: 3, d: Some(\"0.1\".into()) }),\n        \"args\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().argnames.items.is_empty() { return None; }\n            Some(func.unwrap().borrow().argnames.items[0].borrow().clone())\n        },\n        \"body\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().proc.is_some() { return None; }\n            Some(func.unwrap().borrow().code.clone())\n        },\n        \"func-count\" => Some(LilValue { l: 0, d: Some((lil.cmds as i64).into()) }),\n        \"funcs\" => {\n            let mut funcs = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.cmds {\n                funcs.items.push(Rc::new(RefCell::new(LilValue { l: lil.cmd[i].borrow().name.len(), d: Some(lil.cmd[i].borrow().name.clone().into()) })));\n            }\n            Some(LilValue { l: funcs.items.len(), d: None })\n        },\n        \"vars\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                for i in 0..e.borrow().vars {\n                    vars.items.push(Rc::new(RefCell::new(LilValue { l: e.borrow().var[i].borrow().n.len(), d: Some(e.borrow().var[i].borrow().n.clone().into()) })));\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"globals\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.rootenv.borrow().vars {\n                vars.items.push(Rc::new(RefCell::new(LilValue { l: lil.rootenv.borrow().var[i].borrow().n.len(), d: Some(lil.rootenv.borrow().var[i].borrow().n.clone().into()) })));\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"has-func\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            if lil.cmdmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                Some(LilValue { l: 1, d: Some(\"1\".into()) })\n            } else {\n                None\n            }\n        },\n        \"has-var\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                if e.borrow().varmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            None\n        },\n        \"has-global\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            for i in 0..lil.rootenv.borrow().vars {\n                if target == lil.rootenv.borrow().var[i].borrow().n { \n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n            }\n            None\n        },\n        \"error\" => lil.err_msg.is_empty().then(|| LilValue { l: lil.err_msg.len(), d: Some(lil.err_msg.clone().into()) }),\n        \"dollar-prefix\" => {\n            if argc == 1 { return Some(LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) }); }\n            let r = LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) };\n            lil.dollarprefix = lil_to_string(&argv[1]);\n            Some(r)\n        },\n        \"this\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(LilValue { l: lil.catcher.len(), d: Some(lil.catcher.clone().into()) }); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return Some(LilValue { l: lil.rootcode.len(), d: Some(lil.rootcode.clone().into()) }); }\n                if let Some(func) = &e.borrow().func { return Some(func.borrow().code.clone()); }\n            }\n            None\n        },\n        \"name\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(e.borrow().catcher_for.clone()); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return None; }\n                if let Some(func) = &e.borrow().func { return Some(LilValue { l: func.borrow().name.len(), d: Some(func.borrow().name.clone().into()) }); }\n            }\n            None\n        },\n        _ => None\n    }\n}\n\n\npub fn fnc_list<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList { items: Vec::new() };\n    for i in 0..argc {\n        list.items.push(Rc::new(RefCell::new(argv[i].clone())));\n    }\n    LilValue { l: list.items.len(), d: None }\n}\n\n\npub fn fnc_char<T: Clone + From<String> + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        return LilValue { l: 0, d: None };\n    }\n    let s = match &argv[0].d {\n        Some(val) => {\n            let mut buf = [0u8; 2];\n            buf[0] = format!(\"{:?}\", val).parse::<u8>().unwrap_or(0);\n            buf[1] = 0;\n            String::from_utf8_lossy(&buf).to_string()\n        },\n        None => String::new(),\n    };\n    LilValue { l: s.len(), d: Some(T::from(s)) }\n}\n\n\npub fn fnc_rtrim<T: Clone + Debug + FromStr>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn real_trim(s: String, pat: String, _left: i32, _right: i32) -> LilValue<String> {\n        let trimmed = s.trim_end_matches(&pat[..]);\n        LilValue {\n            l: trimmed.len(),\n            d: Some(trimmed.to_string()),\n        }\n    }\n\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let pat = if argc < 2 { \" \\u{000C}\\n\\r\\t\\u{000B}\".to_string() } else { lil_to_string(&argv[1]) };\n    let result = real_trim(s, pat, 0, 1);\n    LilValue { l: result.l, d: Some(result.d.unwrap().parse().ok().unwrap()) }\n}\n\n\npub fn fnc_result<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc > 0 {\n        lil.env.borrow_mut().retval = argv[0].clone();\n        lil.env.borrow_mut().retval_set = true;\n    }\n    if lil.env.borrow().retval_set {\n        Some(lil.env.borrow().retval.clone())\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_downeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    let upenv = Rc::clone(&lil.env);\n    let downenv = Rc::clone(&lil.downenv);\n    if downenv.borrow().parent.is_none() {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.downenv = Rc::new(RefCell::new(LilEnv {\n        parent: None,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    lil.env = Rc::clone(&downenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = downenv;\n    lil.env = upenv;\n    r\n}\n\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n\npub fn add_func<T: Clone + Debug>(lil: &mut LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    let cmd = find_cmd(lil, name);\n    if let Some(cmd) = cmd {\n        let mut cmd_ref = cmd.borrow_mut();\n        if cmd_ref.argnames.items.len() > 0 {\n            let argnames = cmd_ref.argnames.clone();\n            lil_free_list(argnames);\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd_ref.code.clone()))));\n        cmd_ref.argnames = LilList { items: Vec::new() };\n        cmd_ref.code = LilValue { l: 0, d: None };\n        cmd_ref.proc = None;\n        return Some(Rc::clone(&cmd));\n    }\n    let new_cmd = Rc::new(RefCell::new(LilFunc {\n        name: strclone(name).unwrap(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: None,\n    }));\n    lil.cmd.push(Rc::clone(&new_cmd));\n    lil.cmds += 1;\n    hm_put(&mut lil.cmdmap, name, Some(Rc::clone(&new_cmd)));\n    Some(new_cmd)\n}\n\n\npub fn hm_init<T>(hm: &mut HashMap<T>) {\n    hm.cell.clear();\n}\n\n\npub fn fnc_count<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    let mut buff = String::with_capacity(64);\n    if argc == 0 {\n        return LilValue { l: 1, d: Some(T::from(\"0\".to_string())) };\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    buff.push_str(&list.borrow().items.len().to_string());\n    LilValue { l: buff.len(), d: Some(T::from(buff)) }\n}\n\n\npub fn fnc_watch<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    let wcode = lil_to_string(&argv[argc - 1]);\n    for i in 0..(argc - 1) {\n        let vname = lil_to_string(&argv[i]);\n        if vname.is_empty() { continue; }\n        let mut v = lil_find_var(lil, lil.env.clone(), &vname);\n        if v.is_none() {\n            let empty_val = LilValue { l: 0, d: None };\n            lil_set_var(lil, &vname, empty_val, 2);\n            v = lil_find_var(lil, lil.env.clone(), &vname);\n        }\n        if let Some(var) = v {\n            var.borrow_mut().w = if !wcode.is_empty() { wcode.clone() } else { String::new() };\n        }\n    }\n    None\n}\n\n\npub fn fnc_jaileval<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n\n    fn lil_register_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _proc: LilFuncProc<T>) {}\n\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _depth: usize) -> Option<LilValue<T>> {\n        None\n    }\n\n    let mut base = 0;\n    if argc == 0 {\n        return None;\n    }\n    if lil_to_string_wrap(&argv[0]) == \"clean\" {\n        base = 1;\n        if argc == 1 {\n            return None;\n        }\n    }\n    let mut sublil = LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: String::new(),\n        env: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: LilValue { l: 0, d: None },\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: argv[0].d.as_ref().unwrap().clone(),\n        embed: String::new(),\n        embedlen: 0,\n    };\n    if base != 1 {\n        for i in lil.syscmds..lil.cmds {\n            let fnc = lil.cmd[i].clone();\n            if fnc.borrow().proc.is_none() {\n                continue;\n            }\n            lil_register_wrap(&mut sublil, &fnc.borrow().name, fnc.borrow().proc.unwrap());\n        }\n    }\n    let r = lil_parse_value_wrap(&mut sublil, &argv[base], 1);\n    r\n}\n\n\npub fn fnc_topeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    lil.env = Rc::clone(&lil.rootenv);\n    lil.downenv = Rc::clone(&thisenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = thisdownenv;\n    lil.env = thisenv;\n    r\n}\n\n\npub fn fnc_index<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: vec![Rc::new(RefCell::new(val.clone()))] }\n    }\n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i64 {\n        if let Some(d) = &val.d {\n            if let Ok(n) = i64::from_str(&d.to_string()) {\n                return n;\n            }\n        }\n        0\n    }\n    fn lil_free_list_wrap<T: Clone>(_list: LilList<T>) {}\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 2 { return r; }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index < list.items.len() {\n        r = list.items[index].borrow().clone();\n    }\n    lil_free_list_wrap(list);\n    r\n}\n\n\npub fn fnc_foreach<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _flags: i32) {}\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut rlist = LilList { items: Vec::new() };\n    let mut listidx = 0;\n    let mut codeidx = 1;\n    let mut varname = \"i\".to_string();\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    if argc >= 3 {\n        varname = argv[0].d.as_ref().unwrap().to_string();\n        listidx = 1;\n        codeidx = 2;\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[listidx]);\n    for i in 0..list.items.len() {\n        let item = list.items[i].clone();\n        lil_set_var_wrap(lil, &varname, item, 3);\n        let rv = lil_parse_value_wrap(lil, &argv[codeidx], 0);\n        if rv.l != 0 {\n            rlist.items.push(Rc::new(RefCell::new(rv)));\n        }\n        if lil.env.borrow().breakrun || lil.error != 0 { break; }\n    }\n    let r = lil_list_to_value_wrap(&rlist, 1);\n    r\n}\n\n\npub fn lil_alloc_integer<T: Clone + From<i64>>(i: i64) -> LilValue<T> {\n    LilValue { l: 0, d: Some(i.into()) }\n}\n\n\npub fn fnc_read<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let buffer;\n    if argc < 1 {\n        return None;\n    }\n    if let Some(proc) = lil.callback.get(2) {\n        let proc_wrap = |lil: &LilStruct<T>, name: &str| -> String {\n            let args = vec![LilValue { l: name.len(), d: Some(T::from(name.to_string())) }];\n            let result = proc(lil, \"read\", &args);\n            if let Some(s) = result.d {\n                return s.as_ref().to_string();\n            }\n            String::new()\n        };\n        buffer = proc_wrap(lil, argv[0].d.as_ref()?.as_ref());\n    } else {\n        let filename = argv[0].d.as_ref()?.as_ref();\n        let mut file = match std::fs::File::open(filename) {\n            Ok(f) => f,\n            Err(_) => return None,\n        };\n        let size = match file.metadata() {\n            Ok(m) => m.len() as usize,\n            Err(_) => return None,\n        };\n        let mut buf = vec![0; size];\n        if let Err(_) = file.read_exact(&mut buf) {\n            return None;\n        }\n        buffer = String::from_utf8_lossy(&buf).into_owned();\n    }\n    Some(LilValue { l: buffer.len(), d: Some(T::from(buffer)) })\n}\n\n\npub fn fnc_while<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut r: Option<LilValue<T>> = None;\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if lil_to_string(&argv[0]) == \"not\" {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr(lil, &argv[base]);\n        if val.is_none() || lil.error != 0 { return None; }\n        let mut v = lil_to_boolean(&val.unwrap());\n        if not { v = !v; }\n        if !v {\n            break;\n        }\n        if r.is_some() {\n            r = None;\n        }\n        r = lil_parse_value(lil, &argv[base + 1], 0);\n    }\n    r\n}\n\n\npub fn fnc_set<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_get_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: &LilValue<T>, access: i32) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n\n    let mut i = 0;\n    let mut var: Option<Rc<RefCell<LilVar<T>>>> = None;\n    let mut access = 1;\n    if argc == 0 { return None; }\n    if argv[0].d.as_ref().map_or(false, |d| d.to_string() == \"global\") {\n        i = 1;\n        access = 0;\n    }\n    while i < argc {\n        if argc == i + 1 {\n            return lil_get_var_wrap(lil, &argv[i].d.as_ref()?.to_string()).map(|v| v.borrow().v.clone());\n        }\n        var = lil_set_var_wrap(lil, &argv[i].d.as_ref()?.to_string(), &argv[i + 1], access);\n        i += 2;\n    }\n    var.map(|v| v.borrow().v.clone())\n}\n\n\npub fn fnc_split<T: Clone + ToString + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList::<T> { items: Vec::new() };\n    let mut sep = \" \".to_string();\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    if argc > 1 {\n        sep = argv[1].d.as_ref().map(|x| x.to_string()).unwrap_or_else(|| \" \".to_string());\n        if sep.is_empty() { return argv[0].clone(); }\n    }\n    let mut val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n    let str = argv[0].d.as_ref().map(|x| x.to_string()).unwrap_or_default();\n    for c in str.chars() {\n        if sep.contains(c) {\n            list.items.push(Rc::new(RefCell::new(val)));\n            val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n        } else {\n            if let Some(s) = val.d.as_mut() {\n                *s = format!(\"{}{}\", s.to_string(), c).into();\n            }\n        }\n    }\n    list.items.push(Rc::new(RefCell::new(val)));\n    let result_str = list.items.iter().map(|x| x.borrow().d.as_ref().map(|x| x.to_string()).unwrap_or_default()).collect::<Vec<_>>().join(\" \");\n    LilValue { l: 0, d: Some(result_str.into()) }\n}\n\n\nfn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\n\npub fn lil_register<T: Clone>(lil: &mut LilStruct<T>, name: &str, proc: LilFuncProc<T>) {\n    let func = Rc::new(RefCell::new(LilFunc {\n        name: name.to_string(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: Some(proc),\n    }));\n    lil.cmd.push(func.clone());\n    lil.cmds += 1;\n}\n\n\npub fn fnc_write<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut msg = String::new();\n    for i in 0..argc {\n        if i != 0 {\n            msg.push(' ');\n        }\n        msg.push_str(&argv[i].d.as_ref().unwrap().to_string());\n    }\n    println!(\"{}\", msg);\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_if<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if argv[0].d.as_ref().map_or(false, |s| s.to_string() == \"not\") {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    let val = lil_eval_expr(lil, &argv[base]);\n    if val.is_none() || lil.error != 0 { return None; }\n    let v = lil_to_boolean(&val.unwrap());\n    let v = if not { !v } else { v };\n    if v {\n        lil_parse_value(lil, &argv[base + 1], 0)\n    } else if argc > base + 2 {\n        lil_parse_value(lil, &argv[base + 2], 0)\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_length<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(value: i64) -> LilValue<T> {\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n    let mut total = 0;\n    for (i, arg) in argv.iter().enumerate() {\n        if i != 0 {\n            total += 1;\n        }\n        let s = lil_to_string_wrap(arg);\n        total += s.len();\n    }\n    lil_alloc_integer_wrap(total as i64)\n}\n\n\npub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n\npub fn fnc_strpos<T: Clone + From<i32> + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let hay;\n    let str;\n    let mut min = 0;\n    if argc < 2 {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    hay = argv[0].d.as_ref().unwrap().to_string();\n    if argc > 2 {\n        min = argv[2].d.as_ref().unwrap().to_string().parse::<usize>().unwrap();\n        if min >= hay.len() {\n            return LilValue { l: 0, d: Some(T::from(-1)) };\n        }\n    }\n    str = hay[min..].find(&argv[1].d.as_ref().unwrap().to_string());\n    if str.is_none() {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    LilValue { l: 0, d: Some(T::from(str.unwrap() as i32)) }\n}\n\n\npub fn fnc_strcmp<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    let s1 = lil_to_string_wrap(&argv[0]);\n    let s2 = lil_to_string_wrap(&argv[1]);\n    LilValue { l: s1.cmp(&s2) as usize, d: None }\n}\n\n\npub fn fnc_repstr<T: Clone + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 1 {\n        return LilValue { l: 0, d: None };\n    }\n    if argc < 3 {\n        return argv[0].clone();\n    }\n\n    let from = lil_to_string(&argv[1]);\n    let to = lil_to_string(&argv[2]);\n    if from.is_empty() {\n        return LilValue { l: 0, d: None };\n    }\n\n    let mut src = lil_to_string(&argv[0]);\n    let from_len = from.len();\n    let to_len = to.len();\n\n    while let Some(idx) = src.find(&from) {\n        let mut new_src = String::with_capacity(src.len() - from_len + to_len);\n        new_src.push_str(&src[..idx]);\n        new_src.push_str(&to);\n        new_src.push_str(&src[idx + from_len..]);\n        src = new_src;\n    }\n\n    lil_alloc_string(&src)\n}\n\n\npub fn fnc_rename<T: Clone + Debug + From<String>>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let oldname = lil_to_string(&argv[0]);\n    let newname = lil_to_string(&argv[1]);\n    if argc < 2 {\n        return None;\n    }\n\n    let func = find_cmd(lil, &oldname);\n    if func.is_none() {\n        let msg = format!(\"unknown function '{}'\", oldname);\n        lil_set_error_at(lil, lil.head, &msg);\n        return None;\n    }\n    let func = func.unwrap();\n\n    let r = lil_alloc_string(&func.borrow().name);\n    if !newname.is_empty() {\n        hm_put(&mut lil.cmdmap, &oldname, None);\n        hm_put(&mut lil.cmdmap, &newname, Some(func.clone()));\n        func.borrow_mut().name = newname.clone();\n    } else {\n        del_func(lil, &func);\n    }\n\n    Some(LilValue { l: r.l, d: r.d.map(|s| s.into()) })\n}\n\n\npub fn fnc_dec<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        String::new()\n    }\n    \n    fn lil_to_double_wrap<T: Clone>(val: &LilValue<T>) -> f64 {\n        0.0\n    }\n    \n    fn real_inc_wrap<T: Clone>(lil: &LilStruct<T>, s: String, d: f64) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    real_inc_wrap(lil, lil_to_string_wrap(&argv[0]), -(if argc > 1 { lil_to_double_wrap(&argv[1]) } else { 1.0 }))\n}\n\n\npub fn fnc_quote<T: Clone + AsRef<str> + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    let mut r = LilValue { l: 0, d: None };\n    for i in 0..argc {\n        if i != 0 {\n            let lil_append_char_wrap = |r: &mut LilValue<T>, c: char| {\n                if let Some(ref mut data) = r.d {\n                    let mut s = String::new();\n                    s.push_str(data.as_ref());\n                    s.push(c);\n                    r.d = Some(T::from(s));\n                }\n            };\n            lil_append_char_wrap(&mut r, ' ');\n        }\n        let lil_append_val_wrap = |r: &mut LilValue<T>, val: &LilValue<T>| {\n            if let (Some(ref mut dst_data), Some(ref src_data)) = (&mut r.d, &val.d) {\n                let mut s = String::new();\n                s.push_str(dst_data.as_ref());\n                s.push_str(src_data.as_ref());\n                r.d = Some(T::from(s));\n            }\n        };\n        lil_append_val_wrap(&mut r, &argv[i]);\n    }\n    Some(r)\n}\n\n\n\npub fn test_list_operations() {\n    println!(\"Testing list operations...\");\n    \n    let lil = lil_new();\n    assert!(lil.is_some());\n    \n    let mut list = lil_alloc_list();\n    \n    lil_list_append(&mut list, lil_alloc_integer(1));\n    lil_list_append(&mut list, lil_alloc_integer(2));\n    lil_list_append(&mut list, lil_alloc_string(\"three\"));\n    \n    assert_eq!(lil_list_size(Rc::new(RefCell::new(list.clone()))), 3);\n    \n    let val = lil_list_get(Rc::new(RefCell::new(list.clone())), 0);\n    assert_eq!(lil_to_integer(&val.unwrap().borrow()), 1);\n    \n    let val = lil_list_get(Rc::new(RefCell::new(list.clone())), 1);\n    assert_eq!(lil_to_integer(&val.unwrap().borrow()), 2);\n    \n    let val = lil_list_get(Rc::new(RefCell::new(list.clone())), 2);\n    assert_eq!(lil_to_string(&val.unwrap().borrow()), \"three\");\n    \n    lil_free_list(list);\n    lil_free(lil);\n    println!(\"✓ List operations test passed\");\n}\n\npub fn lil_new<T: Clone>() -> Option<Rc<RefCell<LilStruct<T>>>> {\n    let mut lil = Rc::new(RefCell::new(LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: String::from(\"set \"),\n        env: lil_alloc_env(None),\n        rootenv: lil_alloc_env(None),\n        downenv: lil_alloc_env(None),\n        empty: alloc_value(None).unwrap(),\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: unsafe { std::mem::zeroed() },\n        embed: String::new(),\n        embedlen: 0,\n    }));\n    \n    lil.borrow_mut().rootenv = lil.borrow().env.clone();\n    hm_init(&mut lil.borrow_mut().cmdmap);\n    register_stdcmds(&mut lil);\n    Some(lil)\n}\n\npub fn register_stdcmds<T: Clone>(lil: &mut Rc<RefCell<LilStruct<T>>>) {\n    lil_register(lil, \"reflect\", fnc_reflect);\n    lil_register(lil, \"func\", fnc_func);\n    lil_register(lil, \"rename\", fnc_rename);\n    lil_register(lil, \"unusedname\", fnc_unusedname);\n    lil_register(lil, \"quote\", fnc_quote);\n    lil_register(lil, \"set\", fnc_set);\n    lil_register(lil, \"local\", fnc_local);\n    lil_register(lil, \"write\", fnc_write);\n    lil_register(lil, \"print\", fnc_print);\n    lil_register(lil, \"eval\", fnc_eval);\n    lil_register(lil, \"topeval\", fnc_topeval);\n    lil_register(lil, \"upeval\", fnc_upeval);\n    lil_register(lil, \"downeval\", fnc_downeval);\n    lil_register(lil, \"enveval\", fnc_enveval);\n    lil_register(lil, \"jaileval\", fnc_jaileval);\n    lil_register(lil, \"count\", fnc_count);\n    lil_register(lil, \"index\", fnc_index);\n    lil_register(lil, \"indexof\", fnc_indexof);\n    lil_register(lil, \"filter\", fnc_filter);\n    lil_register(lil, \"list\", fnc_list);\n    lil_register(lil, \"append\", fnc_append);\n    lil_register(lil, \"slice\", fnc_slice);\n    lil_register(lil, \"subst\", fnc_subst);\n    lil_register(lil, \"concat\", fnc_concat);\n    lil_register(lil, \"foreach\", fnc_foreach);\n    lil_register(lil, \"return\", fnc_return);\n    lil_register(lil, \"result\", fnc_result);\n    lil_register(lil, \"expr\", fnc_expr);\n    lil_register(lil, \"inc\", fnc_inc);\n    lil_register(lil, \"dec\", fnc_dec);\n    lil_register(lil, \"read\", fnc_read);\n    lil_register(lil, \"store\", fnc_store);\n    lil_register(lil, \"if\", fnc_if);\n    lil_register(lil, \"while\", fnc_while);\n    lil_register(lil, \"for\", fnc_for);\n    lil_register(lil, \"char\", fnc_char);\n    lil_register(lil, \"charat\", fnc_charat);\n    lil_register(lil, \"codeat\", fnc_codeat);\n    lil_register(lil, \"substr\", fnc_substr);\n    lil_register(lil, \"strpos\", fnc_strpos);\n    lil_register(lil, \"length\", fnc_length);\n    lil_register(lil, \"trim\", fnc_trim);\n    lil_register(lil, \"ltrim\", fnc_ltrim);\n    lil_register(lil, \"rtrim\", fnc_rtrim);\n    lil_register(lil, \"strcmp\", fnc_strcmp);\n    lil_register(lil, \"streq\", fnc_streq);\n    lil_register(lil, \"repstr\", fnc_repstr);\n    lil_register(lil, \"split\", fnc_split);\n    lil_register(lil, \"try\", fnc_try);\n    lil_register(lil, \"error\", fnc_error);\n    lil_register(lil, \"exit\", fnc_exit);\n    lil_register(lil, \"source\", fnc_source);\n    lil_register(lil, \"lmap\", fnc_lmap);\n    lil_register(lil, \"rand\", fnc_rand);\n    lil_register(lil, \"catcher\", fnc_catcher);\n    lil_register(lil, \"watch\", fnc_watch);\n    lil.borrow_mut().syscmds = lil.borrow().cmds;\n}\n\npub fn fnc_local<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    for i in 0..argc {\n        let varname = lil_to_string(&argv[i]);\n        if find_cmd(lil, &varname).is_none() {\n            let mut env = lil.env.borrow_mut();\n            let mut found = false;\n            for var in &env.var {\n                if var.borrow().n == varname {\n                    found = true;\n                    break;\n                }\n            }\n            if !found {\n                let var = Rc::new(RefCell::new(LilVar {\n                    n: varname.clone(),\n                    w: String::new(),\n                    env: lil.env.clone(),\n                    v: lil.empty.clone(),\n                }));\n                env.var.push(var);\n                env.vars += 1;\n            }\n        }\n    }\n    None\n}\n\npub fn fnc_source<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    \n    let filename = lil_to_string(&argv[0]);\n    let mut file = std::fs::File::open(filename).ok()?;\n    let mut buffer = String::new();\n    file.read_to_string(&mut buffer).ok()?;\n    \n    Some(LilValue { l: buffer.len(), d: Some(buffer.into()) })\n}\n\npub fn fnc_enveval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    \n    let codeindex = if argc == 1 { 0 } else { 2 };\n    let mut env = lil.env.borrow_mut();\n    let parent = env.parent.clone();\n    let new_env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    \n    if argc > 1 {\n        for i in 0..argc-1 {\n            let varname = lil_to_string(&argv[i]);\n            let var = Rc::new(RefCell::new(LilVar {\n                n: varname.clone(),\n                w: String::new(),\n                env: new_env.clone(),\n                v: argv[i].clone(),\n            }));\n            new_env.borrow_mut().var.push(var);\n            new_env.borrow_mut().vars += 1;\n        }\n    }\n    \n    lil.env = new_env;\n    let result = argv[codeindex].clone();\n    lil.env = env.parent.clone().unwrap_or(lil.rootenv.clone());\n    Some(result)\n}\n\npub fn fnc_ltrim<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    \n    let s = lil_to_string(&argv[0]);\n    let chars_to_trim = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { &lil_to_string(&argv[1]) };\n    let trimmed = s.trim_start_matches(|c| chars_to_trim.contains(c));\n    Some(LilValue { l: trimmed.len(), d: Some(trimmed.into()) })\n}\n\npub fn fnc_trim<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    \n    let s = lil_to_string(&argv[0]);\n    let chars_to_trim = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { &lil_to_string(&argv[1]) };\n    let trimmed = s.trim_matches(|c| chars_to_trim.contains(c));\n    Some(LilValue { l: trimmed.len(), d: Some(trimmed.into()) })\n}\n\nfn main(){}\n //编译报错信息：error: unknown character escape: `f`\n    --> ../../Output/crown/tmp/test-lil_test_list_operations/temp.rs:1965:42\n     |\n1965 |     let chars_to_trim = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { &lil_to_string(&argv[1]) };\n     |                                          ^ unknown character escape\n     |\n     = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "test_system_function": "//同时处理的函数过多，无法处理 :13",
        "test_error_handling": "//同时处理的函数过多，无法处理 :13",
        "test_variable_operations": "//同时处理的函数过多，无法处理 :13"
    },
    "lil": {
        "lil_parse_value": "//同时处理的函数过多，无法处理 :27",
        "get_bracketpart": "//同时处理的函数过多，无法处理 :24",
        "get_dollarpart": "//同时处理的函数过多，无法处理 :24",
        "next_word": "//同时处理的函数过多，无法处理 :18",
        "fnc_trim": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\npub fn fnc_trim<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let chars = if argc < 2 { String::from(\" \\u{000C}\\n\\r\\t\\u{000B}\") } else { lil_to_string(&argv[1]) };\n    real_trim(s, chars, 1, 1)\n}\n\n //编译报错信息：error: unknown character escape: `f`\n   --> ../../Output/crown/tmp/test-lil_fnc_trim/temp.rs:176:47\n    |\n176 |     let chars = if argc < 2 { String::from(\" \\f\\n\\r\\t\\v\") } else { lil_to_string(&argv[1]) };\n    |                                               ^ unknown character escape\n    |\n    = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "fnc_ltrim": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\npub fn fnc_ltrim<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let pat = if argc < 2 { \" \\x0C\\n\\r\\t\\x0B\".to_string() } else { lil_to_string(&argv[1]) };\n    real_trim(lil, &s, &pat, 1, 0)\n}\n\n //编译报错信息：error: unknown character escape: `f`\n   --> ../../Output/crown/tmp/test-lil_fnc_ltrim/temp.rs:110:32\n    |\n110 |     let pat = if argc < 2 { \" \\f\\n\\r\\t\\v\".to_string() } else { lil_to_string(&argv[1]) };\n    |                                ^ unknown character escape\n    |\n    = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "fnc_enveval": "\n\n\n\npub static mut test_running: i32 = 1;\npub static mut test_exit_code: i32 = 0;\n\npub trait ToInteger {\n    fn to_integer(&self) -> i32;\n}\n\nimpl<T: ToInteger> ToInteger for RefCell<T> {\n    fn to_integer(&self) -> i32 {\n        self.borrow().to_integer()\n    }\n}\n\nimpl<T: Clone + ToString> ToInteger for LilValue<T> {\n    fn to_integer(&self) -> i32 {\n        if let Some(ref data) = self.d {\n            if let Ok(num) = data.to_string().parse::<i32>() {\n                return num;\n            }\n        }\n        0\n    }\n}\n\n\n\n\n\n\n\n\nuse std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\n\n\n\n\n\n\n\n\npub fn fnc_enveval<T: Clone + Debug>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut r = LilValue { l: 0, d: None };\n    let mut invars: Option<LilList<T>> = None;\n    let mut outvars: Option<LilList<T>> = None;\n    let mut varvalues: Vec<LilValue<T>> = Vec::new();\n    let mut codeindex: usize = 0;\n\n    if argc < 1 { return r; }\n    if argc == 1 { codeindex = 0; }\n    else if argc >= 2 {\n        invars = Some(lil_subst_to_list(lil, &argv[0]));\n        for i in 0..invars.as_ref().unwrap().items.len() {\n            let var_name = lil_to_string(lil, &invars.as_ref().unwrap().items[i].borrow());\n            let var_value = lil_get_var(lil, &var_name);\n            varvalues.push(lil_clone_value(lil, &var_value));\n        }\n        if argc > 2 {\n            codeindex = 2;\n            outvars = Some(lil_subst_to_list(lil, &argv[1]));\n        } else {\n            codeindex = 1;\n        }\n    }\n\n    lil_push_env(lil);\n    if let Some(ref invars) = invars {\n        for i in 0..invars.items.len() {\n            let var_name = lil_to_string(lil, &invars.items[i].borrow());\n            lil_set_var(lil, &var_name, varvalues[i].clone(), 2);\n            lil_free_value(lil, varvalues[i].clone());\n        }\n    }\n\n    r = lil_parse_value(lil, &argv[codeindex], 0);\n    if invars.is_some() || outvars.is_some() {\n        if let Some(ref outvars) = outvars {\n            varvalues = Vec::with_capacity(outvars.items.len());\n            for i in 0..outvars.items.len() {\n                let var_name = lil_to_string(lil, &outvars.items[i].borrow());\n                let var_value = lil_get_var(lil, &var_name);\n                varvalues.push(lil_clone_value(lil, &var_value));\n            }\n        } else if let Some(ref invars) = invars {\n            for i in 0..invars.items.len() {\n                let var_name = lil_to_string(lil, &invars.items[i].borrow());\n                let var_value = lil_get_var(lil, &var_name);\n                varvalues.push(lil_clone_value(lil, &var_value));\n            }\n        }\n    }\n\n    lil_pop_env(lil);\n    if let Some(invars) = invars {\n        if let Some(outvars) = outvars {\n            for i in 0..outvars.items.len() {\n                let var_name = lil_to_string(lil, &outvars.items[i].borrow());\n                lil_set_var(lil, &var_name, varvalues[i].clone(), 1);\n                lil_free_value(lil, varvalues[i].clone());\n            }\n        } else {\n            for i in 0..invars.items.len() {\n                let var_name = lil_to_string(lil, &invars.items[i].borrow());\n                lil_set_var(lil, &var_name, varvalues[i].clone(), 1);\n                lil_free_value(lil, varvalues[i].clone());\n            }\n        }\n    }\n    r\n}\n\npub fn lil_subst_to_list<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\npub fn lil_to_string<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> String {\n    String::new()\n}\n\npub fn lil_get_var<T: Clone>(_lil: &LilStruct<T>, _name: &str) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\npub fn lil_clone_value<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\npub fn lil_push_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n\npub fn lil_set_var<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _value: LilValue<T>, _flags: i32) {}\n\npub fn lil_free_value<T: Clone>(_lil: &mut LilStruct<T>, _value: LilValue<T>) {}\n\npub fn lil_parse_value<T: Clone>(_lil: &mut LilStruct<T>, _value: &LilValue<T>, _flags: i32) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\npub fn lil_pop_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n\nfn main(){}\n\npub fn fnc_if<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if argv[0].d.as_ref().map_or(false, |s| s.to_string() == \"not\") {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    let val = lil_eval_expr(lil, &argv[base]);\n    if val.is_none() || lil.error != 0 { return None; }\n    let v = lil_to_boolean(&val.unwrap());\n    let v = if not { !v } else { v };\n    if v {\n        lil_parse_value(lil, &argv[base + 1], 0)\n    } else if argc > base + 2 {\n        lil_parse_value(lil, &argv[base + 2], 0)\n    } else {\n        None\n    }\n}\n\n\npub fn lil_free_env<T: Clone>(env: Option<Rc<RefCell<LilEnv<T>>>>) {\n    if env.is_none() {\n        return;\n    }\n    let env = env.unwrap();\n    let mut env = env.borrow_mut();\n    lil_free_value(Some(Rc::new(RefCell::new(env.retval.clone()))));\n    hm_destroy(&mut env.varmap);\n    for i in 0..env.vars {\n        let var = env.var[i].borrow_mut();\n        lil_free_value(Some(Rc::new(RefCell::new(var.v.clone()))));\n    }\n    env.var.clear();\n    env.vars = 0;\n}\n\npub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\npub fn lil_free_value<T: Clone>(_lil: &mut LilStruct<T>, _value: LilValue<T>) {}\n\n\npub fn fnc_reflect<T: Clone + Debug + From<String> + From<i64> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let type_str = lil_to_string(&argv[0]);\n    match type_str.as_str() {\n        \"version\" => Some(lil_alloc_string::<T>(\"0.1\")),\n        \"args\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().argnames.items.is_empty() { return None; }\n            Some(lil_list_to_value(&func.unwrap().borrow().argnames, 1))\n        },\n        \"body\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().proc.is_some() { return None; }\n            Some(lil_clone_value(&func.unwrap().borrow().code))\n        },\n        \"func-count\" => Some(lil_alloc_integer(lil.cmds as i64)),\n        \"funcs\" => {\n            let mut funcs = lil_alloc_list();\n            for i in 0..lil.cmds {\n                lil_list_append(&mut funcs, lil_alloc_string(&lil.cmd[i].borrow().name));\n            }\n            let r = lil_list_to_value(&funcs, 1);\n            lil_free_list(funcs);\n            Some(r)\n        },\n        \"vars\" => {\n            let mut vars = lil_alloc_list();\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                for i in 0..e.borrow().vars {\n                    lil_list_append(&mut vars, lil_alloc_string(&e.borrow().var[i].borrow().n));\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            let r = lil_list_to_value(&vars, 1);\n            lil_free_list(vars);\n            Some(r)\n        },\n        \"globals\" => {\n            let mut vars = lil_alloc_list();\n            for i in 0..lil.rootenv.borrow().vars {\n                lil_list_append(&mut vars, lil_alloc_string(&lil.rootenv.borrow().var[i].borrow().n));\n            }\n            let r = lil_list_to_value(&vars, 1);\n            lil_free_list(vars);\n            Some(r)\n        },\n        \"has-func\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            hm_has(&lil.cmdmap, &target).then(|| lil_alloc_string(\"1\"))\n        },\n        \"has-var\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                if hm_has(&e.borrow().varmap, &target) { return Some(lil_alloc_string(\"1\")); }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            None\n        },\n        \"has-global\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            for i in 0..lil.rootenv.borrow().vars {\n                if target == lil.rootenv.borrow().var[i].borrow().n { return Some(lil_alloc_string(\"1\")); }\n            }\n            None\n        },\n        \"error\" => lil.err_msg.is_empty().then(|| lil_alloc_string(&lil.err_msg)),\n        \"dollar-prefix\" => {\n            if argc == 1 { return Some(lil_alloc_string(&lil.dollarprefix)); }\n            let r = lil_alloc_string(&lil.dollarprefix);\n            lil.dollarprefix = lil_to_string(&argv[1]);\n            Some(r)\n        },\n        \"this\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(lil_alloc_string(&lil.catcher)); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return Some(lil_alloc_string(&lil.rootcode)); }\n                if let Some(func) = &e.borrow().func { return Some(func.borrow().code.clone()); }\n            }\n            None\n        },\n        \"name\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(e.borrow().catcher_for.clone()); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return None; }\n                if let Some(func) = &e.borrow().func { return Some(lil_alloc_string(&func.borrow().name)); }\n            }\n            None\n        },\n        _ => None\n    }\n}\n\n\npub fn lil_clone_value<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_while<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut r: Option<LilValue<T>> = None;\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if lil_to_string(&argv[0]) == \"not\" {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr(lil, &argv[base]);\n        if val.is_none() || lil.error != 0 { return None; }\n        let mut v = lil_to_boolean(&val.unwrap());\n        if not { v = !v; }\n        if !v {\n            break;\n        }\n        if r.is_some() {\n            r = None;\n        }\n        r = lil_parse_value(lil, &argv[base + 1], 0);\n    }\n    r\n}\n\n\npub fn fnc_watch<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    let wcode = lil_to_string(&argv[argc - 1]);\n    for i in 0..(argc - 1) {\n        let vname = lil_to_string(&argv[i]);\n        if vname.is_empty() { continue; }\n        let mut v = lil_find_var(lil, lil.env.clone(), &vname);\n        if v.is_none() {\n            v = Some(lil_set_var(lil, &vname, None, 2));\n        }\n        if let Some(var) = v {\n            var.borrow_mut().w = if !wcode.is_empty() { wcode.clone() } else { String::new() };\n        }\n    }\n    None\n}\n\n\npub fn lil_set_var<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _value: LilValue<T>, _flags: i32) {}\n\nfn lil_find_var<T: Clone>(_lil: &LilStruct<T>, _env: Rc<RefCell<LilEnv<T>>>, _name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    None\n}\n\npub fn hm_put<T>(hm: &mut HashMap<T>, key: &str, value: Option<T>) {\n    let hash = hm_hash(key);\n    let cell_index = (hash & HASHMAP_CELLMASK) as usize;\n    let mut cell = &mut hm.cell[cell_index];\n    \n    for i in 0..cell.c {\n        let entry = cell.e[i].borrow();\n        if entry.k == key {\n            drop(entry);\n            cell.e[i].borrow_mut().v = value;\n            return;\n        }\n    }\n    \n    cell.e.push(Rc::new(RefCell::new(HashEntry {\n        k: strclone(key).unwrap(),\n        v: value,\n    })));\n    cell.c += 1;\n}\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\npub fn ateol<T: Clone>(lil: &LilStruct<T>) -> bool {\n    !(lil.ignoreeol != 0) && (lil.code.chars().nth(lil.head) == Some('\\n') || lil.code.chars().nth(lil.head) == Some('\\r') || lil.code.chars().nth(lil.head) == Some(';'))\n}\n\npub fn lil_to_string<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> String {\n    String::new()\n}\n\npub fn skip_spaces<T: Clone>(lil: &mut LilStruct<T>) {\n    while lil.head < lil.clen {\n        let current_char = lil.code.chars().nth(lil.head).unwrap();\n        if current_char == '#' {\n            if lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                lil.head += 2;\n                while lil.head < lil.clen {\n                    let current_char = lil.code.chars().nth(lil.head).unwrap();\n                    if current_char == '#' && lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                        lil.head += 2;\n                        break;\n                    }\n                    lil.head += 1;\n                }\n            } else {\n                while lil.head < lil.clen && !ateol(lil) {\n                    lil.head += 1;\n                }\n            }\n        } else if current_char == '\\\\' && (lil.code.chars().nth(lil.head + 1) == Some('\\r') || lil.code.chars().nth(lil.head + 1) == Some('\\n')) {\n            lil.head += 1;\n            while lil.head < lil.clen && ateol(lil) {\n                lil.head += 1;\n            }\n        } else if current_char == '\\r' || current_char == '\\n' {\n            if lil.ignoreeol != 0 {\n                lil.head += 1;\n            } else {\n                break;\n            }\n        } else if current_char.is_whitespace() {\n            lil.head += 1;\n        } else {\n            break;\n        }\n    }\n}\n\npub fn lil_list_to_value<T: Clone>(list: &LilList<T>, _depth: usize) -> LilValue<T> {\n    LilValue { l: list.items.len(), d: None }\n}\n\npub fn lil_parse_value<T: Clone>(_lil: &mut LilStruct<T>, _value: &LilValue<T>, _flags: i32) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\npub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\npub fn lil_pop_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n\npub fn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\npub fn lil_push_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n\npub fn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    lil.cmd.iter().find(|f| f.borrow().name == name).cloned()\n}\n\npub fn lil_find_local_var<T: Clone + Debug>(lil: &LilStruct<T>, env: &LilEnv<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    hm_get(&env.varmap, name)\n}\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\npub fn lil_list_append<T: Clone>(list: &mut LilList<T>, val: LilValue<T>) {\n    list.items.push(Rc::new(RefCell::new(val)));\n}\n\npub fn lil_alloc_list<T: Clone>() -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\npub fn lil_append_val<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) -> i32 {\n    if v.d.is_none() || v.l == 0 {\n        return 1;\n    }\n\n    match (&mut val.d, &v.d) {\n        (Some(val_data), Some(v_data)) => {\n            let mut new_data = val_data.clone();\n            new_data = v_data.clone();\n            val.d = Some(new_data);\n            val.l += v.l;\n            1\n        }\n        _ => 1,\n    }\n}\n\npub fn needs_escape(str: &str) -> i32 {\n    if str.is_empty() {\n        return 1;\n    }\n    for c in str.chars() {\n        if c.is_ascii_punctuation() || c.is_whitespace() {\n            return 1;\n        }\n    }\n    0\n}\n\npub fn lil_append_char<T: Clone + Debug + FromStr>(val: Rc<RefCell<LilValue<T>>>, ch: char) -> i32 {\n    let mut val = val.borrow_mut();\n    if let Some(ref mut data) = val.d {\n        let mut s = format!(\"{:?}\", data);\n        s.push(ch);\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    } else {\n        let s = ch.to_string();\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    }\n}\n\npub fn lil_append_string<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str) -> i32 {\n    lil_append_string_len(val, s, s.len())\n}\n\npub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\npub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\npub fn islilspecial(ch: i8) -> i32 {\n    (ch == b'$' as i8 || ch == b'{' as i8 || ch == b'}' as i8 || ch == b'[' as i8 || ch == b']' as i8 || ch == b'\"' as i8 || ch == b'\\'' as i8 || ch == b';' as i8) as i32\n}\n\npub fn lil_append_string_len<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str, len: usize) -> i32 {\n    if s.is_empty() {\n        return 1;\n    }\n\n    let s_slice = if len < s.len() { &s[..len] } else { s };\n    \n    match &mut val.d {\n        Some(data) => {\n            let str_data = data.as_mut();\n            str_data.push_str(s_slice);\n            val.l += s_slice.len();\n            1\n        },\n        None => {\n            val.d = Some(T::from(s_slice.to_string()));\n            val.l = s_slice.len();\n            1\n        }\n    }\n}\n\n\npub fn add_func<T: Clone + Debug>(lil: &mut LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    let cmd = find_cmd(lil, name);\n    if let Some(cmd) = cmd {\n        let mut cmd_ref = cmd.borrow_mut();\n        if cmd_ref.argnames.items.len() > 0 {\n            let argnames = cmd_ref.argnames.clone();\n            lil_free_list(argnames);\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd_ref.code.clone()))));\n        cmd_ref.argnames = LilList { items: Vec::new() };\n        cmd_ref.code = LilValue { l: 0, d: None };\n        cmd_ref.proc = None;\n        return Some(Rc::clone(&cmd));\n    }\n    let new_cmd = Rc::new(RefCell::new(LilFunc {\n        name: strclone(name).unwrap(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: None,\n    }));\n    lil.cmd.push(Rc::clone(&new_cmd));\n    lil.cmds += 1;\n    hm_put(&mut lil.cmdmap, name, Some(Rc::clone(&new_cmd)));\n    Some(new_cmd)\n}\n\n\n //编译报错信息：error[E0428]: the name `lil_free_value` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:291:1\n    |\n235 | pub fn lil_free_value<T: Clone>(_lil: &mut LilStruct<T>, _value: LilValue<T>) {}\n    | ----------------------------------------------------------------------------- previous definition of the value `lil_free_value` here\n...\n291 | pub fn lil_free_value<T: Clone>(_lil: &mut LilStruct<T>, _value: LilValue<T>) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_free_value` redefined here\n    |\n    = note: `lil_free_value` must be defined only once in the value namespace of this module\n\nerror[E0428]: the name `lil_clone_value` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:414:1\n    |\n227 | pub fn lil_clone_value<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> LilValue<T> {\n    | ------------------------------------------------------------------------------------------ previous definition of the value `lil_clone_value` here\n...\n414 | pub fn lil_clone_value<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> LilValue<T> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_clone_value` redefined here\n    |\n    = note: `lil_clone_value` must be defined only once in the value namespace of this module\n\nerror[E0428]: the name `lil_set_var` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:464:1\n    |\n233 | pub fn lil_set_var<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _value: LilValue<T>, _flags: i32) {}\n    | ---------------------------------------------------------------------------------------------------- previous definition of the value `lil_set_var` here\n...\n464 | pub fn lil_set_var<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _value: LilValue<T>, _flags: i32) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_set_var` redefined here\n    |\n    = note: `lil_set_var` must be defined only once in the value namespace of this module\n\nerror[E0428]: the name `lil_to_string` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:501:1\n    |\n219 | pub fn lil_to_string<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> String {\n    | ----------------------------------------------------------------------------------- previous definition of the value `lil_to_string` here\n...\n501 | pub fn lil_to_string<T: Clone>(_lil: &LilStruct<T>, _value: &LilValue<T>) -> String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_to_string` redefined here\n    |\n    = note: `lil_to_string` must be defined only once in the value namespace of this module\n\nerror[E0428]: the name `lil_parse_value` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:547:1\n    |\n237 | pub fn lil_parse_value<T: Clone>(_lil: &mut LilStruct<T>, _value: &LilValue<T>, _flags: i32) -> LilValue<T> {\n    | ----------------------------------------------------------------------------------------------------------- previous definition of the value `lil_parse_value` here\n...\n547 | pub fn lil_parse_value<T: Clone>(_lil: &mut LilStruct<T>, _value: &LilValue<T>, _flags: i32) -> LilValue<T> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_parse_value` redefined here\n    |\n    = note: `lil_parse_value` must be defined only once in the value namespace of this module\n\nerror[E0428]: the name `lil_pop_env` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:559:1\n    |\n241 | pub fn lil_pop_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n    | ----------------------------------------------------- previous definition of the value `lil_pop_env` here\n...\n559 | pub fn lil_pop_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_pop_env` redefined here\n    |\n    = note: `lil_pop_env` must be defined only once in the value namespace of this module\n\nerror[E0428]: the name `lil_push_env` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:563:1\n    |\n231 | pub fn lil_push_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n    | ------------------------------------------------------ previous definition of the value `lil_push_env` here\n...\n563 | pub fn lil_push_env<T: Clone>(_lil: &mut LilStruct<T>) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_push_env` redefined here\n    |\n    = note: `lil_push_env` must be defined only once in the value namespace of this module\n\nerror[E0425]: cannot find function `lil_eval_expr` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:254:15\n    |\n254 |     let val = lil_eval_expr(lil, &argv[base]);\n    |               ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lil_to_boolean` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:256:13\n    |\n256 |     let v = lil_to_boolean(&val.unwrap());\n    |             ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n   --> ../../Output/crown/tmp/test-lil_fnc_enveval/temp.rs:259:9\n    |\n245 | pub fn fnc_if<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    |                                                                                                  ------------------- expected `Option<LilValue<T>>` because of return type\n...\n259 |         lil_parse_value(lil, &argv[base + 1], 0)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<LilValue<T>>`, found `LilValue<T>`\n    |\n    = note: expected enum `Option<LilValue<_>>`\n             found struct `LilValue<_>`\n",
        "fnc_source": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\n\n\npub fn fnc_source<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n\n    let buffer = if let Some(proc) = lil.callback.get(4) {\n        let proc_wrap = |lil: &LilStruct<T>, name: &str| -> String {\n            let val = proc(lil, name, &[]);\n            lil_to_string(&val)\n        };\n        proc_wrap(lil, &lil_to_string(&argv[0]))\n    } else if let Some(proc) = lil.callback.get(2) {\n        let proc_wrap = |lil: &LilStruct<T>, name: &str| -> String {\n            let val = proc(lil, name, &[]);\n            lil_to_string(&val)\n        };\n        proc_wrap(lil, &lil_to_string(&argv[0]))\n    } else {\n        match std::fs::read_to_string(&lil_to_string(&argv[0])) {\n            Ok(content) => content,\n            Err(_) => return None,\n        }\n    };\n\n    let r = lil_parse(lil, &buffer, 0, 0);\n    Some(r)\n}\n\nfn main(){}\n\n\n //编译报错信息：error[E0425]: cannot find function `lil_to_string` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_source/temp.rs:112:13\n    |\n112 |             lil_to_string(&val)\n    |             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lil_to_string` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_source/temp.rs:114:25\n    |\n114 |         proc_wrap(lil, &lil_to_string(&argv[0]))\n    |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lil_to_string` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_source/temp.rs:118:13\n    |\n118 |             lil_to_string(&val)\n    |             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lil_to_string` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_source/temp.rs:120:25\n    |\n120 |         proc_wrap(lil, &lil_to_string(&argv[0]))\n    |                         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lil_to_string` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_source/temp.rs:122:40\n    |\n122 |         match std::fs::read_to_string(&lil_to_string(&argv[0])) {\n    |                                        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lil_parse` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_source/temp.rs:128:13\n    |\n128 |     let r = lil_parse(lil, &buffer, 0, 0);\n    |             ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
        "fnc_local": "\n\n\n\npub static mut test_running: i32 = 1;\npub static mut test_exit_code: i32 = 0;\n\npub trait ToInteger {\n    fn to_integer(&self) -> i32;\n}\n\nimpl<T: ToInteger> ToInteger for RefCell<T> {\n    fn to_integer(&self) -> i32 {\n        self.borrow().to_integer()\n    }\n}\n\nimpl<T: Clone + ToString> ToInteger for LilValue<T> {\n    fn to_integer(&self) -> i32 {\n        if let Some(ref data) = self.d {\n            if let Ok(num) = data.to_string().parse::<i32>() {\n                return num;\n            }\n        }\n        0\n    }\n}\n\n\n\n\n\n\n\n\npub const LIL_SETVAR_LOCAL_NEW: i32 = 2;\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::marker::PhantomData;\n\n#[derive(Clone)]\npub struct LilValue<T> {\n    pub l: i32,\n    pub d: Option<T>,\n}\n\npub struct LilStruct<T> {\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n}\n\npub struct LilEnv<T> {\n    _marker: PhantomData<T>,\n}\n\n\n\npub fn fnc_local<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut i = 0;\n    while i < argc {\n        let varname = lil_to_string(&argv[i]);\n        if !lil_find_local_var(lil, Rc::clone(&lil.env), &varname) {\n            lil_set_var(lil, &varname, lil.empty.clone(), LIL_SETVAR_LOCAL_NEW);\n        }\n        i += 1;\n    }\n    LilValue { l: 0, d: None }\n}\n\npub fn lil_to_string<T: Clone>(val: &LilValue<T>) -> String {\n    String::new()\n}\n\n\npub fn lil_find_local_var<T: Clone>(lil: &LilStruct<T>, env: Rc<RefCell<LilEnv<T>>>, name: &str) -> bool {\n    false\n}\n\n\npub fn lil_set_var<T: Clone>(lil: &mut LilStruct<T>, name: &str, val: LilValue<T>, flags: i32) {\n}\n\n\nfn main(){}\n\n\nfn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\npub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n\nfn lil_list_append<T: Clone>(_list: &mut LilList<T>, _val: LilValue<T>) {}\n\n\npub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\n\npub fn lil_append_string<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str) -> i32 {\n    lil_append_string_len(val, s, s.len())\n}\n\npub fn lil_append_string_len<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str, len: usize) -> i32 {\n    if s.is_empty() {\n        return 1;\n    }\n\n    let s_slice = if len < s.len() { &s[..len] } else { s };\n    \n    match &mut val.d {\n        Some(data) => {\n            let str_data = data.as_mut();\n            str_data.push_str(s_slice);\n            val.l += s_slice.len();\n            1\n        },\n        None => {\n            val.d = Some(T::from(s_slice.to_string()));\n            val.l = s_slice.len();\n            1\n        }\n    }\n}\n\n\nfn lil_list_to_value<T: Clone>(_list: &LilList<T>, _flag: i32) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\npub fn lil_to_string<T: Clone>(val: &LilValue<T>) -> String {\n    String::new()\n}\n\npub fn needs_escape(str: &str) -> i32 {\n    if str.is_empty() {\n        return 1;\n    }\n    for c in str.chars() {\n        if c.is_ascii_punctuation() || c.is_whitespace() {\n            return 1;\n        }\n    }\n    0\n}\n\npub fn lil_append_char<T: Clone + Debug + FromStr>(val: Rc<RefCell<LilValue<T>>>, ch: char) -> i32 {\n    let mut val = val.borrow_mut();\n    if let Some(ref mut data) = val.d {\n        let mut s = format!(\"{:?}\", data);\n        s.push(ch);\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    } else {\n        let s = ch.to_string();\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    }\n}\n\npub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\npub fn lil_append_val<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) -> i32 {\n    if v.d.is_none() || v.l == 0 {\n        return 1;\n    }\n\n    match (&mut val.d, &v.d) {\n        (Some(val_data), Some(v_data)) => {\n            let mut new_data = val_data.clone();\n            new_data = v_data.clone();\n            val.d = Some(new_data);\n            val.l += v.l;\n            1\n        }\n        _ => 1,\n    }\n}\n\npub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\n\npub fn lil_register<T: Clone>(lil: &mut LilStruct<T>, name: &str, proc: LilFuncProc<T>) {\n    let func = Rc::new(RefCell::new(LilFunc {\n        name: name.to_string(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: Some(proc),\n    }));\n    lil.cmd.push(func.clone());\n    lil.cmds += 1;\n}\n\npub fn add_func<T: Clone + Debug>(lil: &mut LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    let cmd = find_cmd(lil, name);\n    if let Some(cmd) = cmd {\n        let mut cmd_ref = cmd.borrow_mut();\n        if cmd_ref.argnames.items.len() > 0 {\n            let argnames = cmd_ref.argnames.clone();\n            lil_free_list(argnames);\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd_ref.code.clone()))));\n        cmd_ref.argnames = LilList { items: Vec::new() };\n        cmd_ref.code = LilValue { l: 0, d: None };\n        cmd_ref.proc = None;\n        return Some(Rc::clone(&cmd));\n    }\n    let new_cmd = Rc::new(RefCell::new(LilFunc {\n        name: strclone(name).unwrap(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: None,\n    }));\n    lil.cmd.push(Rc::clone(&new_cmd));\n    lil.cmds += 1;\n    hm_put(&mut lil.cmdmap, name, Some(Rc::clone(&new_cmd)));\n    Some(new_cmd)\n}\n\npub fn hm_put<T>(hm: &mut HashMap<T>, key: &str, value: Option<T>) {\n    let hash = hm_hash(key);\n    let cell_index = (hash & HASHMAP_CELLMASK) as usize;\n    let mut cell = &mut hm.cell[cell_index];\n    \n    for i in 0..cell.c {\n        let entry = cell.e[i].borrow();\n        if entry.k == key {\n            drop(entry);\n            cell.e[i].borrow_mut().v = value;\n            return;\n        }\n    }\n    \n    cell.e.push(Rc::new(RefCell::new(HashEntry {\n        k: strclone(key).unwrap(),\n        v: value,\n    })));\n    cell.c += 1;\n}\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\npub fn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    lil.cmd.iter().find(|f| f.borrow().name == name).cloned()\n}\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n\nfn lil_subst_to_list<T: Clone>(_lil: &LilStruct<T>, _val: LilValue<T>) -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n\npub fn fnc_func<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Rc<RefCell<LilValue<T>>> {\n    let name: Rc<RefCell<LilValue<T>>>;\n    let cmd: Rc<RefCell<LilFunc<T>>>;\n    let fargs: LilList<T>;\n    \n    fn lil_clone_value_wrap<T: Clone>(value: &Rc<RefCell<LilValue<T>>>) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new((*value.borrow()).clone()))\n    }\n    \n    fn lil_to_string_wrap<T: Clone + ToString>(value: &Rc<RefCell<LilValue<T>>>) -> String {\n        value.borrow().d.as_ref().map_or(String::new(), |v| v.to_string())\n    }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, value: &Rc<RefCell<LilValue<T>>>) -> LilList<T> {\n        LilList { items: vec![Rc::clone(value)] }\n    }\n    \n    fn add_func_wrap<T: Clone>(_lil: &LilStruct<T>, name: &str) -> Rc<RefCell<LilFunc<T>>> {\n        Rc::new(RefCell::new(LilFunc {\n            name: name.to_string(),\n            code: LilValue { l: 0, d: None },\n            argnames: LilList { items: vec![] },\n            proc: None,\n        }))\n    }\n    \n    fn lil_unused_name_wrap<T: Clone>(_lil: &LilStruct<T>, prefix: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: None }))\n    }\n    \n    fn lil_alloc_string_wrap<T: Clone + From<String>>(s: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: Some(s.to_string().into()) }))\n    }\n\n    if argc < 1 {\n        return Rc::new(RefCell::new(LilValue { l: 0, d: None }));\n    }\n    if argc >= 3 {\n        name = lil_clone_value_wrap(&argv[0]);\n        fargs = lil_subst_to_list_wrap(lil, &argv[1]);\n        cmd = add_func_wrap(lil, &lil_to_string_wrap(&argv[0]));\n        cmd.borrow_mut().argnames = fargs;\n        cmd.borrow_mut().code = (*argv[2].borrow()).clone();\n    } else {\n        name = lil_unused_name_wrap(lil, \"anonymous-function\");\n        if argc < 2 {\n            let tmp = lil_alloc_string_wrap(\"args\");\n            fargs = lil_subst_to_list_wrap(lil, &tmp);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[0].borrow()).clone();\n        } else {\n            fargs = lil_subst_to_list_wrap(lil, &argv[0]);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[1].borrow()).clone();\n        }\n    }\n    name\n}\n\n\npub fn lil_alloc_list<T: Clone>() -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n\npub fn fnc_append<T: Clone + Debug + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let mut base = 1;\n    let mut access = 1;\n    let varname = argv[0].d.as_ref().unwrap().to_string();\n    let mut varname = if varname == \"global\" {\n        if argc < 3 { return LilValue { l: 0, d: None }; }\n        base = 2;\n        access = 0;\n        argv[1].d.as_ref().unwrap().to_string()\n    } else {\n        varname\n    };\n    let mut list = lil_subst_to_list(lil, lil_get_var(lil, &varname));\n    for i in base..argc {\n        lil_list_append(&mut list, argv[i].clone());\n    }\n    let r = lil_list_to_value(&list, 1);\n    lil_free_list(list);\n    lil_set_var(lil, &varname, r.clone(), access);\n    r\n}\n\n\npub fn fnc_reflect<T: Clone + Debug + From<String> + From<i64> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let type_str = lil_to_string(&argv[0]);\n    match type_str.as_str() {\n        \"version\" => Some(lil_alloc_string::<T>(\"0.1\")),\n        \"args\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().argnames.items.is_empty() { return None; }\n            Some(lil_list_to_value(&func.unwrap().borrow().argnames, 1))\n        },\n        \"body\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().proc.is_some() { return None; }\n            Some(lil_clone_value(&func.unwrap().borrow().code))\n        },\n        \"func-count\" => Some(lil_alloc_integer(lil.cmds as i64)),\n        \"funcs\" => {\n            let mut funcs = lil_alloc_list();\n            for i in 0..lil.cmds {\n                lil_list_append(&mut funcs, lil_alloc_string(&lil.cmd[i].borrow().name));\n            }\n            let r = lil_list_to_value(&funcs, 1);\n            lil_free_list(funcs);\n            Some(r)\n        },\n        \"vars\" => {\n            let mut vars = lil_alloc_list();\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                for i in 0..e.borrow().vars {\n                    lil_list_append(&mut vars, lil_alloc_string(&e.borrow().var[i].borrow().n));\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            let r = lil_list_to_value(&vars, 1);\n            lil_free_list(vars);\n            Some(r)\n        },\n        \"globals\" => {\n            let mut vars = lil_alloc_list();\n            for i in 0..lil.rootenv.borrow().vars {\n                lil_list_append(&mut vars, lil_alloc_string(&lil.rootenv.borrow().var[i].borrow().n));\n            }\n            let r = lil_list_to_value(&vars, 1);\n            lil_free_list(vars);\n            Some(r)\n        },\n        \"has-func\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            hm_has(&lil.cmdmap, &target).then(|| lil_alloc_string(\"1\"))\n        },\n        \"has-var\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                if hm_has(&e.borrow().varmap, &target) { return Some(lil_alloc_string(\"1\")); }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            None\n        },\n        \"has-global\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            for i in 0..lil.rootenv.borrow().vars {\n                if target == lil.rootenv.borrow().var[i].borrow().n { return Some(lil_alloc_string(\"1\")); }\n            }\n            None\n        },\n        \"error\" => lil.err_msg.is_empty().then(|| lil_alloc_string(&lil.err_msg)),\n        \"dollar-prefix\" => {\n            if argc == 1 { return Some(lil_alloc_string(&lil.dollarprefix)); }\n            let r = lil_alloc_string(&lil.dollarprefix);\n            lil.dollarprefix = lil_to_string(&argv[1]);\n            Some(r)\n        },\n        \"this\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(lil_alloc_string(&lil.catcher)); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return Some(lil_alloc_string(&lil.rootcode)); }\n                if let Some(func) = &e.borrow().func { return Some(func.borrow().code.clone()); }\n            }\n            None\n        },\n        \"name\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(e.borrow().catcher_for.clone()); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return None; }\n                if let Some(func) = &e.borrow().func { return Some(lil_alloc_string(&func.borrow().name)); }\n            }\n            None\n        },\n        _ => None\n    }\n}\n\n\npub fn fnc_charat<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer<T: Clone + Debug>(val: &LilValue<T>) -> i64 {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d).parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    let str = lil_to_string(&argv[0]);\n    let index = lil_to_integer(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    let chstr = &str[index..=index];\n    lil_alloc_string(chstr)\n}\n\n\npub fn hm_has<T>(map: &HashMap<T>, _key: &str) -> bool {\n    false\n}\n\n\npub fn fnc_rtrim<T: Clone + Debug + FromStr>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn real_trim(s: String, pat: String, _left: i32, _right: i32) -> LilValue<String> {\n        let trimmed = s.trim_end_matches(&pat[..]);\n        LilValue {\n            l: trimmed.len(),\n            d: Some(trimmed.to_string()),\n        }\n    }\n\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let pat = if argc < 2 { \" \\u{000C}\\n\\r\\t\\u{000B}\".to_string() } else { lil_to_string(&argv[1]) };\n    let result = real_trim(s, pat, 0, 1);\n    LilValue { l: result.l, d: Some(result.d.unwrap().parse().ok().unwrap()) }\n}\n\n\npub fn fnc_length<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(value: i64) -> LilValue<T> {\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n    let mut total = 0;\n    for (i, arg) in argv.iter().enumerate() {\n        if i != 0 {\n            total += 1;\n        }\n        let s = lil_to_string_wrap(arg);\n        total += s.len();\n    }\n    lil_alloc_integer_wrap(total as i64)\n}\n\n\npub fn fnc_downeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    let upenv = Rc::clone(&lil.env);\n    let downenv = Rc::clone(&lil.downenv);\n    if downenv.borrow().parent.is_none() {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.downenv = Rc::new(RefCell::new(LilEnv {\n        parent: None,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    lil.env = Rc::clone(&downenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = downenv;\n    lil.env = upenv;\n    r\n}\n\n\npub fn fnc_index<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: vec![Rc::new(RefCell::new(val.clone()))] }\n    }\n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i64 {\n        if let Some(d) = &val.d {\n            if let Ok(n) = i64::from_str(&d.to_string()) {\n                return n;\n            }\n        }\n        0\n    }\n    fn lil_free_list_wrap<T: Clone>(_list: LilList<T>) {}\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 2 { return r; }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index < list.items.len() {\n        r = list.items[index].borrow().clone();\n    }\n    lil_free_list_wrap(list);\n    r\n}\n\n\npub fn fnc_count<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    let mut buff = String::with_capacity(64);\n    if argc == 0 {\n        return LilValue { l: 1, d: Some(T::from(\"0\".to_string())) };\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    buff.push_str(&list.borrow().items.len().to_string());\n    LilValue { l: buff.len(), d: Some(T::from(buff)) }\n}\n\n\npub fn fnc_streq<T: Clone + FromStr + PartialEq + std::fmt::Display + From<bool>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return lil.empty.clone(); }\n    let s1 = argv[0].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    let s2 = argv[1].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    LilValue { l: 1, d: Some((s1 == s2).into()) }\n}\n\n\nfn lil_find_var<T: Clone>(_lil: &LilStruct<T>, _env: Rc<RefCell<LilEnv<T>>>, _name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    None\n}\n\npub fn lil_find_local_var<T: Clone>(lil: &LilStruct<T>, env: Rc<RefCell<LilEnv<T>>>, name: &str) -> bool {\n    false\n}\n\n\npub fn fnc_lmap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        unimplemented!()\n    }\n    \n    fn lil_list_get_wrap<T: Clone>(list: &Rc<RefCell<LilList<T>>>, index: usize) -> LilValue<T> {\n        unimplemented!()\n    }\n    \n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: LilValue<T>, flag: i32) {\n        unimplemented!()\n    }\n    \n    fn lil_free_list_wrap<T: Clone>(list: Rc<RefCell<LilList<T>>>) {\n        unimplemented!()\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    for i in 1..argc {\n        let var_name = lil_to_string_wrap(&argv[i]);\n        let value = lil_list_get_wrap(&list, i - 1);\n        lil_set_var_wrap(lil, &var_name, value, 1);\n    }\n    lil_free_list_wrap(list);\n    None\n}\n\n\npub fn fnc_split<T: Clone + ToString + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList::<T> { items: Vec::new() };\n    let mut sep = \" \".to_string();\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    if argc > 1 {\n        sep = argv[1].d.as_ref().map(|x| x.to_string()).unwrap_or_else(|| \" \".to_string());\n        if sep.is_empty() { return argv[0].clone(); }\n    }\n    let mut val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n    let str = argv[0].d.as_ref().map(|x| x.to_string()).unwrap_or_default();\n    for c in str.chars() {\n        if sep.contains(c) {\n            list.items.push(Rc::new(RefCell::new(val)));\n            val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n        } else {\n            if let Some(s) = val.d.as_mut() {\n                *s = format!(\"{}{}\", s.to_string(), c).into();\n            }\n        }\n    }\n    list.items.push(Rc::new(RefCell::new(val)));\n    let result_str = list.items.iter().map(|x| x.borrow().d.as_ref().map(|x| x.to_string()).unwrap_or_default()).collect::<Vec<_>>().join(\" \");\n    LilValue { l: 0, d: Some(result_str.into()) }\n}\n\n\npub fn fnc_list<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList { items: Vec::new() };\n    for i in 0..argc {\n        list.items.push(Rc::new(RefCell::new(argv[i].clone())));\n    }\n    LilValue { l: list.items.len(), d: None }\n}\n\n\npub fn fnc_indexof<T: Clone + PartialEq + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 {\n        return None;\n    }\n\n    fn lil_subst_to_list_wrap<T: Clone>(_: &LilStruct<T>, _: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_to_string_wrap<T: Clone + Debug>(_: &Rc<RefCell<LilValue<T>>>) -> String {\n        String::new()\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(index: i32) -> LilValue<T> {\n        LilValue { l: index as usize, d: None }\n    }\n    fn lil_free_list_wrap<T: Clone>(_: LilList<T>) {}\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut result = None;\n\n    for (index, item) in list.items.iter().enumerate() {\n        let item_str = lil_to_string_wrap(item);\n        let arg_str = lil_to_string_wrap(&Rc::new(RefCell::new(argv[1].clone())));\n        if item_str == arg_str {\n            result = Some(lil_alloc_integer_wrap(index as i32));\n            break;\n        }\n    }\n\n    lil_free_list_wrap(list);\n    result\n}\n\n\npub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\n\npub fn fnc_char<T: Clone + From<String> + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        return LilValue { l: 0, d: None };\n    }\n    let s = match &argv[0].d {\n        Some(val) => {\n            let mut buf = [0u8; 2];\n            buf[0] = format!(\"{:?}\", val).parse::<u8>().unwrap_or(0);\n            buf[1] = 0;\n            String::from_utf8_lossy(&buf).to_string()\n        },\n        None => String::new(),\n    };\n    LilValue { l: s.len(), d: Some(T::from(s)) }\n}\n\n\npub fn fnc_set<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_get_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: &LilValue<T>, access: i32) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n\n    let mut i = 0;\n    let mut var: Option<Rc<RefCell<LilVar<T>>>> = None;\n    let mut access = 1;\n    if argc == 0 { return None; }\n    if argv[0].d.as_ref().map_or(false, |d| d.to_string() == \"global\") {\n        i = 1;\n        access = 0;\n    }\n    while i < argc {\n        if argc == i + 1 {\n            return lil_get_var_wrap(lil, &argv[i].d.as_ref()?.to_string()).map(|v| v.borrow().v.clone());\n        }\n        var = lil_set_var_wrap(lil, &argv[i].d.as_ref()?.to_string(), &argv[i + 1], access);\n        i += 2;\n    }\n    var.map(|v| v.borrow().v.clone())\n}\n\n\npub fn fnc_jaileval<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n\n    fn lil_register_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _proc: LilFuncProc<T>) {}\n\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _depth: usize) -> Option<LilValue<T>> {\n        None\n    }\n\n    let mut base = 0;\n    if argc == 0 {\n        return None;\n    }\n    if lil_to_string_wrap(&argv[0]) == \"clean\" {\n        base = 1;\n        if argc == 1 {\n            return None;\n        }\n    }\n    let mut sublil = LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: String::new(),\n        env: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: LilValue { l: 0, d: None },\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: argv[0].d.as_ref().unwrap().clone(),\n        embed: String::new(),\n        embedlen: 0,\n    };\n    if base != 1 {\n        for i in lil.syscmds..lil.cmds {\n            let fnc = lil.cmd[i].clone();\n            if fnc.borrow().proc.is_none() {\n                continue;\n            }\n            lil_register_wrap(&mut sublil, &fnc.borrow().name, fnc.borrow().proc.unwrap());\n        }\n    }\n    let r = lil_parse_value_wrap(&mut sublil, &argv[base], 1);\n    r\n}\n\n\npub fn fnc_repstr<T: Clone + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 1 {\n        return LilValue { l: 0, d: None };\n    }\n    if argc < 3 {\n        return argv[0].clone();\n    }\n\n    let from = lil_to_string(&argv[1]);\n    let to = lil_to_string(&argv[2]);\n    if from.is_empty() {\n        return LilValue { l: 0, d: None };\n    }\n\n    let mut src = lil_to_string(&argv[0]);\n    let from_len = from.len();\n    let to_len = to.len();\n\n    while let Some(idx) = src.find(&from) {\n        let mut new_src = String::with_capacity(src.len() - from_len + to_len);\n        new_src.push_str(&src[..idx]);\n        new_src.push_str(&to);\n        new_src.push_str(&src[idx + from_len..]);\n        src = new_src;\n    }\n\n    lil_alloc_string(&src)\n}\n\n\npub fn fnc_foreach<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _flags: i32) {}\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut rlist = LilList { items: Vec::new() };\n    let mut listidx = 0;\n    let mut codeidx = 1;\n    let mut varname = \"i\".to_string();\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    if argc >= 3 {\n        varname = argv[0].d.as_ref().unwrap().to_string();\n        listidx = 1;\n        codeidx = 2;\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[listidx]);\n    for i in 0..list.items.len() {\n        let item = list.items[i].clone();\n        lil_set_var_wrap(lil, &varname, item, 3);\n        let rv = lil_parse_value_wrap(lil, &argv[codeidx], 0);\n        if rv.l != 0 {\n            rlist.items.push(Rc::new(RefCell::new(rv)));\n        }\n        if lil.env.borrow().breakrun || lil.error != 0 { break; }\n    }\n    let r = lil_list_to_value_wrap(&rlist, 1);\n    r\n}\n\n\n //编译报错信息：error[E0428]: the name `lil_to_string` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_local/temp.rs:142:1\n    |\n71  | pub fn lil_to_string<T: Clone>(val: &LilValue<T>) -> String {\n    | ----------------------------------------------------------- previous definition of the value `lil_to_string` here\n...\n142 | pub fn lil_to_string<T: Clone>(val: &LilValue<T>) -> String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_to_string` redefined here\n    |\n    = note: `lil_to_string` must be defined only once in the value namespace of this module\n\nerror[E0428]: the name `lil_find_local_var` is defined multiple times\n   --> ../../Output/crown/tmp/test-lil_fnc_local/temp.rs:693:1\n    |\n76  | pub fn lil_find_local_var<T: Clone>(lil: &LilStruct<T>, env: Rc<RefCell<LilEnv<T>>>, name: &str) -> bool {\n    | -------------------------------------------------------------------------------------------------------- previous definition of the value `lil_find_local_var` here\n...\n693 | pub fn lil_find_local_var<T: Clone>(lil: &LilStruct<T>, env: Rc<RefCell<LilEnv<T>>>, name: &str) -> bool {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `lil_find_local_var` redefined here\n    |\n    = note: `lil_find_local_var` must be defined only once in the value namespace of this module\n\nerror[E0412]: cannot find type `LilList` in this scope\n  --> ../../Output/crown/tmp/test-lil_fnc_local/temp.rs:88:35\n   |\n88 | fn lil_free_list<T: Clone>(_list: LilList<T>) {}\n   |                                   ^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `LilList` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_local/temp.rs:100:42\n    |\n100 | fn lil_list_append<T: Clone>(_list: &mut LilList<T>, _val: LilValue<T>) {}\n    |                                          ^^^^^^^ not found in this scope\n\nerror[E0412]: cannot find type `HashMap` in this scope\n   --> ../../Output/crown/tmp/test-lil_fnc_local/temp.rs:103:31\n    |\n103 | pub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    |                               ^^^^^^^ not found in this scope\n    |\n",
        "substitute": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\npub fn next_word<T: Clone>(lil: &mut LilStruct<T>) -> LilValue<T> {\n    let mut val;\n    let start;\n    skip_spaces(lil);\n    match lil.code.chars().nth(lil.head) {\n        Some('$') => val = get_dollarpart(lil),\n        Some('{') => {\n            let mut cnt = 1;\n            lil.head += 1;\n            val = alloc_value(None).unwrap();\n            while lil.head < lil.clen {\n                match lil.code.chars().nth(lil.head) {\n                    Some('{') => {\n                        lil.head += 1;\n                        cnt += 1;\n                        lil_append_char(Rc::new(RefCell::new(val.clone())), '{');\n                    },\n                    Some('}') => {\n                        lil.head += 1;\n                        cnt -= 1;\n                        if cnt == 0 { break; }\n                        else { lil_append_char(Rc::new(RefCell::new(val.clone())), '}'); }\n                    },\n                    Some(c) => lil_append_char(Rc::new(RefCell::new(val.clone())), c),\n                    None => break,\n                }\n            }\n        },\n        Some('[') => val = get_bracketpart(lil),\n        Some('\"') | Some('\\'') => {\n            let sc = lil.code.chars().nth(lil.head).unwrap();\n            lil.head += 1;\n            val = alloc_value(None).unwrap();\n            while lil.head < lil.clen {\n                match lil.code.chars().nth(lil.head) {\n                    Some('[') | Some('$') => {\n                        let tmp = if lil.code.chars().nth(lil.head).unwrap() == '$' { get_dollarpart(lil) } else { get_bracketpart(lil) };\n                        lil_append_val(&mut val, &tmp);\n                        lil_free_value(tmp);\n                        lil.head -= 1;\n                    },\n                    Some('\\\\') => {\n                        lil.head += 1;\n                        match lil.code.chars().nth(lil.head) {\n                            Some('b') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\x08'),\n                            Some('t') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\t'),\n                            Some('n') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\n'),\n                            Some('v') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\x0b'),\n                            Some('f') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\x0c'),\n                            Some('r') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\r'),\n                            Some('0') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\0'),\n                            Some('a') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\x07'),\n                            Some('c') => lil_append_char(Rc::new(RefCell::new(val.clone())), '}'),\n                            Some('o') => lil_append_char(Rc::new(RefCell::new(val.clone())), '{'),\n                            Some(c) => lil_append_char(Rc::new(RefCell::new(val.clone())), c),\n                            None => break,\n                        };\n                    },\n                    Some(c) if c == sc => {\n                        lil.head += 1;\n                        break;\n                    },\n                    Some(c) => lil_append_char(Rc::new(RefCell::new(val.clone())), c),\n                    None => break,\n                }\n                lil.head += 1;\n            }\n        },\n        _ => {\n            start = lil.head;\n            while lil.head < lil.clen && !lil.code.chars().nth(lil.head).map_or(true, |c| c.is_whitespace()) && !islilspecial(lil.code.chars().nth(lil.head).unwrap() as i8) {\n                lil.head += 1;\n            }\n            val = alloc_value_len(Some(lil.code[start..lil.head].to_string()), lil.head - start).unwrap();\n        }\n    }\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\n //编译报错信息：error: unknown character escape: `b`\n   --> ../../Output/crown/tmp/test-lil_substitute/temp.rs:496:96\n    |\n496 | ...                   Some('b') => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\b'),\n    |                                                                                          ^ unknown character escape\n    |\n    = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "register_stdcmds": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n\n\n\n\n\n\n\n\n\n\n\npub fn fnc_return<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    lil.env.borrow_mut().breakrun = true;\n    lil.env.borrow_mut().retval = if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() };\n    lil.env.borrow_mut().retval_set = true;\n    if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() }\n}\n\n\npub fn fnc_print<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_write_wrap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) {\n        // 空实现\n    }\n    fn lil_write_wrap<T: Clone>(lil: &LilStruct<T>, s: &str) {\n        // 空实现\n    }\n    fnc_write_wrap(lil, argc, argv);\n    lil_write_wrap(lil, \"\\n\");\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_error<T: Clone + std::fmt::Display>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let err_msg = if argc > 0 {\n        match &argv[0].d {\n            Some(d) => d.to_string(),\n            None => String::new(),\n        }\n    } else {\n        String::new()\n    };\n    lil.error = 1;\n    lil.err_msg = err_msg;\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_concat<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut r = LilValue { l: 0, d: Some(String::new().into()) };\n    if argc < 1 { return r; }\n    for i in 0..argc {\n        let list = argv[i].clone();\n        let tmp = list;\n        lil_append_val_wrap(&mut r, tmp);\n    }\n    r\n}\n\n\nfn lil_append_val_wrap<T: Clone>(dst: &mut LilValue<T>, src: LilValue<T>) {\n    if let Some(d) = &mut dst.d {\n        if let Some(s) = src.d {\n            *d = s;\n        }\n    }\n}\n\n\npub fn fnc_subst<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    fn lil_subst_to_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        val.clone()\n    }\n    Some(lil_subst_to_value_wrap(lil, &argv[0]))\n}\n\n\npub fn fnc_eval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(data: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d: data }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, ch: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, other: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_parse_value_wrap(lil, &argv[0], 0);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_parse_value_wrap(lil, &val, 0);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_try<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc < 1 {\n        return None;\n    }\n    if lil.error != 0 {\n        return None;\n    }\n    let mut r = lil_parse_value_wrap(lil, &argv[0], 0);\n    if lil.error != 0 {\n        lil.error = 0;\n        lil_free_value_wrap(r.clone());\n        if argc > 1 {\n            r = lil_parse_value_wrap(lil, &argv[1], 0);\n        } else {\n            r = LilValue { l: 0, d: None };\n        }\n    }\n    Some(r)\n}\n\n\npub fn fnc_charat<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer<T: Clone + Debug>(val: &LilValue<T>) -> i64 {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d).parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    let str = lil_to_string(&argv[0]);\n    let index = lil_to_integer(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    let chstr = &str[index..=index];\n    lil_alloc_string(chstr)\n}\n\n\npub fn fnc_indexof<T: Clone + PartialEq + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 {\n        return None;\n    }\n\n    fn lil_subst_to_list_wrap<T: Clone>(_: &LilStruct<T>, _: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_to_string_wrap<T: Clone + Debug>(_: &Rc<RefCell<LilValue<T>>>) -> String {\n        String::new()\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(index: i32) -> LilValue<T> {\n        LilValue { l: index as usize, d: None }\n    }\n    fn lil_free_list_wrap<T: Clone>(_: LilList<T>) {}\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut result = None;\n\n    for (index, item) in list.items.iter().enumerate() {\n        let item_str = lil_to_string_wrap(item);\n        let arg_str = lil_to_string_wrap(&Rc::new(RefCell::new(argv[1].clone())));\n        if item_str == arg_str {\n            result = Some(lil_alloc_integer_wrap(index as i32));\n            break;\n        }\n    }\n\n    lil_free_list_wrap(list);\n    result\n}\n\n\npub fn fnc_expr<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_eval_expr_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(d: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, c: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_eval_expr_wrap(lil, &argv[0]);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_eval_expr_wrap(lil, &val);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_append<T: Clone + Debug + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let mut base = 1;\n    let mut access = 1;\n    let varname = argv[0].d.as_ref().unwrap().to_string();\n    let mut varname = if varname == \"global\" {\n        if argc < 3 { return LilValue { l: 0, d: None }; }\n        base = 2;\n        access = 0;\n        argv[1].d.as_ref().unwrap().to_string()\n    } else {\n        varname\n    };\n    let mut list = lil_subst_to_list(lil, lil_get_var(lil, &varname));\n    for i in base..argc {\n        lil_list_append(&mut list, argv[i].clone());\n    }\n    let r = lil_list_to_value(&list, 1);\n    lil_free_list(list);\n    lil_set_var(lil, &varname, r.clone(), access);\n    r\n}\n\n\npub fn fnc_filter<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_alloc_list_wrap<T: Clone>() -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _scope: i32) {}\n    fn lil_eval_expr_wrap<T: Clone>(_lil: &mut LilStruct<T>, _expr: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(_val: &LilValue<T>) -> bool {\n        false\n    }\n    fn lil_list_append_wrap<T: Clone>(_list: &mut LilList<T>, _val: Rc<RefCell<LilValue<T>>>) {}\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _deep: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut varname = \"x\".to_string();\n    let mut base = 0;\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    if argc > 2 {\n        base = 1;\n        varname = argv[0].d.as_ref().unwrap().to_string();\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[base]);\n    let mut filtered = lil_alloc_list_wrap();\n\n    for i in 0..list.items.len() {\n        if lil.env.borrow().breakrun { break; }\n        lil_set_var_wrap(lil, &varname, list.items[i].clone(), 3);\n        let r = lil_eval_expr_wrap(lil, &argv[base + 1]);\n        if lil_to_boolean_wrap(&r) {\n            lil_list_append_wrap(&mut filtered, list.items[i].clone());\n        }\n    }\n\n    let r = lil_list_to_value_wrap(&filtered, 1);\n    r\n}\n\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\n\npub fn fnc_codeat<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i32 {\n        match &val.d {\n            Some(v) => v.to_string().parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_integer_wrap<T: Clone>(val: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let index: usize;\n    let str: String;\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    str = lil_to_string_wrap(&argv[0]);\n    index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    lil_alloc_integer_wrap(str.chars().nth(index).unwrap() as i32)\n}\n\n\nfn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    None\n}\n\n\npub fn fnc_catcher<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        LilValue {\n            l: lil.catcher.len(),\n            d: Some(T::from(lil.catcher.clone())),\n        }\n    } else {\n        let catcher = argv[0].d.as_ref().unwrap().to_string();\n        lil.catcher = if !catcher.is_empty() { catcher } else { String::new() };\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n}\n\n\npub fn fnc_upeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let fnc_eval_wrap = |lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]| -> LilValue<T> {\n        lil.empty.clone()\n    };\n    \n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    let r;\n    if Rc::ptr_eq(&lil.rootenv, &thisenv) {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.env = match thisenv.borrow().parent.as_ref() {\n        Some(parent) => Rc::clone(parent),\n        None => Rc::clone(&thisenv),\n    };\n    lil.downenv = Rc::clone(&thisenv);\n    r = fnc_eval_wrap(lil, argc, argv);\n    lil.env = thisenv;\n    lil.downenv = thisdownenv;\n    r\n}\n\n\npub fn fnc_rand<T: Clone + From<f64>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    LilValue {\n        l: 8,\n        d: Some(0.5f64.into())\n    }\n}\n\n\npub fn fnc_store<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        if let Some(ref d) = val.d {\n            format!(\"{:?}\", d)\n        } else {\n            String::new()\n        }\n    }\n\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    if let Some(proc) = lil.callback.get(3).copied() {\n        let name = lil_to_string_wrap(&argv[0]);\n        let data = lil_to_string_wrap(&argv[1]);\n        proc(lil, &name, &[argv[1].clone()]);\n    } else {\n        let filename = lil_to_string_wrap(&argv[0]);\n        let buffer = lil_to_string_wrap(&argv[1]);\n        if let Ok(mut file) = std::fs::File::create(&filename) {\n            let _ = std::io::Write::write_all(&mut file, buffer.as_bytes());\n        }\n    }\n    argv[1].clone()\n}\n\n\npub fn fnc_substr<T: Clone + Debug + FromStr + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let str = match &argv[0].d {\n        Some(s) => s.to_string(),\n        None => return LilValue { l: 0, d: None },\n    };\n    if str.is_empty() { return LilValue { l: 0, d: None }; }\n    let slen = str.len();\n    let start = match argv[1].d.as_ref() {\n        Some(s) => s.to_string().parse::<usize>().unwrap_or(0),\n        None => 0,\n    };\n    let end = if argc > 2 {\n        match argv[2].d.as_ref() {\n            Some(s) => s.to_string().parse::<usize>().unwrap_or(slen),\n            None => slen,\n        }\n    } else { slen };\n    let end = if end > slen { slen } else { end };\n    if start >= end { return LilValue { l: 0, d: None }; }\n    let result = str.chars().skip(start).take(end - start).collect::<String>();\n    LilValue { l: result.len(), d: Some(result.parse().unwrap_or_else(|_| panic!(\"Failed to parse string\"))) }\n}\n\n\npub fn fnc_inc<T: Clone + From<u32>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let arg0 = if let Some(d) = &argv[0].d { d.clone() } else { return None; };\n    let arg1 = if argc > 1 { \n        if let Some(d) = &argv[1].d { d.clone() } else { return None; }\n    } else { T::from(1) };\n    Some(LilValue { l: 0, d: Some(arg0) })\n}\n\n\npub fn fnc_exit<T: Clone>(lil: Rc<RefCell<LilStruct<T>>>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Option<Rc<RefCell<LilValue<T>>>> {\n    let lil_ref = lil.borrow();\n    if let Some(proc) = lil_ref.callback.get(0) {\n        let arg = if argc > 0 { Some(argv[0].clone()) } else { None };\n        let lil_wrap = &*lil_ref;\n        proc(lil_wrap, \"\", &[]);\n    }\n    None\n}\n\n\nfn hm_put<T>(map: &mut HashMap<T>, key: &str, value: Option<T>) {\n}\n\n\npub fn fnc_for<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_eval_expr_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(val: &LilValue<T>) -> bool {\n        false\n    }\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 4 { return LilValue { l: 0, d: None }; }\n    let _ = lil_parse_value_wrap(lil, &argv[0], 0);\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr_wrap(lil, &argv[1]);\n        if val.l == 0 || lil.error != 0 { return LilValue { l: 0, d: None }; }\n        if !lil_to_boolean_wrap(&val) {\n            break;\n        }\n        r = lil_parse_value_wrap(lil, &argv[3], 0);\n        let _ = lil_parse_value_wrap(lil, &argv[2], 0);\n    }\n    r\n}\n\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\n\npub fn fnc_slice<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_integer_wrap<T: Clone>(val: &LilValue<T>) -> i64 {\n        0\n    }\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(list: &LilList<T>, _flag: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    \n    let mut from = lil_to_integer_wrap(&argv[1]);\n    if from < 0 { from = 0; }\n    \n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut to = if argc > 2 { lil_to_integer_wrap(&argv[2]) } else { list.items.len() as i64 };\n    if to > list.items.len() as i64 { to = list.items.len() as i64; }\n    if to < from { to = from; }\n    \n    let mut slice = LilList { items: Vec::new() };\n    for i in from as usize..to as usize {\n        slice.items.push(list.items[i].clone());\n    }\n    \n    let r = lil_list_to_value_wrap(&slice, 1);\n    r\n}\n\n\npub fn fnc_func<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Rc<RefCell<LilValue<T>>> {\n    let name: Rc<RefCell<LilValue<T>>>;\n    let cmd: Rc<RefCell<LilFunc<T>>>;\n    let fargs: LilList<T>;\n    \n    fn lil_clone_value_wrap<T: Clone>(value: &Rc<RefCell<LilValue<T>>>) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new((*value.borrow()).clone()))\n    }\n    \n    fn lil_to_string_wrap<T: Clone + ToString>(value: &Rc<RefCell<LilValue<T>>>) -> String {\n        value.borrow().d.as_ref().map_or(String::new(), |v| v.to_string())\n    }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, value: &Rc<RefCell<LilValue<T>>>) -> LilList<T> {\n        LilList { items: vec![Rc::clone(value)] }\n    }\n    \n    fn add_func_wrap<T: Clone>(_lil: &LilStruct<T>, name: &str) -> Rc<RefCell<LilFunc<T>>> {\n        Rc::new(RefCell::new(LilFunc {\n            name: name.to_string(),\n            code: LilValue { l: 0, d: None },\n            argnames: LilList { items: vec![] },\n            proc: None,\n        }))\n    }\n    \n    fn lil_unused_name_wrap<T: Clone>(_lil: &LilStruct<T>, prefix: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: None }))\n    }\n    \n    fn lil_alloc_string_wrap<T: Clone + From<String>>(s: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: Some(s.to_string().into()) }))\n    }\n\n    if argc < 1 {\n        return Rc::new(RefCell::new(LilValue { l: 0, d: None }));\n    }\n    if argc >= 3 {\n        name = lil_clone_value_wrap(&argv[0]);\n        fargs = lil_subst_to_list_wrap(lil, &argv[1]);\n        cmd = add_func_wrap(lil, &lil_to_string_wrap(&argv[0]));\n        cmd.borrow_mut().argnames = fargs;\n        cmd.borrow_mut().code = (*argv[2].borrow()).clone();\n    } else {\n        name = lil_unused_name_wrap(lil, \"anonymous-function\");\n        if argc < 2 {\n            let tmp = lil_alloc_string_wrap(\"args\");\n            fargs = lil_subst_to_list_wrap(lil, &tmp);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[0].borrow()).clone();\n        } else {\n            fargs = lil_subst_to_list_wrap(lil, &argv[0]);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[1].borrow()).clone();\n        }\n    }\n    name\n}\n\n\npub fn fnc_lmap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        unimplemented!()\n    }\n    \n    fn lil_list_get_wrap<T: Clone>(list: &Rc<RefCell<LilList<T>>>, index: usize) -> LilValue<T> {\n        unimplemented!()\n    }\n    \n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: LilValue<T>, flag: i32) {\n        unimplemented!()\n    }\n    \n    fn lil_free_list_wrap<T: Clone>(list: Rc<RefCell<LilList<T>>>) {\n        unimplemented!()\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    for i in 1..argc {\n        let var_name = lil_to_string_wrap(&argv[i]);\n        let value = lil_list_get_wrap(&list, i - 1);\n        lil_set_var_wrap(lil, &var_name, value, 1);\n    }\n    lil_free_list_wrap(list);\n    None\n}\n\n\npub fn fnc_unusedname(lil: &LilStruct<String>, argc: usize, argv: &[LilValue<String>]) -> LilValue<String> {\n    fn lil_to_string_wrap(val: &LilValue<String>) -> String {\n        match &val.d {\n            Some(v) => v.clone(),\n            None => String::new(),\n        }\n    }\n    fn lil_unused_name_wrap(lil: &LilStruct<String>, name: &str) -> LilValue<String> {\n        LilValue {\n            l: name.len(),\n            d: Some(name.to_string()),\n        }\n    }\n    let arg = if argc > 0 { lil_to_string_wrap(&argv[0]) } else { \"unusedname\".to_string() };\n    lil_unused_name_wrap(lil, &arg)\n}\n\n\npub fn fnc_streq<T: Clone + FromStr + PartialEq + std::fmt::Display + From<bool>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return lil.empty.clone(); }\n    let s1 = argv[0].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    let s2 = argv[1].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    LilValue { l: 1, d: Some((s1 == s2).into()) }\n}\n\n\npub fn fnc_reflect<T: Clone + Debug + From<String> + From<&'static str> + From<i64> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let type_str = lil_to_string(&argv[0]);\n    match type_str.as_str() {\n        \"version\" => Some(LilValue { l: 3, d: Some(\"0.1\".into()) }),\n        \"args\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().argnames.items.is_empty() { return None; }\n            Some(func.unwrap().borrow().argnames.items[0].borrow().clone())\n        },\n        \"body\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().proc.is_some() { return None; }\n            Some(func.unwrap().borrow().code.clone())\n        },\n        \"func-count\" => Some(LilValue { l: 0, d: Some((lil.cmds as i64).into()) }),\n        \"funcs\" => {\n            let mut funcs = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.cmds {\n                funcs.items.push(Rc::new(RefCell::new(LilValue { l: lil.cmd[i].borrow().name.len(), d: Some(lil.cmd[i].borrow().name.clone().into()) })));\n            }\n            Some(LilValue { l: funcs.items.len(), d: None })\n        },\n        \"vars\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                for i in 0..e.borrow().vars {\n                    vars.items.push(Rc::new(RefCell::new(LilValue { l: e.borrow().var[i].borrow().n.len(), d: Some(e.borrow().var[i].borrow().n.clone().into()) })));\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"globals\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.rootenv.borrow().vars {\n                vars.items.push(Rc::new(RefCell::new(LilValue { l: lil.rootenv.borrow().var[i].borrow().n.len(), d: Some(lil.rootenv.borrow().var[i].borrow().n.clone().into()) })));\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"has-func\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            if lil.cmdmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                Some(LilValue { l: 1, d: Some(\"1\".into()) })\n            } else {\n                None\n            }\n        },\n        \"has-var\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                if e.borrow().varmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            None\n        },\n        \"has-global\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            for i in 0..lil.rootenv.borrow().vars {\n                if target == lil.rootenv.borrow().var[i].borrow().n { \n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n            }\n            None\n        },\n        \"error\" => lil.err_msg.is_empty().then(|| LilValue { l: lil.err_msg.len(), d: Some(lil.err_msg.clone().into()) }),\n        \"dollar-prefix\" => {\n            if argc == 1 { return Some(LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) }); }\n            let r = LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) };\n            lil.dollarprefix = lil_to_string(&argv[1]);\n            Some(r)\n        },\n        \"this\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(LilValue { l: lil.catcher.len(), d: Some(lil.catcher.clone().into()) }); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return Some(LilValue { l: lil.rootcode.len(), d: Some(lil.rootcode.clone().into()) }); }\n                if let Some(func) = &e.borrow().func { return Some(func.borrow().code.clone()); }\n            }\n            None\n        },\n        \"name\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(e.borrow().catcher_for.clone()); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return None; }\n                if let Some(func) = &e.borrow().func { return Some(LilValue { l: func.borrow().name.len(), d: Some(func.borrow().name.clone().into()) }); }\n            }\n            None\n        },\n        _ => None\n    }\n}\n\n\npub fn fnc_list<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList { items: Vec::new() };\n    for i in 0..argc {\n        list.items.push(Rc::new(RefCell::new(argv[i].clone())));\n    }\n    LilValue { l: list.items.len(), d: None }\n}\n\n\npub fn fnc_char<T: Clone + From<String> + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        return LilValue { l: 0, d: None };\n    }\n    let s = match &argv[0].d {\n        Some(val) => {\n            let mut buf = [0u8; 2];\n            buf[0] = format!(\"{:?}\", val).parse::<u8>().unwrap_or(0);\n            buf[1] = 0;\n            String::from_utf8_lossy(&buf).to_string()\n        },\n        None => String::new(),\n    };\n    LilValue { l: s.len(), d: Some(T::from(s)) }\n}\n\n\npub fn fnc_rtrim<T: Clone + Debug + FromStr>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn real_trim(s: String, pat: String, _left: i32, _right: i32) -> LilValue<String> {\n        let trimmed = s.trim_end_matches(&pat[..]);\n        LilValue {\n            l: trimmed.len(),\n            d: Some(trimmed.to_string()),\n        }\n    }\n\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let pat = if argc < 2 { \" \\u{000C}\\n\\r\\t\\u{000B}\".to_string() } else { lil_to_string(&argv[1]) };\n    let result = real_trim(s, pat, 0, 1);\n    LilValue { l: result.l, d: Some(result.d.unwrap().parse().ok().unwrap()) }\n}\n\n\npub fn fnc_result<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc > 0 {\n        lil.env.borrow_mut().retval = argv[0].clone();\n        lil.env.borrow_mut().retval_set = true;\n    }\n    if lil.env.borrow().retval_set {\n        Some(lil.env.borrow().retval.clone())\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_downeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    let upenv = Rc::clone(&lil.env);\n    let downenv = Rc::clone(&lil.downenv);\n    if downenv.borrow().parent.is_none() {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.downenv = Rc::new(RefCell::new(LilEnv {\n        parent: None,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    lil.env = Rc::clone(&downenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = downenv;\n    lil.env = upenv;\n    r\n}\n\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n\npub fn add_func<T: Clone + Debug>(lil: &mut LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    let cmd = find_cmd(lil, name);\n    if let Some(cmd) = cmd {\n        let mut cmd_ref = cmd.borrow_mut();\n        if cmd_ref.argnames.items.len() > 0 {\n            let argnames = cmd_ref.argnames.clone();\n            lil_free_list(argnames);\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd_ref.code.clone()))));\n        cmd_ref.argnames = LilList { items: Vec::new() };\n        cmd_ref.code = LilValue { l: 0, d: None };\n        cmd_ref.proc = None;\n        return Some(Rc::clone(&cmd));\n    }\n    let new_cmd = Rc::new(RefCell::new(LilFunc {\n        name: strclone(name).unwrap(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: None,\n    }));\n    lil.cmd.push(Rc::clone(&new_cmd));\n    lil.cmds += 1;\n    hm_put(&mut lil.cmdmap, name, Some(Rc::clone(&new_cmd)));\n    Some(new_cmd)\n}\n\n\npub fn fnc_count<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    let mut buff = String::with_capacity(64);\n    if argc == 0 {\n        return LilValue { l: 1, d: Some(T::from(\"0\".to_string())) };\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    buff.push_str(&list.borrow().items.len().to_string());\n    LilValue { l: buff.len(), d: Some(T::from(buff)) }\n}\n\n\npub fn fnc_watch<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    let wcode = lil_to_string(&argv[argc - 1]);\n    for i in 0..(argc - 1) {\n        let vname = lil_to_string(&argv[i]);\n        if vname.is_empty() { continue; }\n        let mut v = lil_find_var(lil, lil.env.clone(), &vname);\n        if v.is_none() {\n            let empty_val = LilValue { l: 0, d: None };\n            lil_set_var(lil, &vname, empty_val, 2);\n            v = lil_find_var(lil, lil.env.clone(), &vname);\n        }\n        if let Some(var) = v {\n            var.borrow_mut().w = if !wcode.is_empty() { wcode.clone() } else { String::new() };\n        }\n    }\n    None\n}\n\n\npub fn fnc_jaileval<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n\n    fn lil_register_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _proc: LilFuncProc<T>) {}\n\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _depth: usize) -> Option<LilValue<T>> {\n        None\n    }\n\n    let mut base = 0;\n    if argc == 0 {\n        return None;\n    }\n    if lil_to_string_wrap(&argv[0]) == \"clean\" {\n        base = 1;\n        if argc == 1 {\n            return None;\n        }\n    }\n    let mut sublil = LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: String::new(),\n        env: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: LilValue { l: 0, d: None },\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: argv[0].d.as_ref().unwrap().clone(),\n        embed: String::new(),\n        embedlen: 0,\n    };\n    if base != 1 {\n        for i in lil.syscmds..lil.cmds {\n            let fnc = lil.cmd[i].clone();\n            if fnc.borrow().proc.is_none() {\n                continue;\n            }\n            lil_register_wrap(&mut sublil, &fnc.borrow().name, fnc.borrow().proc.unwrap());\n        }\n    }\n    let r = lil_parse_value_wrap(&mut sublil, &argv[base], 1);\n    r\n}\n\n\npub fn fnc_topeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    lil.env = Rc::clone(&lil.rootenv);\n    lil.downenv = Rc::clone(&thisenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = thisdownenv;\n    lil.env = thisenv;\n    r\n}\n\n\npub fn fnc_index<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: vec![Rc::new(RefCell::new(val.clone()))] }\n    }\n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i64 {\n        if let Some(d) = &val.d {\n            if let Ok(n) = i64::from_str(&d.to_string()) {\n                return n;\n            }\n        }\n        0\n    }\n    fn lil_free_list_wrap<T: Clone>(_list: LilList<T>) {}\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 2 { return r; }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index < list.items.len() {\n        r = list.items[index].borrow().clone();\n    }\n    lil_free_list_wrap(list);\n    r\n}\n\n\npub fn fnc_foreach<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _flags: i32) {}\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut rlist = LilList { items: Vec::new() };\n    let mut listidx = 0;\n    let mut codeidx = 1;\n    let mut varname = \"i\".to_string();\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    if argc >= 3 {\n        varname = argv[0].d.as_ref().unwrap().to_string();\n        listidx = 1;\n        codeidx = 2;\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[listidx]);\n    for i in 0..list.items.len() {\n        let item = list.items[i].clone();\n        lil_set_var_wrap(lil, &varname, item, 3);\n        let rv = lil_parse_value_wrap(lil, &argv[codeidx], 0);\n        if rv.l != 0 {\n            rlist.items.push(Rc::new(RefCell::new(rv)));\n        }\n        if lil.env.borrow().breakrun || lil.error != 0 { break; }\n    }\n    let r = lil_list_to_value_wrap(&rlist, 1);\n    r\n}\n\n\npub fn fnc_read<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let buffer;\n    if argc < 1 {\n        return None;\n    }\n    if let Some(proc) = lil.callback.get(2) {\n        let proc_wrap = |lil: &LilStruct<T>, name: &str| -> String {\n            let args = vec![LilValue { l: name.len(), d: Some(T::from(name.to_string())) }];\n            let result = proc(lil, \"read\", &args);\n            if let Some(s) = result.d {\n                return s.as_ref().to_string();\n            }\n            String::new()\n        };\n        buffer = proc_wrap(lil, argv[0].d.as_ref()?.as_ref());\n    } else {\n        let filename = argv[0].d.as_ref()?.as_ref();\n        let mut file = match std::fs::File::open(filename) {\n            Ok(f) => f,\n            Err(_) => return None,\n        };\n        let size = match file.metadata() {\n            Ok(m) => m.len() as usize,\n            Err(_) => return None,\n        };\n        let mut buf = vec![0; size];\n        if let Err(_) = file.read_exact(&mut buf) {\n            return None;\n        }\n        buffer = String::from_utf8_lossy(&buf).into_owned();\n    }\n    Some(LilValue { l: buffer.len(), d: Some(T::from(buffer)) })\n}\n\n\npub fn fnc_while<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut r: Option<LilValue<T>> = None;\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if lil_to_string(&argv[0]) == \"not\" {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr(lil, &argv[base]);\n        if val.is_none() || lil.error != 0 { return None; }\n        let mut v = lil_to_boolean(&val.unwrap());\n        if not { v = !v; }\n        if !v {\n            break;\n        }\n        if r.is_some() {\n            r = None;\n        }\n        r = lil_parse_value(lil, &argv[base + 1], 0);\n    }\n    r\n}\n\n\npub fn fnc_set<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_get_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: &LilValue<T>, access: i32) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n\n    let mut i = 0;\n    let mut var: Option<Rc<RefCell<LilVar<T>>>> = None;\n    let mut access = 1;\n    if argc == 0 { return None; }\n    if argv[0].d.as_ref().map_or(false, |d| d.to_string() == \"global\") {\n        i = 1;\n        access = 0;\n    }\n    while i < argc {\n        if argc == i + 1 {\n            return lil_get_var_wrap(lil, &argv[i].d.as_ref()?.to_string()).map(|v| v.borrow().v.clone());\n        }\n        var = lil_set_var_wrap(lil, &argv[i].d.as_ref()?.to_string(), &argv[i + 1], access);\n        i += 2;\n    }\n    var.map(|v| v.borrow().v.clone())\n}\n\n\npub fn fnc_split<T: Clone + ToString + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList::<T> { items: Vec::new() };\n    let mut sep = \" \".to_string();\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    if argc > 1 {\n        sep = argv[1].d.as_ref().map(|x| x.to_string()).unwrap_or_else(|| \" \".to_string());\n        if sep.is_empty() { return argv[0].clone(); }\n    }\n    let mut val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n    let str = argv[0].d.as_ref().map(|x| x.to_string()).unwrap_or_default();\n    for c in str.chars() {\n        if sep.contains(c) {\n            list.items.push(Rc::new(RefCell::new(val)));\n            val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n        } else {\n            if let Some(s) = val.d.as_mut() {\n                *s = format!(\"{}{}\", s.to_string(), c).into();\n            }\n        }\n    }\n    list.items.push(Rc::new(RefCell::new(val)));\n    let result_str = list.items.iter().map(|x| x.borrow().d.as_ref().map(|x| x.to_string()).unwrap_or_default()).collect::<Vec<_>>().join(\" \");\n    LilValue { l: 0, d: Some(result_str.into()) }\n}\n\n\nfn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\n\npub fn lil_register<T: Clone>(lil: &mut LilStruct<T>, name: &str, proc: LilFuncProc<T>) {\n    let func = Rc::new(RefCell::new(LilFunc {\n        name: name.to_string(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: Some(proc),\n    }));\n    lil.cmd.push(func.clone());\n    lil.cmds += 1;\n}\n\n\npub fn fnc_write<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut msg = String::new();\n    for i in 0..argc {\n        if i != 0 {\n            msg.push(' ');\n        }\n        msg.push_str(&argv[i].d.as_ref().unwrap().to_string());\n    }\n    println!(\"{}\", msg);\n    LilValue { l: 0, d: None }\n}\n\n\npub fn fnc_if<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if argv[0].d.as_ref().map_or(false, |s| s.to_string() == \"not\") {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    let val = lil_eval_expr(lil, &argv[base]);\n    if val.is_none() || lil.error != 0 { return None; }\n    let v = lil_to_boolean(&val.unwrap());\n    let v = if not { !v } else { v };\n    if v {\n        lil_parse_value(lil, &argv[base + 1], 0)\n    } else if argc > base + 2 {\n        lil_parse_value(lil, &argv[base + 2], 0)\n    } else {\n        None\n    }\n}\n\n\npub fn fnc_length<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(value: i64) -> LilValue<T> {\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n    let mut total = 0;\n    for (i, arg) in argv.iter().enumerate() {\n        if i != 0 {\n            total += 1;\n        }\n        let s = lil_to_string_wrap(arg);\n        total += s.len();\n    }\n    lil_alloc_integer_wrap(total as i64)\n}\n\n\npub fn fnc_strpos<T: Clone + From<i32> + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let hay;\n    let str;\n    let mut min = 0;\n    if argc < 2 {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    hay = argv[0].d.as_ref().unwrap().to_string();\n    if argc > 2 {\n        min = argv[2].d.as_ref().unwrap().to_string().parse::<usize>().unwrap();\n        if min >= hay.len() {\n            return LilValue { l: 0, d: Some(T::from(-1)) };\n        }\n    }\n    str = hay[min..].find(&argv[1].d.as_ref().unwrap().to_string());\n    if str.is_none() {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    LilValue { l: 0, d: Some(T::from(str.unwrap() as i32)) }\n}\n\n\npub fn fnc_strcmp<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    let s1 = lil_to_string_wrap(&argv[0]);\n    let s2 = lil_to_string_wrap(&argv[1]);\n    LilValue { l: s1.cmp(&s2) as usize, d: None }\n}\n\n\npub fn fnc_repstr<T: Clone + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 1 {\n        return LilValue { l: 0, d: None };\n    }\n    if argc < 3 {\n        return argv[0].clone();\n    }\n\n    let from = lil_to_string(&argv[1]);\n    let to = lil_to_string(&argv[2]);\n    if from.is_empty() {\n        return LilValue { l: 0, d: None };\n    }\n\n    let mut src = lil_to_string(&argv[0]);\n    let from_len = from.len();\n    let to_len = to.len();\n\n    while let Some(idx) = src.find(&from) {\n        let mut new_src = String::with_capacity(src.len() - from_len + to_len);\n        new_src.push_str(&src[..idx]);\n        new_src.push_str(&to);\n        new_src.push_str(&src[idx + from_len..]);\n        src = new_src;\n    }\n\n    lil_alloc_string(&src)\n}\n\n\npub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n\npub fn fnc_rename<T: Clone + Debug + From<String>>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let oldname = lil_to_string(&argv[0]);\n    let newname = lil_to_string(&argv[1]);\n    if argc < 2 {\n        return None;\n    }\n\n    let func = find_cmd(lil, &oldname);\n    if func.is_none() {\n        let msg = format!(\"unknown function '{}'\", oldname);\n        lil_set_error_at(lil, lil.head, &msg);\n        return None;\n    }\n    let func = func.unwrap();\n\n    let r = lil_alloc_string(&func.borrow().name);\n    if !newname.is_empty() {\n        hm_put(&mut lil.cmdmap, &oldname, None);\n        hm_put(&mut lil.cmdmap, &newname, Some(func.clone()));\n        func.borrow_mut().name = newname.clone();\n    } else {\n        del_func(lil, &func);\n    }\n\n    Some(LilValue { l: r.l, d: r.d.map(|s| s.into()) })\n}\n\n\npub fn fnc_dec<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        String::new()\n    }\n    \n    fn lil_to_double_wrap<T: Clone>(val: &LilValue<T>) -> f64 {\n        0.0\n    }\n    \n    fn real_inc_wrap<T: Clone>(lil: &LilStruct<T>, s: String, d: f64) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    real_inc_wrap(lil, lil_to_string_wrap(&argv[0]), -(if argc > 1 { lil_to_double_wrap(&argv[1]) } else { 1.0 }))\n}\n\n\npub fn fnc_quote<T: Clone + AsRef<str> + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    let mut r = LilValue { l: 0, d: None };\n    for i in 0..argc {\n        if i != 0 {\n            let lil_append_char_wrap = |r: &mut LilValue<T>, c: char| {\n                if let Some(ref mut data) = r.d {\n                    let mut s = String::new();\n                    s.push_str(data.as_ref());\n                    s.push(c);\n                    r.d = Some(T::from(s));\n                }\n            };\n            lil_append_char_wrap(&mut r, ' ');\n        }\n        let lil_append_val_wrap = |r: &mut LilValue<T>, val: &LilValue<T>| {\n            if let (Some(ref mut dst_data), Some(ref src_data)) = (&mut r.d, &val.d) {\n                let mut s = String::new();\n                s.push_str(dst_data.as_ref());\n                s.push_str(src_data.as_ref());\n                r.d = Some(T::from(s));\n            }\n        };\n        lil_append_val_wrap(&mut r, &argv[i]);\n    }\n    Some(r)\n}\n\n\n\npub fn register_stdcmds<T: Clone + Debug + From<String> + FromStr + ToString>(lil: &mut LilStruct<T>) {\n    lil_register(lil, \"reflect\", fnc_reflect);\n    lil_register(lil, \"func\", fnc_func);\n    lil_register(lil, \"rename\", fnc_rename);\n    lil_register(lil, \"unusedname\", fnc_unusedname);\n    lil_register(lil, \"quote\", fnc_quote);\n    lil_register(lil, \"set\", fnc_set);\n    lil_register(lil, \"local\", fnc_local);\n    lil_register(lil, \"write\", fnc_write);\n    lil_register(lil, \"print\", fnc_print);\n    lil_register(lil, \"eval\", fnc_eval);\n    lil_register(lil, \"topeval\", fnc_topeval);\n    lil_register(lil, \"upeval\", fnc_upeval);\n    lil_register(lil, \"downeval\", fnc_downeval);\n    lil_register(lil, \"enveval\", fnc_enveval);\n    lil_register(lil, \"jaileval\", fnc_jaileval);\n    lil_register(lil, \"count\", fnc_count);\n    lil_register(lil, \"index\", fnc_index);\n    lil_register(lil, \"indexof\", fnc_indexof);\n    lil_register(lil, \"filter\", fnc_filter);\n    lil_register(lil, \"list\", fnc_list);\n    lil_register(lil, \"append\", fnc_append);\n    lil_register(lil, \"slice\", fnc_slice);\n    lil_register(lil, \"subst\", fnc_subst);\n    lil_register(lil, \"concat\", fnc_concat);\n    lil_register(lil, \"foreach\", fnc_foreach);\n    lil_register(lil, \"return\", fnc_return);\n    lil_register(lil, \"result\", fnc_result);\n    lil_register(lil, \"expr\", fnc_expr);\n    lil_register(lil, \"inc\", fnc_inc);\n    lil_register(lil, \"dec\", fnc_dec);\n    lil_register(lil, \"read\", fnc_read);\n    lil_register(lil, \"store\", fnc_store);\n    lil_register(lil, \"if\", fnc_if);\n    lil_register(lil, \"while\", fnc_while);\n    lil_register(lil, \"for\", fnc_for);\n    lil_register(lil, \"char\", fnc_char);\n    lil_register(lil, \"charat\", fnc_charat);\n    lil_register(lil, \"codeat\", fnc_codeat);\n    lil_register(lil, \"substr\", fnc_substr);\n    lil_register(lil, \"strpos\", fnc_strpos);\n    lil_register(lil, \"length\", fnc_length);\n    lil_register(lil, \"trim\", fnc_trim);\n    lil_register(lil, \"ltrim\", fnc_ltrim);\n    lil_register(lil, \"rtrim\", fnc_rtrim);\n    lil_register(lil, \"strcmp\", fnc_strcmp);\n    lil_register(lil, \"streq\", fnc_streq);\n    lil_register(lil, \"repstr\", fnc_repstr);\n    lil_register(lil, \"split\", fnc_split);\n    lil_register(lil, \"try\", fnc_try);\n    lil_register(lil, \"error\", fnc_error);\n    lil_register(lil, \"exit\", fnc_exit);\n    lil_register(lil, \"source\", fnc_source);\n    lil_register(lil, \"lmap\", fnc_lmap);\n    lil_register(lil, \"rand\", fnc_rand);\n    lil_register(lil, \"catcher\", fnc_catcher);\n    lil_register(lil, \"watch\", fnc_watch);\n    lil.syscmds = lil.cmds;\n}\n\npub fn fnc_local<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    for i in 0..argc {\n        let varname = match &argv[i].d {\n            Some(s) => s.to_string(),\n            None => continue,\n        };\n        if find_cmd(lil, &varname).is_none() {\n            hm_put(&mut lil.env.borrow_mut().varmap, &varname, Some(Rc::new(RefCell::new(LilVar {\n                n: varname.clone(),\n                w: String::new(),\n                env: Rc::clone(&lil.env),\n                v: LilValue { l: 0, d: None },\n            }))));\n        }\n    }\n    None\n}\n\npub fn fnc_source<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let filename = match &argv[0].d {\n        Some(s) => s.as_ref(),\n        None => return None,\n    };\n    let mut contents = String::new();\n    if let Some(proc) = lil.callback[4] {\n        let result = proc(lil, filename);\n        contents = result.to_string();\n    } else if let Some(proc) = lil.callback[2] {\n        let result = proc(lil, filename);\n        contents = result.to_string();\n    } else {\n        let mut file = match std::fs::File::open(filename) {\n            Ok(f) => f,\n            Err(_) => return None,\n        };\n        if let Err(_) = file.read_to_string(&mut contents) {\n            return None;\n        }\n    }\n    Some(LilValue { l: contents.len(), d: Some(contents.parse().unwrap()) })\n}\n\npub fn fnc_enveval<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let codeindex = if argc == 1 { 0 } else { 2 };\n    let mut invars = Vec::new();\n    let mut outvars = Vec::new();\n    let mut varvalues = Vec::new();\n    if argc >= 2 {\n        if let Some(list) = fnc_subst(lil, 1, &argv[0..1]) {\n            for i in 0..list.l {\n                if let Some(var) = list.d.as_ref().and_then(|d| d.to_string().parse().ok()) {\n                    invars.push(var);\n                    if let Some(val) = hm_get(&lil.env.borrow().varmap, &var) {\n                        varvalues.push(val.borrow().v.clone());\n                    }\n                }\n            }\n        }\n        if argc > 2 {\n            if let Some(list) = fnc_subst(lil, 1, &argv[1..2]) {\n                for i in 0..list.l {\n                    if let Some(var) = list.d.as_ref().and_then(|d| d.to_string().parse().ok()) {\n                        outvars.push(var);\n                    }\n                }\n            }\n        }\n    }\n    let oldenv = Rc::clone(&lil.env);\n    lil.env = Rc::new(RefCell::new(LilEnv {\n        parent: Some(Rc::clone(&oldenv)),\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    for i in 0..invars.len() {\n        hm_put(&mut lil.env.borrow_mut().varmap, &invars[i], Some(Rc::new(RefCell::new(LilVar {\n            n: invars[i].clone(),\n            w: String::new(),\n            env: Rc::clone(&lil.env),\n            v: varvalues[i].clone(),\n        }))));\n    }\n    let r = fnc_eval(lil, 1, &argv[codeindex..codeindex+1]);\n    if !invars.is_empty() || !outvars.is_empty() {\n        varvalues.clear();\n        if !outvars.is_empty() {\n            for var in &outvars {\n                if let Some(val) = hm_get(&lil.env.borrow().varmap, var) {\n                    varvalues.push(val.borrow().v.clone());\n                }\n            }\n        } else {\n            for var in &invars {\n                if let Some(val) = hm_get(&lil.env.borrow().varmap, var) {\n                    varvalues.push(val.borrow().v.clone());\n                }\n            }\n        }\n    }\n    lil.env = oldenv;\n    if !invars.is_empty() {\n        if !outvars.is_empty() {\n            for i in 0..outvars.len() {\n                hm_put(&mut lil.env.borrow_mut().varmap, &outvars[i], Some(Rc::new(RefCell::new(LilVar {\n                    n: outvars[i].clone(),\n                    w: String::new(),\n                    env: Rc::clone(&lil.env),\n                    v: varvalues[i].clone(),\n                }))));\n            }\n        } else {\n            for i in 0..invars.len() {\n                hm_put(&mut lil.env.borrow_mut().varmap, &invars[i], Some(Rc::new(RefCell::new(LilVar {\n                    n: invars[i].clone(),\n                    w: String::new(),\n                    env: Rc::clone(&lil.env),\n                    v: varvalues[i].clone(),\n                }))));\n            }\n        }\n    }\n    r\n}\n\npub fn fnc_ltrim<T: Clone + From<String> + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let s = match &argv[0].d {\n        Some(s) => s.to_string(),\n        None => return None,\n    };\n    let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { \n        match &argv[1].d {\n            Some(s) => s.to_string().as_str(),\n            None => \" \\f\\n\\r\\t\\v\",\n        }\n    };\n    let trimmed = s.trim_start_matches(chars);\n    Some(LilValue { l: trimmed.len(), d: Some(trimmed.parse().unwrap()) })\n}\n\npub fn fnc_trim<T: Clone + From<String> + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let s = match &argv[0].d {\n        Some(s) => s.to_string(),\n        None => return None,\n    };\n    let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { \n        match &argv[1].d {\n            Some(s) => s.to_string().as_str(),\n            None => \" \\f\\n\\r\\t\\v\",\n        }\n    };\n    let trimmed = s.trim_matches(chars);\n    Some(LilValue { l: trimmed.len(), d: Some(trimmed.parse().unwrap()) })\n}\n\nfn main(){}\n //编译报错信息：error: unknown character escape: `f`\n    --> ../../Output/crown/tmp/test-lil_register_stdcmds/temp.rs:1783:34\n     |\n1783 |     let chars = if argc < 2 { \" \\f\\n\\r\\t\\v\" } else { \n     |                                  ^ unknown character escape\n     |\n     = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "lil_parse": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\npub const MAX_CATCHER_DEPTH: usize = 16;\npub const ERROR_DEFAULT: i32 = 0;\npub const ERROR_FIXHEAD: i32 = 1;\npub const LIL_CALLBACK_ERROR: usize = 0;\npub const LIL_SETVAR_LOCAL_NEW: i32 = 0;\n\n\n\npub fn next_word<T: Clone + FromStr + Debug>(lil: &mut LilStruct<T>) -> Option<LilValue<T>> {\n    let mut val: Option<LilValue<T>> = None;\n    skip_spaces(lil);\n    \n    match lil.code.chars().nth(lil.head) {\n        Some('$') => val = get_dollarpart(lil),\n        Some('{') => {\n            let mut cnt = 1;\n            lil.head += 1;\n            val = alloc_value(None);\n            while lil.head < lil.clen {\n                match lil.code.chars().nth(lil.head) {\n                    Some('{') => {\n                        lil.head += 1;\n                        cnt += 1;\n                        lil_append_char(val.as_ref().unwrap().clone(), '{');\n                    },\n                    Some('}') => {\n                        lil.head += 1;\n                        cnt -= 1;\n                        if cnt == 0 { break; }\n                        else { lil_append_char(val.as_ref().unwrap().clone(), '}'); }\n                    },\n                    Some(c) => {\n                        lil_append_char(val.as_ref().unwrap().clone(), c);\n                        lil.head += 1;\n                    },\n                    None => break,\n                }\n            }\n        },\n        Some('[') => val = get_bracketpart(lil),\n        Some('\"') | Some('\\'') => {\n            let sc = lil.code.chars().nth(lil.head).unwrap();\n            lil.head += 1;\n            val = alloc_value(None);\n            while lil.head < lil.clen {\n                match lil.code.chars().nth(lil.head) {\n                    Some('[') | Some('$') => {\n                        let tmp = if lil.code.chars().nth(lil.head).unwrap() == '$' { \n                            get_dollarpart(lil) \n                        } else { \n                            get_bracketpart(lil) \n                        };\n                        lil_append_val(&mut val.as_mut().unwrap(), &tmp.unwrap());\n                        lil_free_value(tmp);\n                        lil.head -= 1;\n                    },\n                    Some('\\\\') => {\n                        lil.head += 1;\n                        match lil.code.chars().nth(lil.head) {\n                            Some('b') => lil_append_char(val.as_ref().unwrap().clone(), '\\x08'),\n                            Some('t') => lil_append_char(val.as_ref().unwrap().clone(), '\\t'),\n                            Some('n') => lil_append_char(val.as_ref().unwrap().clone(), '\\n'),\n                            Some('v') => lil_append_char(val.as_ref().unwrap().clone(), '\\x0b'),\n                            Some('f') => lil_append_char(val.as_ref().unwrap().clone(), '\\x0c'),\n                            Some('r') => lil_append_char(val.as_ref().unwrap().clone(), '\\r'),\n                            Some('0') => lil_append_char(val.as_ref().unwrap().clone(), '\\0'),\n                            Some('a') => lil_append_char(val.as_ref().unwrap().clone(), '\\x07'),\n                            Some('c') => lil_append_char(val.as_ref().unwrap().clone(), '}'),\n                            Some('o') => lil_append_char(val.as_ref().unwrap().clone(), '{'),\n                            Some(c) => lil_append_char(val.as_ref().unwrap().clone(), c),\n                            None => (),\n                        };\n                    },\n                    Some(c) if c == sc => {\n                        lil.head += 1;\n                        break;\n                    },\n                    Some(c) => {\n                        lil_append_char(val.as_ref().unwrap().clone(), c);\n                        lil.head += 1;\n                    },\n                    None => break,\n                }\n            }\n        },\n        Some(_) => {\n            let start = lil.head;\n            while lil.head < lil.clen {\n                let c = lil.code.chars().nth(lil.head).unwrap();\n                if !c.is_whitespace() && islilspecial(c as i8) == 0 {\n                    lil.head += 1;\n                } else {\n                    break;\n                }\n            }\n            val = alloc_value_len(Some(&lil.code[start..lil.head]), lil.head - start);\n        },\n        None => (),\n    }\n    \n    val.or_else(|| alloc_value(None))\n}\n\n //编译报错信息：error: unknown character escape: `b`\n   --> ../../Output/crown/tmp/test-lil_lil_parse/temp.rs:621:91\n    |\n621 | ...                   Some('b') => lil_append_char(val.as_ref().unwrap().clone(), '\\b'),\n    |                                                                                     ^ unknown character escape\n    |\n    = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "lil_new": "//上下文长度超过限制",
        "ee_paren": "//同时处理的函数过多，无法处理 :13",
        "ee_unary": "//上下文长度超过限制",
        "ee_muldiv": "//上下文长度超过限制",
        "ee_addsub": "//上下文长度超过限制",
        "ee_shift": "//上下文长度超过限制",
        "ee_compare": "//上下文长度超过限制",
        "ee_equals": "//上下文长度超过限制",
        "ee_bitand": "//上下文长度超过限制",
        "ee_bitor": "//上下文长度超过限制",
        "ee_logand": "//上下文长度超过限制",
        "ee_logor": "//上下文长度超过限制",
        "lil_subst_to_value": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n#[derive(Debug, Clone)]\npub enum ExprEvalType {\n    Int,\n    Float,\n}\n\n#[derive(Debug, Clone)]\npub struct Expreval {\n    pub type_: ExprEvalType,\n    pub ival: i64,\n    pub dval: f64,\n    pub head: usize,\n    pub len: usize,\n    pub code: String,\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn lil_push_env<T: Clone>(lil: &mut LilStruct<T>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = lil_alloc_env(Some(Rc::clone(&lil.env)));\n    lil.env = Rc::clone(&env);\n    env\n}\n\n\npub fn lil_alloc_list<T: Clone>() -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n\npub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\n\nfn lil_to_string<T: Clone>(value: &LilValue<T>) -> String {\n    String::new()\n}\n\n\npub fn lil_parse_value<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> Option<LilValue<T>> {\n    Some(val.clone())\n}\n\n\npub fn islilspecial(ch: i8) -> i32 {\n    (ch == b'$' as i8 || ch == b'{' as i8 || ch == b'}' as i8 || ch == b'[' as i8 || ch == b']' as i8 || ch == b'\"' as i8 || ch == b'\\'' as i8 || ch == b';' as i8) as i32\n}\n\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\n\nfn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    None\n}\n\n\npub fn lil_clone_value<T: Clone>(val: &LilValue<T>) -> LilValue<T> {\n    val.clone()\n}\n\n\npub fn ateol<T: Clone>(lil: &LilStruct<T>) -> bool {\n    !(lil.ignoreeol != 0) && (lil.code.chars().nth(lil.head) == Some('\\n') || lil.code.chars().nth(lil.head) == Some('\\r') || lil.code.chars().nth(lil.head) == Some(';'))\n}\n\n\nfn lil_list_append<T: Clone>(_list: &mut LilList<T>, _val: LilValue<T>) {}\n\n\nfn hm_put<T>(map: &mut HashMap<T>, key: &str, value: Option<T>) {\n}\n\n\npub fn lil_free_env<T: Clone>(env: Option<Rc<RefCell<LilEnv<T>>>>) {\n    if env.is_none() {\n        return;\n    }\n    let env = env.unwrap();\n    let mut env = env.borrow_mut();\n    lil_free_value(Some(Rc::new(RefCell::new(env.retval.clone()))));\n    hm_destroy(&mut env.varmap);\n    for i in 0..env.vars {\n        let var = env.var[i].borrow_mut();\n        lil_free_value(Some(Rc::new(RefCell::new(var.v.clone()))));\n    }\n    env.var.clear();\n    env.vars = 0;\n}\n\n\npub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\n\npub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\n\npub fn skip_spaces<T: Clone>(lil: &mut LilStruct<T>) {\n    while lil.head < lil.clen {\n        let current_char = lil.code.chars().nth(lil.head).unwrap();\n        if current_char == '#' {\n            if lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                lil.head += 2;\n                while lil.head < lil.clen {\n                    let current_char = lil.code.chars().nth(lil.head).unwrap();\n                    if current_char == '#' && lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                        lil.head += 2;\n                        break;\n                    }\n                    lil.head += 1;\n                }\n            } else {\n                while lil.head < lil.clen && !ateol(lil) {\n                    lil.head += 1;\n                }\n            }\n        } else if current_char == '\\\\' && (lil.code.chars().nth(lil.head + 1) == Some('\\r') || lil.code.chars().nth(lil.head + 1) == Some('\\n')) {\n            lil.head += 1;\n            while lil.head < lil.clen && ateol(lil) {\n                lil.head += 1;\n            }\n        } else if current_char == '\\r' || current_char == '\\n' {\n            if lil.ignoreeol != 0 {\n                lil.head += 1;\n            } else {\n                break;\n            }\n        } else if current_char.is_whitespace() {\n            lil.head += 1;\n        } else {\n            break;\n        }\n    }\n}\n\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\n\npub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\n\nfn lil_find_var<T: Clone>(_lil: &LilStruct<T>, _env: Rc<RefCell<LilEnv<T>>>, _name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    None\n}\n\n\npub fn lil_pop_env<T: Clone>(lil: &mut LilStruct<T>) {\n    let parent = {\n        let env = lil.env.borrow();\n        env.parent.clone()\n    };\n    if let Some(next) = parent {\n        lil_free_env(Some(lil.env.clone()));\n        lil.env = next;\n    }\n}\n\n\npub fn lil_find_local_var<T: Clone + Debug>(lil: &LilStruct<T>, env: &LilEnv<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    hm_get(&env.varmap, name)\n}\n\n\npub fn needs_escape(str: &str) -> i32 {\n    if str.is_empty() {\n        return 1;\n    }\n    for c in str.chars() {\n        if c.is_ascii_punctuation() || c.is_whitespace() {\n            return 1;\n        }\n    }\n    0\n}\n\n\nfn lil_subst_to_list<T: Clone>(_lil: &LilStruct<T>, _val: LilValue<T>) -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n\npub fn lil_append_char<T: Clone + Debug + FromStr>(val: Rc<RefCell<LilValue<T>>>, ch: char) -> i32 {\n    let mut val = val.borrow_mut();\n    if let Some(ref mut data) = val.d {\n        let mut s = format!(\"{:?}\", data);\n        s.push(ch);\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    } else {\n        let s = ch.to_string();\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    }\n}\n\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n\nfn lil_set_var<T: Clone>(_lil: &LilStruct<T>, _name: &str, _val: LilValue<T>, _access: i32) {}\n\n\npub fn lil_append_string_len<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str, len: usize) -> i32 {\n    if s.is_empty() {\n        return 1;\n    }\n\n    let s_slice = if len < s.len() { &s[..len] } else { s };\n    \n    match &mut val.d {\n        Some(data) => {\n            let str_data = data.as_mut();\n            str_data.push_str(s_slice);\n            val.l += s_slice.len();\n            1\n        },\n        None => {\n            val.d = Some(T::from(s_slice.to_string()));\n            val.l = s_slice.len();\n            1\n        }\n    }\n}\n\n\npub fn lil_append_string<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str) -> i32 {\n    lil_append_string_len(val, s, s.len())\n}\n\n\nfn lil_set_error_at<T: Clone>(lil: &mut LilStruct<T>, pos: usize, msg: &str) {\n}\n\n\nfn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\n\npub fn lil_append_val<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) -> i32 {\n    if v.d.is_none() || v.l == 0 {\n        return 1;\n    }\n\n    match (&mut val.d, &v.d) {\n        (Some(val_data), Some(v_data)) => {\n            let mut new_data = val_data.clone();\n            new_data = v_data.clone();\n            val.d = Some(new_data);\n            val.l += v.l;\n            1\n        }\n        _ => 1,\n    }\n}\n\n\nfn lil_list_to_value<T: Clone>(_list: &LilList<T>, _flag: i32) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\n\npub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n\n\npub fn lil_subst_to_value<T: Clone>(lil: &LilStruct<T>, code: LilValue<T>) -> LilValue<T> {\n    let words = lil_subst_to_list(lil, code);\n    let val = lil_list_to_value(&words, 0);\n    lil_free_list(words);\n    val\n}\n\npub fn substitute<T: Clone>(lil: &mut LilStruct<T>) -> LilList<T> {\n    let mut words = lil_alloc_list();\n\n    skip_spaces(lil);\n    while lil.head < lil.clen && !ateol(lil) && !lil.error {\n        let mut w = alloc_value(None);\n        loop {\n            let head = lil.head;\n            let wp = next_word(lil);\n            if head == lil.head {\n                lil_free_value(w);\n                lil_free_value(wp);\n                lil_free_list(words);\n                return LilList { items: Vec::new() };\n            }\n            lil_append_val(&mut w, &wp);\n            lil_free_value(wp);\n            if !(lil.head < lil.clen && !ateol(lil) && !lil.code.chars().nth(lil.head).unwrap().is_whitespace() && !lil.error) {\n                break;\n            }\n        }\n        skip_spaces(lil);\n\n        lil_list_append(&mut words, w);\n    }\n\n    words\n}\n\npub fn next_word<T: Clone>(lil: &mut LilStruct<T>) -> LilValue<T> {\n    let mut val;\n    let start;\n    skip_spaces(lil);\n    if lil.code.chars().nth(lil.head).unwrap() == '$' {\n        val = get_dollarpart(lil);\n    } else if lil.code.chars().nth(lil.head).unwrap() == '{' {\n        let mut cnt = 1;\n        lil.head += 1;\n        val = alloc_value(None);\n        while lil.head < lil.clen {\n            if lil.code.chars().nth(lil.head).unwrap() == '{' {\n                lil.head += 1;\n                cnt += 1;\n                lil_append_char(Rc::new(RefCell::new(val.clone())), '{');\n            } else if lil.code.chars().nth(lil.head).unwrap() == '}' {\n                lil.head += 1;\n                cnt -= 1;\n                if cnt == 0 {\n                    break;\n                } else {\n                    lil_append_char(Rc::new(RefCell::new(val.clone())), '}');\n                }\n            } else {\n                lil_append_char(Rc::new(RefCell::new(val.clone())), lil.code.chars().nth(lil.head).unwrap());\n                lil.head += 1;\n            }\n        }\n    } else if lil.code.chars().nth(lil.head).unwrap() == '[' {\n        val = get_bracketpart(lil);\n    } else if lil.code.chars().nth(lil.head).unwrap() == '\"' || lil.code.chars().nth(lil.head).unwrap() == '\\'' {\n        let sc = lil.code.chars().nth(lil.head).unwrap();\n        lil.head += 1;\n        val = alloc_value(None);\n        while lil.head < lil.clen {\n            if lil.code.chars().nth(lil.head).unwrap() == '[' || lil.code.chars().nth(lil.head).unwrap() == '$' {\n                let tmp = if lil.code.chars().nth(lil.head).unwrap() == '$' {\n                    get_dollarpart(lil)\n                } else {\n                    get_bracketpart(lil)\n                };\n                lil_append_val(&mut val, &tmp);\n                lil_free_value(tmp);\n                lil.head -= 1;\n            } else if lil.code.chars().nth(lil.head).unwrap() == '\\\\' {\n                lil.head += 1;\n                match lil.code.chars().nth(lil.head).unwrap() {\n                    'b' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\b'),\n                    't' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\t'),\n                    'n' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\n'),\n                    'v' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\v'),\n                    'f' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\f'),\n                    'r' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\r'),\n                    '0' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\0'),\n                    'a' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\x07'),\n                    'c' => lil_append_char(Rc::new(RefCell::new(val.clone())), '}'),\n                    'o' => lil_append_char(Rc::new(RefCell::new(val.clone())), '{'),\n                    _ => lil_append_char(Rc::new(RefCell::new(val.clone())), lil.code.chars().nth(lil.head).unwrap()),\n                }\n            } else if lil.code.chars().nth(lil.head).unwrap() == sc {\n                lil.head += 1;\n                break;\n            } else {\n                lil_append_char(Rc::new(RefCell::new(val.clone())), lil.code.chars().nth(lil.head).unwrap());\n            }\n            lil.head += 1;\n        }\n    } else {\n        start = lil.head;\n        while lil.head < lil.clen && !lil.code.chars().nth(lil.head).unwrap().is_whitespace() && islilspecial(lil.code.chars().nth(lil.head).unwrap() as i8) == 0 {\n            lil.head += 1;\n        }\n        val = alloc_value_len(Some(lil.code[start..lil.head].to_string()), lil.head - start);\n    }\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\npub fn get_bracketpart<T: Clone>(lil: &mut LilStruct<T>) -> LilValue<T> {\n    let mut cnt = 1;\n    let mut cmd = alloc_value(None);\n    lil.head += 1;\n    while lil.head < lil.clen {\n        if lil.code.chars().nth(lil.head).unwrap() == '[' {\n            lil.head += 1;\n            cnt += 1;\n            lil_append_char(Rc::new(RefCell::new(cmd.clone())), '[');\n        } else if lil.code.chars().nth(lil.head).unwrap() == ']' {\n            lil.head += 1;\n            cnt -= 1;\n            if cnt == 0 {\n                break;\n            } else {\n                lil_append_char(Rc::new(RefCell::new(cmd.clone())), ']');\n            }\n        } else {\n            lil_append_char(Rc::new(RefCell::new(cmd.clone())), lil.code.chars().nth(lil.head).unwrap());\n            lil.head += 1;\n        }\n    }\n    let val = lil_parse_value(lil, &cmd, 0);\n    lil_free_value(cmd);\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\npub fn get_dollarpart<T: Clone>(lil: &mut LilStruct<T>) -> LilValue<T> {\n    lil.head += 1;\n    let name = next_word(lil);\n    let mut tmp = alloc_value(Some(lil.dollarprefix.clone()));\n    lil_append_val(&mut tmp, &name);\n    lil_free_value(name);\n    let val = lil_parse_value(lil, &tmp, 0);\n    lil_free_value(tmp);\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\npub fn lil_parse<T: Clone>(lil: &mut LilStruct<T>, code: &str, codelen: usize, funclevel: i32) -> LilValue<T> {\n    let save_code = lil.code.clone();\n    let save_clen = lil.clen;\n    let save_head = lil.head;\n    let mut val = None;\n    let mut words = None;\n\n    if save_code.is_empty() {\n        lil.rootcode = code.to_string();\n    }\n    lil.code = code.to_string();\n    lil.clen = if codelen != 0 { codelen } else { code.len() };\n    lil.head = 0;\n    skip_spaces(lil);\n    lil.parse_depth += 1;\n\n    if lil.parse_depth == 1 {\n        lil.error = 0;\n    }\n    if funclevel != 0 {\n        lil.env.borrow_mut().breakrun = false;\n    }\n\n    while lil.head < lil.clen && !lil.error {\n        if words.is_some() {\n            lil_free_list(words.take().unwrap());\n        }\n        if val.is_some() {\n            lil_free_value(val.take());\n        }\n\n        words = Some(substitute(lil));\n        if words.as_ref().unwrap().items.is_empty() || lil.error {\n            break;\n        }\n\n        if !words.as_ref().unwrap().items.is_empty() {\n            let cmd = find_cmd(lil, &lil_to_string(&words.as_ref().unwrap().items[0].borrow()));\n            if cmd.is_none() {\n                if words.as_ref().unwrap().items[0].borrow().l != 0 {\n                    if !lil.catcher.is_empty() {\n                        let args = lil_list_to_value(&words.as_ref().unwrap(), 1);\n                        lil_set_var(lil, \"args\", args, 2);\n                        lil_free_value(args);\n                        val = Some(lil_parse(lil, &lil.catcher, 0, 1).unwrap());\n                    } else {\n                        lil_set_error_at(lil, lil.head, &format!(\"unknown function {}\", lil_to_string(&words.as_ref().unwrap().items[0].borrow())));\n                        break;\n                    }\n                }\n            }\n            if let Some(cmd) = cmd {\n                if let Some(proc) = cmd.borrow().proc {\n                    let shead = lil.head;\n                    val = Some(proc(lil, cmd.borrow().name.as_str(), &[]));\n                    if lil.error == 2 {\n                        lil.error = 1;\n                        lil.err_head = shead;\n                    }\n                } else {\n                    lil_push_env(lil);\n                    lil.env.borrow_mut().func = Some(cmd.clone());\n                    if cmd.borrow().argnames.items.len() == 1 && lil_to_string(&cmd.borrow().argnames.items[0].borrow()) == \"args\" {\n                        let args = lil_list_to_value(&words.as_ref().unwrap(), 1);\n                        lil_set_var(lil, \"args\", args, 2);\n                        lil_free_value(args);\n                    } else {\n                        for i in 0..cmd.borrow().argnames.items.len() {\n                            lil_set_var(\n                                lil,\n                                &lil_to_string(&cmd.borrow().argnames.items[i].borrow()),\n                                if i < words.as_ref().unwrap().items.len() - 1 {\n                                    words.as_ref().unwrap().items[i + 1].borrow().clone()\n                                } else {\n                                    lil.empty.clone()\n                                },\n                                2,\n                            );\n                        }\n                    }\n                    val = lil_parse_value(lil, &cmd.borrow().code, 1);\n                    lil_pop_env(lil);\n                }\n            }\n        }\n\n        if lil.env.borrow().breakrun {\n            break;\n        }\n\n        skip_spaces(lil);\n        while ateol(lil) {\n            lil.head += 1;\n        }\n        skip_spaces(lil);\n    }\n\n    if words.is_some() {\n        lil_free_list(words.take().unwrap());\n    }\n    lil.code = save_code;\n    lil.clen = save_clen;\n    lil.head = save_head;\n\n    if funclevel != 0 && lil.env.borrow().retval_set {\n        if val.is_some() {\n            lil_free_value(val.take());\n        }\n        val = Some(lil.env.borrow().retval.clone());\n        lil.env.borrow_mut().retval = alloc_value(None).unwrap();\n        lil.env.borrow_mut().retval_set = false;\n        lil.env.borrow_mut().breakrun = false;\n    }\n\n    lil.parse_depth -= 1;\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\nfn main(){}\n //编译报错信息：error: unknown character escape: `b`\n   --> ../../Output/crown/tmp/test-uncovered_lil_lil_subst_to_value/temp.rs:530:82\n    |\n530 |                     'b' => lil_append_char(Rc::new(RefCell::new(val.clone())), '\\b'),\n    |                                                                                  ^ unknown character escape\n    |\n    = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "ee_expr": "//上下文长度超过限制",
        "real_inc": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n#[derive(Debug, Clone)]\npub enum ExprEvalType {\n    Int,\n    Float,\n}\n\n#[derive(Debug, Clone)]\npub struct Expreval {\n    pub type_: ExprEvalType,\n    pub ival: i64,\n    pub dval: f64,\n    pub head: usize,\n    pub len: usize,\n    pub code: String,\n}\npub fn lil_push_env<T: Clone>(lil: &mut LilStruct<T>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = lil_alloc_env(Some(Rc::clone(&lil.env)));\n    lil.env = Rc::clone(&env);\n    env\n}\n\n\nfn lil_get_var<T: Clone>(_lil: &LilStruct<T>, _name: &str) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\n\npub fn lil_alloc_list<T: Clone>() -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n\npub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\n\nfn lil_to_string<T: Clone>(value: &LilValue<T>) -> String {\n    String::new()\n}\n\n\npub fn lil_parse_value<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> Option<LilValue<T>> {\n    Some(val.clone())\n}\n\n\npub fn islilspecial(ch: i8) -> i32 {\n    (ch == b'$' as i8 || ch == b'{' as i8 || ch == b'}' as i8 || ch == b'[' as i8 || ch == b']' as i8 || ch == b'\"' as i8 || ch == b'\\'' as i8 || ch == b';' as i8) as i32\n}\n\n\npub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\n\nfn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    None\n}\n\n\npub fn lil_clone_value<T: Clone>(val: &LilValue<T>) -> LilValue<T> {\n    val.clone()\n}\n\n\npub fn ateol<T: Clone>(lil: &LilStruct<T>) -> bool {\n    !(lil.ignoreeol != 0) && (lil.code.chars().nth(lil.head) == Some('\\n') || lil.code.chars().nth(lil.head) == Some('\\r') || lil.code.chars().nth(lil.head) == Some(';'))\n}\n\n\nfn lil_list_append<T: Clone>(_list: &mut LilList<T>, _val: LilValue<T>) {}\n\n\npub fn lil_alloc_double<T: Clone + FromStr>(num: f64) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let buff = format!(\"{}\", num);\n    alloc_value(Some(buff))\n}\n\n\nfn hm_put<T>(map: &mut HashMap<T>, key: &str, value: Option<T>) {\n}\n\n\npub fn lil_free_env<T: Clone>(env: Option<Rc<RefCell<LilEnv<T>>>>) {\n    if env.is_none() {\n        return;\n    }\n    let env = env.unwrap();\n    let mut env = env.borrow_mut();\n    lil_free_value(Some(Rc::new(RefCell::new(env.retval.clone()))));\n    hm_destroy(&mut env.varmap);\n    for i in 0..env.vars {\n        let var = env.var[i].borrow_mut();\n        lil_free_value(Some(Rc::new(RefCell::new(var.v.clone()))));\n    }\n    env.var.clear();\n    env.vars = 0;\n}\n\n\npub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\n\npub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\n\npub fn skip_spaces<T: Clone>(lil: &mut LilStruct<T>) {\n    while lil.head < lil.clen {\n        let current_char = lil.code.chars().nth(lil.head).unwrap();\n        if current_char == '#' {\n            if lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                lil.head += 2;\n                while lil.head < lil.clen {\n                    let current_char = lil.code.chars().nth(lil.head).unwrap();\n                    if current_char == '#' && lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                        lil.head += 2;\n                        break;\n                    }\n                    lil.head += 1;\n                }\n            } else {\n                while lil.head < lil.clen && !ateol(lil) {\n                    lil.head += 1;\n                }\n            }\n        } else if current_char == '\\\\' && (lil.code.chars().nth(lil.head + 1) == Some('\\r') || lil.code.chars().nth(lil.head + 1) == Some('\\n')) {\n            lil.head += 1;\n            while lil.head < lil.clen && ateol(lil) {\n                lil.head += 1;\n            }\n        } else if current_char == '\\r' || current_char == '\\n' {\n            if lil.ignoreeol != 0 {\n                lil.head += 1;\n            } else {\n                break;\n            }\n        } else if current_char.is_whitespace() {\n            lil.head += 1;\n        } else {\n            break;\n        }\n    }\n}\n\n\npub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\n\npub fn lil_to_double<T: Clone>(val: &LilValue<T>) -> f64 {\n    lil_to_string(val).parse::<f64>().unwrap_or(0.0)\n}\n\n\npub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\n\nfn lil_find_var<T: Clone>(_lil: &LilStruct<T>, _env: Rc<RefCell<LilEnv<T>>>, _name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    None\n}\n\n\npub fn lil_pop_env<T: Clone>(lil: &mut LilStruct<T>) {\n    let parent = {\n        let env = lil.env.borrow();\n        env.parent.clone()\n    };\n    if let Some(next) = parent {\n        lil_free_env(Some(lil.env.clone()));\n        lil.env = next;\n    }\n}\n\n\npub fn lil_find_local_var<T: Clone + Debug>(lil: &LilStruct<T>, env: &LilEnv<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    hm_get(&env.varmap, name)\n}\n\n\npub fn needs_escape(str: &str) -> i32 {\n    if str.is_empty() {\n        return 1;\n    }\n    for c in str.chars() {\n        if c.is_ascii_punctuation() || c.is_whitespace() {\n            return 1;\n        }\n    }\n    0\n}\n\n\npub fn lil_append_char<T: Clone + Debug + FromStr>(val: Rc<RefCell<LilValue<T>>>, ch: char) -> i32 {\n    let mut val = val.borrow_mut();\n    if let Some(ref mut data) = val.d {\n        let mut s = format!(\"{:?}\", data);\n        s.push(ch);\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    } else {\n        let s = ch.to_string();\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    }\n}\n\n\npub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n\nfn lil_set_var<T: Clone>(_lil: &LilStruct<T>, _name: &str, _val: LilValue<T>, _access: i32) {}\n\n\npub fn lil_append_string_len<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str, len: usize) -> i32 {\n    if s.is_empty() {\n        return 1;\n    }\n\n    let s_slice = if len < s.len() { &s[..len] } else { s };\n    \n    match &mut val.d {\n        Some(data) => {\n            let str_data = data.as_mut();\n            str_data.push_str(s_slice);\n            val.l += s_slice.len();\n            1\n        },\n        None => {\n            val.d = Some(T::from(s_slice.to_string()));\n            val.l = s_slice.len();\n            1\n        }\n    }\n}\n\n\npub fn lil_append_string<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str) -> i32 {\n    lil_append_string_len(val, s, s.len())\n}\n\n\npub fn lil_alloc_integer<T: Clone + From<i64>>(i: i64) -> LilValue<T> {\n    LilValue { l: 0, d: Some(i.into()) }\n}\n\n\nfn lil_set_error_at<T: Clone>(lil: &mut LilStruct<T>, pos: usize, msg: &str) {\n}\n\n\nfn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\n\npub fn lil_append_val<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) -> i32 {\n    if v.d.is_none() || v.l == 0 {\n        return 1;\n    }\n\n    match (&mut val.d, &v.d) {\n        (Some(val_data), Some(v_data)) => {\n            let mut new_data = val_data.clone();\n            new_data = v_data.clone();\n            val.d = Some(new_data);\n            val.l += v.l;\n            1\n        }\n        _ => 1,\n    }\n}\n\n\nfn lil_list_to_value<T: Clone>(_list: &LilList<T>, _flag: i32) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\n\npub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n\npub fn lil_get_var_or<T: Clone + Debug>(lil: &LilStruct<T>, name: &str, defvalue: LilValue<T>) -> LilValue<T> {\n    let var = lil_find_var(lil, Rc::clone(&lil.env), name);\n    let var_clone = var.clone();\n    let mut retval = match var {\n        Some(v) => v.borrow().v.clone(),\n        None => defvalue,\n    };\n\n    if let Some(callback) = lil.callback.get(7) {\n        let is_root_env = match &var_clone {\n            Some(v) => Rc::ptr_eq(&v.borrow().env, &lil.rootenv),\n            None => true,\n        };\n        if is_root_env {\n            let newretval = callback(lil, name, &[retval.clone()]);\n            retval = newretval;\n        }\n    }\n\n    retval\n}\n\n\n\npub fn real_inc<T: Clone + FromStr + From<i64> + Debug>(lil: &mut LilStruct<T>, varname: &str, v: f32) -> LilValue<T> {\n    let pv = lil_get_var(lil, varname);\n    let dv = lil_to_double(&pv) + f64::from(v);\n    let pv = if dv.fract() != 0.0 {\n        lil_alloc_double(dv).unwrap()\n    } else {\n        lil_alloc_integer(dv as i64)\n    };\n    lil_set_var(lil, varname, pv.clone(), 1);\n    pv\n}\n\npub fn lil_parse<T: Clone + Debug + FromStr + From<i64>>(lil: &mut LilStruct<T>, code: &str, codelen: usize, funclevel: i32) -> LilValue<T> {\n    let save_code = lil.code.clone();\n    let save_clen = lil.clen;\n    let save_head = lil.head;\n    let mut val: Option<LilValue<T>> = None;\n    let mut words: Option<LilList<T>> = None;\n    if save_code.is_empty() { lil.rootcode = code.to_string(); }\n    lil.code = code.to_string();\n    lil.clen = if codelen != 0 { codelen } else { code.len() };\n    lil.head = 0;\n    skip_spaces(lil);\n    lil.parse_depth += 1;\n    if lil.parse_depth == 1 { lil.error = 0; }\n    if funclevel != 0 { lil.env.borrow_mut().breakrun = false; }\n    while lil.head < lil.clen && lil.error == 0 {\n        if words.is_some() { lil_free_list(words.take().unwrap()); }\n        if val.is_some() { lil_free_value(Some(Rc::new(RefCell::new(val.take().unwrap())))); }\n        words = Some(substitute(lil));\n        if words.is_none() || lil.error != 0 { break; }\n        let words_ref = words.as_ref().unwrap();\n        if words_ref.items.len() > 0 {\n            let cmd_name = lil_to_string(&words_ref.items[0].borrow());\n            let cmd = find_cmd(lil, &cmd_name);\n            if cmd.is_none() {\n                if words_ref.items[0].borrow().l != 0 {\n                    if !lil.catcher.is_empty() {\n                        if lil.in_catcher < 16384 {\n                            lil.in_catcher += 1;\n                            lil_push_env(lil);\n                            lil.env.borrow_mut().catcher_for = words_ref.items[0].borrow().clone();\n                            let args = lil_list_to_value(words_ref, 1);\n                            lil_set_var(lil, \"args\", args.clone(), 2);\n                            lil_free_value(Some(Rc::new(RefCell::new(args))));\n                            val = Some(lil_parse(lil, &lil.catcher, 0, 1));\n                            lil_pop_env(lil);\n                            lil.in_catcher -= 1;\n                        } else {\n                            let msg = format!(\"catcher limit reached while trying to call unknown function {}\", cmd_name);\n                            lil_set_error_at(lil, lil.head, &msg);\n                            break;\n                        }\n                    } else {\n                        let msg = format!(\"unknown function {}\", cmd_name);\n                        lil_set_error_at(lil, lil.head, &msg);\n                        break;\n                    }\n                }\n            }\n            if let Some(cmd_ref) = cmd {\n                if let Some(proc) = &cmd_ref.borrow().proc {\n                    let shead = lil.head;\n                    val = Some(proc(lil, &cmd_name, &words_ref.items[1..].iter().map(|x| x.borrow().clone()).collect::<Vec<_>>()));\n                    if lil.error == 2 {\n                        lil.error = 1;\n                        lil.err_head = shead;\n                    }\n                } else {\n                    lil_push_env(lil);\n                    lil.env.borrow_mut().func = Some(cmd_ref.clone());\n                    let argnames = &cmd_ref.borrow().argnames;\n                    if argnames.items.len() == 1 && lil_to_string(&argnames.items[0].borrow()) == \"args\" {\n                        let args = lil_list_to_value(words_ref, 1);\n                        lil_set_var(lil, \"args\", args.clone(), 2);\n                        lil_free_value(Some(Rc::new(RefCell::new(args))));\n                    } else {\n                        for i in 0..argnames.items.len() {\n                            let argname = lil_to_string(&argnames.items[i].borrow());\n                            let argval = if i < words_ref.items.len() - 1 {\n                                words_ref.items[i + 1].borrow().clone()\n                            } else {\n                                lil.empty.clone()\n                            };\n                            lil_set_var(lil, &argname, argval, 2);\n                        }\n                    }\n                    val = lil_parse_value(lil, &cmd_ref.borrow().code, 1);\n                    lil_pop_env(lil);\n                }\n            }\n        }\n        if lil.env.borrow().breakrun { break; }\n        skip_spaces(lil);\n        while ateol(lil) { lil.head += 1; }\n        skip_spaces(lil);\n    }\n    if lil.error != 0 && lil.callback[5] != None && lil.parse_depth == 1 {\n        let proc = lil.callback[5];\n        proc(lil, lil.err_head, &lil.err_msg);\n    }\n    if words.is_some() { lil_free_list(words.take().unwrap()); }\n    lil.code = save_code;\n    lil.clen = save_clen;\n    lil.head = save_head;\n    if funclevel != 0 && lil.env.borrow().retval_set {\n        if val.is_some() { lil_free_value(Some(Rc::new(RefCell::new(val.take().unwrap())))); }\n        val = Some(lil.env.borrow().retval.clone());\n        lil.env.borrow_mut().retval = lil.empty.clone();\n        lil.env.borrow_mut().retval_set = false;\n        lil.env.borrow_mut().breakrun = false;\n    }\n    lil.parse_depth -= 1;\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\npub fn substitute<T: Clone + Debug + FromStr>(lil: &mut LilStruct<T>) -> LilList<T> {\n    let mut words = lil_alloc_list();\n    skip_spaces(lil);\n    while lil.head < lil.clen && !ateol(lil) && lil.error == 0 {\n        let mut w = alloc_value(None).unwrap();\n        loop {\n            let head = lil.head;\n            let wp = next_word(lil);\n            if head == lil.head {\n                lil_free_value(Some(Rc::new(RefCell::new(w))));\n                lil_free_value(Some(Rc::new(RefCell::new(wp))));\n                lil_free_list(words);\n                return lil_alloc_list();\n            }\n            lil_append_val(&mut w, &wp);\n            lil_free_value(Some(Rc::new(RefCell::new(wp))));\n            if lil.head >= lil.clen || ateol(lil) || lil.code.chars().nth(lil.head).unwrap().is_whitespace() || lil.error != 0 {\n                break;\n            }\n        }\n        skip_spaces(lil);\n        lil_list_append(&mut words, w);\n    }\n    words\n}\n\npub fn next_word<T: Clone + Debug + FromStr>(lil: &mut LilStruct<T>) -> LilValue<T> {\n    let mut val;\n    skip_spaces(lil);\n    if lil.code.chars().nth(lil.head).unwrap() == '$' {\n        val = get_dollarpart(lil);\n    } else if lil.code.chars().nth(lil.head).unwrap() == '{' {\n        let mut cnt = 1;\n        lil.head += 1;\n        val = alloc_value(None).unwrap();\n        while lil.head < lil.clen {\n            let ch = lil.code.chars().nth(lil.head).unwrap();\n            if ch == '{' {\n                lil.head += 1;\n                cnt += 1;\n                lil_append_char(Rc::new(RefCell::new(val.clone())), '{');\n                val = Rc::try_unwrap(Rc::new(RefCell::new(val))).unwrap().into_inner();\n            } else if ch == '}' {\n                lil.head += 1;\n                cnt -= 1;\n                if cnt == 0 { break; }\n                else { lil_append_char(Rc::new(RefCell::new(val.clone())), '}'); }\n                val = Rc::try_unwrap(Rc::new(RefCell::new(val))).unwrap().into_inner();\n            } else {\n                lil_append_char(Rc::new(RefCell::new(val.clone())), ch);\n                val = Rc::try_unwrap(Rc::new(RefCell::new(val))).unwrap().into_inner();\n                lil.head += 1;\n            }\n        }\n    } else if lil.code.chars().nth(lil.head).unwrap() == '[' {\n        val = get_bracketpart(lil);\n    } else if lil.code.chars().nth(lil.head).unwrap() == '\"' || lil.code.chars().nth(lil.head).unwrap() == '\\'' {\n        let sc = lil.code.chars().nth(lil.head).unwrap();\n        lil.head += 1;\n        val = alloc_value(None).unwrap();\n        while lil.head < lil.clen {\n            let ch = lil.code.chars().nth(lil.head).unwrap();\n            if ch == '[' || ch == '$' {\n                let tmp = if ch == '$' { get_dollarpart(lil) } else { get_bracketpart(lil) };\n                lil_append_val(&mut val, &tmp);\n                lil_free_value(Some(Rc::new(RefCell::new(tmp))));\n                lil.head -= 1;\n            } else if ch == '\\\\' {\n                lil.head += 1;\n                let esc_ch = match lil.code.chars().nth(lil.head).unwrap() {\n                    'b' => '\\b',\n                    't' => '\\t',\n                    'n' => '\\n',\n                    'v' => '\\v',\n                    'f' => '\\f',\n                    'r' => '\\r',\n                    '0' => '\\0',\n                    'a' => '\\x07',\n                    'c' => '}',\n                    'o' => '{',\n                    c => c,\n                };\n                lil_append_char(Rc::new(RefCell::new(val.clone())), esc_ch);\n                val = Rc::try_unwrap(Rc::new(RefCell::new(val))).unwrap().into_inner();\n            } else if ch == sc {\n                lil.head += 1;\n                break;\n            } else {\n                lil_append_char(Rc::new(RefCell::new(val.clone())), ch);\n                val = Rc::try_unwrap(Rc::new(RefCell::new(val))).unwrap().into_inner();\n            }\n            lil.head += 1;\n        }\n    } else {\n        let start = lil.head;\n        while lil.head < lil.clen {\n            let ch = lil.code.chars().nth(lil.head).unwrap();\n            if ch.is_whitespace() || islilspecial(ch as i8) != 0 {\n                break;\n            }\n            lil.head += 1;\n        }\n        val = alloc_value_len(Some(&lil.code[start..lil.head]), lil.head - start).unwrap();\n    }\n    val\n}\n\npub fn get_bracketpart<T: Clone + Debug + FromStr>(lil: &mut LilStruct<T>) -> LilValue<T> {\n    let mut cnt = 1;\n    let mut cmd = alloc_value(None).unwrap();\n    lil.head += 1;\n    while lil.head < lil.clen {\n        let ch = lil.code.chars().nth(lil.head).unwrap();\n        if ch == '[' {\n            lil.head += 1;\n            cnt += 1;\n            lil_append_char(Rc::new(RefCell::new(cmd.clone())), '[');\n            cmd = Rc::try_unwrap(Rc::new(RefCell::new(cmd))).unwrap().into_inner();\n        } else if ch == ']' {\n            lil.head += 1;\n            cnt -= 1;\n            if cnt == 0 { break; }\n            else { lil_append_char(Rc::new(RefCell::new(cmd.clone())), ']'); }\n            cmd = Rc::try_unwrap(Rc::new(RefCell::new(cmd))).unwrap().into_inner();\n        } else {\n            lil_append_char(Rc::new(RefCell::new(cmd.clone())), ch);\n            cmd = Rc::try_unwrap(Rc::new(RefCell::new(cmd))).unwrap().into_inner();\n            lil.head += 1;\n        }\n    }\n    let val = lil_parse_value(lil, &cmd, 0);\n    lil_free_value(Some(Rc::new(RefCell::new(cmd))));\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\npub fn get_dollarpart<T: Clone + Debug + FromStr>(lil: &mut LilStruct<T>) -> LilValue<T> {\n    lil.head += 1;\n    let name = next_word(lil);\n    let mut tmp = alloc_value(Some(lil.dollarprefix.clone())).unwrap();\n    lil_append_val(&mut tmp, &name);\n    lil_free_value(Some(Rc::new(RefCell::new(name))));\n    let val = lil_parse_value(lil, &tmp, 0);\n    lil_free_value(Some(Rc::new(RefCell::new(tmp))));\n    val.unwrap_or_else(|| alloc_value(None).unwrap())\n}\n\nfn main(){}\n //编译报错信息：error: unknown character escape: `b`\n   --> ../../Output/crown/tmp/test-uncovered_lil_real_inc/temp.rs:661:30\n    |\n661 |                     'b' => '\\b',\n    |                              ^ unknown character escape\n    |\n    = help: for more information, visit <https://doc.rust-lang.org/reference/tokens.html#literals>\n",
        "lil_embedded": "//上下文长度超过限制",
        "lil_call": "//上下文长度超过限制"
    },
    "binn": {
        "binn_object_blob": "pub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\npub const INT64_MIN: i64 = -9223372036854775808;\npub const INT64_MAX: i64 = 9223372036854775807;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\npub struct BinnIter {\n    pub pnext: Vec<u8>,\n    pub plimit: Vec<u8>,\n    pub current: i32,\n    pub count: i32,\n    pub type_: i32,\n}\n\nimpl Default for BinnIter {\n    fn default() -> Self {\n        BinnIter {\n            pnext: Vec::new(),\n            plimit: Vec::new(),\n            current: 0,\n            count: 0,\n            type_: 0,\n        }\n    }\n}\n\nimpl BinnIter {\n    pub fn is_null(&self) -> bool {\n        self.pnext.is_empty()\n    }\n}\n\npub const INVALID_BINN: i32 = 0;\npub const BINN_STORAGE_MAX: i32 = BINN_STORAGE_CONTAINER;\npub const BINN_STORAGE_MIN: i32 = BINN_STORAGE_NOBYTES;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\n\npub fn binn_object_blob(obj: Option<&Vec<u8>>, key: &str, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value: Vec<u8> = Vec::new();\n    if !binn_object_get(obj, key, BINN_BLOB, &mut value, psize) {\n        None\n    } else {\n        Some(value)\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `Vec<u8>: Copy` is not satisfied\n    --> ../../Output/crown/tmp/test-uncovered_binn_binn_object_blob/temp.rs:1089:46\n     |\n1089 |     if !binn_object_get(obj, key, BINN_BLOB, &mut value, psize) {\n     |         ---------------                      ^^^^^^^^^^ the trait `Copy` is not implemented for `Vec<u8>`\n     |         |\n     |         required by a bound introduced by this call\n     |\nnote: required by a bound in `binn_object_get`\n    --> ../../Output/crown/tmp/test-uncovered_binn_binn_object_blob/temp.rs:762:27\n     |\n762  | pub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n     |                           ^^^^ required by this bound in `binn_object_get`\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
        "binn_object_object": "pub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\npub const INT64_MIN: i64 = -9223372036854775808;\npub const INT64_MAX: i64 = 9223372036854775807;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\npub struct BinnIter {\n    pub pnext: Vec<u8>,\n    pub plimit: Vec<u8>,\n    pub current: i32,\n    pub count: i32,\n    pub type_: i32,\n}\n\nimpl Default for BinnIter {\n    fn default() -> Self {\n        BinnIter {\n            pnext: Vec::new(),\n            plimit: Vec::new(),\n            current: 0,\n            count: 0,\n            type_: 0,\n        }\n    }\n}\n\nimpl BinnIter {\n    pub fn is_null(&self) -> bool {\n        self.pnext.is_empty()\n    }\n}\n\npub const INVALID_BINN: i32 = 0;\npub const BINN_STORAGE_MAX: i32 = BINN_STORAGE_CONTAINER;\npub const BINN_STORAGE_MIN: i32 = BINN_STORAGE_NOBYTES;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n\npub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n\npub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n\npub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n\n\npub fn binn_object_object(obj: Option<&Vec<u8>>, key: &str) -> Option<Vec<u8>> {\n    let mut value: Vec<u8> = Vec::new();\n    if binn_object_get(obj, key, BINN_OBJECT, &mut value, None) {\n        Some(value)\n    } else {\n        None\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `Vec<u8>: Copy` is not satisfied\n    --> ../../Output/crown/tmp/test-uncovered_binn_binn_object_object/temp.rs:1085:47\n     |\n1085 |     if binn_object_get(obj, key, BINN_OBJECT, &mut value, None) {\n     |        ---------------                        ^^^^^^^^^^ the trait `Copy` is not implemented for `Vec<u8>`\n     |        |\n     |        required by a bound introduced by this call\n     |\nnote: required by a bound in `binn_object_get`\n    --> ../../Output/crown/tmp/test-uncovered_binn_binn_object_object/temp.rs:758:27\n     |\n758  | pub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n     |                           ^^^^ required by this bound in `binn_object_get`\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
    }
}