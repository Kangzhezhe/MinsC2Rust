{
    "test-quadtree": {
        "test_tree": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct QuadtreePoint {\n    pub x: f64,\n    pub y: f64,\n}\n\npub struct QuadtreeNode<T> {\n    pub ne: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub nw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub se: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub sw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub bounds: Option<Rc<RefCell<QuadtreeBounds>>>,\n    pub point: Option<Rc<RefCell<QuadtreePoint>>>,\n    pub key: Option<T>,\n}\n\npub struct QuadtreeBounds {\n    pub nw: Rc<RefCell<QuadtreePoint>>,\n    pub se: Rc<RefCell<QuadtreePoint>>,\n    pub width: f64,\n    pub height: f64,\n}\n\npub struct Quadtree<T> {\n    pub key_free: Option<fn(T)>,\n    pub root: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n}\n\npub struct quadtree_node_t {\n    ne: Option<Rc<RefCell<quadtree_node_t>>>,\n    nw: Option<Rc<RefCell<quadtree_node_t>>>,\n    se: Option<Rc<RefCell<quadtree_node_t>>>,\n    sw: Option<Rc<RefCell<quadtree_node_t>>>,\n}\n\n\n\npub fn quadtree_new<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Quadtree<T>> {\n    let root = quadtree_node_with_bounds::<T>(minx, miny, maxx, maxy)?;\n    let tree = Quadtree {\n        key_free: None,\n        root: Some(root),\n    };\n    Some(tree)\n}\n\n\npub fn quadtree_insert<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64, key: T) -> i32 {\n    let point = quadtree_point_new(x, y);\n    if point.is_none() {\n        return 0;\n    }\n    let point_rc = Rc::new(RefCell::new(point.unwrap()));\n    if !node_contains_(tree.borrow().root.as_ref().unwrap().clone(), point_rc.clone()) {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    let insert_status = insert_(tree.clone(), tree.borrow().root.as_ref().unwrap().clone(), Some(point_rc.clone()), Some(key));\n    if insert_status == 0 {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    if insert_status == 1 {\n        let mut tree_mut = tree.borrow_mut();\n        // Assuming length is a field in Quadtree struct\n        // If not, you need to add it\n        // tree_mut.length += 1;\n    }\n    insert_status\n}\n\n\npub fn quadtree_point_free(point: Rc<RefCell<QuadtreePoint>>) {\n    // 释放 QuadtreePoint 的内存\n    // 由于 Rc<RefCell<T>> 是智能指针，无需手动释放内存\n}\n\n\npub fn quadtree_node_new<T>() -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = QuadtreeNode {\n        ne: None,\n        nw: None,\n        se: None,\n        sw: None,\n        bounds: None,\n        point: None,\n        key: None,\n    };\n    Some(Rc::new(RefCell::new(node)))\n}\n\n\npub fn quadtree_node_reset<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(point) = &node_borrow.point {\n        quadtree_point_free(point.clone());\n    }\n    if let Some(key) = node_borrow.key.take() {\n        key_free(key);\n    }\n}\n\n\npub fn quadtree_search<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    let tree_ref = tree.borrow();\n    find_(tree_ref.root.clone(), x, y)\n}\n\n\npub fn quadtree_point_new(x: f64, y: f64) -> Option<QuadtreePoint> {\n    Some(QuadtreePoint { x, y })\n}\n\n\npub fn quadtree_node_with_bounds<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = quadtree_node_new()?;\n    let bounds = quadtree_bounds_new()?;\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.bounds = Some(bounds.clone());\n    }\n    quadtree_bounds_extend(bounds.clone(), maxx, maxy);\n    quadtree_bounds_extend(bounds.clone(), minx, miny);\n    Some(node)\n}\n\n\npub fn reset_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) {\n    let key_free = tree.borrow().key_free.clone();\n    if let Some(key_free) = key_free {\n        quadtree_node_reset(node, key_free);\n    } else {\n        let elision_wrap = |key: T| { elision_(key); };\n        quadtree_node_reset(node, elision_wrap);\n    }\n}\n\n\npub fn node_contains_<T>(outer: Rc<RefCell<QuadtreeNode<T>>>, it: Rc<RefCell<QuadtreePoint>>) -> bool {\n    let outer = outer.borrow();\n    let it = it.borrow();\n    if let Some(bounds) = &outer.bounds {\n        let bounds = bounds.borrow();\n        bounds.nw.borrow().x <= it.x &&\n        bounds.nw.borrow().y >= it.y &&\n        bounds.se.borrow().x >= it.x &&\n        bounds.se.borrow().y <= it.y\n    } else {\n        false\n    }\n}\n\n\npub fn quadtree_bounds_extend(bounds: Rc<RefCell<QuadtreeBounds>>, x: f64, y: f64) {\n    let nw_x;\n    let nw_y;\n    let se_x;\n    let se_y;\n    {\n        let bounds = bounds.borrow();\n        let nw = bounds.nw.borrow();\n        let se = bounds.se.borrow();\n        nw_x = f64::min(x, nw.x);\n        nw_y = f64::max(y, nw.y);\n        se_x = f64::max(x, se.x);\n        se_y = f64::min(y, se.y);\n    }\n    {\n        let mut bounds = bounds.borrow_mut();\n        bounds.width = (nw_x - se_x).abs();\n        bounds.height = (nw_y - se_y).abs();\n    }\n}\n\n\npub fn quadtree_free<T>(tree: Rc<RefCell<Quadtree<T>>>) {\n    let tree_borrow = tree.borrow();\n    if let Some(key_free) = tree_borrow.key_free {\n        if let Some(root) = &tree_borrow.root {\n            quadtree_node_free(Rc::clone(root), key_free);\n        }\n    } else {\n        if let Some(root) = &tree_borrow.root {\n            fn elision_wrap<T>(key: T) {\n                elision_(key);\n            }\n            quadtree_node_free(Rc::clone(root), elision_wrap);\n        }\n    }\n}\n\n\npub fn get_quadrant_<T>(root: Rc<RefCell<QuadtreeNode<T>>>, point: Rc<RefCell<QuadtreePoint>>) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let root = root.borrow();\n    if let Some(nw) = &root.nw {\n        if node_contains_(nw.clone(), point.clone()) {\n            return Some(nw.clone());\n        }\n    }\n    if let Some(ne) = &root.ne {\n        if node_contains_(ne.clone(), point.clone()) {\n            return Some(ne.clone());\n        }\n    }\n    if let Some(sw) = &root.sw {\n        if node_contains_(sw.clone(), point.clone()) {\n            return Some(sw.clone());\n        }\n    }\n    if let Some(se) = &root.se {\n        if node_contains_(se.clone(), point.clone()) {\n            return Some(se.clone());\n        }\n    }\n    None\n}\n\n\npub fn insert_<T>(\n    tree: Rc<RefCell<Quadtree<T>>>,\n    root: Rc<RefCell<QuadtreeNode<T>>>,\n    point: Option<Rc<RefCell<QuadtreePoint>>>,\n    key: Option<T>,\n) -> i32 {\n    if quadtree_node_isempty(&root) {\n        {\n            let mut root_mut = root.borrow_mut();\n            root_mut.point = point;\n            root_mut.key = key;\n        }\n        return 1; // normal insertion flag\n    } else if quadtree_node_isleaf(&root) {\n        let root_point = root.borrow().point.as_ref().unwrap().clone();\n        let point_ref = point.as_ref().unwrap().clone();\n        let root_point_borrow = root_point.borrow();\n        let point_ref_borrow = point_ref.borrow();\n        if root_point_borrow.x == point_ref_borrow.x && root_point_borrow.y == point_ref_borrow.y {\n            reset_node_(tree.clone(), root.clone());\n            {\n                let mut root_mut = root.borrow_mut();\n                root_mut.point = point;\n                root_mut.key = key;\n            }\n            return 2; // replace insertion flag\n        } else {\n            if !split_node_(tree.clone(), root.clone()) {\n                return 0; // failed insertion flag\n            }\n            return insert_(tree, root, point, key);\n        }\n    } else if quadtree_node_ispointer(&root) {\n        let quadrant = get_quadrant_(root.clone(), point.as_ref().unwrap().clone());\n        if quadrant.is_none() {\n            return 0;\n        }\n        return insert_(tree, quadrant.unwrap(), point, key);\n    }\n    0\n}\n\n\npub fn quadtree_bounds_new() -> Option<Rc<RefCell<QuadtreeBounds>>> {\n    let nw = Rc::new(RefCell::new(QuadtreePoint { x: f64::INFINITY, y: -f64::INFINITY }));\n    let se = Rc::new(RefCell::new(QuadtreePoint { x: -f64::INFINITY, y: f64::INFINITY }));\n    let bounds = QuadtreeBounds {\n        nw,\n        se,\n        width: 0.0,\n        height: 0.0,\n    };\n    Some(Rc::new(RefCell::new(bounds)))\n}\n\n\npub fn quadtree_node_free<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(nw) = node_borrow.nw.take() {\n        quadtree_node_free(nw, key_free);\n    }\n    if let Some(ne) = node_borrow.ne.take() {\n        quadtree_node_free(ne, key_free);\n    }\n    if let Some(sw) = node_borrow.sw.take() {\n        quadtree_node_free(sw, key_free);\n    }\n    if let Some(se) = node_borrow.se.take() {\n        quadtree_node_free(se, key_free);\n    }\n    if let Some(bounds) = node_borrow.bounds.take() {\n        quadtree_bounds_free(bounds);\n    }\n    quadtree_node_reset(Rc::clone(&node), key_free);\n}\n\n\npub fn elision_<T>(key: T) -> T {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    key\n}\n\n\npub fn descent(node: Rc<RefCell<quadtree_node_t>>) {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    let mut node = node.borrow_mut();\n    if let Some(ne) = &node.ne {\n        descent(Rc::clone(ne));\n    }\n    if let Some(nw) = &node.nw {\n        descent(Rc::clone(nw));\n    }\n    if let Some(se) = &node.se {\n        descent(Rc::clone(se));\n    }\n    if let Some(sw) = &node.sw {\n        descent(Rc::clone(sw));\n    }\n}\n\n\npub fn quadtree_bounds_free(bounds: Rc<RefCell<QuadtreeBounds>>) {\n    // 释放 QuadtreeBounds 的内存\n    // 由于 Rc<RefCell<T>> 是智能指针，无需手动释放内存\n    let bounds = bounds.borrow();\n    quadtree_point_free(Rc::clone(&bounds.nw));\n    quadtree_point_free(Rc::clone(&bounds.se));\n}\n\n\npub fn quadtree_walk<T>(root: Option<Rc<RefCell<QuadtreeNode<T>>>>, descent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>), ascent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>)) {\n    descent(root.clone());\n    if let Some(node) = &root {\n        let node_ref = node.borrow();\n        if let Some(nw) = &node_ref.nw {\n            quadtree_walk(Some(nw.clone()), descent, ascent);\n        }\n        if let Some(ne) = &node_ref.ne {\n            quadtree_walk(Some(ne.clone()), descent, ascent);\n        }\n        if let Some(sw) = &node_ref.sw {\n            quadtree_walk(Some(sw.clone()), descent, ascent);\n        }\n        if let Some(se) = &node_ref.se {\n            quadtree_walk(Some(se.clone()), descent, ascent);\n        }\n    }\n    ascent(root);\n}\n\n\npub fn find_<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        if quadtree_node_isleaf(&node) {\n            if let Some(point) = &node_ref.point {\n                let point_ref = point.borrow();\n                if point_ref.x == x && point_ref.y == y {\n                    return Some(point.clone());\n                }\n            }\n        } else if quadtree_node_ispointer(&node) {\n            let test = Rc::new(RefCell::new(QuadtreePoint { x, y }));\n            return find_(get_quadrant_(node.clone(), test), x, y);\n        }\n    }\n    None\n}\n\n\npub fn ascent<T>(node: Rc<RefCell<QuadtreeNode<T>>>) {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    // Function implementation\n}\n\n\npub fn quadtree_node_ispointer<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_some()\n        && node_ref.ne.is_some()\n        && node_ref.sw.is_some()\n        && node_ref.se.is_some()\n        && !quadtree_node_isleaf(node)\n}\n\n\npub fn quadtree_node_isempty<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_none()\n        && node_ref.ne.is_none()\n        && node_ref.sw.is_none()\n        && node_ref.se.is_none()\n        && !quadtree_node_isleaf(node)\n}\n\n\npub fn quadtree_node_isleaf<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    node.borrow().point.is_some()\n}\n\n\npub fn split_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let x;\n    let y;\n    let hw;\n    let hh;\n    {\n        let node_borrow = node.borrow();\n        let bounds = node_borrow.bounds.as_ref().unwrap().borrow();\n        x = bounds.nw.borrow().x;\n        y = bounds.nw.borrow().y;\n        hw = bounds.width / 2.0;\n        hh = bounds.height / 2.0;\n    }\n\n    let nw = quadtree_node_with_bounds::<T>(x, y - hh, x + hw, y);\n    let ne = quadtree_node_with_bounds::<T>(x + hw, y - hh, x + hw * 2.0, y);\n    let sw = quadtree_node_with_bounds::<T>(x, y - hh * 2.0, x + hw, y - hh);\n    let se = quadtree_node_with_bounds::<T>(x + hw, y - hh * 2.0, x + hw * 2.0, y - hh);\n\n    if nw.is_none() || ne.is_none() || sw.is_none() || se.is_none() {\n        return false;\n    }\n\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.nw = Some(nw.unwrap());\n        node_mut.ne = Some(ne.unwrap());\n        node_mut.sw = Some(sw.unwrap());\n        node_mut.se = Some(se.unwrap());\n    }\n\n    let old_point;\n    let old_key;\n    {\n        let mut node_mut = node.borrow_mut();\n        old_point = node_mut.point.take();\n        old_key = node_mut.key.take();\n    }\n\n    insert_(tree.clone(), node, old_point, old_key) != 0\n}\n\n\npub fn test_tree() {\n    let val = 10;\n\n    let tree = quadtree_new::<i32>(1.0, 1.0, 10.0, 10.0).unwrap();\n    let tree_rc = Rc::new(RefCell::new(tree));\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        let bounds = root.bounds.as_ref().unwrap().borrow();\n        assert_eq!(bounds.nw.borrow().x, 1.0);\n        assert_eq!(bounds.nw.borrow().y, 10.0);\n        assert_eq!(bounds.se.borrow().x, 10.0);\n        assert_eq!(bounds.se.borrow().y, 1.0);\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 0.0, 0.0, val), 0);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 110.0, 110.0, val), 0);\n\n    assert_ne!(quadtree_insert(tree_rc.clone(), 8.0, 2.0, val), 0);\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        let point = root.point.as_ref().unwrap().borrow();\n        assert_eq!(point.x, 8.0);\n        assert_eq!(point.y, 2.0);\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 0.0, 1.0, val), 0);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 2.0, 3.0, val), 1);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 2.0, 3.0, val), 2);\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        assert!(root.point.is_none());\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 3.0, 1.1, val), 1);\n    {\n        let point = quadtree_search(tree_rc.clone(), 3.0, 1.1).unwrap();\n        let point_ref = point.borrow();\n        assert_eq!(point_ref.x, 3.0);\n    }\n\n    fn ascent_wrap<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>) {\n        if let Some(node) = node {\n            ascent(node);\n        }\n    }\n\n    fn descent_wrap<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>) {\n        if let Some(node) = node {\n            let node_t = Rc::new(RefCell::new(quadtree_node_t {\n                ne: None,\n                nw: None,\n                se: None,\n                sw: None,\n            }));\n            descent(node_t);\n        }\n    }\n\n    quadtree_walk(tree_rc.borrow().root.clone(), ascent_wrap, descent_wrap);\n    quadtree_free(tree_rc);\n}\n\nfn main(){}\n\n\n //编译报错信息："
    },
    "test-rgba": {
        "test_named": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub struct Rgba {\n    pub r: f64,\n    pub g: f64,\n    pub b: f64,\n    pub a: f64,\n}\n\npub struct NamedColor {\n    pub name: &'static str,\n    pub val: u32,\n}\n\npub const NAMED_COLORS: &[NamedColor] = &[\n    NamedColor { name: \"transparent\", val: 0xFFFFFF00 },\n    NamedColor { name: \"aliceblue\", val: 0xF0F8FFFF },\n    NamedColor { name: \"antiquewhite\", val: 0xFAEBD7FF },\n    NamedColor { name: \"aqua\", val: 0x00FFFFFF },\n    NamedColor { name: \"aquamarine\", val: 0x7FFFD4FF },\n    NamedColor { name: \"azure\", val: 0xF0FFFFFF },\n    NamedColor { name: \"beige\", val: 0xF5F5DCFF },\n    NamedColor { name: \"bisque\", val: 0xFFE4C4FF },\n    NamedColor { name: \"black\", val: 0x000000FF },\n    NamedColor { name: \"blanchedalmond\", val: 0xFFEBCDFF },\n    NamedColor { name: \"blue\", val: 0x0000FFFF },\n    NamedColor { name: \"blueviolet\", val: 0x8A2BE2FF },\n    NamedColor { name: \"brown\", val: 0xA52A2AFF },\n    NamedColor { name: \"burlywood\", val: 0xDEB887FF },\n    NamedColor { name: \"cadetblue\", val: 0x5F9EA0FF },\n    NamedColor { name: \"chartreuse\", val: 0x7FFF00FF },\n    NamedColor { name: \"chocolate\", val: 0xD2691EFF },\n    NamedColor { name: \"coral\", val: 0xFF7F50FF },\n    NamedColor { name: \"cornflowerblue\", val: 0x6495EDFF },\n    NamedColor { name: \"cornsilk\", val: 0xFFF8DCFF },\n    NamedColor { name: \"crimson\", val: 0xDC143CFF },\n    NamedColor { name: \"cyan\", val: 0x00FFFFFF },\n    NamedColor { name: \"darkblue\", val: 0x00008BFF },\n    NamedColor { name: \"darkcyan\", val: 0x008B8BFF },\n    NamedColor { name: \"darkgoldenrod\", val: 0xB8860BFF },\n    NamedColor { name: \"darkgray\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkgreen\", val: 0x006400FF },\n    NamedColor { name: \"darkgrey\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkkhaki\", val: 0xBDB76BFF },\n    NamedColor { name: \"darkmagenta\", val: 0x8B008BFF },\n    NamedColor { name: \"darkolivegreen\", val: 0x556B2FFF },\n    NamedColor { name: \"darkorange\", val: 0xFF8C00FF },\n    NamedColor { name: \"darkorchid\", val: 0x9932CCFF },\n    NamedColor { name: \"darkred\", val: 0x8B0000FF },\n    NamedColor { name: \"darksalmon\", val: 0xE9967AFF },\n    NamedColor { name: \"darkseagreen\", val: 0x8FBC8FFF },\n    NamedColor { name: \"darkslateblue\", val: 0x483D8BFF },\n    NamedColor { name: \"darkslategray\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkslategrey\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkturquoise\", val: 0x00CED1FF },\n    NamedColor { name: \"darkviolet\", val: 0x9400D3FF },\n    NamedColor { name: \"deeppink\", val: 0xFF1493FF },\n    NamedColor { name: \"deepskyblue\", val: 0x00BFFFFF },\n    NamedColor { name: \"dimgray\", val: 0x696969FF },\n    NamedColor { name: \"dimgrey\", val: 0x696969FF },\n    NamedColor { name: \"dodgerblue\", val: 0x1E90FFFF },\n    NamedColor { name: \"firebrick\", val: 0xB22222FF },\n    NamedColor { name: \"floralwhite\", val: 0xFFFAF0FF },\n    NamedColor { name: \"forestgreen\", val: 0x228B22FF },\n    NamedColor { name: \"fuchsia\", val: 0xFF00FFFF },\n    NamedColor { name: \"gainsboro\", val: 0xDCDCDCFF },\n    NamedColor { name: \"ghostwhite\", val: 0xF8F8FFFF },\n    NamedColor { name: \"gold\", val: 0xFFD700FF },\n    NamedColor { name: \"goldenrod\", val: 0xDAA520FF },\n    NamedColor { name: \"gray\", val: 0x808080FF },\n    NamedColor { name: \"green\", val: 0x008000FF },\n    NamedColor { name: \"greenyellow\", val: 0xADFF2FFF },\n    NamedColor { name: \"grey\", val: 0x808080FF },\n    NamedColor { name: \"honeydew\", val: 0xF0FFF0FF },\n    NamedColor { name: \"hotpink\", val: 0xFF69B4FF },\n    NamedColor { name: \"indianred\", val: 0xCD5C5CFF },\n    NamedColor { name: \"indigo\", val: 0x4B0082FF },\n    NamedColor { name: \"ivory\", val: 0xFFFFF0FF },\n    NamedColor { name: \"khaki\", val: 0xF0E68CFF },\n    NamedColor { name: \"lavender\", val: 0xE6E6FAFF },\n    NamedColor { name: \"lavenderblush\", val: 0xFFF0F5FF },\n    NamedColor { name: \"lawngreen\", val: 0x7CFC00FF },\n    NamedColor { name: \"lemonchiffon\", val: 0xFFFACDFF },\n    NamedColor { name: \"lightblue\", val: 0xADD8E6FF },\n    NamedColor { name: \"lightcoral\", val: 0xF08080FF },\n    NamedColor { name: \"lightcyan\", val: 0xE0FFFFFF },\n    NamedColor { name: \"lightgoldenrodyellow\", val: 0xFAFAD2FF },\n    NamedColor { name: \"lightgray\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightgreen\", val: 0x90EE90FF },\n    NamedColor { name: \"lightgrey\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightpink\", val: 0xFFB6C1FF },\n    NamedColor { name: \"lightsalmon\", val: 0xFFA07AFF },\n    NamedColor { name: \"lightseagreen\", val: 0x20B2AAFF },\n    NamedColor { name: \"lightskyblue\", val: 0x87CEFAFF },\n    NamedColor { name: \"lightslategray\", val: 0x778899FF },\n    NamedColor { name: \"lightslategrey\", val: 0x778899FF },\n    NamedColor { name: \"lightsteelblue\", val: 0xB0C4DEFF },\n    NamedColor { name: \"lightyellow\", val: 0xFFFFE0FF },\n    NamedColor { name: \"lime\", val: 0x00FF00FF },\n    NamedColor { name: \"limegreen\", val: 0x32CD32FF },\n    NamedColor { name: \"linen\", val: 0xFAF0E6FF },\n    NamedColor { name: \"magenta\", val: 0xFF00FFFF },\n    NamedColor { name: \"maroon\", val: 0x800000FF },\n    NamedColor { name: \"mediumaquamarine\", val: 0x66CDAAFF },\n    NamedColor { name: \"mediumblue\", val: 0x0000CDFF },\n    NamedColor { name: \"mediumorchid\", val: 0xBA55D3FF },\n    NamedColor { name: \"mediumpurple\", val: 0x9370DBFF },\n    NamedColor { name: \"mediumseagreen\", val: 0x3CB371FF },\n    NamedColor { name: \"mediumslateblue\", val: 0x7B68EEFF },\n    NamedColor { name: \"mediumspringgreen\", val: 0x00FA9AFF },\n    NamedColor { name: \"mediumturquoise\", val: 0x48D1CCFF },\n    NamedColor { name: \"mediumvioletred\", val: 0xC71585FF },\n    NamedColor { name: \"midnightblue\", val: 0x191970FF },\n    NamedColor { name: \"mintcream\", val: 0xF5FFFAFF },\n    NamedColor { name: \"mistyrose\", val: 0xFFE4E1FF },\n    NamedColor { name: \"moccasin\", val: 0xFFE4B5FF },\n    NamedColor { name: \"navajowhite\", val: 0xFFDEADFF },\n    NamedColor { name: \"navy\", val: 0x000080FF },\n    NamedColor { name: \"oldlace\", val: 0xFDF5E6FF },\n    NamedColor { name: \"olive\", val: 0x808000FF },\n    NamedColor { name: \"olivedrab\", val: 0x6B8E23FF },\n    NamedColor { name: \"orange\", val: 0xFFA500FF },\n    NamedColor { name: \"orangered\", val: 0xFF4500FF },\n    NamedColor { name: \"orchid\", val: 0xDA70D6FF },\n    NamedColor { name: \"palegoldenrod\", val: 0xEEE8AAFF },\n    NamedColor { name: \"palegreen\", val: 0x98FB98FF },\n    NamedColor { name: \"paleturquoise\", val: 0xAFEEEEFF },\n    NamedColor { name: \"palevioletred\", val: 0xDB7093FF },\n    NamedColor { name: \"papayawhip\", val: 0xFFEFD5FF },\n    NamedColor { name: \"peachpuff\", val: 0xFFDAB9FF },\n    NamedColor { name: \"peru\", val: 0xCD853FFF },\n    NamedColor { name: \"pink\", val: 0xFFC0CBFF },\n    NamedColor { name: \"plum\", val: 0xDDA0DDFF },\n    NamedColor { name: \"powderblue\", val: 0xB0E0E6FF },\n    NamedColor { name: \"purple\", val: 0x800080FF },\n    NamedColor { name: \"red\", val: 0xFF0000FF },\n    NamedColor { name: \"rosybrown\", val: 0xBC8F8FFF },\n    NamedColor { name: \"royalblue\", val: 0x4169E1FF },\n    NamedColor { name: \"saddlebrown\", val: 0x8B4513FF },\n    NamedColor { name: \"salmon\", val: 0xFA8072FF },\n    NamedColor { name: \"sandybrown\", val: 0xF4A460FF },\n    NamedColor { name: \"seagreen\", val: 0x2E8B57FF },\n    NamedColor { name: \"seashell\", val: 0xFFF5EEFF },\n    NamedColor { name: \"sienna\", val: 0xA0522DFF },\n    NamedColor { name: \"silver\", val: 0xC0C0C0FF },\n    NamedColor { name: \"skyblue\", val: 0x87CEEBFF },\n    NamedColor { name: \"slateblue\", val: 0x6A5ACDFF },\n    NamedColor { name: \"slategray\", val: 0x708090FF },\n    NamedColor { name: \"slategrey\", val: 0x708090FF },\n    NamedColor { name: \"snow\", val: 0xFFFAFAFF },\n    NamedColor { name: \"springgreen\", val: 0x00FF7FFF },\n    NamedColor { name: \"steelblue\", val: 0x4682B4FF },\n    NamedColor { name: \"tan\", val: 0xD2B48CFF },\n    NamedColor { name: \"teal\", val: 0x008080FF },\n    NamedColor { name: \"thistle\", val: 0xD8BFD8FF },\n    NamedColor { name: \"tomato\", val: 0xFF6347FF },\n    NamedColor { name: \"turquoise\", val: 0x40E0D0FF },\n    NamedColor { name: \"violet\", val: 0xEE82EEFF },\n    NamedColor { name: \"wheat\", val: 0xF5DEB3FF },\n    NamedColor { name: \"white\", val: 0xFFFFFFFF },\n    NamedColor { name: \"whitesmoke\", val: 0xF5F5F5FF },\n    NamedColor { name: \"yellow\", val: 0xFFFF00FF },\n    NamedColor { name: \"yellowgreen\", val: 0x9ACD32FF }\n];\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npub fn rgba_to_string(rgba: Rgba, buf: &mut String, len: usize) {\n    if rgba.a == 1.0 {\n        *buf = format!(\"#{:02x}{:02x}{:02x}\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8);\n    } else {\n        *buf = format!(\"rgba({}, {}, {}, {:.2})\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8, \n            rgba.a);\n    }\n}\n\n\npub fn rgba_new(rgba: u32) -> Rgba {\n    let mut color = Rgba {\n        r: 0.0,\n        g: 0.0,\n        b: 0.0,\n        a: 0.0,\n    };\n    color.r = (rgba >> 24) as f64 / 255.0;\n    color.g = ((rgba >> 16) & 0xff) as f64 / 255.0;\n    color.b = ((rgba >> 8) & 0xff) as f64 / 255.0;\n    color.a = (rgba & 0xff) as f64 / 255.0;\n    color\n}\n\n\npub fn test_to_string() {\n    let mut buf = String::new();\n    let color = rgba_new(0xffcc00ff);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"#ffcc00\", buf);\n\n    let color = rgba_new(0xffcc0050);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"rgba(255, 204, 0, 0.31)\", buf);\n}\n\n\npub fn rgba_from_string(str: &str, ok: &mut i16) -> u32 {\n    let mut bool_ok = false;\n    let result = if str.starts_with('#') {\n        rgba_from_hex_string(str[1..].to_string(), ok)\n    } else if str.starts_with(\"rgba\") {\n        rgba_from_rgba_string(str.to_string(), &mut bool_ok)\n    } else if str.starts_with(\"rgb\") {\n        rgba_from_rgb_string(str, &mut bool_ok)\n    } else {\n        rgba_from_name_string(str, &mut bool_ok)\n    };\n    *ok = if bool_ok { 1 } else { 0 };\n    result\n}\n\n\npub fn rgba_from_rgba_string(str: String, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgba(\") {\n        let mut str = str[5..].to_string();\n        str = str.trim().to_string();\n        \n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut a: f32 = 0.0;\n        \n        let mut iter = str.split_whitespace();\n        if let Some(r_str) = iter.next() {\n            if let Ok(r_val) = r_str.parse::<u8>() {\n                r = r_val;\n            }\n        }\n        if let Some(g_str) = iter.next() {\n            if let Ok(g_val) = g_str.parse::<u8>() {\n                g = g_val;\n            }\n        }\n        if let Some(b_str) = iter.next() {\n            if let Ok(b_val) = b_str.parse::<u8>() {\n                b = b_val;\n            }\n        }\n        if let Some(a_str) = iter.next() {\n            if a_str.starts_with('1') {\n                a = 1.0;\n            } else if a_str.starts_with('0') {\n                if a_str.len() > 1 && a_str.chars().nth(1) == Some('.') {\n                    let mut n = 0.1;\n                    for c in a_str[2..].chars() {\n                        if c.is_digit(10) {\n                            a += (c.to_digit(10).unwrap() as f32) * n;\n                            n *= 0.1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        *ok = true;\n        return rgba_from_rgba(r, g, b, (a * 255.0) as u8);\n    }\n    \n    *ok = false;\n    0\n}\n\n\npub fn rgba_from_hex3_string(str: String) -> u32 {\n    let mut chars = str.chars();\n    let r_char = chars.next().unwrap_or('0');\n    let g_char = chars.next().unwrap_or('0');\n    let b_char = chars.next().unwrap_or('0');\n    \n    let r = (h(r_char) << 4) + h(r_char);\n    let g = (h(g_char) << 4) + h(g_char);\n    let b = (h(b_char) << 4) + h(b_char);\n    \n    rgba_from_rgb(r as u8, g as u8, b as u8)\n}\n\n\npub fn rgba_from_name_string(str: &str, ok: &mut bool) -> u32 {\n    for color in NAMED_COLORS {\n        if str == color.name {\n            *ok = true;\n            return color.val;\n        }\n    }\n    *ok = false;\n    0\n}\n\n\npub fn rgba_from_rgb_string(str: &str, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgb(\") {\n        let mut str = &str[4..];\n        str = str.trim_start();\n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut chars = str.chars();\n        let parse_channel = |c: &mut std::str::Chars| {\n            let mut num = 0;\n            while let Some(ch) = c.next() {\n                if ch.is_ascii_digit() {\n                    num = num * 10 + (ch as u8 - b'0');\n                } else if ch == ',' || ch == ')' {\n                    break;\n                }\n            }\n            num\n        };\n        r = parse_channel(&mut chars);\n        g = parse_channel(&mut chars);\n        b = parse_channel(&mut chars);\n        *ok = true;\n        return rgba_from_rgb(r, g, b);\n    }\n    *ok = false;\n    0\n}\n\n\npub fn rgba_from_rgb(r: u8, g: u8, b: u8) -> u32 {\n    rgba_from_rgba(r, g, b, 255)\n}\n\n\npub fn rgba_from_rgba(r: u8, g: u8, b: u8, a: u8) -> u32 {\n    (r as u32) << 24 | (g as u32) << 16 | (b as u32) << 8 | (a as u32)\n}\n\n\npub fn rgba_from_hex_string(str: String, ok: &mut i16) -> u32 {\n    let len = str.len();\n    *ok = 1;\n    if len == 6 {\n        return rgba_from_hex6_string(str);\n    }\n    if len == 3 {\n        return rgba_from_hex3_string(str);\n    }\n    *ok = 0;\n    0\n}\n\n\npub fn rgba_from_hex6_string(str: String) -> u32 {\n    let chars: Vec<char> = str.chars().collect();\n    rgba_from_rgb(\n        ((h(chars[0]) << 4) + h(chars[1])) as u8,\n        ((h(chars[2]) << 4) + h(chars[3])) as u8,\n        ((h(chars[4]) << 4) + h(chars[5])) as u8,\n    )\n}\n\n\npub fn h(c: char) -> i32 {\n    match c {\n        '0'..='9' => (c as i32) - ('0' as i32),\n        'a'..='f' => (c as i32) - ('a' as i32) + 10,\n        'A'..='F' => (c as i32) - ('A' as i32) + 10,\n        _ => 0,\n    }\n}\n\n\npub fn test_named() {\n    let mut ok: i16 = 0;\n    let val = rgba_from_string(\"olive\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0x808000FF, val);\n}\n\n\nfn main(){}\n\n //insert编译报错信息：error: unknown start of token: \\u{ff0c}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:42\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                              ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地,我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。\n   |                                              ~\n\nerror: unknown start of token: \\u{ff0c}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:56\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                                                          ^^\n   |\nhelp: Unicode character '，' (Fullwidth Comma) looks like ',' (Comma), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本,因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。\n   |                                                                          ~\n\nerror: unknown start of token: \\u{3002}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:69\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                                                                                    ^^\n   |\nhelp: Unicode character '。' (Ideographic Full Stop) looks like '.' (Period), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力.请尝试缩短文本或将其分成更小的部分。\n   |                                                                                                    ~\n\nerror: unknown start of token: \\u{3002}\n  --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:35:87\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n   |                                                                                                                                        ^^\n   |\nhelp: Unicode character '。' (Ideographic Full Stop) looks like '.' (Period), but it is not\n   |\n35 |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分.\n   |                                                                                                                                        ~\n\nerror: this file contains an unclosed delimiter\n   --> ../../exp/rgba/Output/tmp/test-rgba_test_named/test_source.rs:255:12\n    |\n13  | pub const NAMED_COLORS: &[NamedColor] = &[\n    |                                          - unclosed delimiter\n...\n35  |     NamedColor { name: \"cyan\", val: 0极可能地，我无法完全处理您提供的文本，因为它超出了我的处理能力。请尝试缩短文本或将其分成更小的部分。                                               ...\n    |                - unclosed delimiter\n...\n255 | fn main(){}\n    |            ^\n\nerror: aborting due to 5 previous errors\n\n"
    }
}