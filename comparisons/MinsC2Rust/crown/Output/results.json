{
    "bst": {
        "_bst_subtree_min_val": "pub fn _bst_subtree_min_val<T: Ord + Clone>(n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<T> {\n    // The minimum value in any subtree is just the leftmost value. Keep going \n    // left till we get there.\n    let mut current = n;\n    while let Some(node) = current {\n        if node.borrow().left.is_none() {\n            return Some(node.borrow().val.clone());\n        }\n        current = node.borrow().left.clone();\n    }\n    None\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BstNode<T> {\n    pub val: T,\n    pub left: Option<Rc<RefCell<BstNode<T>>>>,\n    pub right: Option<Rc<RefCell<BstNode<T>>>>,\n}\n\npub struct Bst<T> {\n    pub root: Option<Rc<RefCell<BstNode<T>>>>,\n}\n",
        "_bst_subtree_remove": "pub fn _bst_subtree_remove<T: Ord + Clone>(val: T, n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<Rc<RefCell<BstNode<T>>>> {\n    if n.is_none() {\n        return None;\n    }\n\n    let node = n.unwrap();\n    let mut node_borrow = node.borrow_mut();\n\n    if val < node_borrow.val {\n        let left = node_borrow.left.take();\n        node_borrow.left = _bst_subtree_remove(val, left);\n        drop(node_borrow);\n        return Some(node);\n    } else if val > node_borrow.val {\n        let right = node_borrow.right.take();\n        node_borrow.right = _bst_subtree_remove(val, right);\n        drop(node_borrow);\n        return Some(node);\n    } else {\n        if node_borrow.left.is_some() && node_borrow.right.is_some() {\n            let min_val = _bst_subtree_min_val(node_borrow.right.clone()).unwrap();\n            node_borrow.val = min_val.clone();\n            let right = node_borrow.right.take();\n            node_borrow.right = _bst_subtree_remove(min_val, right);\n            drop(node_borrow);\n            return Some(node);\n        } else if node_borrow.left.is_some() {\n            let left = node_borrow.left.take();\n            drop(node_borrow);\n            return left;\n        } else if node_borrow.right.is_some() {\n            let right = node_borrow.right.take();\n            drop(node_borrow);\n            return right;\n        } else {\n            drop(node_borrow);\n            return None;\n        }\n    }\n}\n\n",
        "_bst_node_create": "pub fn _bst_node_create<T>(val: T) -> Rc<RefCell<BstNode<T>>> {\n    let node = Rc::new(RefCell::new(BstNode {\n        val,\n        left: None,\n        right: None,\n    }));\n    node\n}\n\n",
        "bst_remove": "pub fn bst_remove<T: Ord + Clone>(val: T, bst: &mut Bst<T>) {\n    assert!(bst.root.is_some());\n\n    // We remove val by using our subtree removal function starting with the\n    // subtree rooted at bst->root (i.e. the whole tree).\n    let root = bst.root.take();\n    bst.root = _bst_subtree_remove(val, root);\n}\n\n",
        "bst_isempty": "pub fn bst_isempty<T>(bst: &Bst<T>) -> bool {\n    bst.root.is_none()\n}\n\n",
        "_bst_subtree_insert": "pub fn _bst_subtree_insert<T: PartialOrd + Clone>(val: T, n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<Rc<RefCell<BstNode<T>>>> {\n    match n {\n        None => {\n            Some(_bst_node_create(val))\n        },\n        Some(node) => {\n            let mut node_mut = node.borrow_mut();\n            if val < node_mut.val {\n                node_mut.left = _bst_subtree_insert(val, node_mut.left.clone());\n            } else {\n                node_mut.right = _bst_subtree_insert(val, node_mut.right.clone());\n            }\n            Some(node.clone())\n        }\n    }\n}\n\n",
        "bst_free": "pub fn bst_free<T: Ord + Clone>(mut bst: Bst<T>) {\n    assert!(bst.root.is_some());\n\n    // Assume that bst_remove() frees each node it removes and use it to free\n    // all of the nodes in the tree.\n    while !bst_isempty(&bst) {\n        let root_val = bst.root.as_ref().unwrap().borrow().val.clone();\n        bst_remove(root_val, &mut bst);\n    }\n}\n\n",
        "bst_contains": "pub fn bst_contains<T: PartialOrd>(val: T, bst: &Bst<T>) -> bool {\n    assert!(bst.root.is_some());\n\n    let mut cur = bst.root.clone();\n    while let Some(node) = cur {\n        let node_ref = node.borrow();\n        if val == node_ref.val {\n            return true;\n        } else if val < node_ref.val {\n            cur = node_ref.left.clone();\n        } else {\n            cur = node_ref.right.clone();\n        }\n    }\n\n    false\n}\n\n",
        "bst_insert": "pub fn bst_insert<T: PartialOrd + Clone>(val: T, bst: &mut Bst<T>) {\n    assert!(bst.root.is_some());\n    bst.root = _bst_subtree_insert(val, bst.root.clone());\n}\n\n",
        "bst_create": "pub fn bst_create<T>() -> Bst<T> {\n    Bst { root: None }\n}\n\n"
    },
    "test-bst": {
        "main": "fn main(){}\n",
        "test_bst": "pub fn test_bst() {\n    let mut bst = bst_create();\n    let good_nums = [32, 16, 8, 12, 4, 64, 48, 80];\n    let bad_nums = [1, 3, 5, 7, 9, 11, 13, 15];\n\n    // Initialize the tree.\n    for i in 0..8 {\n        bst_insert(good_nums[i], &mut bst);\n    }\n\n    // Test containment.\n    for i in 0..8 {\n        assert!(bst_contains(good_nums[i], &bst));\n    }\n    println!(\"== Verified that BST contains all the expected values.\");\n\n    for i in 0..8 {\n        assert!(!bst_contains(bad_nums[i], &bst));\n    }\n    println!(\"== Verified that BST contains none of the unexpected values.\");\n\n    /*\n     * Test removal by removing one good number at a time and making sure the\n     * remaining good numbers are still in the tree.\n     */\n    for i in 0..8 {\n        bst_remove(good_nums[i], &mut bst);\n        assert!(!bst_contains(good_nums[i], &bst));\n        for j in (i + 1)..8 {\n            assert!(bst_contains(good_nums[j], &bst));\n        }\n    }\n    println!(\"== Verified removal works as expected.\");\n\n    bst_free(bst);\n}\n\n",
        "extra": "\nuse test_project::bst::{_bst_subtree_insert, bst_free, bst_contains, bst_isempty, bst_create, _bst_subtree_remove, _bst_node_create, bst_remove, _bst_subtree_min_val, bst_insert};\n"
    },
    "buffer": {
        "buffer_resize": "pub fn buffer_resize(buffer: &mut Buffer, n: usize) -> i32 {\n    let n = ((n + 1023) / 1024) * 1024;\n    buffer.len = n;\n    buffer.alloc = String::with_capacity(n + 1);\n    buffer.data = buffer.alloc.clone();\n    buffer.alloc.push('\\0');\n    0\n}\n\n",
        "extra": "pub const BUFFER_DEFAULT_SIZE: usize = 1024;\n\n#[derive(Clone)]\npub struct Buffer {\n    pub len: usize,\n    pub alloc: String,\n    pub data: String,\n}\n",
        "buffer_length": "pub fn buffer_length(buffer: &Buffer) -> usize {\n    buffer.data.len()\n}\n\n",
        "buffer_append_n": "pub fn buffer_append_n(buffer: &mut Buffer, str: &str, len: usize) -> i32 {\n    let prev = buffer.data.len();\n    let needed = len + prev;\n\n    if buffer.len > needed {\n        buffer.data.push_str(&str[..len]);\n        return 0;\n    }\n\n    let ret = buffer_resize(buffer, needed);\n    if ret == -1 {\n        return -1;\n    }\n\n    buffer.data.push_str(&str[..len]);\n    0\n}\n\n",
        "buffer_new_with_size": "pub fn buffer_new_with_size(n: usize) -> Result<Buffer, String> {\n    let mut buffer = Buffer {\n        len: n,\n        alloc: String::with_capacity(n + 1),\n        data: String::with_capacity(n + 1),\n    };\n    buffer.alloc.push_str(&\"\\0\".repeat(n + 1));\n    buffer.data.push_str(&\"\\0\".repeat(n + 1));\n    Ok(buffer)\n}\n\n",
        "buffer_trim_right": "pub fn buffer_trim_right(buffer: &mut Buffer) {\n    let mut i = buffer_length(buffer) - 1;\n    while i >= 0 {\n        let c = buffer.data.chars().nth(i as usize).unwrap();\n        if !c.is_whitespace() {\n            break;\n        }\n        buffer.data.truncate(i as usize);\n        i -= 1;\n        if i < 0 {\n            break;\n        }\n    }\n}\n\n",
        "buffer_trim_left": "pub fn buffer_trim_left(buffer: &mut Buffer) {\n    while let Some(c) = buffer.data.chars().next() {\n        if !c.is_whitespace() {\n            break;\n        }\n        buffer.data = buffer.data[1..].to_string();\n    }\n}\n\n",
        "buffer_fill": "pub fn buffer_fill(buffer: &mut Buffer, c: i32) {\n    buffer.data = vec![c as u8; buffer.len].iter().map(|&b| b as char).collect();\n}\n\n",
        "buffer_free": "pub fn buffer_free(buffer: Buffer) {\n    // Function to free the buffer's allocated memory\n    // No explicit free needed in Rust due to ownership and drop semantics\n}\n\n",
        "buffer_prepend": "pub fn buffer_prepend(buffer: &mut Buffer, str: String) -> i32 {\n    let len = str.len();\n    let prev = buffer.data.len();\n    let needed = len + prev;\n\n    if buffer.len > needed {\n        // enough space\n    } else {\n        // resize\n        let ret = buffer_resize(buffer, needed);\n        if ret == -1 {\n            return -1;\n        }\n    }\n\n    // move\n    let mut new_data = String::with_capacity(needed + 1);\n    new_data.push_str(&str);\n    new_data.push_str(&buffer.data);\n    buffer.data = new_data;\n\n    0\n}\n\n",
        "buffer_append": "pub fn buffer_append(buffer: &mut Buffer, str: &str) -> i32 {\n    buffer_append_n(buffer, str, str.len())\n}\n\n",
        "buffer_new": "pub fn buffer_new() -> Result<Buffer, String> {\n    buffer_new_with_size(BUFFER_DEFAULT_SIZE)\n}\n\n",
        "buffer_size": "pub fn buffer_size(buffer: &Buffer) -> usize {\n    buffer.len\n}\n\n",
        "buffer_slice": "pub fn buffer_slice(buf: &Buffer, from: usize, to: isize) -> Result<Buffer, String> {\n    let len = buf.data.len();\n\n    // bad range\n    if to < from as isize {\n        return Err(\"Invalid range\".to_string());\n    }\n\n    // relative to end\n    let to = if to < 0 {\n        len - (!to as usize)\n    } else {\n        to as usize\n    };\n\n    // cap end\n    let to = if to > len { len } else { to };\n\n    let n = to - from;\n    let mut self_buf = buffer_new_with_size(n)?;\n    self_buf.data = buf.data[from..to].to_string();\n    Ok(self_buf)\n}\n\n",
        "buffer_new_with_copy": "pub fn buffer_new_with_copy(str: String) -> Result<Buffer, String> {\n    let len = str.len();\n    let mut buffer = buffer_new_with_size(len)?;\n    buffer.alloc = str.clone();\n    buffer.data = str;\n    Ok(buffer)\n}\n\n",
        "buffer_trim": "pub fn buffer_trim(buffer: &mut Buffer) {\n    buffer_trim_left(buffer);\n    buffer_trim_right(buffer);\n}\n\n",
        "buffer_compact": "pub fn buffer_compact(buffer: &mut Buffer) -> i32 {\n    let len = buffer_length(buffer);\n    let rem = buffer.len - len;\n    let mut buf = String::with_capacity(len + 1);\n    buf.push_str(&buffer.data);\n    buffer.alloc = buf.clone();\n    buffer.data = buf;\n    buffer.len = len;\n    rem as i32\n}\n\n",
        "buffer_indexof": "pub fn buffer_indexof(buffer: &Buffer, str: String) -> i32 {\n    let sub = buffer.data.find(&str);\n    match sub {\n        Some(index) => index as i32,\n        None => -1,\n    }\n}\n\n",
        "buffer_clear": "pub fn buffer_clear(buffer: &mut Buffer) {  \n    buffer_fill(buffer, 0);  \n}\n\n",
        "buffer_appendf": "pub fn buffer_appendf(buffer: &mut Buffer, format: String, args: Vec<String>) -> i32 {\n    let length = buffer_length(buffer);\n    let required = format.len();\n    if buffer_resize(buffer, length + required) == -1 {\n        return -1;\n    }\n    let dst = &mut buffer.data[length..];\n    let mut s = dst.to_string();\n    let formatted_args = format!(\"{}\", args.join(\" \"));\n    let result = std::fmt::write(&mut s, format_args!(\"{}\", formatted_args));\n    if result.is_err() {\n        -1\n    } else {\n        0\n    }\n}\n\n",
        "buffer_equals": "pub fn buffer_equals(buffer: &Buffer, other: &Buffer) -> bool {\n    buffer.data == other.data\n}\n\n"
    },
    "test-buffer": {
        "main": "fn main(){}\n",
        "test_buffer_prepend": "pub fn test_buffer_prepend() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \" World\"));\n    assert_eq!(0, buffer_prepend(&mut buf, \"Hello\".to_string()));\n    assert_eq!(\"Hello World\".len(), buffer_length(&buf));\n    equal(\"Hello World\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "equal": "pub fn equal(a: &str, b: &str) {\n    if a != b {\n        println!();\n        println!(\"  expected: '{}'\", a);\n        println!(\"    actual: '{}'\", b);\n        println!();\n        std::process::exit(1);\n    }\n}\n\n",
        "extra": "use test_project::buffer::{BUFFER_DEFAULT_SIZE, Buffer, buffer_new, buffer_append, buffer_prepend, buffer_length, buffer_free, buffer_size, buffer_new_with_size, buffer_new_with_copy, buffer_slice, buffer_trim, buffer_compact, buffer_append_n, buffer_fill, buffer_indexof, buffer_trim_left, buffer_trim_right, buffer_clear, buffer_appendf, buffer_equals};",
        "test_buffer_new": "pub fn test_buffer_new() {\n    let buf = buffer_new().unwrap();\n    assert_eq!(BUFFER_DEFAULT_SIZE, buffer_size(&buf));\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_new_with_size": "pub fn test_buffer_new_with_size() {\n    let buf = buffer_new_with_size(1024).unwrap();\n    assert_eq!(1024, buffer_size(&buf));\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__end_overflow": "pub fn test_buffer_slice__end_overflow() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n    let a = buffer_slice(&buf, 5, 1000).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"Ferret\", &a.data);\n    buffer_free(a);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_compact": "pub fn test_buffer_compact() {\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim(&mut buf);\n    assert_eq!(5, buffer_length(&buf));\n    assert_eq!(10, buffer_size(&buf));\n\n    let removed = buffer_compact(&mut buf);\n    assert_eq!(5, removed);\n    assert_eq!(5, buffer_length(&buf));\n    assert_eq!(5, buffer_size(&buf));\n    equal(\"Hello\", &buf.data);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append": "pub fn test_buffer_append() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \"Hello\"));\n    assert_eq!(0, buffer_append(&mut buf, \" World\"));\n    assert_eq!(\"Hello World\".len(), buffer_length(&buf));\n    equal(\"Hello World\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append_n": "pub fn test_buffer_append_n() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append_n(&mut buf, \"subway\", 3));\n    assert_eq!(0, buffer_append_n(&mut buf, \"marines\", 6));\n    assert_eq!(\"submarine\".len(), buffer_length(&buf));\n    equal(\"submarine\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append__grow": "pub fn test_buffer_append__grow() {\n    let mut buf = buffer_new_with_size(10).unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \"Hello\"));\n    assert_eq!(0, buffer_append(&mut buf, \" tobi\"));\n    assert_eq!(0, buffer_append(&mut buf, \" was\"));\n    assert_eq!(0, buffer_append(&mut buf, \" here\"));\n\n    let str = \"Hello tobi was here\";\n    equal(str, &buf.data);\n    assert_eq!(1024, buffer_size(&buf));\n    assert_eq!(str.len(), buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_prepend_issue_15": "pub fn test_buffer_prepend_issue_15() {\n    let mut file = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut file, \"layout.bk.html\"));\n    assert_eq!(0, buffer_prepend(&mut file, \"./example/\".to_string()));\n    assert_eq!(\"./example/layout.bk.html\".len(), buffer_length(&file));\n    equal(\"./example/layout.bk.html\", &file.data);\n    buffer_free(file);\n}\n\n",
        "test_buffer_fill": "pub fn test_buffer_fill() {\n    let mut buf = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    assert_eq!(5, buffer_length(&buf));\n\n    buffer_fill(&mut buf, 0);\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_indexof": "pub fn test_buffer_indexof() {\n    let buf = buffer_new_with_copy(String::from(\"Tobi is a ferret\")).unwrap();\n\n    let i = buffer_indexof(&buf, String::from(\"is\"));\n    assert_eq!(5, i);\n\n    let i = buffer_indexof(&buf, String::from(\"a\"));\n    assert_eq!(8, i);\n\n    let i = buffer_indexof(&buf, String::from(\"something\"));\n    assert_eq!(-1, i);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_trim": "pub fn test_buffer_trim() {\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim(&mut buf);\n    equal(\"Hello\", &buf.data);\n\n    buffer_free(buf);\n\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim_left(&mut buf);\n    equal(\"Hello\\n\\n \", &buf.data);\n\n    buffer_free(buf);\n\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim_right(&mut buf);\n    equal(\"  Hello\", &buf.data);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__range_error": "pub fn test_buffer_slice__range_error() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n    let a = buffer_slice(&buf, 10, 2);\n    assert!(a.is_err());\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__end": "pub fn test_buffer_slice__end() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n\n    let a = buffer_slice(&buf, 5, -1).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"Ferret\", &a.data);\n\n    let b = buffer_slice(&buf, 5, -3).unwrap();\n    equal(\"Ferr\", &b.data);\n\n    let c = buffer_slice(&buf, 8, -1).unwrap();\n    equal(\"ret\", &c.data);\n\n    buffer_free(buf);\n    buffer_free(a);\n    buffer_free(b);\n    buffer_free(c);\n}\n\n",
        "test_buffer_clear": "pub fn test_buffer_clear() {\n    let mut buf = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    assert_eq!(5, buffer_length(&buf));\n\n    buffer_clear(&mut buf);\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_formatting": "pub fn test_buffer_formatting() {\n    let mut buf = buffer_new().expect(\"Failed to create buffer\");\n    let result = buffer_appendf(&mut buf, \"%d %s\".to_string(), vec![\"3\".to_string(), \"cow\".to_string()]);\n    assert_eq!(0, result);\n    equal(\"3 cow\", &buf.data);\n    let result = buffer_appendf(&mut buf, \" - 0x%08X\".to_string(), vec![\"0xDEADBEEF\".to_string()]);\n    assert_eq!(0, result);\n    equal(\"3 cow - 0xDEADBEEF\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_equals": "pub fn test_buffer_equals() {\n    let a = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    let b = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n\n    assert!(buffer_equals(&a, &b));\n\n    buffer_append(&mut b.clone(), \" World\");\n    assert!(!buffer_equals(&a, &b));\n\n    buffer_free(a);\n    buffer_free(b);\n}\n\n",
        "test_buffer_slice": "pub fn test_buffer_slice() {\n    let mut buf = buffer_new().unwrap();\n    buffer_append(&mut buf, \"Tobi Ferret\");\n\n    let a = buffer_slice(&buf, 2, 8).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"bi Fer\", &a.data);\n\n    buffer_free(buf);\n    buffer_free(a);\n}\n\nfn nearest_multiple_of(base: usize, n: usize) -> usize {\n    ((n + base - 1) / base) * base\n}\n\n"
    },
    "ht": {
        "hash_key": "pub fn hash_key(key: String) -> u64 {\n    let mut hash: u64 = 14695981039346656037;\n    for c in key.chars() {\n        hash ^= c as u64;\n        hash = hash.wrapping_mul(1099511628211);\n    }\n    hash\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse std::fmt;\n\nconst INITIAL_CAPACITY: usize = 16;\n\n#[derive(Debug)]\npub struct HtEntry<T> {\n    pub key: Option<String>,\n    pub value: Option<T>,\n}\n\n#[derive(Debug)]\npub struct Ht<T> {\n    pub entries: Vec<Rc<RefCell<HtEntry<T>>>>,\n    pub capacity: usize,\n    pub length: usize,\n}\n\npub struct HtIterator<T> {\n    pub key: Option<String>,\n    pub value: Option<T>,\n    pub _table: Rc<RefCell<Ht<T>>>,\n    pub _index: usize,\n}\n",
        "ht_set_entry": "pub fn ht_set_entry<T>(entries: &mut Vec<Rc<RefCell<HtEntry<T>>>>, capacity: usize, key: String, value: T, plength: &mut usize) -> Option<String> {\n    let hash = hash_key(key.clone());\n    let mut index = (hash & (capacity as u64 - 1)) as usize;\n\n    loop {\n        let entry = entries[index].borrow();\n        if let Some(existing_key) = &entry.key {\n            if *existing_key == key {\n                entries[index].borrow_mut().value = Some(value);\n                return Some(existing_key.clone());\n            }\n            index += 1;\n            if index >= capacity {\n                index = 0;\n            }\n        } else {\n            break;\n        }\n    }\n\n    if *plength != 0 {\n        *plength += 1;\n    }\n    entries[index].borrow_mut().key = Some(key.clone());\n    entries[index].borrow_mut().value = Some(value);\n    Some(key)\n}\n\n",
        "ht_expand": "pub fn ht_expand<T: Clone>(entries: &mut Vec<Rc<RefCell<HtEntry<T>>>>, capacity: &mut usize, length: &mut usize) -> bool {\n    let new_capacity = *capacity * 2;\n    if new_capacity < *capacity {\n        return false;  // overflow (capacity would be too big)\n    }\n\n    let mut new_entries = Vec::with_capacity(new_capacity);\n    for _ in 0..new_capacity {\n        new_entries.push(Rc::new(RefCell::new(HtEntry { key: None, value: None })));\n    }\n\n    for i in 0..*capacity {\n        let entry = entries[i].borrow();\n        if let Some(key) = &entry.key {\n            let value = entry.value.as_ref().unwrap().clone();\n            ht_set_entry(&mut new_entries, new_capacity, key.clone(), value, length);\n        }\n    }\n\n    *entries = new_entries;\n    *capacity = new_capacity;\n    true\n}\n\n",
        "ht_destroy": "pub fn ht_destroy<T>(table: Ht<T>) {\n    // First free allocated keys.\n    for i in 0..table.capacity {\n        let mut entry = table.entries[i].borrow_mut();\n        entry.key = None;\n    }\n\n    // Then free entries array and table itself.\n    // Rust's ownership system will automatically handle the cleanup of the Vec and Ht struct.\n}\n\n",
        "ht_create": "pub fn ht_create<T>() -> Ht<T> {\n    let mut table = Ht {\n        entries: Vec::with_capacity(INITIAL_CAPACITY),\n        capacity: INITIAL_CAPACITY,\n        length: 0,\n    };\n    for _ in 0..INITIAL_CAPACITY {\n        table.entries.push(Rc::new(RefCell::new(HtEntry {\n            key: None,\n            value: None,\n        })));\n    }\n    table\n}\n\n",
        "ht_set": "pub fn ht_set<T: Clone>(table: &mut Ht<T>, key: String, value: T) -> Option<String> {\n    if table.length >= table.capacity / 2 {\n        if !ht_expand(&mut table.entries, &mut table.capacity, &mut table.length) {\n            return None;\n        }\n    }\n    ht_set_entry(&mut table.entries, table.capacity, key, value, &mut table.length)\n}\n\n",
        "ht_length": "pub fn ht_length<T>(table: &Ht<T>) -> usize {\n    table.length\n}\n\n",
        "ht_get": "pub fn ht_get<T: Clone>(table: &Ht<T>, key: String) -> Option<Rc<RefCell<T>>> {\n    let hash = hash_key(key.clone());\n    let mut index = (hash & (table.capacity as u64 - 1)) as usize;\n\n    while table.entries[index].borrow().key.is_some() {\n        if table.entries[index].borrow().key.as_ref().unwrap() == &key {\n            let value = table.entries[index].borrow().value.as_ref().unwrap().clone();\n            return Some(Rc::new(RefCell::new(value)));\n        }\n        index += 1;\n        if index >= table.capacity {\n            index = 0;\n        }\n    }\n    None\n}\n\n",
        "ht_iterator": "pub fn ht_iterator<T>(table: Rc<RefCell<Ht<T>>>) -> HtIterator<T> {\n    HtIterator {\n        key: None,\n        value: None,\n        _table: table,\n        _index: 0,\n    }\n}\n\n",
        "ht_next": "pub fn ht_next<T: Clone>(mut it: HtIterator<T>) -> (bool, HtIterator<T>) {\n    let table = Rc::clone(&it._table);\n    let mut table_borrow = table.borrow_mut();\n    while it._index < table_borrow.capacity {\n        let i = it._index;\n        it._index += 1;\n        if let Some(entry) = &table_borrow.entries[i].borrow().key {\n            let entry_borrow = table_borrow.entries[i].borrow();\n            it.key = entry_borrow.key.clone();\n            it.value = entry_borrow.value.as_ref().map(|v| v.clone());\n            return (true, it);\n        }\n    }\n    (false, it)\n}\n\n"
    },
    "test-ht": {
        "main": "fn main(){}\n\n",
        "test_ht_update_value": "pub fn test_ht_update_value() {\n    let mut table = ht_create::<i32>();\n    \n    // Insert a key-value pair\n    let value1 = 42;\n    let key = String::from(\"key\");\n    assert!(ht_set(&mut table, key.clone(), value1).is_some());\n    \n    // Update the value for the same key\n    let value2 = 84;\n    assert!(ht_set(&mut table, key.clone(), value2).is_some());\n    \n    // Retrieve the updated value\n    let retrieved_value = ht_get(&table, key.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value2);\n    \n    // Check the length of the hash table (should still be 1)\n    assert_eq!(ht_length(&table), 1);\n    \n    ht_destroy(table);\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse test_project::ht::{ht_iterator, ht_length, ht_set_entry, ht_create, hash_key, ht_next, ht_destroy, ht_set, ht_expand, ht_get, Ht, HtEntry, HtIterator};",
        "test_ht_memory_management": "pub fn test_ht_memory_management() {\n    let mut table = ht_create::<Rc<RefCell<i32>>>();\n    \n    let value1 = Rc::new(RefCell::new(42));\n    let value2 = Rc::new(RefCell::new(84));\n    \n    assert!(ht_set(&mut table, \"key1\".to_string(), Rc::clone(&value1)).is_some());\n    assert!(ht_set(&mut table, \"key2\".to_string(), Rc::clone(&value2)).is_some());\n    \n    let mut it = ht_iterator(Rc::new(RefCell::new(table)));\n    loop {\n        let (has_next, new_it) = ht_next(it);\n        it = new_it;\n        if !has_next {\n            break;\n        }\n    }\n    \n    let table = Rc::try_unwrap(it._table).unwrap().into_inner();\n    ht_destroy(table);\n}\n\n",
        "test_ht_set_and_get": "pub fn test_ht_set_and_get() {\n    let mut table = ht_create::<i32>();\n\n    // Insert a key-value pair\n    let value1 = 42;\n    let key1 = String::from(\"key1\");\n    assert!(ht_set(&mut table, key1.clone(), value1).is_some());\n\n    // Retrieve the value\n    let retrieved_value = ht_get(&table, key1.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value1);\n\n    // Insert another key-value pair\n    let value2 = 84;\n    let key2 = String::from(\"key2\");\n    assert!(ht_set(&mut table, key2.clone(), value2).is_some());\n\n    // Retrieve the second value\n    let retrieved_value = ht_get(&table, key2.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value2);\n\n    // Check the length of the hash table\n    assert_eq!(ht_length(&table), 2);\n\n    ht_destroy(table);\n}\n\n",
        "test_ht_create_and_destroy": "pub fn test_ht_create_and_destroy() {\n    let mut table = ht_create::<i32>();\n    assert_eq!(ht_length(&table), 0);\n    ht_destroy(table);\n}\n\n",
        "test_ht_iterator": "pub fn test_ht_iterator() {\n    let mut table = ht_create();\n    let value1 = 1;\n    let value2 = 2;\n    let value3 = 3;\n    assert!(ht_set(&mut table, \"key1\".to_string(), value1).is_some());\n    assert!(ht_set(&mut table, \"key2\".to_string(), value2).is_some());\n    assert!(ht_set(&mut table, \"key3\".to_string(), value3).is_some());\n\n    let it = ht_iterator(Rc::new(RefCell::new(table)));\n    let mut count = 0;\n    let mut it = it;\n    loop {\n        let (has_next, new_it) = ht_next(it);\n        it = new_it;\n        if !has_next {\n            break;\n        }\n        assert!(it.key.is_some());\n        assert!(it.value.is_some());\n        count += 1;\n    }\n\n    assert_eq!(count, 3);\n\n    let table = it._table.borrow();\n    let table_clone = Ht {\n        entries: table.entries.clone(),\n        capacity: table.capacity,\n        length: table.length,\n    };\n    ht_destroy(table_clone);\n}\n\n"
    },
    "quadtree": {
        "quadtree_point_new": "pub fn quadtree_point_new(x: f64, y: f64) -> Option<QuadtreePoint> {\n    Some(QuadtreePoint { x, y })\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct QuadtreePoint {\n    pub x: f64,\n    pub y: f64,\n}\n\npub struct QuadtreeNode<T> {\n    pub ne: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub nw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub se: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub sw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub bounds: Option<Rc<RefCell<QuadtreeBounds>>>,\n    pub point: Option<Rc<RefCell<QuadtreePoint>>>,\n    pub key: Option<T>,\n}\n\npub struct QuadtreeBounds {\n    pub nw: Rc<RefCell<QuadtreePoint>>,\n    pub se: Rc<RefCell<QuadtreePoint>>,\n    pub width: f64,\n    pub height: f64,\n}\n\npub struct Quadtree<T> {\n    pub key_free: Option<fn(T)>,\n    pub root: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n}\n\npub struct quadtree_node_t {\n    pub ne: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub nw: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub se: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub sw: Option<Rc<RefCell<quadtree_node_t>>>,\n}\n",
        "quadtree_node_new": "pub fn quadtree_node_new<T>() -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = QuadtreeNode {\n        ne: None,\n        nw: None,\n        se: None,\n        sw: None,\n        bounds: None,\n        point: None,\n        key: None,\n    };\n    Some(Rc::new(RefCell::new(node)))\n}\n\n",
        "quadtree_bounds_extend": "pub fn quadtree_bounds_extend(bounds: Rc<RefCell<QuadtreeBounds>>, x: f64, y: f64) {\n    let nw_x;\n    let nw_y;\n    let se_x;\n    let se_y;\n    {\n        let bounds = bounds.borrow();\n        let nw = bounds.nw.borrow();\n        let se = bounds.se.borrow();\n        nw_x = f64::min(x, nw.x);\n        nw_y = f64::max(y, nw.y);\n        se_x = f64::max(x, se.x);\n        se_y = f64::min(y, se.y);\n    }\n    {\n        let mut bounds = bounds.borrow_mut();\n        bounds.width = (nw_x - se_x).abs();\n        bounds.height = (nw_y - se_y).abs();\n    }\n}\n\n",
        "quadtree_bounds_new": "pub fn quadtree_bounds_new() -> Option<Rc<RefCell<QuadtreeBounds>>> {\n    let nw = Rc::new(RefCell::new(QuadtreePoint { x: f64::INFINITY, y: -f64::INFINITY }));\n    let se = Rc::new(RefCell::new(QuadtreePoint { x: -f64::INFINITY, y: f64::INFINITY }));\n    let bounds = QuadtreeBounds {\n        nw,\n        se,\n        width: 0.0,\n        height: 0.0,\n    };\n    Some(Rc::new(RefCell::new(bounds)))\n}\n\n",
        "quadtree_point_free": "pub fn quadtree_point_free(point: Rc<RefCell<QuadtreePoint>>) {\n    // \u91ca\u653e QuadtreePoint \u7684\u5185\u5b58\n    // \u7531\u4e8e Rc<RefCell<T>> \u662f\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u624b\u52a8\u91ca\u653e\u5185\u5b58\n}\n\n",
        "node_contains_": "pub fn node_contains_<T>(outer: Rc<RefCell<QuadtreeNode<T>>>, it: Rc<RefCell<QuadtreePoint>>) -> bool {\n    let outer = outer.borrow();\n    let it = it.borrow();\n    if let Some(bounds) = &outer.bounds {\n        let bounds = bounds.borrow();\n        bounds.nw.borrow().x <= it.x &&\n        bounds.nw.borrow().y >= it.y &&\n        bounds.se.borrow().x >= it.x &&\n        bounds.se.borrow().y <= it.y\n    } else {\n        false\n    }\n}\n\n",
        "quadtree_node_isleaf": "pub fn quadtree_node_isleaf<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    node.borrow().point.is_some()\n}\n\n",
        "quadtree_node_with_bounds": "pub fn quadtree_node_with_bounds<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = quadtree_node_new()?;\n    let bounds = quadtree_bounds_new()?;\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.bounds = Some(bounds.clone());\n    }\n    quadtree_bounds_extend(bounds.clone(), maxx, maxy);\n    quadtree_bounds_extend(bounds.clone(), minx, miny);\n    Some(node)\n}\n\n",
        "quadtree_node_reset": "pub fn quadtree_node_reset<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(point) = &node_borrow.point {\n        quadtree_point_free(point.clone());\n    }\n    if let Some(key) = node_borrow.key.take() {\n        key_free(key);\n    }\n}\n\n",
        "elision_": "pub fn elision_<T>(key: T) -> T {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    key\n}\n\n",
        "get_quadrant_": "pub fn get_quadrant_<T>(root: Rc<RefCell<QuadtreeNode<T>>>, point: Rc<RefCell<QuadtreePoint>>) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let root = root.borrow();\n    if let Some(nw) = &root.nw {\n        if node_contains_(nw.clone(), point.clone()) {\n            return Some(nw.clone());\n        }\n    }\n    if let Some(ne) = &root.ne {\n        if node_contains_(ne.clone(), point.clone()) {\n            return Some(ne.clone());\n        }\n    }\n    if let Some(sw) = &root.sw {\n        if node_contains_(sw.clone(), point.clone()) {\n            return Some(sw.clone());\n        }\n    }\n    if let Some(se) = &root.se {\n        if node_contains_(se.clone(), point.clone()) {\n            return Some(se.clone());\n        }\n    }\n    None\n}\n\n",
        "quadtree_node_ispointer": "pub fn quadtree_node_ispointer<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_some()\n        && node_ref.ne.is_some()\n        && node_ref.sw.is_some()\n        && node_ref.se.is_some()\n        && !quadtree_node_isleaf(node)\n}\n\n",
        "split_node_": "pub fn split_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let x;\n    let y;\n    let hw;\n    let hh;\n    {\n        let node_borrow = node.borrow();\n        let bounds = node_borrow.bounds.as_ref().unwrap().borrow();\n        x = bounds.nw.borrow().x;\n        y = bounds.nw.borrow().y;\n        hw = bounds.width / 2.0;\n        hh = bounds.height / 2.0;\n    }\n\n    let nw = quadtree_node_with_bounds::<T>(x, y - hh, x + hw, y);\n    let ne = quadtree_node_with_bounds::<T>(x + hw, y - hh, x + hw * 2.0, y);\n    let sw = quadtree_node_with_bounds::<T>(x, y - hh * 2.0, x + hw, y - hh);\n    let se = quadtree_node_with_bounds::<T>(x + hw, y - hh * 2.0, x + hw * 2.0, y - hh);\n\n    if nw.is_none() || ne.is_none() || sw.is_none() || se.is_none() {\n        return false;\n    }\n\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.nw = Some(nw.unwrap());\n        node_mut.ne = Some(ne.unwrap());\n        node_mut.sw = Some(sw.unwrap());\n        node_mut.se = Some(se.unwrap());\n    }\n\n    let old_point;\n    let old_key;\n    {\n        let mut node_mut = node.borrow_mut();\n        old_point = node_mut.point.take();\n        old_key = node_mut.key.take();\n    }\n\n    insert_(tree.clone(), node, old_point, old_key) != 0\n}\n\n",
        "reset_node_": "pub fn reset_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) {\n    let key_free = tree.borrow().key_free.clone();\n    if let Some(key_free) = key_free {\n        quadtree_node_reset(node, key_free);\n    } else {\n        let elision_wrap = |key: T| { elision_(key); };\n        quadtree_node_reset(node, elision_wrap);\n    }\n}\n\n",
        "insert_": "pub fn insert_<T>(\n    tree: Rc<RefCell<Quadtree<T>>>,\n    root: Rc<RefCell<QuadtreeNode<T>>>,\n    point: Option<Rc<RefCell<QuadtreePoint>>>,\n    key: Option<T>,\n) -> i32 {\n    if quadtree_node_isempty(&root) {\n        {\n            let mut root_mut = root.borrow_mut();\n            root_mut.point = point;\n            root_mut.key = key;\n        }\n        return 1; // normal insertion flag\n    } else if quadtree_node_isleaf(&root) {\n        let root_point = root.borrow().point.as_ref().unwrap().clone();\n        let point_ref = point.as_ref().unwrap().clone();\n        let root_point_borrow = root_point.borrow();\n        let point_ref_borrow = point_ref.borrow();\n        if root_point_borrow.x == point_ref_borrow.x && root_point_borrow.y == point_ref_borrow.y {\n            reset_node_(tree.clone(), root.clone());\n            {\n                let mut root_mut = root.borrow_mut();\n                root_mut.point = point;\n                root_mut.key = key;\n            }\n            return 2; // replace insertion flag\n        } else {\n            if !split_node_(tree.clone(), root.clone()) {\n                return 0; // failed insertion flag\n            }\n            return insert_(tree, root, point, key);\n        }\n    } else if quadtree_node_ispointer(&root) {\n        let quadrant = get_quadrant_(root.clone(), point.as_ref().unwrap().clone());\n        if quadrant.is_none() {\n            return 0;\n        }\n        return insert_(tree, quadrant.unwrap(), point, key);\n    }\n    0\n}\n\n",
        "quadtree_node_isempty": "pub fn quadtree_node_isempty<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_none()\n        && node_ref.ne.is_none()\n        && node_ref.sw.is_none()\n        && node_ref.se.is_none()\n        && !quadtree_node_isleaf(node)\n}\n\n",
        "quadtree_bounds_free": "pub fn quadtree_bounds_free(bounds: Rc<RefCell<QuadtreeBounds>>) {\n    // \u91ca\u653e QuadtreeBounds \u7684\u5185\u5b58\n    // \u7531\u4e8e Rc<RefCell<T>> \u662f\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u624b\u52a8\u91ca\u653e\u5185\u5b58\n    let bounds = bounds.borrow();\n    quadtree_point_free(Rc::clone(&bounds.nw));\n    quadtree_point_free(Rc::clone(&bounds.se));\n}\n\n",
        "find_": "pub fn find_<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        if quadtree_node_isleaf(&node) {\n            if let Some(point) = &node_ref.point {\n                let point_ref = point.borrow();\n                if point_ref.x == x && point_ref.y == y {\n                    return Some(point.clone());\n                }\n            }\n        } else if quadtree_node_ispointer(&node) {\n            let test = Rc::new(RefCell::new(QuadtreePoint { x, y }));\n            return find_(get_quadrant_(node.clone(), test), x, y);\n        }\n    }\n    None\n}\n\n",
        "quadtree_node_free": "pub fn quadtree_node_free<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(nw) = node_borrow.nw.take() {\n        quadtree_node_free(nw, key_free);\n    }\n    if let Some(ne) = node_borrow.ne.take() {\n        quadtree_node_free(ne, key_free);\n    }\n    if let Some(sw) = node_borrow.sw.take() {\n        quadtree_node_free(sw, key_free);\n    }\n    if let Some(se) = node_borrow.se.take() {\n        quadtree_node_free(se, key_free);\n    }\n    if let Some(bounds) = node_borrow.bounds.take() {\n        quadtree_bounds_free(bounds);\n    }\n    quadtree_node_reset(Rc::clone(&node), key_free);\n}\n\n",
        "quadtree_search": "pub fn quadtree_search<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    let tree_ref = tree.borrow();\n    find_(tree_ref.root.clone(), x, y)\n}\n\n",
        "quadtree_insert": "pub fn quadtree_insert<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64, key: T) -> i32 {\n    let point = quadtree_point_new(x, y);\n    if point.is_none() {\n        return 0;\n    }\n    let point_rc = Rc::new(RefCell::new(point.unwrap()));\n    if !node_contains_(tree.borrow().root.as_ref().unwrap().clone(), point_rc.clone()) {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    let insert_status = insert_(tree.clone(), tree.borrow().root.as_ref().unwrap().clone(), Some(point_rc.clone()), Some(key));\n    if insert_status == 0 {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    if insert_status == 1 {\n        let mut tree_mut = tree.borrow_mut();\n        // Assuming length is a field in Quadtree struct\n        // If not, you need to add it\n        // tree_mut.length += 1;\n    }\n    insert_status\n}\n\n",
        "quadtree_free": "pub fn quadtree_free<T>(tree: Rc<RefCell<Quadtree<T>>>) {\n    let tree_borrow = tree.borrow();\n    if let Some(key_free) = tree_borrow.key_free {\n        if let Some(root) = &tree_borrow.root {\n            quadtree_node_free(Rc::clone(root), key_free);\n        }\n    } else {\n        if let Some(root) = &tree_borrow.root {\n            fn elision_wrap<T>(key: T) {\n                elision_(key);\n            }\n            quadtree_node_free(Rc::clone(root), elision_wrap);\n        }\n    }\n}\n\n",
        "quadtree_new": "pub fn quadtree_new<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Quadtree<T>> {\n    let root = quadtree_node_with_bounds::<T>(minx, miny, maxx, maxy)?;\n    let tree = Quadtree {\n        key_free: None,\n        root: Some(root),\n    };\n    Some(tree)\n}\n\n",
        "quadtree_walk": "pub fn quadtree_walk<T>(root: Option<Rc<RefCell<QuadtreeNode<T>>>>, descent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>), ascent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>)) {\n    descent(root.clone());\n    if let Some(node) = &root {\n        let node_ref = node.borrow();\n        if let Some(nw) = &node_ref.nw {\n            quadtree_walk(Some(nw.clone()), descent, ascent);\n        }\n        if let Some(ne) = &node_ref.ne {\n            quadtree_walk(Some(ne.clone()), descent, ascent);\n        }\n        if let Some(sw) = &node_ref.sw {\n            quadtree_walk(Some(sw.clone()), descent, ascent);\n        }\n        if let Some(se) = &node_ref.se {\n            quadtree_walk(Some(se.clone()), descent, ascent);\n        }\n    }\n    ascent(root);\n}\n\n"
    },
    "test-quadtree": {
        "main": "fn main(){}\n\n",
        "ascent": "pub fn ascent<T>(node: Rc<RefCell<QuadtreeNode<T>>>) {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    // Function implementation\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse test_project::quadtree::{QuadtreeNode, quadtree_node_t, quadtree_node_isleaf, find_, quadtree_walk, quadtree_node_new, quadtree_bounds_extend, quadtree_new, quadtree_node_isempty, quadtree_node_ispointer, quadtree_node_free, insert_, quadtree_search, quadtree_free, elision_, quadtree_bounds_free, quadtree_point_new, quadtree_bounds_new, get_quadrant_, reset_node_, split_node_, node_contains_, quadtree_insert, quadtree_node_with_bounds, quadtree_point_free, quadtree_node_reset};",
        "descent": "pub fn descent(node: Rc<RefCell<quadtree_node_t>>) {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    let mut node = node.borrow_mut();\n    if let Some(ne) = &node.ne {\n        descent(Rc::clone(ne));\n    }\n    if let Some(nw) = &node.nw {\n        descent(Rc::clone(nw));\n    }\n    if let Some(se) = &node.se {\n        descent(Rc::clone(se));\n    }\n    if let Some(sw) = &node.sw {\n        descent(Rc::clone(sw));\n    }\n}\n\n",
        "test_bounds": "pub fn test_bounds() {\n    let bounds = quadtree_bounds_new().unwrap();\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.x, f64::INFINITY);\n        assert_eq!(se.x, -f64::INFINITY);\n    }\n\n    quadtree_bounds_extend(Rc::clone(&bounds), 5.0, 5.0);\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.x, 5.0);\n        assert_eq!(se.x, 5.0);\n    }\n\n    quadtree_bounds_extend(Rc::clone(&bounds), 10.0, 10.0);\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.y, 10.0);\n        assert_eq!(se.y, 5.0);\n        assert_eq!(bounds_ref.width, 5.0);\n        assert_eq!(bounds_ref.height, 5.0);\n    }\n\n    quadtree_bounds_free(bounds);\n}\n\n",
        "test_points": "pub fn test_points() {\n    let point = quadtree_point_new(5.0, 6.0);\n    assert!(point.as_ref().unwrap().x == 5.0);\n    assert!(point.as_ref().unwrap().y == 6.0);\n    quadtree_point_free(Rc::new(RefCell::new(point.unwrap())));\n}\n\n",
        "test_node": "pub fn test_node() {\n    let node = quadtree_node_new::<i32>();\n    let node_ref = node.as_ref().unwrap();\n    assert!(!quadtree_node_isleaf(node_ref));\n    assert!(quadtree_node_isempty(node_ref));\n    assert!(!quadtree_node_ispointer(node_ref));\n}\n\n"
    },
    "rgba": {
        "rgba_from_rgba": "pub fn rgba_from_rgba(r: u8, g: u8, b: u8, a: u8) -> u32 {\n    (r as u32) << 24 | (g as u32) << 16 | (b as u32) << 8 | (a as u32)\n}\n\n",
        "extra": "pub struct Rgba {\n    pub r: f64,\n    pub g: f64,\n    pub b: f64,\n    pub a: f64,\n}\n\npub struct NamedColor {\n    pub name: &'static str,\n    pub val: u32,\n}\n\npub const NAMED_COLORS: &[NamedColor] = &[\n    NamedColor { name: \"transparent\", val: 0xFFFFFF00 },\n    NamedColor { name: \"aliceblue\", val: 0xF0F8FFFF },\n    NamedColor { name: \"antiquewhite\", val: 0xFAEBD7FF },\n    NamedColor { name: \"aqua\", val: 0x00FFFFFF },\n    NamedColor { name: \"aquamarine\", val: 0x7FFFD4FF },\n    NamedColor { name: \"azure\", val: 0xF0FFFFFF },\n    NamedColor { name: \"beige\", val: 0xF5F5DCFF },\n    NamedColor { name: \"bisque\", val: 0xFFE4C4FF },\n    NamedColor { name: \"black\", val: 0x000000FF },\n    NamedColor { name: \"blanchedalmond\", val: 0xFFEBCDFF },\n    NamedColor { name: \"blue\", val: 0x0000FFFF },\n    NamedColor { name: \"blueviolet\", val: 0x8A2BE2FF },\n    NamedColor { name: \"brown\", val: 0xA52A2AFF },\n    NamedColor { name: \"burlywood\", val: 0xDEB887FF },\n    NamedColor { name: \"cadetblue\", val: 0x5F9EA0FF },\n    NamedColor { name: \"chartreuse\", val: 0x7FFF00FF },\n    NamedColor { name: \"chocolate\", val: 0xD2691EFF },\n    NamedColor { name: \"coral\", val: 0xFF7F50FF },\n    NamedColor { name: \"cornflowerblue\", val: 0x6495EDFF },\n    NamedColor { name: \"cornsilk\", val: 0xFFF8DCFF },\n    NamedColor { name: \"crimson\", val: 0xDC143CFF },\n    NamedColor { name: \"cyan\", val: 0x00FFFFFF },\n    NamedColor { name: \"darkblue\", val: 0x00008BFF },\n    NamedColor { name: \"darkcyan\", val: 0x008B8BFF },\n    NamedColor { name: \"darkgoldenrod\", val: 0xB8860BFF },\n    NamedColor { name: \"darkgray\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkgreen\", val: 0x006400FF },\n    NamedColor { name: \"darkgrey\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkkhaki\", val: 0xBDB76BFF },\n    NamedColor { name: \"darkmagenta\", val: 0x8B008BFF },\n    NamedColor { name: \"darkolivegreen\", val: 0x556B2FFF },\n    NamedColor { name: \"darkorange\", val: 0xFF8C00FF },\n    NamedColor { name: \"darkorchid\", val: 0x9932CCFF },\n    NamedColor { name: \"darkred\", val: 0x8B0000FF },\n    NamedColor { name: \"darksalmon\", val: 0xE9967AFF },\n    NamedColor { name: \"darkseagreen\", val: 0x8FBC8FFF },\n    NamedColor { name: \"darkslateblue\", val: 0x483D8BFF },\n    NamedColor { name: \"darkslategray\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkslategrey\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkturquoise\", val: 0x00CED1FF },\n    NamedColor { name: \"darkviolet\", val: 0x9400D3FF },\n    NamedColor { name: \"deeppink\", val: 0xFF1493FF },\n    NamedColor { name: \"deepskyblue\", val: 0x00BFFFFF },\n    NamedColor { name: \"dimgray\", val: 0x696969FF },\n    NamedColor { name: \"dimgrey\", val: 0x696969FF },\n    NamedColor { name: \"dodgerblue\", val: 0x1E90FFFF },\n    NamedColor { name: \"firebrick\", val: 0xB22222FF },\n    NamedColor { name: \"floralwhite\", val: 0xFFFAF0FF },\n    NamedColor { name: \"forestgreen\", val: 0x228B22FF },\n    NamedColor { name: \"fuchsia\", val: 0xFF00FFFF },\n    NamedColor { name: \"gainsboro\", val: 0xDCDCDCFF },\n    NamedColor { name: \"ghostwhite\", val: 0xF8F8FFFF },\n    NamedColor { name: \"gold\", val: 0xFFD700FF },\n    NamedColor { name: \"goldenrod\", val: 0xDAA520FF },\n    NamedColor { name: \"gray\", val: 0x808080FF },\n    NamedColor { name: \"green\", val: 0x008000FF },\n    NamedColor { name: \"greenyellow\", val: 0xADFF2FFF },\n    NamedColor { name: \"grey\", val: 0x808080FF },\n    NamedColor { name: \"honeydew\", val: 0xF0FFF0FF },\n    NamedColor { name: \"hotpink\", val: 0xFF69B4FF },\n    NamedColor { name: \"indianred\", val: 0xCD5C5CFF },\n    NamedColor { name: \"indigo\", val: 0x4B0082FF },\n    NamedColor { name: \"ivory\", val: 0xFFFFF0FF },\n    NamedColor { name: \"khaki\", val: 0xF0E68CFF },\n    NamedColor { name: \"lavender\", val: 0xE6E6FAFF },\n    NamedColor { name: \"lavenderblush\", val: 0xFFF0F5FF },\n    NamedColor { name: \"lawngreen\", val: 0x7CFC00FF },\n    NamedColor { name: \"lemonchiffon\", val: 0xFFFACDFF },\n    NamedColor { name: \"lightblue\", val: 0xADD8E6FF },\n    NamedColor { name: \"lightcoral\", val: 0xF08080FF },\n    NamedColor { name: \"lightcyan\", val: 0xE0FFFFFF },\n    NamedColor { name: \"lightgoldenrodyellow\", val: 0xFAFAD2FF },\n    NamedColor { name: \"lightgray\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightgreen\", val: 0x90EE90FF },\n    NamedColor { name: \"lightgrey\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightpink\", val: 0xFFB6C1FF },\n    NamedColor { name: \"lightsalmon\", val: 0xFFA07AFF },\n    NamedColor { name: \"lightseagreen\", val: 0x20B2AAFF },\n    NamedColor { name: \"lightskyblue\", val: 0x87CEFAFF },\n    NamedColor { name: \"lightslategray\", val: 0x778899FF },\n    NamedColor { name: \"lightslategrey\", val: 0x778899FF },\n    NamedColor { name: \"lightsteelblue\", val: 0xB0C4DEFF },\n    NamedColor { name: \"lightyellow\", val: 0xFFFFE0FF },\n    NamedColor { name: \"lime\", val: 0x00FF00FF },\n    NamedColor { name: \"limegreen\", val: 0x32CD32FF },\n    NamedColor { name: \"linen\", val: 0xFAF0E6FF },\n    NamedColor { name: \"magenta\", val: 0xFF00FFFF },\n    NamedColor { name: \"maroon\", val: 0x800000FF },\n    NamedColor { name: \"mediumaquamarine\", val: 0x66CDAAFF },\n    NamedColor { name: \"mediumblue\", val: 0x0000CDFF },\n    NamedColor { name: \"mediumorchid\", val: 0xBA55D3FF },\n    NamedColor { name: \"mediumpurple\", val: 0x9370DBFF },\n    NamedColor { name: \"mediumseagreen\", val: 0x3CB371FF },\n    NamedColor { name: \"mediumslateblue\", val: 0x7B68EEFF },\n    NamedColor { name: \"mediumspringgreen\", val: 0x00FA9AFF },\n    NamedColor { name: \"mediumturquoise\", val: 0x48D1CCFF },\n    NamedColor { name: \"mediumvioletred\", val: 0xC71585FF },\n    NamedColor { name: \"midnightblue\", val: 0x191970FF },\n    NamedColor { name: \"mintcream\", val: 0xF5FFFAFF },\n    NamedColor { name: \"mistyrose\", val: 0xFFE4E1FF },\n    NamedColor { name: \"moccasin\", val: 0xFFE4B5FF },\n    NamedColor { name: \"navajowhite\", val: 0xFFDEADFF },\n    NamedColor { name: \"navy\", val: 0x000080FF },\n    NamedColor { name: \"oldlace\", val: 0xFDF5E6FF },\n    NamedColor { name: \"olive\", val: 0x808000FF },\n    NamedColor { name: \"olivedrab\", val: 0x6B8E23FF },\n    NamedColor { name: \"orange\", val: 0xFFA500FF },\n    NamedColor { name: \"orangered\", val: 0xFF4500FF },\n    NamedColor { name: \"orchid\", val: 0xDA70D6FF },\n    NamedColor { name: \"palegoldenrod\", val: 0xEEE8AAFF },\n    NamedColor { name: \"palegreen\", val: 0x98FB98FF },\n    NamedColor { name: \"paleturquoise\", val: 0xAFEEEEFF },\n    NamedColor { name: \"palevioletred\", val: 0xDB7093FF },\n    NamedColor { name: \"papayawhip\", val: 0xFFEFD5FF },\n    NamedColor { name: \"peachpuff\", val: 0xFFDAB9FF },\n    NamedColor { name: \"peru\", val: 0xCD853FFF },\n    NamedColor { name: \"pink\", val: 0xFFC0CBFF },\n    NamedColor { name: \"plum\", val: 0xDDA0DDFF },\n    NamedColor { name: \"powderblue\", val: 0xB0E0E6FF },\n    NamedColor { name: \"purple\", val: 0x800080FF },\n    NamedColor { name: \"red\", val: 0xFF0000FF },\n    NamedColor { name: \"rosybrown\", val: 0xBC8F8FFF },\n    NamedColor { name: \"royalblue\", val: 0x4169E1FF },\n    NamedColor { name: \"saddlebrown\", val: 0x8B4513FF },\n    NamedColor { name: \"salmon\", val: 0xFA8072FF },\n    NamedColor { name: \"sandybrown\", val: 0xF4A460FF },\n    NamedColor { name: \"seagreen\", val: 0x2E8B57FF },\n    NamedColor { name: \"seashell\", val: 0xFFF5EEFF },\n    NamedColor { name: \"sienna\", val: 0xA0522DFF },\n    NamedColor { name: \"silver\", val: 0xC0C0C0FF },\n    NamedColor { name: \"skyblue\", val: 0x87CEEBFF },\n    NamedColor { name: \"slateblue\", val: 0x6A5ACDFF },\n    NamedColor { name: \"slategray\", val: 0x708090FF },\n    NamedColor { name: \"slategrey\", val: 0x708090FF },\n    NamedColor { name: \"snow\", val: 0xFFFAFAFF },\n    NamedColor { name: \"springgreen\", val: 0x00FF7FFF },\n    NamedColor { name: \"steelblue\", val: 0x4682B4FF },\n    NamedColor { name: \"tan\", val: 0xD2B48CFF },\n    NamedColor { name: \"teal\", val: 0x008080FF },\n    NamedColor { name: \"thistle\", val: 0xD8BFD8FF },\n    NamedColor { name: \"tomato\", val: 0xFF6347FF },\n    NamedColor { name: \"turquoise\", val: 0x40E0D0FF },\n    NamedColor { name: \"violet\", val: 0xEE82EEFF },\n    NamedColor { name: \"wheat\", val: 0xF5DEB3FF },\n    NamedColor { name: \"white\", val: 0xFFFFFFFF },\n    NamedColor { name: \"whitesmoke\", val: 0xF5F5F5FF },\n    NamedColor { name: \"yellow\", val: 0xFFFF00FF },\n    NamedColor { name: \"yellowgreen\", val: 0x9ACD32FF }\n];",
        "h": "pub fn h(c: char) -> i32 {\n    match c {\n        '0'..='9' => (c as i32) - ('0' as i32),\n        'a'..='f' => (c as i32) - ('a' as i32) + 10,\n        'A'..='F' => (c as i32) - ('A' as i32) + 10,\n        _ => 0,\n    }\n}\n\n",
        "rgba_from_rgb": "pub fn rgba_from_rgb(r: u8, g: u8, b: u8) -> u32 {\n    rgba_from_rgba(r, g, b, 255)\n}\n\n",
        "rgba_from_hex6_string": "pub fn rgba_from_hex6_string(str: String) -> u32 {\n    let chars: Vec<char> = str.chars().collect();\n    rgba_from_rgb(\n        ((h(chars[0]) << 4) + h(chars[1])) as u8,\n        ((h(chars[2]) << 4) + h(chars[3])) as u8,\n        ((h(chars[4]) << 4) + h(chars[5])) as u8,\n    )\n}\n\n",
        "rgba_from_hex3_string": "pub fn rgba_from_hex3_string(str: String) -> u32 {\n    let mut chars = str.chars();\n    let r_char = chars.next().unwrap_or('0');\n    let g_char = chars.next().unwrap_or('0');\n    let b_char = chars.next().unwrap_or('0');\n    \n    let r = (h(r_char) << 4) + h(r_char);\n    let g = (h(g_char) << 4) + h(g_char);\n    let b = (h(b_char) << 4) + h(b_char);\n    \n    rgba_from_rgb(r as u8, g as u8, b as u8)\n}\n\n",
        "rgba_from_rgba_string": "pub fn rgba_from_rgba_string(str: String, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgba(\") {\n        let mut str = str[5..].to_string();\n        str = str.trim().to_string();\n        \n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut a: f32 = 0.0;\n        \n        let mut iter = str.split_whitespace();\n        if let Some(r_str) = iter.next() {\n            if let Ok(r_val) = r_str.parse::<u8>() {\n                r = r_val;\n            }\n        }\n        if let Some(g_str) = iter.next() {\n            if let Ok(g_val) = g_str.parse::<u8>() {\n                g = g_val;\n            }\n        }\n        if let Some(b_str) = iter.next() {\n            if let Ok(b_val) = b_str.parse::<u8>() {\n                b = b_val;\n            }\n        }\n        if let Some(a_str) = iter.next() {\n            if a_str.starts_with('1') {\n                a = 1.0;\n            } else if a_str.starts_with('0') {\n                if a_str.len() > 1 && a_str.chars().nth(1) == Some('.') {\n                    let mut n = 0.1;\n                    for c in a_str[2..].chars() {\n                        if c.is_digit(10) {\n                            a += (c.to_digit(10).unwrap() as f32) * n;\n                            n *= 0.1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        *ok = true;\n        return rgba_from_rgba(r, g, b, (a * 255.0) as u8);\n    }\n    \n    *ok = false;\n    0\n}\n\n",
        "rgba_from_hex_string": "pub fn rgba_from_hex_string(str: String, ok: &mut i16) -> u32 {\n    let len = str.len();\n    *ok = 1;\n    if len == 6 {\n        return rgba_from_hex6_string(str);\n    }\n    if len == 3 {\n        return rgba_from_hex3_string(str);\n    }\n    *ok = 0;\n    0\n}\n\n",
        "rgba_from_name_string": "pub fn rgba_from_name_string(str: &str, ok: &mut bool) -> u32 {\n    for color in NAMED_COLORS {\n        if str == color.name {\n            *ok = true;\n            return color.val;\n        }\n    }\n    *ok = false;\n    0\n}\n\n",
        "rgba_from_rgb_string": "pub fn rgba_from_rgb_string(str: &str, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgb(\") {\n        let mut str = &str[4..];\n        str = str.trim_start();\n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut chars = str.chars();\n        let parse_channel = |c: &mut std::str::Chars| {\n            let mut num = 0;\n            while let Some(ch) = c.next() {\n                if ch.is_ascii_digit() {\n                    num = num * 10 + (ch as u8 - b'0');\n                } else if ch == ',' || ch == ')' {\n                    break;\n                }\n            }\n            num\n        };\n        r = parse_channel(&mut chars);\n        g = parse_channel(&mut chars);\n        b = parse_channel(&mut chars);\n        *ok = true;\n        return rgba_from_rgb(r, g, b);\n    }\n    *ok = false;\n    0\n}\n\n",
        "rgba_from_string": "pub fn rgba_from_string(str: &str, ok: &mut i16) -> u32 {\n    let mut bool_ok = false;\n    let result = if str.starts_with('#') {\n        rgba_from_hex_string(str[1..].to_string(), ok)\n    } else if str.starts_with(\"rgba\") {\n        rgba_from_rgba_string(str.to_string(), &mut bool_ok)\n    } else if str.starts_with(\"rgb\") {\n        rgba_from_rgb_string(str, &mut bool_ok)\n    } else {\n        rgba_from_name_string(str, &mut bool_ok)\n    };\n    *ok = if bool_ok { 1 } else { 0 };\n    result\n}\n\n",
        "rgba_to_string": "pub fn rgba_to_string(rgba: Rgba, buf: &mut String, len: usize) {\n    if rgba.a == 1.0 {\n        *buf = format!(\"#{:02x}{:02x}{:02x}\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8);\n    } else {\n        *buf = format!(\"rgba({}, {}, {}, {:.2})\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8, \n            rgba.a);\n    }\n}\n\n",
        "rgba_new": "pub fn rgba_new(rgba: u32) -> Rgba {\n    let mut color = Rgba {\n        r: 0.0,\n        g: 0.0,\n        b: 0.0,\n        a: 0.0,\n    };\n    color.r = (rgba >> 24) as f64 / 255.0;\n    color.g = ((rgba >> 16) & 0xff) as f64 / 255.0;\n    color.b = ((rgba >> 8) & 0xff) as f64 / 255.0;\n    color.a = (rgba & 0xff) as f64 / 255.0;\n    color\n}\n\n"
    },
    "test-rgba": {
        "main": "fn main(){}\n",
        "test_to_string": "pub fn test_to_string() {\n    let mut buf = String::new();\n    let color = rgba_new(0xffcc00ff);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"#ffcc00\", buf);\n\n    let color = rgba_new(0xffcc0050);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"rgba(255, 204, 0, 0.31)\", buf);\n}\n\n",
        "extra": "\nuse test_project::rgba::{rgba_new, rgba_from_hex6_string, h, rgba_from_hex_string, rgba_to_string, rgba_from_name_string, rgba_from_rgba_string, rgba_from_rgb_string, rgba_from_hex3_string, rgba_from_rgba, rgba_from_rgb, rgba_from_string, Rgba, NamedColor, NAMED_COLORS};\n",
        "test_rgba": "pub fn test_rgba() {\n    let mut ok: i16 = 0;\n    let mut val = rgba_from_string(\"rgba(255, 30   , 0, .5)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xff1e007f, val);\n\n    val = rgba_from_string(\"rgba(0,0,0, 1)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0x000000ff, val);\n}\n\n",
        "test_hex": "pub fn test_hex() {\n    let mut ok: i16 = 0;\n    let mut val = rgba_from_string(\"#ff1e00\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xff1e00ff, val);\n\n    val = rgba_from_string(\"#ffffff\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xffffffff, val);\n\n    val = rgba_from_string(\"#ffcc00\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xffcc00ff, val);\n\n    val = rgba_from_string(\"#fco\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xffcc00ff, val);\n}\n\n",
        "test_rgb": "pub fn test_rgb() {\n    let mut ok: i16 = 0;\n    let val = rgba_from_string(\"rgb(255, 30   , 0)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xff1e00ff, val);\n\n    let val = rgba_from_string(\"rgb(0,0,0)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0x000000ff, val);\n}\n\n"
    },
    "urlparser": {
        "ParseURL": "pub fn ParseURL(URL: String, pURL_Parts: &mut URL_PARTS) -> bool {\n    let mut i: usize;\n    let mut c: u8;\n    let mut b: bool = false;\n\n    // Clear the data\n    *pURL_Parts = URL_PARTS {\n        scheme: String::new(),\n        authority: String::new(),\n        port: String::new(),\n        path: String::new(),\n        query: String::new(),\n        fragment: String::new(),\n    };\n\n    // Setup our parser pointer\n    let mut string = URL.as_bytes();\n\n    // Check for the authority preceding double slash\n    let authority = match str::from_utf8(string).unwrap().find(\"//\") {\n        Some(pos) => {\n            let scheme_end = pos;\n            i = 0;\n            while i < scheme_end {\n                c = string[i];\n                if c == b':' || c == b'/' {\n                    break;\n                }\n                if pURL_Parts.scheme.len() == MAX_URL_SCHEME_LEN - 1 {\n                    return false;\n                }\n                pURL_Parts.scheme.push(c as char);\n                i += 1;\n            }\n            &string[pos + 2..]\n        }\n        None => string,\n    };\n\n    c = authority[0];\n    if c == b'[' {\n        b = true;\n        string = &authority[1..];\n    } else {\n        string = authority;\n    }\n\n    // Parse the authority\n    i = 0;\n    while i < string.len() {\n        c = string[i];\n        if c == b' ' {\n            i += 1;\n            continue;\n        }\n        if c == b'/' || c == b'?' || c == b'#' || (c == b':' && !b) {\n            break;\n        }\n        if b && c == b']' {\n            i += 1;\n            break;\n        }\n        if pURL_Parts.authority.len() == MAX_URL_AUTHORITY_LEN - 1 {\n            return false;\n        }\n        pURL_Parts.authority.push(c as char);\n        i += 1;\n    }\n\n    string = &string[i..];\n\n    // Check for a port number\n    if !string.is_empty() && string[0] == b':' {\n        string = &string[1..];\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'/' || c == b'?' || c == b'#' {\n                break;\n            }\n            if pURL_Parts.port.len() == MAX_URL_PORT_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.port.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a path\n    if !string.is_empty() && string[0] == b'/' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'?' || c == b'#' {\n                break;\n            }\n            if pURL_Parts.path.len() == MAX_URL_PATH_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.path.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a query\n    if !string.is_empty() && string[0] == b'?' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'#' {\n                break;\n            }\n            if pURL_Parts.query.len() == MAX_URL_QUERY_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.query.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a fragment\n    if !string.is_empty() && string[0] == b'#' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if pURL_Parts.fragment.len() == MAX_URL_FRAGMENT_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.fragment.push(c as char);\n            i += 1;\n        }\n    }\n\n    true\n}\n\n",
        "extra": "use std::str;\n\npub const MAX_URL_FRAGMENT_LEN: usize = 256;\npub const MAX_URL_SCHEME_LEN: usize = 32;\npub const MAX_URL_PATH_LEN: usize = 1024;\npub const MAX_URL_QUERY_LEN: usize = 1024;\npub const MAX_URL_AUTHORITY_LEN: usize = 512;\npub const MAX_URL_PORT_LEN: usize = 64;\n\npub struct URL_PARTS {\n    pub scheme: String,\n    pub authority: String,\n    pub port: String,\n    pub path: String,\n    pub query: String,\n    pub fragment: String,\n}\n"
    },
    "test-urlparser": {
        "main": "fn main(){}\n",
        "test_parse_url": "pub fn test_parse_url() {\n    let mut url_parts = URL_PARTS {\n        scheme: String::new(),\n        authority: String::new(),\n        port: String::new(),\n        path: String::new(),\n        query: String::new(),\n        fragment: String::new(),\n    };\n\n    // Test case 1: Basic HTTP URL\n    assert!(ParseURL(\"http://sullewarehouse.com/login\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"http\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"\"); // No port specified\n    assert_eq!(url_parts.path, \"/login\");\n    assert_eq!(url_parts.query, \"\"); // No query\n    assert_eq!(url_parts.fragment, \"\"); // No fragment\n\n    // Test case 2: HTTPS URL with port\n    assert!(ParseURL(\"https://sullewarehouse.com:1000/login\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"1000\");\n    assert_eq!(url_parts.path, \"/login\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 3: URL with query parameters\n    assert!(ParseURL(\"https://sullewarehouse.com:1000/api/get?username=myuser\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"1000\");\n    assert_eq!(url_parts.path, \"/api/get\");\n    assert_eq!(url_parts.query, \"?username=myuser\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 4: URL without scheme\n    assert!(ParseURL(\"sullewarehouse.com/register\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"\"); // No scheme\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"\");\n    assert_eq!(url_parts.path, \"/register\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 5: IPv6 URL\n    assert!(ParseURL(\"http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]/newpage\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"http\");\n    assert_eq!(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n    assert_eq!(url_parts.port, \"\");\n    assert_eq!(url_parts.path, \"/newpage\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 6: IPv6 URL with port\n    assert!(ParseURL(\"https://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:2678/blog\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n    assert_eq!(url_parts.port, \"2678\");\n    assert_eq!(url_parts.path, \"/blog\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    println!(\"All tests passed!\");\n}\n\n",
        "extra": "\nuse test_project::urlparser::{ParseURL, URL_PARTS, MAX_URL_FRAGMENT_LEN, MAX_URL_SCHEME_LEN, MAX_URL_PATH_LEN, MAX_URL_QUERY_LEN, MAX_URL_AUTHORITY_LEN, MAX_URL_PORT_LEN};\n"
    }
}