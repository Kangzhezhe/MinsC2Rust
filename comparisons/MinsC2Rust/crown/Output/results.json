{
    "bst": {
        "_bst_subtree_min_val": "pub fn _bst_subtree_min_val<T: Ord + Clone>(n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<T> {\n    // The minimum value in any subtree is just the leftmost value. Keep going \n    // left till we get there.\n    let mut current = n;\n    while let Some(node) = current {\n        if node.borrow().left.is_none() {\n            return Some(node.borrow().val.clone());\n        }\n        current = node.borrow().left.clone();\n    }\n    None\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BstNode<T> {\n    pub val: T,\n    pub left: Option<Rc<RefCell<BstNode<T>>>>,\n    pub right: Option<Rc<RefCell<BstNode<T>>>>,\n}\n\npub struct Bst<T> {\n    pub root: Option<Rc<RefCell<BstNode<T>>>>,\n}\n",
        "_bst_subtree_remove": "pub fn _bst_subtree_remove<T: Ord + Clone>(val: T, n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<Rc<RefCell<BstNode<T>>>> {\n    if n.is_none() {\n        return None;\n    }\n\n    let node = n.unwrap();\n    let mut node_borrow = node.borrow_mut();\n\n    if val < node_borrow.val {\n        let left = node_borrow.left.take();\n        node_borrow.left = _bst_subtree_remove(val, left);\n        drop(node_borrow);\n        return Some(node);\n    } else if val > node_borrow.val {\n        let right = node_borrow.right.take();\n        node_borrow.right = _bst_subtree_remove(val, right);\n        drop(node_borrow);\n        return Some(node);\n    } else {\n        if node_borrow.left.is_some() && node_borrow.right.is_some() {\n            let min_val = _bst_subtree_min_val(node_borrow.right.clone()).unwrap();\n            node_borrow.val = min_val.clone();\n            let right = node_borrow.right.take();\n            node_borrow.right = _bst_subtree_remove(min_val, right);\n            drop(node_borrow);\n            return Some(node);\n        } else if node_borrow.left.is_some() {\n            let left = node_borrow.left.take();\n            drop(node_borrow);\n            return left;\n        } else if node_borrow.right.is_some() {\n            let right = node_borrow.right.take();\n            drop(node_borrow);\n            return right;\n        } else {\n            drop(node_borrow);\n            return None;\n        }\n    }\n}\n\n",
        "_bst_node_create": "pub fn _bst_node_create<T>(val: T) -> Rc<RefCell<BstNode<T>>> {\n    let node = Rc::new(RefCell::new(BstNode {\n        val,\n        left: None,\n        right: None,\n    }));\n    node\n}\n\n",
        "bst_remove": "pub fn bst_remove<T: Ord + Clone>(val: T, bst: &mut Bst<T>) {\n    assert!(bst.root.is_some());\n\n    // We remove val by using our subtree removal function starting with the\n    // subtree rooted at bst->root (i.e. the whole tree).\n    let root = bst.root.take();\n    bst.root = _bst_subtree_remove(val, root);\n}\n\n",
        "bst_isempty": "pub fn bst_isempty<T>(bst: &Bst<T>) -> bool {\n    bst.root.is_none()\n}\n\n",
        "_bst_subtree_insert": "pub fn _bst_subtree_insert<T: PartialOrd + Clone>(val: T, n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<Rc<RefCell<BstNode<T>>>> {\n    match n {\n        None => {\n            Some(_bst_node_create(val))\n        },\n        Some(node) => {\n            let mut node_mut = node.borrow_mut();\n            if val < node_mut.val {\n                node_mut.left = _bst_subtree_insert(val, node_mut.left.clone());\n            } else {\n                node_mut.right = _bst_subtree_insert(val, node_mut.right.clone());\n            }\n            Some(node.clone())\n        }\n    }\n}\n\n",
        "bst_free": "pub fn bst_free<T: Ord + Clone>(mut bst: Bst<T>) {\n    assert!(bst.root.is_some());\n\n    // Assume that bst_remove() frees each node it removes and use it to free\n    // all of the nodes in the tree.\n    while !bst_isempty(&bst) {\n        let root_val = bst.root.as_ref().unwrap().borrow().val.clone();\n        bst_remove(root_val, &mut bst);\n    }\n}\n\n",
        "bst_contains": "pub fn bst_contains<T: PartialOrd>(val: T, bst: &Bst<T>) -> bool {\n    assert!(bst.root.is_some());\n\n    let mut cur = bst.root.clone();\n    while let Some(node) = cur {\n        let node_ref = node.borrow();\n        if val == node_ref.val {\n            return true;\n        } else if val < node_ref.val {\n            cur = node_ref.left.clone();\n        } else {\n            cur = node_ref.right.clone();\n        }\n    }\n\n    false\n}\n\n",
        "bst_insert": "pub fn bst_insert<T: PartialOrd + Clone>(val: T, bst: &mut Bst<T>) {\n    assert!(bst.root.is_some());\n    bst.root = _bst_subtree_insert(val, bst.root.clone());\n}\n\n",
        "bst_create": "pub fn bst_create<T>() -> Bst<T> {\n    Bst { root: None }\n}\n\n"
    },
    "test-bst": {
        "main": "fn main(){}\n",
        "test_bst": "pub fn test_bst() {\n    let mut bst = bst_create();\n    let good_nums = [32, 16, 8, 12, 4, 64, 48, 80];\n    let bad_nums = [1, 3, 5, 7, 9, 11, 13, 15];\n\n    // Initialize the tree.\n    for i in 0..8 {\n        bst_insert(good_nums[i], &mut bst);\n    }\n\n    // Test containment.\n    for i in 0..8 {\n        assert!(bst_contains(good_nums[i], &bst));\n    }\n    println!(\"== Verified that BST contains all the expected values.\");\n\n    for i in 0..8 {\n        assert!(!bst_contains(bad_nums[i], &bst));\n    }\n    println!(\"== Verified that BST contains none of the unexpected values.\");\n\n    /*\n     * Test removal by removing one good number at a time and making sure the\n     * remaining good numbers are still in the tree.\n     */\n    for i in 0..8 {\n        bst_remove(good_nums[i], &mut bst);\n        assert!(!bst_contains(good_nums[i], &bst));\n        for j in (i + 1)..8 {\n            assert!(bst_contains(good_nums[j], &bst));\n        }\n    }\n    println!(\"== Verified removal works as expected.\");\n\n    bst_free(bst);\n}\n\n",
        "extra": "\nuse test_project::bst::{_bst_subtree_insert, bst_free, bst_contains, bst_isempty, bst_create, _bst_subtree_remove, _bst_node_create, bst_remove, _bst_subtree_min_val, bst_insert};\n"
    },
    "buffer": {
        "buffer_resize": "pub fn buffer_resize(buffer: &mut Buffer, n: usize) -> i32 {\n    let n = ((n + 1023) / 1024) * 1024;\n    buffer.len = n;\n    buffer.alloc = String::with_capacity(n + 1);\n    buffer.data = buffer.alloc.clone();\n    buffer.alloc.push('\\0');\n    0\n}\n\n",
        "extra": "pub const BUFFER_DEFAULT_SIZE: usize = 1024;\n\n#[derive(Clone)]\npub struct Buffer {\n    pub len: usize,\n    pub alloc: String,\n    pub data: String,\n}\n",
        "buffer_length": "pub fn buffer_length(buffer: &Buffer) -> usize {\n    buffer.data.len()\n}\n\n",
        "buffer_append_n": "pub fn buffer_append_n(buffer: &mut Buffer, str: &str, len: usize) -> i32 {\n    let prev = buffer.data.len();\n    let needed = len + prev;\n\n    if buffer.len > needed {\n        buffer.data.push_str(&str[..len]);\n        return 0;\n    }\n\n    let ret = buffer_resize(buffer, needed);\n    if ret == -1 {\n        return -1;\n    }\n\n    buffer.data.push_str(&str[..len]);\n    0\n}\n\n",
        "buffer_new_with_size": "pub fn buffer_new_with_size(n: usize) -> Result<Buffer, String> {\n    let mut buffer = Buffer {\n        len: n,\n        alloc: String::with_capacity(n + 1),\n        data: String::with_capacity(n + 1),\n    };\n    buffer.alloc.push_str(&\"\\0\".repeat(n + 1));\n    buffer.data.push_str(&\"\\0\".repeat(n + 1));\n    Ok(buffer)\n}\n\n",
        "buffer_trim_right": "pub fn buffer_trim_right(buffer: &mut Buffer) {\n    let mut i = buffer_length(buffer) - 1;\n    while i >= 0 {\n        let c = buffer.data.chars().nth(i as usize).unwrap();\n        if !c.is_whitespace() {\n            break;\n        }\n        buffer.data.truncate(i as usize);\n        i -= 1;\n        if i < 0 {\n            break;\n        }\n    }\n}\n\n",
        "buffer_trim_left": "pub fn buffer_trim_left(buffer: &mut Buffer) {\n    while let Some(c) = buffer.data.chars().next() {\n        if !c.is_whitespace() {\n            break;\n        }\n        buffer.data = buffer.data[1..].to_string();\n    }\n}\n\n",
        "buffer_fill": "pub fn buffer_fill(buffer: &mut Buffer, c: i32) {\n    buffer.data = vec![c as u8; buffer.len].iter().map(|&b| b as char).collect();\n}\n\n",
        "buffer_free": "pub fn buffer_free(buffer: Buffer) {\n    // Function to free the buffer's allocated memory\n    // No explicit free needed in Rust due to ownership and drop semantics\n}\n\n",
        "buffer_prepend": "pub fn buffer_prepend(buffer: &mut Buffer, str: String) -> i32 {\n    let len = str.len();\n    let prev = buffer.data.len();\n    let needed = len + prev;\n\n    if buffer.len > needed {\n        // enough space\n    } else {\n        // resize\n        let ret = buffer_resize(buffer, needed);\n        if ret == -1 {\n            return -1;\n        }\n    }\n\n    // move\n    let mut new_data = String::with_capacity(needed + 1);\n    new_data.push_str(&str);\n    new_data.push_str(&buffer.data);\n    buffer.data = new_data;\n\n    0\n}\n\n",
        "buffer_append": "pub fn buffer_append(buffer: &mut Buffer, str: &str) -> i32 {\n    buffer_append_n(buffer, str, str.len())\n}\n\n",
        "buffer_new": "pub fn buffer_new() -> Result<Buffer, String> {\n    buffer_new_with_size(BUFFER_DEFAULT_SIZE)\n}\n\n",
        "buffer_size": "pub fn buffer_size(buffer: &Buffer) -> usize {\n    buffer.len\n}\n\n",
        "buffer_slice": "pub fn buffer_slice(buf: &Buffer, from: usize, to: isize) -> Result<Buffer, String> {\n    let len = buf.data.len();\n\n    // bad range\n    if to < from as isize {\n        return Err(\"Invalid range\".to_string());\n    }\n\n    // relative to end\n    let to = if to < 0 {\n        len - (!to as usize)\n    } else {\n        to as usize\n    };\n\n    // cap end\n    let to = if to > len { len } else { to };\n\n    let n = to - from;\n    let mut self_buf = buffer_new_with_size(n)?;\n    self_buf.data = buf.data[from..to].to_string();\n    Ok(self_buf)\n}\n\n",
        "buffer_new_with_copy": "pub fn buffer_new_with_copy(str: String) -> Result<Buffer, String> {\n    let len = str.len();\n    let mut buffer = buffer_new_with_size(len)?;\n    buffer.alloc = str.clone();\n    buffer.data = str;\n    Ok(buffer)\n}\n\n",
        "buffer_trim": "pub fn buffer_trim(buffer: &mut Buffer) {\n    buffer_trim_left(buffer);\n    buffer_trim_right(buffer);\n}\n\n",
        "buffer_compact": "pub fn buffer_compact(buffer: &mut Buffer) -> i32 {\n    let len = buffer_length(buffer);\n    let rem = buffer.len - len;\n    let mut buf = String::with_capacity(len + 1);\n    buf.push_str(&buffer.data);\n    buffer.alloc = buf.clone();\n    buffer.data = buf;\n    buffer.len = len;\n    rem as i32\n}\n\n",
        "buffer_indexof": "pub fn buffer_indexof(buffer: &Buffer, str: String) -> i32 {\n    let sub = buffer.data.find(&str);\n    match sub {\n        Some(index) => index as i32,\n        None => -1,\n    }\n}\n\n",
        "buffer_clear": "pub fn buffer_clear(buffer: &mut Buffer) {  \n    buffer_fill(buffer, 0);  \n}\n\n",
        "buffer_appendf": "pub fn buffer_appendf(buffer: &mut Buffer, format: String, args: Vec<String>) -> i32 {\n    let length = buffer_length(buffer);\n    let required = format.len();\n    if buffer_resize(buffer, length + required) == -1 {\n        return -1;\n    }\n    let dst = &mut buffer.data[length..];\n    let mut s = dst.to_string();\n    let formatted_args = format!(\"{}\", args.join(\" \"));\n    let result = std::fmt::write(&mut s, format_args!(\"{}\", formatted_args));\n    if result.is_err() {\n        -1\n    } else {\n        0\n    }\n}\n\n",
        "buffer_equals": "pub fn buffer_equals(buffer: &Buffer, other: &Buffer) -> bool {\n    buffer.data == other.data\n}\n\n"
    },
    "test-buffer": {
        "main": "fn main(){}\n",
        "test_buffer_prepend": "pub fn test_buffer_prepend() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \" World\"));\n    assert_eq!(0, buffer_prepend(&mut buf, \"Hello\".to_string()));\n    assert_eq!(\"Hello World\".len(), buffer_length(&buf));\n    equal(\"Hello World\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "equal": "pub fn equal(a: &str, b: &str) {\n    if a != b {\n        println!();\n        println!(\"  expected: '{}'\", a);\n        println!(\"    actual: '{}'\", b);\n        println!();\n        std::process::exit(1);\n    }\n}\n\n",
        "extra": "use test_project::buffer::{BUFFER_DEFAULT_SIZE, Buffer, buffer_new, buffer_append, buffer_prepend, buffer_length, buffer_free, buffer_size, buffer_new_with_size, buffer_new_with_copy, buffer_slice, buffer_trim, buffer_compact, buffer_append_n, buffer_fill, buffer_indexof, buffer_trim_left, buffer_trim_right, buffer_clear, buffer_appendf, buffer_equals};",
        "test_buffer_new": "pub fn test_buffer_new() {\n    let buf = buffer_new().unwrap();\n    assert_eq!(BUFFER_DEFAULT_SIZE, buffer_size(&buf));\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_new_with_size": "pub fn test_buffer_new_with_size() {\n    let buf = buffer_new_with_size(1024).unwrap();\n    assert_eq!(1024, buffer_size(&buf));\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__end_overflow": "pub fn test_buffer_slice__end_overflow() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n    let a = buffer_slice(&buf, 5, 1000).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"Ferret\", &a.data);\n    buffer_free(a);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_compact": "pub fn test_buffer_compact() {\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim(&mut buf);\n    assert_eq!(5, buffer_length(&buf));\n    assert_eq!(10, buffer_size(&buf));\n\n    let removed = buffer_compact(&mut buf);\n    assert_eq!(5, removed);\n    assert_eq!(5, buffer_length(&buf));\n    assert_eq!(5, buffer_size(&buf));\n    equal(\"Hello\", &buf.data);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append": "pub fn test_buffer_append() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \"Hello\"));\n    assert_eq!(0, buffer_append(&mut buf, \" World\"));\n    assert_eq!(\"Hello World\".len(), buffer_length(&buf));\n    equal(\"Hello World\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append_n": "pub fn test_buffer_append_n() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append_n(&mut buf, \"subway\", 3));\n    assert_eq!(0, buffer_append_n(&mut buf, \"marines\", 6));\n    assert_eq!(\"submarine\".len(), buffer_length(&buf));\n    equal(\"submarine\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append__grow": "pub fn test_buffer_append__grow() {\n    let mut buf = buffer_new_with_size(10).unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \"Hello\"));\n    assert_eq!(0, buffer_append(&mut buf, \" tobi\"));\n    assert_eq!(0, buffer_append(&mut buf, \" was\"));\n    assert_eq!(0, buffer_append(&mut buf, \" here\"));\n\n    let str = \"Hello tobi was here\";\n    equal(str, &buf.data);\n    assert_eq!(1024, buffer_size(&buf));\n    assert_eq!(str.len(), buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_prepend_issue_15": "pub fn test_buffer_prepend_issue_15() {\n    let mut file = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut file, \"layout.bk.html\"));\n    assert_eq!(0, buffer_prepend(&mut file, \"./example/\".to_string()));\n    assert_eq!(\"./example/layout.bk.html\".len(), buffer_length(&file));\n    equal(\"./example/layout.bk.html\", &file.data);\n    buffer_free(file);\n}\n\n",
        "test_buffer_fill": "pub fn test_buffer_fill() {\n    let mut buf = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    assert_eq!(5, buffer_length(&buf));\n\n    buffer_fill(&mut buf, 0);\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_indexof": "pub fn test_buffer_indexof() {\n    let buf = buffer_new_with_copy(String::from(\"Tobi is a ferret\")).unwrap();\n\n    let i = buffer_indexof(&buf, String::from(\"is\"));\n    assert_eq!(5, i);\n\n    let i = buffer_indexof(&buf, String::from(\"a\"));\n    assert_eq!(8, i);\n\n    let i = buffer_indexof(&buf, String::from(\"something\"));\n    assert_eq!(-1, i);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_trim": "pub fn test_buffer_trim() {\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim(&mut buf);\n    equal(\"Hello\", &buf.data);\n\n    buffer_free(buf);\n\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim_left(&mut buf);\n    equal(\"Hello\\n\\n \", &buf.data);\n\n    buffer_free(buf);\n\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim_right(&mut buf);\n    equal(\"  Hello\", &buf.data);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__range_error": "pub fn test_buffer_slice__range_error() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n    let a = buffer_slice(&buf, 10, 2);\n    assert!(a.is_err());\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__end": "pub fn test_buffer_slice__end() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n\n    let a = buffer_slice(&buf, 5, -1).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"Ferret\", &a.data);\n\n    let b = buffer_slice(&buf, 5, -3).unwrap();\n    equal(\"Ferr\", &b.data);\n\n    let c = buffer_slice(&buf, 8, -1).unwrap();\n    equal(\"ret\", &c.data);\n\n    buffer_free(buf);\n    buffer_free(a);\n    buffer_free(b);\n    buffer_free(c);\n}\n\n",
        "test_buffer_clear": "pub fn test_buffer_clear() {\n    let mut buf = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    assert_eq!(5, buffer_length(&buf));\n\n    buffer_clear(&mut buf);\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_formatting": "pub fn test_buffer_formatting() {\n    let mut buf = buffer_new().expect(\"Failed to create buffer\");\n    let result = buffer_appendf(&mut buf, \"%d %s\".to_string(), vec![\"3\".to_string(), \"cow\".to_string()]);\n    assert_eq!(0, result);\n    equal(\"3 cow\", &buf.data);\n    let result = buffer_appendf(&mut buf, \" - 0x%08X\".to_string(), vec![\"0xDEADBEEF\".to_string()]);\n    assert_eq!(0, result);\n    equal(\"3 cow - 0xDEADBEEF\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_equals": "pub fn test_buffer_equals() {\n    let a = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    let b = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n\n    assert!(buffer_equals(&a, &b));\n\n    buffer_append(&mut b.clone(), \" World\");\n    assert!(!buffer_equals(&a, &b));\n\n    buffer_free(a);\n    buffer_free(b);\n}\n\n",
        "test_buffer_slice": "pub fn test_buffer_slice() {\n    let mut buf = buffer_new().unwrap();\n    buffer_append(&mut buf, \"Tobi Ferret\");\n\n    let a = buffer_slice(&buf, 2, 8).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"bi Fer\", &a.data);\n\n    buffer_free(buf);\n    buffer_free(a);\n}\n\nfn nearest_multiple_of(base: usize, n: usize) -> usize {\n    ((n + base - 1) / base) * base\n}\n\n"
    },
    "ht": {
        "hash_key": "pub fn hash_key(key: String) -> u64 {\n    let mut hash: u64 = 14695981039346656037;\n    for c in key.chars() {\n        hash ^= c as u64;\n        hash = hash.wrapping_mul(1099511628211);\n    }\n    hash\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse std::fmt;\n\nconst INITIAL_CAPACITY: usize = 16;\n\n#[derive(Debug)]\npub struct HtEntry<T> {\n    pub key: Option<String>,\n    pub value: Option<T>,\n}\n\n#[derive(Debug)]\npub struct Ht<T> {\n    pub entries: Vec<Rc<RefCell<HtEntry<T>>>>,\n    pub capacity: usize,\n    pub length: usize,\n}\n\npub struct HtIterator<T> {\n    pub key: Option<String>,\n    pub value: Option<T>,\n    pub _table: Rc<RefCell<Ht<T>>>,\n    pub _index: usize,\n}\n",
        "ht_set_entry": "pub fn ht_set_entry<T>(entries: &mut Vec<Rc<RefCell<HtEntry<T>>>>, capacity: usize, key: String, value: T, plength: &mut usize) -> Option<String> {\n    let hash = hash_key(key.clone());\n    let mut index = (hash & (capacity as u64 - 1)) as usize;\n\n    loop {\n        let entry = entries[index].borrow();\n        if let Some(existing_key) = &entry.key {\n            if *existing_key == key {\n                entries[index].borrow_mut().value = Some(value);\n                return Some(existing_key.clone());\n            }\n            index += 1;\n            if index >= capacity {\n                index = 0;\n            }\n        } else {\n            break;\n        }\n    }\n\n    if *plength != 0 {\n        *plength += 1;\n    }\n    entries[index].borrow_mut().key = Some(key.clone());\n    entries[index].borrow_mut().value = Some(value);\n    Some(key)\n}\n\n",
        "ht_expand": "pub fn ht_expand<T: Clone>(entries: &mut Vec<Rc<RefCell<HtEntry<T>>>>, capacity: &mut usize, length: &mut usize) -> bool {\n    let new_capacity = *capacity * 2;\n    if new_capacity < *capacity {\n        return false;  // overflow (capacity would be too big)\n    }\n\n    let mut new_entries = Vec::with_capacity(new_capacity);\n    for _ in 0..new_capacity {\n        new_entries.push(Rc::new(RefCell::new(HtEntry { key: None, value: None })));\n    }\n\n    for i in 0..*capacity {\n        let entry = entries[i].borrow();\n        if let Some(key) = &entry.key {\n            let value = entry.value.as_ref().unwrap().clone();\n            ht_set_entry(&mut new_entries, new_capacity, key.clone(), value, length);\n        }\n    }\n\n    *entries = new_entries;\n    *capacity = new_capacity;\n    true\n}\n\n",
        "ht_destroy": "pub fn ht_destroy<T>(table: Ht<T>) {\n    // First free allocated keys.\n    for i in 0..table.capacity {\n        let mut entry = table.entries[i].borrow_mut();\n        entry.key = None;\n    }\n\n    // Then free entries array and table itself.\n    // Rust's ownership system will automatically handle the cleanup of the Vec and Ht struct.\n}\n\n",
        "ht_create": "pub fn ht_create<T>() -> Ht<T> {\n    let mut table = Ht {\n        entries: Vec::with_capacity(INITIAL_CAPACITY),\n        capacity: INITIAL_CAPACITY,\n        length: 0,\n    };\n    for _ in 0..INITIAL_CAPACITY {\n        table.entries.push(Rc::new(RefCell::new(HtEntry {\n            key: None,\n            value: None,\n        })));\n    }\n    table\n}\n\n",
        "ht_set": "pub fn ht_set<T: Clone>(table: &mut Ht<T>, key: String, value: T) -> Option<String> {\n    if table.length >= table.capacity / 2 {\n        if !ht_expand(&mut table.entries, &mut table.capacity, &mut table.length) {\n            return None;\n        }\n    }\n    ht_set_entry(&mut table.entries, table.capacity, key, value, &mut table.length)\n}\n\n",
        "ht_length": "pub fn ht_length<T>(table: &Ht<T>) -> usize {\n    table.length\n}\n\n",
        "ht_get": "pub fn ht_get<T: Clone>(table: &Ht<T>, key: String) -> Option<Rc<RefCell<T>>> {\n    let hash = hash_key(key.clone());\n    let mut index = (hash & (table.capacity as u64 - 1)) as usize;\n\n    while table.entries[index].borrow().key.is_some() {\n        if table.entries[index].borrow().key.as_ref().unwrap() == &key {\n            let value = table.entries[index].borrow().value.as_ref().unwrap().clone();\n            return Some(Rc::new(RefCell::new(value)));\n        }\n        index += 1;\n        if index >= table.capacity {\n            index = 0;\n        }\n    }\n    None\n}\n\n",
        "ht_iterator": "pub fn ht_iterator<T>(table: Rc<RefCell<Ht<T>>>) -> HtIterator<T> {\n    HtIterator {\n        key: None,\n        value: None,\n        _table: table,\n        _index: 0,\n    }\n}\n\n",
        "ht_next": "pub fn ht_next<T: Clone>(mut it: HtIterator<T>) -> (bool, HtIterator<T>) {\n    let table = Rc::clone(&it._table);\n    let mut table_borrow = table.borrow_mut();\n    while it._index < table_borrow.capacity {\n        let i = it._index;\n        it._index += 1;\n        if let Some(entry) = &table_borrow.entries[i].borrow().key {\n            let entry_borrow = table_borrow.entries[i].borrow();\n            it.key = entry_borrow.key.clone();\n            it.value = entry_borrow.value.as_ref().map(|v| v.clone());\n            return (true, it);\n        }\n    }\n    (false, it)\n}\n\n"
    },
    "test-ht": {
        "main": "fn main(){}\n\n",
        "test_ht_update_value": "pub fn test_ht_update_value() {\n    let mut table = ht_create::<i32>();\n    \n    // Insert a key-value pair\n    let value1 = 42;\n    let key = String::from(\"key\");\n    assert!(ht_set(&mut table, key.clone(), value1).is_some());\n    \n    // Update the value for the same key\n    let value2 = 84;\n    assert!(ht_set(&mut table, key.clone(), value2).is_some());\n    \n    // Retrieve the updated value\n    let retrieved_value = ht_get(&table, key.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value2);\n    \n    // Check the length of the hash table (should still be 1)\n    assert_eq!(ht_length(&table), 1);\n    \n    ht_destroy(table);\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse test_project::ht::{ht_iterator, ht_length, ht_set_entry, ht_create, hash_key, ht_next, ht_destroy, ht_set, ht_expand, ht_get, Ht, HtEntry, HtIterator};",
        "test_ht_memory_management": "pub fn test_ht_memory_management() {\n    let mut table = ht_create::<Rc<RefCell<i32>>>();\n    \n    let value1 = Rc::new(RefCell::new(42));\n    let value2 = Rc::new(RefCell::new(84));\n    \n    assert!(ht_set(&mut table, \"key1\".to_string(), Rc::clone(&value1)).is_some());\n    assert!(ht_set(&mut table, \"key2\".to_string(), Rc::clone(&value2)).is_some());\n    \n    let mut it = ht_iterator(Rc::new(RefCell::new(table)));\n    loop {\n        let (has_next, new_it) = ht_next(it);\n        it = new_it;\n        if !has_next {\n            break;\n        }\n    }\n    \n    let table = Rc::try_unwrap(it._table).unwrap().into_inner();\n    ht_destroy(table);\n}\n\n",
        "test_ht_set_and_get": "pub fn test_ht_set_and_get() {\n    let mut table = ht_create::<i32>();\n\n    // Insert a key-value pair\n    let value1 = 42;\n    let key1 = String::from(\"key1\");\n    assert!(ht_set(&mut table, key1.clone(), value1).is_some());\n\n    // Retrieve the value\n    let retrieved_value = ht_get(&table, key1.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value1);\n\n    // Insert another key-value pair\n    let value2 = 84;\n    let key2 = String::from(\"key2\");\n    assert!(ht_set(&mut table, key2.clone(), value2).is_some());\n\n    // Retrieve the second value\n    let retrieved_value = ht_get(&table, key2.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value2);\n\n    // Check the length of the hash table\n    assert_eq!(ht_length(&table), 2);\n\n    ht_destroy(table);\n}\n\n",
        "test_ht_create_and_destroy": "pub fn test_ht_create_and_destroy() {\n    let mut table = ht_create::<i32>();\n    assert_eq!(ht_length(&table), 0);\n    ht_destroy(table);\n}\n\n",
        "test_ht_iterator": "pub fn test_ht_iterator() {\n    let mut table = ht_create();\n    let value1 = 1;\n    let value2 = 2;\n    let value3 = 3;\n    assert!(ht_set(&mut table, \"key1\".to_string(), value1).is_some());\n    assert!(ht_set(&mut table, \"key2\".to_string(), value2).is_some());\n    assert!(ht_set(&mut table, \"key3\".to_string(), value3).is_some());\n\n    let it = ht_iterator(Rc::new(RefCell::new(table)));\n    let mut count = 0;\n    let mut it = it;\n    loop {\n        let (has_next, new_it) = ht_next(it);\n        it = new_it;\n        if !has_next {\n            break;\n        }\n        assert!(it.key.is_some());\n        assert!(it.value.is_some());\n        count += 1;\n    }\n\n    assert_eq!(count, 3);\n\n    let table = it._table.borrow();\n    let table_clone = Ht {\n        entries: table.entries.clone(),\n        capacity: table.capacity,\n        length: table.length,\n    };\n    ht_destroy(table_clone);\n}\n\n"
    },
    "quadtree": {
        "quadtree_point_new": "pub fn quadtree_point_new(x: f64, y: f64) -> Option<QuadtreePoint> {\n    Some(QuadtreePoint { x, y })\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct QuadtreePoint {\n    pub x: f64,\n    pub y: f64,\n}\n\npub struct QuadtreeNode<T> {\n    pub ne: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub nw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub se: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub sw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub bounds: Option<Rc<RefCell<QuadtreeBounds>>>,\n    pub point: Option<Rc<RefCell<QuadtreePoint>>>,\n    pub key: Option<T>,\n}\n\npub struct QuadtreeBounds {\n    pub nw: Rc<RefCell<QuadtreePoint>>,\n    pub se: Rc<RefCell<QuadtreePoint>>,\n    pub width: f64,\n    pub height: f64,\n}\n\npub struct Quadtree<T> {\n    pub key_free: Option<fn(T)>,\n    pub root: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n}\n\npub struct quadtree_node_t {\n    pub ne: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub nw: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub se: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub sw: Option<Rc<RefCell<quadtree_node_t>>>,\n}\n",
        "quadtree_node_new": "pub fn quadtree_node_new<T>() -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = QuadtreeNode {\n        ne: None,\n        nw: None,\n        se: None,\n        sw: None,\n        bounds: None,\n        point: None,\n        key: None,\n    };\n    Some(Rc::new(RefCell::new(node)))\n}\n\n",
        "quadtree_bounds_extend": "pub fn quadtree_bounds_extend(bounds: Rc<RefCell<QuadtreeBounds>>, x: f64, y: f64) {\n    let nw_x;\n    let nw_y;\n    let se_x;\n    let se_y;\n    {\n        let bounds = bounds.borrow();\n        let nw = bounds.nw.borrow();\n        let se = bounds.se.borrow();\n        nw_x = f64::min(x, nw.x);\n        nw_y = f64::max(y, nw.y);\n        se_x = f64::max(x, se.x);\n        se_y = f64::min(y, se.y);\n    }\n    {\n        let mut bounds = bounds.borrow_mut();\n        bounds.width = (nw_x - se_x).abs();\n        bounds.height = (nw_y - se_y).abs();\n    }\n}\n\n",
        "quadtree_bounds_new": "pub fn quadtree_bounds_new() -> Option<Rc<RefCell<QuadtreeBounds>>> {\n    let nw = Rc::new(RefCell::new(QuadtreePoint { x: f64::INFINITY, y: -f64::INFINITY }));\n    let se = Rc::new(RefCell::new(QuadtreePoint { x: -f64::INFINITY, y: f64::INFINITY }));\n    let bounds = QuadtreeBounds {\n        nw,\n        se,\n        width: 0.0,\n        height: 0.0,\n    };\n    Some(Rc::new(RefCell::new(bounds)))\n}\n\n",
        "quadtree_point_free": "pub fn quadtree_point_free(point: Rc<RefCell<QuadtreePoint>>) {\n    // \u91ca\u653e QuadtreePoint \u7684\u5185\u5b58\n    // \u7531\u4e8e Rc<RefCell<T>> \u662f\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u624b\u52a8\u91ca\u653e\u5185\u5b58\n}\n\n",
        "node_contains_": "pub fn node_contains_<T>(outer: Rc<RefCell<QuadtreeNode<T>>>, it: Rc<RefCell<QuadtreePoint>>) -> bool {\n    let outer = outer.borrow();\n    let it = it.borrow();\n    if let Some(bounds) = &outer.bounds {\n        let bounds = bounds.borrow();\n        bounds.nw.borrow().x <= it.x &&\n        bounds.nw.borrow().y >= it.y &&\n        bounds.se.borrow().x >= it.x &&\n        bounds.se.borrow().y <= it.y\n    } else {\n        false\n    }\n}\n\n",
        "quadtree_node_isleaf": "pub fn quadtree_node_isleaf<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    node.borrow().point.is_some()\n}\n\n",
        "quadtree_node_with_bounds": "pub fn quadtree_node_with_bounds<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = quadtree_node_new()?;\n    let bounds = quadtree_bounds_new()?;\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.bounds = Some(bounds.clone());\n    }\n    quadtree_bounds_extend(bounds.clone(), maxx, maxy);\n    quadtree_bounds_extend(bounds.clone(), minx, miny);\n    Some(node)\n}\n\n",
        "quadtree_node_reset": "pub fn quadtree_node_reset<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(point) = &node_borrow.point {\n        quadtree_point_free(point.clone());\n    }\n    if let Some(key) = node_borrow.key.take() {\n        key_free(key);\n    }\n}\n\n",
        "elision_": "pub fn elision_<T>(key: T) -> T {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    key\n}\n\n",
        "get_quadrant_": "pub fn get_quadrant_<T>(root: Rc<RefCell<QuadtreeNode<T>>>, point: Rc<RefCell<QuadtreePoint>>) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let root = root.borrow();\n    if let Some(nw) = &root.nw {\n        if node_contains_(nw.clone(), point.clone()) {\n            return Some(nw.clone());\n        }\n    }\n    if let Some(ne) = &root.ne {\n        if node_contains_(ne.clone(), point.clone()) {\n            return Some(ne.clone());\n        }\n    }\n    if let Some(sw) = &root.sw {\n        if node_contains_(sw.clone(), point.clone()) {\n            return Some(sw.clone());\n        }\n    }\n    if let Some(se) = &root.se {\n        if node_contains_(se.clone(), point.clone()) {\n            return Some(se.clone());\n        }\n    }\n    None\n}\n\n",
        "quadtree_node_ispointer": "pub fn quadtree_node_ispointer<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_some()\n        && node_ref.ne.is_some()\n        && node_ref.sw.is_some()\n        && node_ref.se.is_some()\n        && !quadtree_node_isleaf(node)\n}\n\n",
        "split_node_": "pub fn split_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let x;\n    let y;\n    let hw;\n    let hh;\n    {\n        let node_borrow = node.borrow();\n        let bounds = node_borrow.bounds.as_ref().unwrap().borrow();\n        x = bounds.nw.borrow().x;\n        y = bounds.nw.borrow().y;\n        hw = bounds.width / 2.0;\n        hh = bounds.height / 2.0;\n    }\n\n    let nw = quadtree_node_with_bounds::<T>(x, y - hh, x + hw, y);\n    let ne = quadtree_node_with_bounds::<T>(x + hw, y - hh, x + hw * 2.0, y);\n    let sw = quadtree_node_with_bounds::<T>(x, y - hh * 2.0, x + hw, y - hh);\n    let se = quadtree_node_with_bounds::<T>(x + hw, y - hh * 2.0, x + hw * 2.0, y - hh);\n\n    if nw.is_none() || ne.is_none() || sw.is_none() || se.is_none() {\n        return false;\n    }\n\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.nw = Some(nw.unwrap());\n        node_mut.ne = Some(ne.unwrap());\n        node_mut.sw = Some(sw.unwrap());\n        node_mut.se = Some(se.unwrap());\n    }\n\n    let old_point;\n    let old_key;\n    {\n        let mut node_mut = node.borrow_mut();\n        old_point = node_mut.point.take();\n        old_key = node_mut.key.take();\n    }\n\n    insert_(tree.clone(), node, old_point, old_key) != 0\n}\n\n",
        "reset_node_": "pub fn reset_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) {\n    let key_free = tree.borrow().key_free.clone();\n    if let Some(key_free) = key_free {\n        quadtree_node_reset(node, key_free);\n    } else {\n        let elision_wrap = |key: T| { elision_(key); };\n        quadtree_node_reset(node, elision_wrap);\n    }\n}\n\n",
        "insert_": "pub fn insert_<T>(\n    tree: Rc<RefCell<Quadtree<T>>>,\n    root: Rc<RefCell<QuadtreeNode<T>>>,\n    point: Option<Rc<RefCell<QuadtreePoint>>>,\n    key: Option<T>,\n) -> i32 {\n    if quadtree_node_isempty(&root) {\n        {\n            let mut root_mut = root.borrow_mut();\n            root_mut.point = point;\n            root_mut.key = key;\n        }\n        return 1; // normal insertion flag\n    } else if quadtree_node_isleaf(&root) {\n        let root_point = root.borrow().point.as_ref().unwrap().clone();\n        let point_ref = point.as_ref().unwrap().clone();\n        let root_point_borrow = root_point.borrow();\n        let point_ref_borrow = point_ref.borrow();\n        if root_point_borrow.x == point_ref_borrow.x && root_point_borrow.y == point_ref_borrow.y {\n            reset_node_(tree.clone(), root.clone());\n            {\n                let mut root_mut = root.borrow_mut();\n                root_mut.point = point;\n                root_mut.key = key;\n            }\n            return 2; // replace insertion flag\n        } else {\n            if !split_node_(tree.clone(), root.clone()) {\n                return 0; // failed insertion flag\n            }\n            return insert_(tree, root, point, key);\n        }\n    } else if quadtree_node_ispointer(&root) {\n        let quadrant = get_quadrant_(root.clone(), point.as_ref().unwrap().clone());\n        if quadrant.is_none() {\n            return 0;\n        }\n        return insert_(tree, quadrant.unwrap(), point, key);\n    }\n    0\n}\n\n",
        "quadtree_node_isempty": "pub fn quadtree_node_isempty<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_none()\n        && node_ref.ne.is_none()\n        && node_ref.sw.is_none()\n        && node_ref.se.is_none()\n        && !quadtree_node_isleaf(node)\n}\n\n",
        "quadtree_bounds_free": "pub fn quadtree_bounds_free(bounds: Rc<RefCell<QuadtreeBounds>>) {\n    // \u91ca\u653e QuadtreeBounds \u7684\u5185\u5b58\n    // \u7531\u4e8e Rc<RefCell<T>> \u662f\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u624b\u52a8\u91ca\u653e\u5185\u5b58\n    let bounds = bounds.borrow();\n    quadtree_point_free(Rc::clone(&bounds.nw));\n    quadtree_point_free(Rc::clone(&bounds.se));\n}\n\n",
        "find_": "pub fn find_<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        if quadtree_node_isleaf(&node) {\n            if let Some(point) = &node_ref.point {\n                let point_ref = point.borrow();\n                if point_ref.x == x && point_ref.y == y {\n                    return Some(point.clone());\n                }\n            }\n        } else if quadtree_node_ispointer(&node) {\n            let test = Rc::new(RefCell::new(QuadtreePoint { x, y }));\n            return find_(get_quadrant_(node.clone(), test), x, y);\n        }\n    }\n    None\n}\n\n",
        "quadtree_node_free": "pub fn quadtree_node_free<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(nw) = node_borrow.nw.take() {\n        quadtree_node_free(nw, key_free);\n    }\n    if let Some(ne) = node_borrow.ne.take() {\n        quadtree_node_free(ne, key_free);\n    }\n    if let Some(sw) = node_borrow.sw.take() {\n        quadtree_node_free(sw, key_free);\n    }\n    if let Some(se) = node_borrow.se.take() {\n        quadtree_node_free(se, key_free);\n    }\n    if let Some(bounds) = node_borrow.bounds.take() {\n        quadtree_bounds_free(bounds);\n    }\n    quadtree_node_reset(Rc::clone(&node), key_free);\n}\n\n",
        "quadtree_search": "pub fn quadtree_search<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    let tree_ref = tree.borrow();\n    find_(tree_ref.root.clone(), x, y)\n}\n\n",
        "quadtree_insert": "pub fn quadtree_insert<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64, key: T) -> i32 {\n    let point = quadtree_point_new(x, y);\n    if point.is_none() {\n        return 0;\n    }\n    let point_rc = Rc::new(RefCell::new(point.unwrap()));\n    if !node_contains_(tree.borrow().root.as_ref().unwrap().clone(), point_rc.clone()) {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    let insert_status = insert_(tree.clone(), tree.borrow().root.as_ref().unwrap().clone(), Some(point_rc.clone()), Some(key));\n    if insert_status == 0 {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    if insert_status == 1 {\n        let mut tree_mut = tree.borrow_mut();\n        // Assuming length is a field in Quadtree struct\n        // If not, you need to add it\n        // tree_mut.length += 1;\n    }\n    insert_status\n}\n\n",
        "quadtree_free": "pub fn quadtree_free<T>(tree: Rc<RefCell<Quadtree<T>>>) {\n    let tree_borrow = tree.borrow();\n    if let Some(key_free) = tree_borrow.key_free {\n        if let Some(root) = &tree_borrow.root {\n            quadtree_node_free(Rc::clone(root), key_free);\n        }\n    } else {\n        if let Some(root) = &tree_borrow.root {\n            fn elision_wrap<T>(key: T) {\n                elision_(key);\n            }\n            quadtree_node_free(Rc::clone(root), elision_wrap);\n        }\n    }\n}\n\n",
        "quadtree_new": "pub fn quadtree_new<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Quadtree<T>> {\n    let root = quadtree_node_with_bounds::<T>(minx, miny, maxx, maxy)?;\n    let tree = Quadtree {\n        key_free: None,\n        root: Some(root),\n    };\n    Some(tree)\n}\n\n",
        "quadtree_walk": "pub fn quadtree_walk<T>(root: Option<Rc<RefCell<QuadtreeNode<T>>>>, descent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>), ascent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>)) {\n    descent(root.clone());\n    if let Some(node) = &root {\n        let node_ref = node.borrow();\n        if let Some(nw) = &node_ref.nw {\n            quadtree_walk(Some(nw.clone()), descent, ascent);\n        }\n        if let Some(ne) = &node_ref.ne {\n            quadtree_walk(Some(ne.clone()), descent, ascent);\n        }\n        if let Some(sw) = &node_ref.sw {\n            quadtree_walk(Some(sw.clone()), descent, ascent);\n        }\n        if let Some(se) = &node_ref.se {\n            quadtree_walk(Some(se.clone()), descent, ascent);\n        }\n    }\n    ascent(root);\n}\n\n"
    },
    "test-quadtree": {
        "main": "fn main(){}\n\n",
        "ascent": "pub fn ascent<T>(node: Rc<RefCell<QuadtreeNode<T>>>) {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    // Function implementation\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse test_project::quadtree::{QuadtreeNode, quadtree_node_t, quadtree_node_isleaf, find_, quadtree_walk, quadtree_node_new, quadtree_bounds_extend, quadtree_new, quadtree_node_isempty, quadtree_node_ispointer, quadtree_node_free, insert_, quadtree_search, quadtree_free, elision_, quadtree_bounds_free, quadtree_point_new, quadtree_bounds_new, get_quadrant_, reset_node_, split_node_, node_contains_, quadtree_insert, quadtree_node_with_bounds, quadtree_point_free, quadtree_node_reset};",
        "descent": "pub fn descent(node: Rc<RefCell<quadtree_node_t>>) {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    let mut node = node.borrow_mut();\n    if let Some(ne) = &node.ne {\n        descent(Rc::clone(ne));\n    }\n    if let Some(nw) = &node.nw {\n        descent(Rc::clone(nw));\n    }\n    if let Some(se) = &node.se {\n        descent(Rc::clone(se));\n    }\n    if let Some(sw) = &node.sw {\n        descent(Rc::clone(sw));\n    }\n}\n\n",
        "test_bounds": "pub fn test_bounds() {\n    let bounds = quadtree_bounds_new().unwrap();\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.x, f64::INFINITY);\n        assert_eq!(se.x, -f64::INFINITY);\n    }\n\n    quadtree_bounds_extend(Rc::clone(&bounds), 5.0, 5.0);\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.x, 5.0);\n        assert_eq!(se.x, 5.0);\n    }\n\n    quadtree_bounds_extend(Rc::clone(&bounds), 10.0, 10.0);\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.y, 10.0);\n        assert_eq!(se.y, 5.0);\n        assert_eq!(bounds_ref.width, 5.0);\n        assert_eq!(bounds_ref.height, 5.0);\n    }\n\n    quadtree_bounds_free(bounds);\n}\n\n",
        "test_points": "pub fn test_points() {\n    let point = quadtree_point_new(5.0, 6.0);\n    assert!(point.as_ref().unwrap().x == 5.0);\n    assert!(point.as_ref().unwrap().y == 6.0);\n    quadtree_point_free(Rc::new(RefCell::new(point.unwrap())));\n}\n\n",
        "test_node": "pub fn test_node() {\n    let node = quadtree_node_new::<i32>();\n    let node_ref = node.as_ref().unwrap();\n    assert!(!quadtree_node_isleaf(node_ref));\n    assert!(quadtree_node_isempty(node_ref));\n    assert!(!quadtree_node_ispointer(node_ref));\n}\n\n"
    },
    "rgba": {
        "rgba_from_rgba": "pub fn rgba_from_rgba(r: u8, g: u8, b: u8, a: u8) -> u32 {\n    (r as u32) << 24 | (g as u32) << 16 | (b as u32) << 8 | (a as u32)\n}\n\n",
        "extra": "pub struct Rgba {\n    pub r: f64,\n    pub g: f64,\n    pub b: f64,\n    pub a: f64,\n}\n\npub struct NamedColor {\n    pub name: &'static str,\n    pub val: u32,\n}\n\npub const NAMED_COLORS: &[NamedColor] = &[\n    NamedColor { name: \"transparent\", val: 0xFFFFFF00 },\n    NamedColor { name: \"aliceblue\", val: 0xF0F8FFFF },\n    NamedColor { name: \"antiquewhite\", val: 0xFAEBD7FF },\n    NamedColor { name: \"aqua\", val: 0x00FFFFFF },\n    NamedColor { name: \"aquamarine\", val: 0x7FFFD4FF },\n    NamedColor { name: \"azure\", val: 0xF0FFFFFF },\n    NamedColor { name: \"beige\", val: 0xF5F5DCFF },\n    NamedColor { name: \"bisque\", val: 0xFFE4C4FF },\n    NamedColor { name: \"black\", val: 0x000000FF },\n    NamedColor { name: \"blanchedalmond\", val: 0xFFEBCDFF },\n    NamedColor { name: \"blue\", val: 0x0000FFFF },\n    NamedColor { name: \"blueviolet\", val: 0x8A2BE2FF },\n    NamedColor { name: \"brown\", val: 0xA52A2AFF },\n    NamedColor { name: \"burlywood\", val: 0xDEB887FF },\n    NamedColor { name: \"cadetblue\", val: 0x5F9EA0FF },\n    NamedColor { name: \"chartreuse\", val: 0x7FFF00FF },\n    NamedColor { name: \"chocolate\", val: 0xD2691EFF },\n    NamedColor { name: \"coral\", val: 0xFF7F50FF },\n    NamedColor { name: \"cornflowerblue\", val: 0x6495EDFF },\n    NamedColor { name: \"cornsilk\", val: 0xFFF8DCFF },\n    NamedColor { name: \"crimson\", val: 0xDC143CFF },\n    NamedColor { name: \"cyan\", val: 0x00FFFFFF },\n    NamedColor { name: \"darkblue\", val: 0x00008BFF },\n    NamedColor { name: \"darkcyan\", val: 0x008B8BFF },\n    NamedColor { name: \"darkgoldenrod\", val: 0xB8860BFF },\n    NamedColor { name: \"darkgray\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkgreen\", val: 0x006400FF },\n    NamedColor { name: \"darkgrey\", val: 0xA9A9A9FF },\n    NamedColor { name: \"darkkhaki\", val: 0xBDB76BFF },\n    NamedColor { name: \"darkmagenta\", val: 0x8B008BFF },\n    NamedColor { name: \"darkolivegreen\", val: 0x556B2FFF },\n    NamedColor { name: \"darkorange\", val: 0xFF8C00FF },\n    NamedColor { name: \"darkorchid\", val: 0x9932CCFF },\n    NamedColor { name: \"darkred\", val: 0x8B0000FF },\n    NamedColor { name: \"darksalmon\", val: 0xE9967AFF },\n    NamedColor { name: \"darkseagreen\", val: 0x8FBC8FFF },\n    NamedColor { name: \"darkslateblue\", val: 0x483D8BFF },\n    NamedColor { name: \"darkslategray\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkslategrey\", val: 0x2F4F4FFF },\n    NamedColor { name: \"darkturquoise\", val: 0x00CED1FF },\n    NamedColor { name: \"darkviolet\", val: 0x9400D3FF },\n    NamedColor { name: \"deeppink\", val: 0xFF1493FF },\n    NamedColor { name: \"deepskyblue\", val: 0x00BFFFFF },\n    NamedColor { name: \"dimgray\", val: 0x696969FF },\n    NamedColor { name: \"dimgrey\", val: 0x696969FF },\n    NamedColor { name: \"dodgerblue\", val: 0x1E90FFFF },\n    NamedColor { name: \"firebrick\", val: 0xB22222FF },\n    NamedColor { name: \"floralwhite\", val: 0xFFFAF0FF },\n    NamedColor { name: \"forestgreen\", val: 0x228B22FF },\n    NamedColor { name: \"fuchsia\", val: 0xFF00FFFF },\n    NamedColor { name: \"gainsboro\", val: 0xDCDCDCFF },\n    NamedColor { name: \"ghostwhite\", val: 0xF8F8FFFF },\n    NamedColor { name: \"gold\", val: 0xFFD700FF },\n    NamedColor { name: \"goldenrod\", val: 0xDAA520FF },\n    NamedColor { name: \"gray\", val: 0x808080FF },\n    NamedColor { name: \"green\", val: 0x008000FF },\n    NamedColor { name: \"greenyellow\", val: 0xADFF2FFF },\n    NamedColor { name: \"grey\", val: 0x808080FF },\n    NamedColor { name: \"honeydew\", val: 0xF0FFF0FF },\n    NamedColor { name: \"hotpink\", val: 0xFF69B4FF },\n    NamedColor { name: \"indianred\", val: 0xCD5C5CFF },\n    NamedColor { name: \"indigo\", val: 0x4B0082FF },\n    NamedColor { name: \"ivory\", val: 0xFFFFF0FF },\n    NamedColor { name: \"khaki\", val: 0xF0E68CFF },\n    NamedColor { name: \"lavender\", val: 0xE6E6FAFF },\n    NamedColor { name: \"lavenderblush\", val: 0xFFF0F5FF },\n    NamedColor { name: \"lawngreen\", val: 0x7CFC00FF },\n    NamedColor { name: \"lemonchiffon\", val: 0xFFFACDFF },\n    NamedColor { name: \"lightblue\", val: 0xADD8E6FF },\n    NamedColor { name: \"lightcoral\", val: 0xF08080FF },\n    NamedColor { name: \"lightcyan\", val: 0xE0FFFFFF },\n    NamedColor { name: \"lightgoldenrodyellow\", val: 0xFAFAD2FF },\n    NamedColor { name: \"lightgray\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightgreen\", val: 0x90EE90FF },\n    NamedColor { name: \"lightgrey\", val: 0xD3D3D3FF },\n    NamedColor { name: \"lightpink\", val: 0xFFB6C1FF },\n    NamedColor { name: \"lightsalmon\", val: 0xFFA07AFF },\n    NamedColor { name: \"lightseagreen\", val: 0x20B2AAFF },\n    NamedColor { name: \"lightskyblue\", val: 0x87CEFAFF },\n    NamedColor { name: \"lightslategray\", val: 0x778899FF },\n    NamedColor { name: \"lightslategrey\", val: 0x778899FF },\n    NamedColor { name: \"lightsteelblue\", val: 0xB0C4DEFF },\n    NamedColor { name: \"lightyellow\", val: 0xFFFFE0FF },\n    NamedColor { name: \"lime\", val: 0x00FF00FF },\n    NamedColor { name: \"limegreen\", val: 0x32CD32FF },\n    NamedColor { name: \"linen\", val: 0xFAF0E6FF },\n    NamedColor { name: \"magenta\", val: 0xFF00FFFF },\n    NamedColor { name: \"maroon\", val: 0x800000FF },\n    NamedColor { name: \"mediumaquamarine\", val: 0x66CDAAFF },\n    NamedColor { name: \"mediumblue\", val: 0x0000CDFF },\n    NamedColor { name: \"mediumorchid\", val: 0xBA55D3FF },\n    NamedColor { name: \"mediumpurple\", val: 0x9370DBFF },\n    NamedColor { name: \"mediumseagreen\", val: 0x3CB371FF },\n    NamedColor { name: \"mediumslateblue\", val: 0x7B68EEFF },\n    NamedColor { name: \"mediumspringgreen\", val: 0x00FA9AFF },\n    NamedColor { name: \"mediumturquoise\", val: 0x48D1CCFF },\n    NamedColor { name: \"mediumvioletred\", val: 0xC71585FF },\n    NamedColor { name: \"midnightblue\", val: 0x191970FF },\n    NamedColor { name: \"mintcream\", val: 0xF5FFFAFF },\n    NamedColor { name: \"mistyrose\", val: 0xFFE4E1FF },\n    NamedColor { name: \"moccasin\", val: 0xFFE4B5FF },\n    NamedColor { name: \"navajowhite\", val: 0xFFDEADFF },\n    NamedColor { name: \"navy\", val: 0x000080FF },\n    NamedColor { name: \"oldlace\", val: 0xFDF5E6FF },\n    NamedColor { name: \"olive\", val: 0x808000FF },\n    NamedColor { name: \"olivedrab\", val: 0x6B8E23FF },\n    NamedColor { name: \"orange\", val: 0xFFA500FF },\n    NamedColor { name: \"orangered\", val: 0xFF4500FF },\n    NamedColor { name: \"orchid\", val: 0xDA70D6FF },\n    NamedColor { name: \"palegoldenrod\", val: 0xEEE8AAFF },\n    NamedColor { name: \"palegreen\", val: 0x98FB98FF },\n    NamedColor { name: \"paleturquoise\", val: 0xAFEEEEFF },\n    NamedColor { name: \"palevioletred\", val: 0xDB7093FF },\n    NamedColor { name: \"papayawhip\", val: 0xFFEFD5FF },\n    NamedColor { name: \"peachpuff\", val: 0xFFDAB9FF },\n    NamedColor { name: \"peru\", val: 0xCD853FFF },\n    NamedColor { name: \"pink\", val: 0xFFC0CBFF },\n    NamedColor { name: \"plum\", val: 0xDDA0DDFF },\n    NamedColor { name: \"powderblue\", val: 0xB0E0E6FF },\n    NamedColor { name: \"purple\", val: 0x800080FF },\n    NamedColor { name: \"red\", val: 0xFF0000FF },\n    NamedColor { name: \"rosybrown\", val: 0xBC8F8FFF },\n    NamedColor { name: \"royalblue\", val: 0x4169E1FF },\n    NamedColor { name: \"saddlebrown\", val: 0x8B4513FF },\n    NamedColor { name: \"salmon\", val: 0xFA8072FF },\n    NamedColor { name: \"sandybrown\", val: 0xF4A460FF },\n    NamedColor { name: \"seagreen\", val: 0x2E8B57FF },\n    NamedColor { name: \"seashell\", val: 0xFFF5EEFF },\n    NamedColor { name: \"sienna\", val: 0xA0522DFF },\n    NamedColor { name: \"silver\", val: 0xC0C0C0FF },\n    NamedColor { name: \"skyblue\", val: 0x87CEEBFF },\n    NamedColor { name: \"slateblue\", val: 0x6A5ACDFF },\n    NamedColor { name: \"slategray\", val: 0x708090FF },\n    NamedColor { name: \"slategrey\", val: 0x708090FF },\n    NamedColor { name: \"snow\", val: 0xFFFAFAFF },\n    NamedColor { name: \"springgreen\", val: 0x00FF7FFF },\n    NamedColor { name: \"steelblue\", val: 0x4682B4FF },\n    NamedColor { name: \"tan\", val: 0xD2B48CFF },\n    NamedColor { name: \"teal\", val: 0x008080FF },\n    NamedColor { name: \"thistle\", val: 0xD8BFD8FF },\n    NamedColor { name: \"tomato\", val: 0xFF6347FF },\n    NamedColor { name: \"turquoise\", val: 0x40E0D0FF },\n    NamedColor { name: \"violet\", val: 0xEE82EEFF },\n    NamedColor { name: \"wheat\", val: 0xF5DEB3FF },\n    NamedColor { name: \"white\", val: 0xFFFFFFFF },\n    NamedColor { name: \"whitesmoke\", val: 0xF5F5F5FF },\n    NamedColor { name: \"yellow\", val: 0xFFFF00FF },\n    NamedColor { name: \"yellowgreen\", val: 0x9ACD32FF }\n];",
        "h": "pub fn h(c: char) -> i32 {\n    match c {\n        '0'..='9' => (c as i32) - ('0' as i32),\n        'a'..='f' => (c as i32) - ('a' as i32) + 10,\n        'A'..='F' => (c as i32) - ('A' as i32) + 10,\n        _ => 0,\n    }\n}\n\n",
        "rgba_from_rgb": "pub fn rgba_from_rgb(r: u8, g: u8, b: u8) -> u32 {\n    rgba_from_rgba(r, g, b, 255)\n}\n\n",
        "rgba_from_hex6_string": "pub fn rgba_from_hex6_string(str: String) -> u32 {\n    let chars: Vec<char> = str.chars().collect();\n    rgba_from_rgb(\n        ((h(chars[0]) << 4) + h(chars[1])) as u8,\n        ((h(chars[2]) << 4) + h(chars[3])) as u8,\n        ((h(chars[4]) << 4) + h(chars[5])) as u8,\n    )\n}\n\n",
        "rgba_from_hex3_string": "pub fn rgba_from_hex3_string(str: String) -> u32 {\n    let mut chars = str.chars();\n    let r_char = chars.next().unwrap_or('0');\n    let g_char = chars.next().unwrap_or('0');\n    let b_char = chars.next().unwrap_or('0');\n    \n    let r = (h(r_char) << 4) + h(r_char);\n    let g = (h(g_char) << 4) + h(g_char);\n    let b = (h(b_char) << 4) + h(b_char);\n    \n    rgba_from_rgb(r as u8, g as u8, b as u8)\n}\n\n",
        "rgba_from_rgba_string": "pub fn rgba_from_rgba_string(str: String, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgba(\") {\n        let mut str = str[5..].to_string();\n        str = str.trim().to_string();\n        \n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut a: f32 = 0.0;\n        \n        let mut iter = str.split_whitespace();\n        if let Some(r_str) = iter.next() {\n            if let Ok(r_val) = r_str.parse::<u8>() {\n                r = r_val;\n            }\n        }\n        if let Some(g_str) = iter.next() {\n            if let Ok(g_val) = g_str.parse::<u8>() {\n                g = g_val;\n            }\n        }\n        if let Some(b_str) = iter.next() {\n            if let Ok(b_val) = b_str.parse::<u8>() {\n                b = b_val;\n            }\n        }\n        if let Some(a_str) = iter.next() {\n            if a_str.starts_with('1') {\n                a = 1.0;\n            } else if a_str.starts_with('0') {\n                if a_str.len() > 1 && a_str.chars().nth(1) == Some('.') {\n                    let mut n = 0.1;\n                    for c in a_str[2..].chars() {\n                        if c.is_digit(10) {\n                            a += (c.to_digit(10).unwrap() as f32) * n;\n                            n *= 0.1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        *ok = true;\n        return rgba_from_rgba(r, g, b, (a * 255.0) as u8);\n    }\n    \n    *ok = false;\n    0\n}\n\n",
        "rgba_from_hex_string": "pub fn rgba_from_hex_string(str: String, ok: &mut i16) -> u32 {\n    let len = str.len();\n    *ok = 1;\n    if len == 6 {\n        return rgba_from_hex6_string(str);\n    }\n    if len == 3 {\n        return rgba_from_hex3_string(str);\n    }\n    *ok = 0;\n    0\n}\n\n",
        "rgba_from_name_string": "pub fn rgba_from_name_string(str: &str, ok: &mut bool) -> u32 {\n    for color in NAMED_COLORS {\n        if str == color.name {\n            *ok = true;\n            return color.val;\n        }\n    }\n    *ok = false;\n    0\n}\n\n",
        "rgba_from_rgb_string": "pub fn rgba_from_rgb_string(str: &str, ok: &mut bool) -> u32 {\n    if str.starts_with(\"rgb(\") {\n        let mut str = &str[4..];\n        str = str.trim_start();\n        let mut r: u8 = 0;\n        let mut g: u8 = 0;\n        let mut b: u8 = 0;\n        let mut chars = str.chars();\n        let parse_channel = |c: &mut std::str::Chars| {\n            let mut num = 0;\n            while let Some(ch) = c.next() {\n                if ch.is_ascii_digit() {\n                    num = num * 10 + (ch as u8 - b'0');\n                } else if ch == ',' || ch == ')' {\n                    break;\n                }\n            }\n            num\n        };\n        r = parse_channel(&mut chars);\n        g = parse_channel(&mut chars);\n        b = parse_channel(&mut chars);\n        *ok = true;\n        return rgba_from_rgb(r, g, b);\n    }\n    *ok = false;\n    0\n}\n\n",
        "rgba_from_string": "pub fn rgba_from_string(str: &str, ok: &mut i16) -> u32 {\n    let mut bool_ok = false;\n    let result = if str.starts_with('#') {\n        rgba_from_hex_string(str[1..].to_string(), ok)\n    } else if str.starts_with(\"rgba\") {\n        rgba_from_rgba_string(str.to_string(), &mut bool_ok)\n    } else if str.starts_with(\"rgb\") {\n        rgba_from_rgb_string(str, &mut bool_ok)\n    } else {\n        rgba_from_name_string(str, &mut bool_ok)\n    };\n    *ok = if bool_ok { 1 } else { 0 };\n    result\n}\n\n",
        "rgba_to_string": "pub fn rgba_to_string(rgba: Rgba, buf: &mut String, len: usize) {\n    if rgba.a == 1.0 {\n        *buf = format!(\"#{:02x}{:02x}{:02x}\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8);\n    } else {\n        *buf = format!(\"rgba({}, {}, {}, {:.2})\", \n            (rgba.r * 255.0) as u8, \n            (rgba.g * 255.0) as u8, \n            (rgba.b * 255.0) as u8, \n            rgba.a);\n    }\n}\n\n",
        "rgba_new": "pub fn rgba_new(rgba: u32) -> Rgba {\n    let mut color = Rgba {\n        r: 0.0,\n        g: 0.0,\n        b: 0.0,\n        a: 0.0,\n    };\n    color.r = (rgba >> 24) as f64 / 255.0;\n    color.g = ((rgba >> 16) & 0xff) as f64 / 255.0;\n    color.b = ((rgba >> 8) & 0xff) as f64 / 255.0;\n    color.a = (rgba & 0xff) as f64 / 255.0;\n    color\n}\n\n"
    },
    "test-rgba": {
        "main": "fn main(){}\n",
        "test_to_string": "pub fn test_to_string() {\n    let mut buf = String::new();\n    let color = rgba_new(0xffcc00ff);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"#ffcc00\", buf);\n\n    let color = rgba_new(0xffcc0050);\n    rgba_to_string(color, &mut buf, 256);\n    assert_eq!(\"rgba(255, 204, 0, 0.31)\", buf);\n}\n\n",
        "extra": "\nuse test_project::rgba::{rgba_new, rgba_from_hex6_string, h, rgba_from_hex_string, rgba_to_string, rgba_from_name_string, rgba_from_rgba_string, rgba_from_rgb_string, rgba_from_hex3_string, rgba_from_rgba, rgba_from_rgb, rgba_from_string, Rgba, NamedColor, NAMED_COLORS};\n",
        "test_rgba": "pub fn test_rgba() {\n    let mut ok: i16 = 0;\n    let mut val = rgba_from_string(\"rgba(255, 30   , 0, .5)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xff1e007f, val);\n\n    val = rgba_from_string(\"rgba(0,0,0, 1)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0x000000ff, val);\n}\n\n",
        "test_hex": "pub fn test_hex() {\n    let mut ok: i16 = 0;\n    let mut val = rgba_from_string(\"#ff1e00\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xff1e00ff, val);\n\n    val = rgba_from_string(\"#ffffff\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xffffffff, val);\n\n    val = rgba_from_string(\"#ffcc00\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xffcc00ff, val);\n\n    val = rgba_from_string(\"#fco\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xffcc00ff, val);\n}\n\n",
        "test_rgb": "pub fn test_rgb() {\n    let mut ok: i16 = 0;\n    let val = rgba_from_string(\"rgb(255, 30   , 0)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0xff1e00ff, val);\n\n    let val = rgba_from_string(\"rgb(0,0,0)\", &mut ok);\n    assert_eq!(ok, 1);\n    assert_eq!(0x000000ff, val);\n}\n\n"
    },
    "urlparser": {
        "ParseURL": "pub fn ParseURL(URL: String, pURL_Parts: &mut URL_PARTS) -> bool {\n    let mut i: usize;\n    let mut c: u8;\n    let mut b: bool = false;\n\n    // Clear the data\n    *pURL_Parts = URL_PARTS {\n        scheme: String::new(),\n        authority: String::new(),\n        port: String::new(),\n        path: String::new(),\n        query: String::new(),\n        fragment: String::new(),\n    };\n\n    // Setup our parser pointer\n    let mut string = URL.as_bytes();\n\n    // Check for the authority preceding double slash\n    let authority = match str::from_utf8(string).unwrap().find(\"//\") {\n        Some(pos) => {\n            let scheme_end = pos;\n            i = 0;\n            while i < scheme_end {\n                c = string[i];\n                if c == b':' || c == b'/' {\n                    break;\n                }\n                if pURL_Parts.scheme.len() == MAX_URL_SCHEME_LEN - 1 {\n                    return false;\n                }\n                pURL_Parts.scheme.push(c as char);\n                i += 1;\n            }\n            &string[pos + 2..]\n        }\n        None => string,\n    };\n\n    c = authority[0];\n    if c == b'[' {\n        b = true;\n        string = &authority[1..];\n    } else {\n        string = authority;\n    }\n\n    // Parse the authority\n    i = 0;\n    while i < string.len() {\n        c = string[i];\n        if c == b' ' {\n            i += 1;\n            continue;\n        }\n        if c == b'/' || c == b'?' || c == b'#' || (c == b':' && !b) {\n            break;\n        }\n        if b && c == b']' {\n            i += 1;\n            break;\n        }\n        if pURL_Parts.authority.len() == MAX_URL_AUTHORITY_LEN - 1 {\n            return false;\n        }\n        pURL_Parts.authority.push(c as char);\n        i += 1;\n    }\n\n    string = &string[i..];\n\n    // Check for a port number\n    if !string.is_empty() && string[0] == b':' {\n        string = &string[1..];\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'/' || c == b'?' || c == b'#' {\n                break;\n            }\n            if pURL_Parts.port.len() == MAX_URL_PORT_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.port.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a path\n    if !string.is_empty() && string[0] == b'/' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'?' || c == b'#' {\n                break;\n            }\n            if pURL_Parts.path.len() == MAX_URL_PATH_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.path.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a query\n    if !string.is_empty() && string[0] == b'?' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'#' {\n                break;\n            }\n            if pURL_Parts.query.len() == MAX_URL_QUERY_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.query.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a fragment\n    if !string.is_empty() && string[0] == b'#' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if pURL_Parts.fragment.len() == MAX_URL_FRAGMENT_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.fragment.push(c as char);\n            i += 1;\n        }\n    }\n\n    true\n}\n\n",
        "extra": "use std::str;\n\npub const MAX_URL_FRAGMENT_LEN: usize = 256;\npub const MAX_URL_SCHEME_LEN: usize = 32;\npub const MAX_URL_PATH_LEN: usize = 1024;\npub const MAX_URL_QUERY_LEN: usize = 1024;\npub const MAX_URL_AUTHORITY_LEN: usize = 512;\npub const MAX_URL_PORT_LEN: usize = 64;\n\npub struct URL_PARTS {\n    pub scheme: String,\n    pub authority: String,\n    pub port: String,\n    pub path: String,\n    pub query: String,\n    pub fragment: String,\n}\n"
    },
    "test-urlparser": {
        "main": "fn main(){}\n",
        "test_parse_url": "pub fn test_parse_url() {\n    let mut url_parts = URL_PARTS {\n        scheme: String::new(),\n        authority: String::new(),\n        port: String::new(),\n        path: String::new(),\n        query: String::new(),\n        fragment: String::new(),\n    };\n\n    // Test case 1: Basic HTTP URL\n    assert!(ParseURL(\"http://sullewarehouse.com/login\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"http\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"\"); // No port specified\n    assert_eq!(url_parts.path, \"/login\");\n    assert_eq!(url_parts.query, \"\"); // No query\n    assert_eq!(url_parts.fragment, \"\"); // No fragment\n\n    // Test case 2: HTTPS URL with port\n    assert!(ParseURL(\"https://sullewarehouse.com:1000/login\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"1000\");\n    assert_eq!(url_parts.path, \"/login\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 3: URL with query parameters\n    assert!(ParseURL(\"https://sullewarehouse.com:1000/api/get?username=myuser\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"1000\");\n    assert_eq!(url_parts.path, \"/api/get\");\n    assert_eq!(url_parts.query, \"?username=myuser\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 4: URL without scheme\n    assert!(ParseURL(\"sullewarehouse.com/register\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"\"); // No scheme\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"\");\n    assert_eq!(url_parts.path, \"/register\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 5: IPv6 URL\n    assert!(ParseURL(\"http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]/newpage\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"http\");\n    assert_eq!(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n    assert_eq!(url_parts.port, \"\");\n    assert_eq!(url_parts.path, \"/newpage\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 6: IPv6 URL with port\n    assert!(ParseURL(\"https://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:2678/blog\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n    assert_eq!(url_parts.port, \"2678\");\n    assert_eq!(url_parts.path, \"/blog\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    println!(\"All tests passed!\");\n}\n\n",
        "extra": "\nuse test_project::urlparser::{ParseURL, URL_PARTS, MAX_URL_FRAGMENT_LEN, MAX_URL_SCHEME_LEN, MAX_URL_PATH_LEN, MAX_URL_QUERY_LEN, MAX_URL_AUTHORITY_LEN, MAX_URL_PORT_LEN};\n"
    },
    "binn": {
        "binn_get_type_info": "pub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval = true;\n    let mut current_type = long_type;\n\n    loop {\n        if current_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if current_type <= 0xff {\n            storage_type = (current_type & BINN_STORAGE_MASK as i32) as i32;\n            extra_type = (current_type & BINN_TYPE_MASK as i32) as i32;\n            break;\n        } else if current_type <= 0xffff {\n            storage_type = (current_type & BINN_STORAGE_MASK16 as i32) as i32;\n            storage_type >>= 8;\n            extra_type = (current_type & BINN_TYPE_MASK16 as i32) as i32;\n            extra_type >>= 4;\n            break;\n        } else if (current_type & BINN_STORAGE_VIRTUAL as i32) != 0 {\n            current_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(storage) = pstorage_type {\n        *storage = storage_type;\n    }\n    if let Some(extra) = pextra_type {\n        *extra = extra_type;\n    }\n\n    retval\n}\n\n",
        "extra": "pub const BINN_TYPE_MASK: u32 = 0x0F;\npub const BINN_STORAGE_MASK: u32 = 0xE0;\npub const BINN_TYPE_MASK16: u32 = 0x0FFF;\npub const BINN_STORAGE_MASK16: u32 = 0xE000;\npub const BINN_STORAGE_VIRTUAL: u32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\npub const BINN_BOOL: i32 = 0x80061;\npub const CHUNK_SIZE: i32 = 256;\npub const BIG_ENDIAN: u32 = 0x1000;\npub const LITTLE_ENDIAN: u32 = 0x0001;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT8: i32 = 0x21;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_STORAGE_BYTE: i32 = 0x20;\npub const INT8_MIN: i64 = -128;\npub const INT16_MIN: i64 = -32768;\npub const INT32_MIN: i64 = -2147483648;\npub const INT8_MAX: i64 = 127;\npub const INT16_MAX: i64 = 32767;\npub const INT32_MAX: i64 = 2147483647;\npub const UINT8_MAX: u64 = 255;\npub const UINT16_MAX: u64 = 65535;\npub const UINT32_MAX: u64 = 4294967295;\npub const BINN_UNSIGNED_INT: i32 = 22;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_STORAGE_BLOB: i32 = 0xC0;\npub const BINN_STORAGE_HAS_MORE: u8 = 0x80;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const MIN_BINN_SIZE: i32 = 3;\npub const MAX_BINN_HEADER: usize = 9;\npub const NULL: i32 = 0;\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_MAGIC: u32 = 0x1F22B11F;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_DOUBLE: i32 = BINN_FLOAT64;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_FAMILY_NULL: i32 = 0xF1;\npub const BINN_FAMILY_FLOAT: i32 = 0xF3;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_FAMILY_BLOB: i32 = 0xF5;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\npub const BINN_FAMILY_INT: i32 = 0xF2;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_OBJECT: i32 = 0xE2;\npub const BINN_SINGLE: i32 = BINN_FLOAT32;\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FAMILY_BOOL: i32 = 0xF6;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_NULL: i32 = 0x00;\npub const BINN_DATETIME: i32 = 0xA1;\npub const BINN_BMP: i32 = 0xD004;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_FAMILY_NONE: i32 = 0x00;\npub const BINN_FAMILY_STRING: i32 = 0xF4;\npub const BINN_FAMILY_BINN: i32 = 0xF7;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\npub const INT64_MIN: i64 = -9223372036854775808;\npub const INT64_MAX: i64 = 9223372036854775807;\n\npub static mut malloc_fn: Option<fn(usize) -> Option<Box<[u8]>>> = None;\npub static mut realloc_fn: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>> = None;\npub static mut free_fn: Option<fn(Option<Box<[u8]>>)> = None;\n\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<fn(Vec<u8>)>,\n    pub vint8: i8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vuint8: u8,\n    pub vuint16: u16,\n    pub vuint32: u32,\n    pub vuint64: u64,\n    pub vchar: i8,\n    pub vuchar: u8,\n    pub vshort: i16,\n    pub vushort: u16,\n    pub vint: i32,\n    pub vuint: u32,\n    pub vfloat: f32,\n    pub vdouble: f64,\n    pub vbool: bool,\n    pub disable_int_compression: bool,\n}\n\nimpl Clone for Binn {\n    fn clone(&self) -> Self {\n        Binn {\n            header: self.header,\n            allocated: self.allocated,\n            writable: self.writable,\n            dirty: self.dirty,\n            pbuf: self.pbuf.clone(),\n            pre_allocated: self.pre_allocated,\n            alloc_size: self.alloc_size,\n            used_size: self.used_size,\n            type_: self.type_,\n            ptr: self.ptr.clone(),\n            size: self.size,\n            count: self.count,\n            freefn: self.freefn,\n            vint8: self.vint8,\n            vint16: self.vint16,\n            vint32: self.vint32,\n            vint64: self.vint64,\n            vuint8: self.vuint8,\n            vuint16: self.vuint16,\n            vuint32: self.vuint32,\n            vuint64: self.vuint64,\n            vchar: self.vchar,\n            vuchar: self.vuchar,\n            vshort: self.vshort,\n            vushort: self.vushort,\n            vint: self.vint,\n            vuint: self.vuint,\n            vfloat: self.vfloat,\n            vdouble: self.vdouble,\n            vbool: self.vbool,\n            disable_int_compression: self.disable_int_compression,\n        }\n    }\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            vint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vuint8: 0,\n            vuint16: 0,\n            vuint32: 0,\n            vuint64: 0,\n            vchar: 0,\n            vuchar: 0,\n            vshort: 0,\n            vushort: 0,\n            vint: 0,\n            vuint: 0,\n            vfloat: 0.0,\n            vdouble: 0.0,\n            vbool: false,\n            disable_int_compression: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.header == 0\n    }\n}\n\npub const BINN_VERSION: &str = \"3.0.0\";\n\npub struct BinnIter {\n    pub pnext: Vec<u8>,\n    pub plimit: Vec<u8>,\n    pub current: i32,\n    pub count: i32,\n    pub type_: i32,\n}\n\nimpl Default for BinnIter {\n    fn default() -> Self {\n        BinnIter {\n            pnext: Vec::new(),\n            plimit: Vec::new(),\n            current: 0,\n            count: 0,\n            type_: 0,\n        }\n    }\n}\n\nimpl BinnIter {\n    pub fn is_null(&self) -> bool {\n        self.pnext.is_empty()\n    }\n}\n\npub const INVALID_BINN: i32 = 0;\npub const BINN_STORAGE_MAX: i32 = BINN_STORAGE_CONTAINER;\npub const BINN_STORAGE_MIN: i32 = BINN_STORAGE_NOBYTES;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "binn_get_write_storage": "pub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n",
        "CalcAllocation": "pub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;\n    }\n    calc_size\n}\n\n",
        "copy_be32": "pub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    *pdest = psource.to_be_bytes();\n}\n\n",
        "check_alloc_functions": "pub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(|size| vec![0u8; size].into_boxed_slice().into());\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(|ptr, size| {\n                let mut new_vec = vec![0u8; size];\n                if let Some(p) = ptr {\n                    let len = std::cmp::min(p.len(), size);\n                    new_vec[..len].copy_from_slice(&p[..len]);\n                }\n                new_vec.into_boxed_slice().into()\n            });\n        }\n        if free_fn.is_none() {\n            free_fn = Some(|_| {});\n        }\n    }\n}\n\n",
        "copy_be16": "pub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    *pdest = psource.to_be_bytes();\n}\n\n",
        "compress_int": "pub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a mut [u8]) -> &'a mut [u8] {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vint = i64::from_le_bytes(buf);\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vint = i32::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_INT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vint = i16::from_le_bytes(buf) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= UINT8_MAX {\n                    type2 = BINN_UINT8;\n                } else if vuint <= UINT16_MAX {\n                    type2 = BINN_UINT16;\n                } else if vuint <= UINT32_MAX {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= INT8_MIN {\n                    type2 = BINN_INT8;\n                } else if vint >= INT16_MIN {\n                    type2 = BINN_INT16;\n                } else if vint >= INT32_MIN {\n                    type2 = BINN_INT32;\n                }\n            }\n        },\n        BINN_UINT64 => {\n            let mut buf = [0u8; 8];\n            buf.copy_from_slice(&psource[..8]);\n            vuint = u64::from_le_bytes(buf);\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT32 => {\n            let mut buf = [0u8; 4];\n            buf.copy_from_slice(&psource[..4]);\n            vuint = u32::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        BINN_UINT16 => {\n            let mut buf = [0u8; 2];\n            buf.copy_from_slice(&psource[..2]);\n            vuint = u16::from_le_bytes(buf) as u64;\n            if vuint <= UINT8_MAX {\n                type2 = BINN_UINT8;\n            } else if vuint <= UINT16_MAX {\n                type2 = BINN_UINT16;\n            } else if vuint <= UINT32_MAX {\n                type2 = BINN_UINT32;\n            }\n        },\n        _ => return psource,\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\n",
        "int_type": "pub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n",
        "AdvanceDataPos": "pub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: usize) -> Option<usize> {\n    if p.len() > plimit {\n        return None;\n    }\n\n    let byte = p[0];\n    let storage_type = byte as i32 & BINN_STORAGE_MASK as i32;\n    let mut pos = 1;\n\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        pos += 1;\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => pos += 1,\n        BINN_STORAGE_WORD => pos += 2,\n        BINN_STORAGE_DWORD => pos += 4,\n        BINN_STORAGE_QWORD => pos += 8,\n        BINN_STORAGE_BLOB => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n        },\n        BINN_STORAGE_STRING => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n                pos += 4;\n            } else {\n                pos += 1;\n            }\n            pos += data_size as usize;\n            pos += 1;\n        },\n        BINN_STORAGE_CONTAINER => {\n            if pos > plimit {\n                return None;\n            }\n            let mut data_size = p[pos] as u32;\n            if data_size & 0x80 != 0 {\n                if pos + 4 - 1 > plimit {\n                    return None;\n                }\n                let size_bytes = u32::from_be_bytes([p[pos], p[pos+1], p[pos+2], p[pos+3]]);\n                data_size = size_bytes & 0x7FFFFFFF;\n            }\n            data_size -= 1;\n            pos += data_size as usize;\n        },\n        _ => return None,\n    }\n\n    if pos > plimit {\n        None\n    } else {\n        Some(pos)\n    }\n}\n\n",
        "binn_save_header": "pub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p = item.pbuf[MAX_BINN_HEADER..].to_vec();\n    let mut size = item.used_size - MAX_BINN_HEADER as i32 + 3;\n\n    if item.count > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (item.count as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = item.count as u8;\n    }\n\n    if size > 127 {\n        p = p[4..].to_vec();\n        size += 3;\n        let int32 = (size as u32) | 0x80000000;\n        let mut dest = [0; 4];\n        copy_be32(&mut dest, &int32);\n        p[..4].copy_from_slice(&dest);\n    } else {\n        p = p[1..].to_vec();\n        p[0] = size as u8;\n    }\n\n    p = p[1..].to_vec();\n    p[0] = item.type_ as u8;\n\n    item.ptr = p;\n    item.size = size;\n    item.dirty = false;\n\n    true\n}\n\n",
        "binn_get_ptr_type": "pub fn binn_get_ptr_type(ptr: Option<&Vec<u8>>) -> i32 {\n    if ptr.is_none() {\n        return 0;\n    }\n    let ptr = ptr.unwrap();\n    if ptr.len() < 4 {\n        return BINN_BUFFER;\n    }\n    let magic = (ptr[0] as u32) << 24 | (ptr[1] as u32) << 16 | (ptr[2] as u32) << 8 | ptr[3] as u32;\n    if magic == BINN_MAGIC {\n        BINN_STRUCT\n    } else {\n        BINN_BUFFER\n    }\n}\n\n",
        "copy_be64": "pub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    *pdest = psource.to_be_bytes();\n}\n\n",
        "IsValidBinnHeader": "pub fn IsValidBinnHeader(pbuf: &[u8], ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = 0;\n    let mut plimit = 0usize;\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < 3 {\n            return false;\n        }\n        plimit = (*psize - 1) as usize;\n    }\n\n    let byte = pbuf[p];\n    p += 1;\n    if (byte & (BINN_STORAGE_MASK as u8)) != (BINN_STORAGE_CONTAINER as u8) {\n        return false;\n    }\n    if (byte & (BINN_STORAGE_HAS_MORE as u8)) != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        0xE0 | 0xE1 | 0xE2 => (),\n        _ => return false,\n    }\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    size = int32;\n\n    if plimit > 0 && p > plimit {\n        return false;\n    }\n    int32 = pbuf[p] as i32;\n    if (int32 & 0x80) != 0 {\n        if plimit > 0 && p + 4 - 1 > plimit {\n            return false;\n        }\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&pbuf[p..p+4]);\n        int32 = i32::from_be_bytes(bytes) & 0x7FFFFFFF;\n        p += 4;\n    } else {\n        p += 1;\n    }\n    count = int32;\n\n    if size < 3 || count < 0 {\n        return false;\n    }\n\n    if *ptype != 0 {\n        *ptype = type_;\n    }\n    if *pcount != 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    if *pheadersize != 0 {\n        *pheadersize = p as i32;\n    }\n    true\n}\n\n",
        "CheckAllocation": "pub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n",
        "strlen2": "pub fn strlen2(str: String) -> usize {\n    if str.is_empty() {\n        return 0;\n    }\n    str.len()\n}\n\n",
        "type_family": "pub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n",
        "read_map_id": "pub fn read_map_id(pp: &mut Vec<u8>, plimit: &u8) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() == 0 || &p[0] > plimit {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() < extra_bytes as usize || &p[extra_bytes as usize - 1] > plimit {\n            *pp = p[extra_bytes as usize..].to_vec();\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n        id = (id << 8) | (p.remove(0) as i32);\n    } else if type_ == 0xE0 {\n        let mut bytes = [0u8; 4];\n        bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(bytes);\n        p.drain(0..4);\n    } else {\n        *pp = vec![];\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n",
        "binn_get_read_storage": "pub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => BINN_STORAGE_QWORD,\n        BINN_BOOL | BINN_TRUE | BINN_FALSE => BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n",
        "copy_raw_value": "pub fn copy_raw_value<T: Copy>(psource: &T, pdest: &mut T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pdest = *psource,\n        BINN_STORAGE_WORD => *pdest = *psource,\n        BINN_STORAGE_DWORD => *pdest = *psource,\n        BINN_STORAGE_QWORD => *pdest = *psource,\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pdest = *psource,\n        _ => return false,\n    }\n    true\n}\n\n",
        "copy_int_value": "pub fn copy_int_value(psource: &dyn std::any::Any, pdest: &mut dyn std::any::Any, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => {\n            if let Some(v) = psource.downcast_ref::<i8>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if let Some(v) = psource.downcast_ref::<i16>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if let Some(v) = psource.downcast_ref::<i32>() {\n                vint64 = *v as i64;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(v) = psource.downcast_ref::<i64>() {\n                vint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if let Some(v) = psource.downcast_ref::<u8>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if let Some(v) = psource.downcast_ref::<u16>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if let Some(v) = psource.downcast_ref::<u32>() {\n                vuint64 = *v as u64;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(v) = psource.downcast_ref::<u64>() {\n                vuint64 = *v;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < INT8_MIN as i64 || vint64 > INT8_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i8>() {\n                *p = vint64 as i8;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT16 => {\n            if vint64 < INT16_MIN as i64 || vint64 > INT16_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i16>() {\n                *p = vint64 as i16;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT32 => {\n            if vint64 < INT32_MIN as i64 || vint64 > INT32_MAX as i64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<i32>() {\n                *p = vint64 as i32;\n            } else {\n                return false;\n            }\n        },\n        BINN_INT64 => {\n            if let Some(p) = pdest.downcast_mut::<i64>() {\n                *p = vint64;\n            } else {\n                return false;\n            }\n        },\n\n        BINN_UINT8 => {\n            if vuint64 > UINT8_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u8>() {\n                *p = vuint64 as u8;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT16 => {\n            if vuint64 > UINT16_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u16>() {\n                *p = vuint64 as u16;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT32 => {\n            if vuint64 > UINT32_MAX as u64 {\n                return false;\n            }\n            if let Some(p) = pdest.downcast_mut::<u32>() {\n                *p = vuint64 as u32;\n            } else {\n                return false;\n            }\n        },\n        BINN_UINT64 => {\n            if let Some(p) = pdest.downcast_mut::<u64>() {\n                *p = vuint64;\n            } else {\n                return false;\n            }\n        },\n\n        _ => return false,\n    }\n\n    true\n}\n\n",
        "copy_float_value": "pub fn copy_float_value(psource: f32, pdest: &mut f64, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = f64::from(psource);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = psource as f64;\n            true\n        }\n        _ => false,\n    }\n}\n\n",
        "SearchForKey": "pub fn SearchForKey(p: &mut Vec<u8>, header_size: usize, size: usize, numitems: usize, key: &str) -> Option<usize> {\n    let base = 0;\n    let plimit = size - 1;\n    let mut pos = header_size;\n    let keylen = key.len();\n\n    for _ in 0..numitems {\n        if pos > plimit {\n            break;\n        }\n        let len = p[pos] as usize;\n        pos += 1;\n        if pos + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if key.len() >= len && key[..len].eq_ignore_ascii_case(&String::from_utf8_lossy(&p[pos..pos+len])) {\n                if keylen == len {\n                    pos += len;\n                    return Some(pos);\n                }\n            }\n            pos += len;\n        } else if keylen == 0 {\n            return Some(pos);\n        }\n        match AdvanceDataPos(&mut p[pos..].to_vec(), plimit - pos) {\n            Some(advance) => pos += advance,\n            None => break,\n        }\n        if pos < base {\n            break;\n        }\n    }\n\n    None\n}\n\n",
        "binn_ptr": "pub fn binn_ptr(ptr: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let item_type = binn_get_ptr_type(ptr);\n    match item_type {\n        BINN_STRUCT => {\n            if let Some(ptr_data) = ptr {\n                let mut item = Binn {\n                    header: 0,\n                    allocated: false,\n                    writable: false,\n                    dirty: false,\n                    pbuf: ptr_data.clone(),\n                    pre_allocated: false,\n                    alloc_size: 0,\n                    used_size: 0,\n                    type_: 0,\n                    ptr: Vec::new(),\n                    size: 0,\n                    count: 0,\n                    freefn: None,\n                    vint8: 0,\n                    vint16: 0,\n                    vint32: 0,\n                    vint64: 0,\n                    vuint8: 0,\n                    vuint16: 0,\n                    vuint32: 0,\n                    vuint64: 0,\n                    vchar: 0,\n                    vuchar: 0,\n                    vshort: 0,\n                    vushort: 0,\n                    vint: 0,\n                    vuint: 0,\n                    vfloat: 0.0,\n                    vdouble: 0.0,\n                    vbool: false,\n                    disable_int_compression: false,\n                };\n                if item.writable && item.dirty {\n                    binn_save_header(&mut item);\n                }\n                Some(item.ptr)\n            } else {\n                None\n            }\n        },\n        BINN_BUFFER => ptr.cloned(),\n        _ => None,\n    }\n}\n\n",
        "GetValue": "pub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let p2 = p.clone();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    if p.len() > plimit.len() {\n        return false;\n    }\n    byte = p.remove(0);\n    storage_type = (byte & (BINN_STORAGE_MASK as u8)) as i32;\n    if (byte & BINN_STORAGE_HAS_MORE) != 0 {\n        data_type = (byte as i32) << 8;\n        if p.len() > plimit.len() {\n            return false;\n        }\n        byte = p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            value.vuint8 = p.remove(0);\n            value.ptr = vec![value.vuint8];\n        },\n        BINN_STORAGE_WORD => {\n            if p.len() + 1 > plimit.len() {\n                return false;\n            }\n            let mut vint16_bytes = [0u8; 2];\n            vint16_bytes.copy_from_slice(&p[..2]);\n            value.vint16 = i16::from_be_bytes(vint16_bytes);\n            p.drain(..2);\n            value.ptr = value.vint16.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_DWORD => {\n            if p.len() + 3 > plimit.len() {\n                return false;\n            }\n            let mut vint32_bytes = [0u8; 4];\n            vint32_bytes.copy_from_slice(&p[..4]);\n            value.vint32 = i32::from_be_bytes(vint32_bytes);\n            p.drain(..4);\n            value.ptr = value.vint32.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_QWORD => {\n            if p.len() + 7 > plimit.len() {\n                return false;\n            }\n            let mut vint64_bytes = [0u8; 8];\n            vint64_bytes.copy_from_slice(&p[..8]);\n            value.vint64 = i64::from_be_bytes(vint64_bytes);\n            p.drain(..8);\n            value.ptr = value.vint64.to_be_bytes().to_vec();\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if p.len() > plimit.len() {\n                return false;\n            }\n            data_size = p.remove(0) as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                data_size_bytes.copy_from_slice(&p[..4]);\n                data_size = i32::from_be_bytes(data_size_bytes) & 0x7FFFFFFF;\n                p.drain(..4);\n            } else {\n                data_size &= 0x7F;\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.drain(..data_size as usize).collect();\n        },\n        BINN_STORAGE_CONTAINER => {\n            let mut count = 0;\n            let mut size = 0;\n            if !IsValidBinnHeader(&p2, &mut 0, &mut count, &mut size, &mut 0) {\n                return false;\n            }\n            value.ptr = p2;\n            value.count = count;\n            value.size = size;\n        },\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![if value.vbool { 1 } else { 0 }];\n        },\n        _ => (),\n    }\n\n    true\n}\n\n",
        "binn_malloc": "pub fn binn_malloc(size: i32) -> Option<Box<[u8]>> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(alloc_fn) = malloc_fn {\n            alloc_fn(size as usize)\n        } else {\n            None\n        }\n    }\n}\n\n",
        "AddValue": "pub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            },\n            _ => return false,\n        }\n    }\n\n    let compressed_value;\n    let mut compressed_pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let mut temp_storage = storage_type;\n        let mut temp_type = type_;\n        let value = pvalue.unwrap().clone();\n        let mut temp_vec = value.to_vec();\n        let compressed = compress_int(&mut temp_storage, &mut temp_type, &mut temp_vec);\n        compressed_value = compressed.to_vec();\n        compressed_pvalue = Some(&compressed_value);\n    }\n\n    let (size, arg_size) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_BYTE => (1, 1),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            (size, size + 4)\n        },\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let actual_size = if size == 0 {\n                strlen2(String::from_utf8(pvalue.unwrap().clone()).unwrap())\n            } else {\n                size as usize\n            };\n            (actual_size as i32, actual_size as i32 + 5)\n        },\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            (size, size)\n        },\n        _ => return false,\n    };\n\n    let arg_size = arg_size + 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n    let mut p_idx = 0;\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &type16);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            p_idx += 2;\n            item.used_size += 2;\n        } else {\n            p[p_idx] = type_ as u8;\n            p_idx += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[p_idx] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        },\n        BINN_STORAGE_WORD => {\n            let val = u16::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1]]);\n            let mut dest = [0u8; 2];\n            copy_be16(&mut dest, &val);\n            p[p_idx..p_idx+2].copy_from_slice(&dest);\n            item.used_size += 2;\n        },\n        BINN_STORAGE_DWORD => {\n            let val = u32::from_be_bytes([pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3]]);\n            let mut dest = [0u8; 4];\n            copy_be32(&mut dest, &val);\n            p[p_idx..p_idx+4].copy_from_slice(&dest);\n            item.used_size += 4;\n        },\n        BINN_STORAGE_QWORD => {\n            let val = u64::from_be_bytes([\n                pvalue.unwrap()[0], pvalue.unwrap()[1], pvalue.unwrap()[2], pvalue.unwrap()[3],\n                pvalue.unwrap()[4], pvalue.unwrap()[5], pvalue.unwrap()[6], pvalue.unwrap()[7],\n            ]);\n            let mut dest = [0u8; 8];\n            copy_be64(&mut dest, &val);\n            p[p_idx..p_idx+8].copy_from_slice(&dest);\n            item.used_size += 8;\n        },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = (size as u32) | 0x80000000;\n                let mut dest = [0u8; 4];\n                copy_be32(&mut dest, &int32);\n                p[p_idx..p_idx+4].copy_from_slice(&dest);\n                p_idx += 4;\n                item.used_size += 4;\n            } else {\n                p[p_idx] = size as u8;\n                p_idx += 1;\n                item.used_size += 1;\n            }\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            if storage_type == BINN_STORAGE_STRING {\n                p[p_idx + size as usize] = 0;\n                item.used_size += size + 1;\n            } else {\n                item.used_size += size;\n            }\n        },\n        BINN_STORAGE_CONTAINER => {\n            p[p_idx..p_idx + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        },\n        _ => return false,\n    }\n\n    item.dirty = true;\n    true\n}\n\n",
        "SearchForID": "pub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = size - 1;\n    let mut p = p.clone();\n    p.drain(0..header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &(plimit as u8));\n        if p.is_empty() || p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, plimit as usize) {\n            Some(new_pos) => {\n                p.drain(0..new_pos);\n                if p.len() < base.len() {\n                    break;\n                }\n            }\n            None => break,\n        }\n    }\n\n    None\n}\n\n",
        "zero_value": "pub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING | BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => (),\n    }\n}\n\n",
        "copy_value": "pub fn copy_value<T: Copy + 'static>(psource: &T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: &dyn std::any::Any = psource;\n        let pdest_wrap: &mut dyn std::any::Any = pdest;\n        copy_int_value(psource_wrap, pdest_wrap, source_type, dest_type)\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        let mut temp_dest = 0.0f64;\n        let result = copy_float_value(*unsafe { &*(psource as *const T as *const f32) }, &mut temp_dest, source_type, dest_type);\n        if result {\n            *pdest = unsafe { std::mem::transmute_copy(&temp_dest) };\n        }\n        result\n    } else {\n        copy_raw_value(psource, pdest, data_store)\n    }\n}\n\n",
        "binn_object_get_value": "pub fn binn_object_get_value(ptr: Option<&Vec<u8>>, key: &str, value: &mut Binn) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_ref.clone();\n    let plimit = p.len() - 1;\n\n    let pos = SearchForKey(&mut p, header_size as usize, size as usize, count as usize, key);\n    if pos.is_none() {\n        return false;\n    }\n\n    let mut p_slice = p[pos.unwrap()..].to_vec();\n    let mut plimit_slice = p[plimit..].to_vec();\n    GetValue(&mut p_slice, &mut plimit_slice, value)\n}\n\n",
        "binn_create": "pub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n    let mut size = size;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(ptr) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = ptr;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if size == 0 { CHUNK_SIZE } else { size };\n        if let Some(allocated) = binn_malloc(alloc_size) {\n            item.pbuf = allocated.to_vec();\n        } else {\n            return false;\n        }\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC as i32;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER as i32;\n    item.type_ = type_;\n    item.dirty = true;\n\n    true\n}\n\n",
        "binn_list_get_value": "pub fn binn_list_get_value(ptr: Option<&Vec<u8>>, pos: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n    if pos <= 0 || pos > count {\n        return false;\n    }\n    let pos = pos - 1;\n\n    let base = ptr_ref.clone();\n    let plimit = base.len().min(size as usize);\n    let mut p = base[header_size as usize..].to_vec();\n\n    for _ in 0..pos {\n        let new_pos = AdvanceDataPos(&mut p, plimit);\n        if new_pos.is_none() {\n            return false;\n        }\n        p = base[new_pos.unwrap()..].to_vec();\n        if p.len() < base.len() {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut base.clone(), value)\n}\n\n",
        "binn_map_set_raw": "pub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    let mut p = SearchForID(&mut item.pbuf, MAX_BINN_HEADER as i32, item.used_size, item.count, id);\n    if p.is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut base = item.used_size as usize;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    let mut id_size = 0;\n    let mut p = item.used_size as usize;\n\n    if id <= 0x3F {\n        item.pbuf[p] = ((sign as u8) << 6) | (id as u8);\n        p += 1;\n        id_size = 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | ((sign as u8) << 4) | (((id & 0xF00) >> 8) as u8);\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 2;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | ((sign as u8) << 4) | (((id & 0xF0000) >> 16) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 3;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | ((sign as u8) << 4) | (((id & 0xF000000) >> 24) as u8);\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n        id_size = 4;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign {\n            id = -id;\n        }\n        let id_bytes = id.to_be_bytes();\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n        id_size = 5;\n    }\n\n    item.used_size += id_size;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size;\n        return false;\n    }\n\n    item.count += 1;\n\n    true\n}\n\n",
        "GetWriteConvertedData": "pub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Box<[u8]>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: [u8; 128] = [0; 128];\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => (),\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {\n                    ()\n                } else {\n                    return false;\n                }\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        BINN_SINGLE => {\n            if let Some(ref mut value) = ppvalue {\n                f1 = f32::from_ne_bytes([value[0], value[1], value[2], value[3]]);\n                d1 = f1 as f64;\n                type_ = BINN_SINGLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_DOUBLE => {\n            if let Some(ref mut value) = ppvalue {\n                d1 = f64::from_ne_bytes([\n                    value[0], value[1], value[2], value[3],\n                    value[4], value[5], value[6], value[7],\n                ]);\n                type_ = BINN_DOUBLE_STR;\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            if let Some(ref mut value) = ppvalue {\n                if value[0] == BINN_FALSE as u8 {\n                    type_ = BINN_FALSE;\n                } else {\n                    type_ = BINN_TRUE;\n                }\n                *ptype = type_;\n            } else {\n                return false;\n            }\n            return true;\n        }\n        BINN_DECIMAL => return true,\n        BINN_CURRENCYSTR => return true,\n        BINN_DATE => return true,\n        BINN_DATETIME => return true,\n        BINN_TIME => return true,\n        _ => (),\n    }\n\n    if type_ == BINN_SINGLE_STR || type_ == BINN_DOUBLE_STR {\n        let formatted = format!(\"{:.17e}\", d1);\n        let bytes = formatted.into_bytes();\n        *ppvalue = Some(bytes.into_boxed_slice());\n        *ptype = type_;\n    }\n\n    true\n}\n\n",
        "binn_list_add_raw": "pub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    let pvalue_vec = pvalue.map(|v| v.to_vec());\n    if !AddValue(item, type_, pvalue_vec.as_ref(), size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n",
        "binn_object_set_raw": "pub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let keylen = key.len();\n    if keylen > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size as usize, item.count as usize, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + keylen as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    let len = keylen as u8;\n    item.pbuf[p] = len;\n    p += 1;\n    item.pbuf[p..p+keylen].copy_from_slice(key.as_bytes());\n    let mut total_size = keylen + 1;\n    item.used_size += total_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= total_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n",
        "binn_buf_size": "pub fn binn_buf_size(pbuf: &[u8]) -> i32 {\n    let mut size = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n    size\n}\n\n",
        "binn_object_get": "pub fn binn_object_get<T: Copy + 'static>(ptr: Option<&Vec<u8>>, key: &str, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool {\n    let mut storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_BLOB || type_family(value.type_) == BINN_FAMILY_STRING {\n        *pvalue = unsafe { std::mem::transmute_copy(&value.ptr) };\n    } else {\n        let temp: T = unsafe { std::ptr::read(value.ptr.as_ptr() as *const T) };\n        if !copy_value(&temp, pvalue, value.type_, type_, storage_type) {\n            return false;\n        }\n    }\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n",
        "binn_new": "pub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Box<Binn>> {\n    let mut item = Box::new(Binn::default());\n    \n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n",
        "binn_list_get": "pub fn binn_list_get<T>(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut T, psize: Option<&mut i32>) -> bool \nwhere\n    T: 'static,\n{\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue as *const _ == std::ptr::null() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT && value.type_ != type_ {\n        let psource_wrap: &dyn std::any::Any = &value.ptr;\n        let pdest_wrap: &mut dyn std::any::Any = pvalue;\n        copy_int_value(psource_wrap, pdest_wrap, value.type_, type_)\n    } else if type_family(value.type_) == BINN_FAMILY_FLOAT && value.type_ != type_ {\n        let mut temp_dest = 0.0f64;\n        let result = if value.type_ == BINN_FLOAT32 {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f32) };\n            copy_float_value(src, &mut temp_dest, value.type_, type_)\n        } else {\n            let src = unsafe { std::ptr::read_unaligned(value.ptr.as_ptr() as *const f64) };\n            copy_float_value(src as f32, &mut temp_dest, value.type_, type_)\n        };\n        if result {\n            unsafe { std::ptr::write(pvalue as *mut T as *mut f64, temp_dest) };\n        }\n        result\n    } else {\n        unsafe {\n            std::ptr::copy_nonoverlapping(value.ptr.as_ptr(), pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n            true\n        }\n    }\n}\n\n",
        "binn_read_pair": "pub fn binn_read_pair(expected_type: i32, ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let ptr = match binn_ptr(ptr) {\n        Some(p) => p,\n        None => return false,\n    };\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr[header_size as usize..].to_vec();\n    let base = ptr.as_ptr() as usize;\n    let plimit = base + size as usize - 1;\n    let mut counter = 0;\n    let mut id = 0;\n    let mut key = Vec::new();\n    let mut len = 0;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let plimit_u8 = (plimit - base) as u8;\n                id = read_map_id(&mut p, &plimit_u8);\n                if p.is_empty() || p.as_ptr() as usize > plimit {\n                    return false;\n                }\n            },\n            BINN_OBJECT => {\n                len = p.remove(0) as usize;\n                if p.len() < len || p.as_ptr() as usize + len > plimit {\n                    return false;\n                }\n                key = p[..len].to_vec();\n                p.drain(..len);\n            },\n            _ => return false,\n        }\n\n        counter += 1;\n        if counter == pos {\n            match type_ {\n                BINN_MAP => {\n                    *pid = id;\n                },\n                BINN_OBJECT => {\n                    if let Ok(s) = String::from_utf8(key) {\n                        *pkey = s;\n                    } else {\n                        return false;\n                    }\n                },\n                _ => return false,\n            }\n\n            let mut plimit_vec = Vec::new();\n            return GetValue(&mut p, &mut plimit_vec, value);\n        }\n\n        match AdvanceDataPos(&mut p, plimit) {\n            Some(new_pos) => p = ptr[new_pos..].to_vec(),\n            None => return false,\n        }\n    }\n\n    false\n}\n\n",
        "binn_map_get_value": "pub fn binn_map_get_value(ptr: Option<&Vec<u8>>, id: i32, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let ptr_val = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr_val, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr_val.clone();\n    let plimit = p.len() - 1;\n\n    let found = SearchForID(&mut p, header_size, size, count, id);\n    if found.is_none() {\n        return false;\n    }\n\n    let mut p_found = found.unwrap();\n    GetValue(&mut p_found, &mut p, value)\n}\n\n",
        "store_value": "pub fn store_value(value: &Binn) -> Vec<u8> {\n    let mut local_value = Binn::default();\n    local_value.header = value.header;\n    local_value.allocated = value.allocated;\n    local_value.writable = value.writable;\n    local_value.dirty = value.dirty;\n    local_value.pbuf = value.pbuf.clone();\n    local_value.pre_allocated = value.pre_allocated;\n    local_value.alloc_size = value.alloc_size;\n    local_value.used_size = value.used_size;\n    local_value.type_ = value.type_;\n    local_value.ptr = value.ptr.clone();\n    local_value.size = value.size;\n    local_value.count = value.count;\n    local_value.freefn = value.freefn;\n    local_value.vint8 = value.vint8;\n    local_value.vint16 = value.vint16;\n    local_value.vint32 = value.vint32;\n    local_value.vint64 = value.vint64;\n    local_value.vuint8 = value.vuint8;\n    local_value.vuint16 = value.vuint16;\n    local_value.vuint32 = value.vuint32;\n    local_value.vuint64 = value.vuint64;\n    local_value.vchar = value.vchar;\n    local_value.vuchar = value.vuchar;\n    local_value.vshort = value.vshort;\n    local_value.vushort = value.vushort;\n    local_value.vint = value.vint;\n    local_value.vuint = value.vuint;\n    local_value.vfloat = value.vfloat;\n    local_value.vdouble = value.vdouble;\n    local_value.vbool = value.vbool;\n    local_value.disable_int_compression = value.disable_int_compression;\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => {\n            let mut result = Vec::new();\n            result.extend_from_slice(&local_value.vint32.to_le_bytes());\n            result\n        }\n        _ => value.ptr.clone()\n    }\n}\n\n",
        "binn_map_set": "pub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n",
        "binn_list_add": "pub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = pvalue.map(|v| v.clone().into_boxed_slice());\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    let pvalue_ref = pvalue_mut.as_ref().map(|v| v.as_ref());\n    binn_list_add_raw(list, type_mut, pvalue_ref, size_mut)\n}\n\n",
        "binn_object_set": "pub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n\n    if !GetWriteConvertedData(&mut type_, &mut pvalue.map(|v| v.clone().into_boxed_slice()), &mut size) {\n        return false;\n    }\n\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n",
        "binn_is_valid_ex2": "pub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = 0;\n    let base = 0;\n    let plimit = ptr.len() - 1;\n    p += header_size as usize;\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p > plimit {\n                    return false;\n                }\n                let len = ptr[p] as usize;\n                p += 1;\n                p += len;\n            }\n            BINN_MAP => {\n                let mut p_slice = ptr[p..].to_vec();\n                let plimit_slice = ptr[plimit];\n                if read_map_id(&mut p_slice, &plimit_slice) == 0 {\n                    return false;\n                }\n                p += p_slice.len();\n            }\n            BINN_LIST => {}\n            _ => return false,\n        }\n\n        if p > plimit {\n            return false;\n        }\n\n        if (ptr[p] & (BINN_STORAGE_MASK as u8)) == (BINN_STORAGE_CONTAINER as u8) {\n            let size2 = plimit - p + 1;\n            let mut dummy_type = 0;\n            let mut dummy_count = 0;\n            let mut dummy_size = size2 as i32;\n            if !binn_is_valid_ex2(&ptr[p..].to_vec(), &mut dummy_type, &mut dummy_count, &mut dummy_size) {\n                return false;\n            }\n            p += dummy_size as usize;\n        } else {\n            match AdvanceDataPos(&mut ptr[p..].to_vec(), plimit) {\n                Some(new_p) => p += new_p,\n                None => return false,\n            }\n            if p < base {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    if *psize != 0 {\n        *psize = size;\n    }\n    true\n}\n\n",
        "binn_size": "pub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match binn_get_ptr_type(ptr.map(|p| &p.ptr)) {\n        BINN_STRUCT => {\n            let mut item = ptr.unwrap().clone();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            item.size\n        }\n        BINN_BUFFER => binn_buf_size(&ptr.unwrap().ptr),\n        _ => 0,\n    }\n}\n\n",
        "binn_object_str": "pub fn binn_object_str(obj: Option<&Vec<u8>>, key: &str) -> String {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return String::new();\n    }\n    if value.type_ != BINN_STRING {\n        return String::new();\n    }\n    String::from_utf8_lossy(&value.ptr).into_owned()\n}\n\n",
        "binn_object": "pub fn binn_object() -> Option<Box<Binn>> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n",
        "binn_is_valid_ex": "pub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n",
        "binn_map_get_pair": "pub fn binn_map_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    let mut key = String::new();\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut key, value)\n}\n\n",
        "binn_free": "pub fn binn_free(mut item: Option<Box<Binn>>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.take().unwrap();\n\n    if item.writable && !item.pre_allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.clone().into_boxed_slice();\n            free(Some(slice));\n        }\n    }\n\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr.clone());\n    }\n\n    if item.allocated {\n        if let Some(free) = unsafe { free_fn } {\n            let slice = item.pbuf.into_boxed_slice();\n            free(Some(slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n}\n\n",
        "binn_map": "pub fn binn_map() -> Option<Box<Binn>> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n",
        "binn_object_read": "pub fn binn_object_read<T>(obj: Option<&Vec<u8>>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n",
        "binn_list_read": "pub fn binn_list_read(list: Option<&Vec<u8>>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n",
        "binn_list": "pub fn binn_list() -> Option<Box<Binn>> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n",
        "binn_map_read": "pub fn binn_map_read(map: Option<&Vec<u8>>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    Some(store_value(&value))\n}\n\n",
        "binn_map_set_int32": "pub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    let bytes = value.to_le_bytes().to_vec();\n    binn_map_set(map, id, BINN_INT32, Some(&bytes), 0)\n}\n\n",
        "binn_object_set_int32": "pub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    binn_object_set(obj, key, BINN_INT32, Some(&vec![value as u8]), 0)\n}\n\n",
        "binn_list_add_int32": "pub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    binn_list_add(list, BINN_INT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_set_bool": "pub fn binn_map_set_bool(map: &mut Binn, id: i32, value: bool) -> bool {\n    let value = if value { BINN_TRUE } else { BINN_FALSE };\n    binn_map_set(map, id, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n",
        "binn_list_add_double": "pub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    binn_list_add(list, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_object_set_bool": "pub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    binn_object_set(obj, key, BINN_BOOL, Some(&vec![value as u8]), 0)\n}\n\n",
        "binn_object_set_double": "pub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    binn_object_set(obj, key, BINN_FLOAT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_set_double": "pub fn binn_map_set_double(map: &mut Binn, id: i32, value: f64) -> bool {\n    binn_map_set(map, id, BINN_FLOAT64, Some(&value.to_le_bytes().to_vec()), 0)\n}\n\n",
        "binn_list_add_bool": "pub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    binn_list_add(list, BINN_BOOL, Some(&vec![if value { BINN_TRUE as u8 } else { BINN_FALSE as u8 }]), 0)\n}\n\n",
        "binn_list_get_int32": "pub fn binn_list_get_int32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i32) -> bool {\n    binn_list_get(list, pos, BINN_INT32, pvalue, None)\n}\n\n",
        "binn_list_blob": "pub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n    if value.type_ != BINN_BLOB {\n        return None;\n    }\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    Some(value.ptr)\n}\n\n",
        "binn_map_set_str": "pub fn binn_map_set_str(map: &mut Binn, id: i32, str: String) -> bool {\n    binn_map_set(map, id, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n",
        "binn_list_add_str": "pub fn binn_list_add_str(list: &mut Binn, str: String) -> bool {\n    binn_list_add(list, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n",
        "binn_list_add_blob": "pub fn binn_list_add_blob(list: &mut Binn, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_list_add(list, BINN_BLOB, ptr, size)\n}\n\n",
        "binn_object_set_blob": "pub fn binn_object_set_blob(obj: &mut Binn, key: &str, ptr: Vec<u8>, size: i32) -> bool {\n    binn_object_set(obj, key, BINN_BLOB, Some(&ptr), size)\n}\n\n",
        "binn_object_set_str": "pub fn binn_object_set_str(obj: &mut Binn, key: &str, str: String) -> bool {\n    binn_object_set(obj, key, BINN_STRING, Some(&str.into_bytes()), 0)\n}\n\n",
        "binn_map_set_blob": "pub fn binn_map_set_blob(map: &mut Binn, id: i32, ptr: Option<&Vec<u8>>, size: i32) -> bool {\n    binn_map_set(map, id, BINN_BLOB, ptr, size)\n}\n\n",
        "binn_version": "pub fn binn_version() -> String {\n    BINN_VERSION.to_string()\n}\n\n",
        "binn_alloc_item": "pub fn binn_alloc_item() -> Option<Binn> {\n    let mut item = Binn::default();\n    item.header = BINN_MAGIC as i32;\n    item.allocated = true;\n    Some(item)\n}\n\n",
        "binn_memdup": "pub fn binn_memdup(src: &[u8], size: i32) -> Option<Vec<u8>> {\n    if src.is_empty() || size <= 0 {\n        return None;\n    }\n    let mut dest = binn_malloc(size)?.to_vec();\n    dest[..size as usize].copy_from_slice(&src[..size as usize]);\n    Some(dest)\n}\n\n",
        "binn_read_next_pair": "pub fn binn_read_next_pair(expected_type: i32, iter: &mut BinnIter, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let mut int32: i32;\n    let mut id: i32;\n    let mut p: Vec<u8>;\n    let mut key: Vec<u8>;\n    let mut len: u16;\n\n    if iter.pnext.is_empty() || iter.pnext.len() > iter.plimit.len() || iter.current > iter.count || iter.type_ != expected_type {\n        return false;\n    }\n\n    iter.current += 1;\n    if iter.current > iter.count {\n        return false;\n    }\n\n    p = iter.pnext.clone();\n    let p_len = p.len();\n\n    let result = match expected_type {\n        BINN_MAP => {\n            int32 = read_map_id(&mut p, &iter.plimit[0]);\n            if p.len() > iter.plimit.len() {\n                return false;\n            }\n            id = int32;\n            if pid != &mut 0 {\n                *pid = id;\n            }\n            true\n        },\n        BINN_OBJECT => {\n            len = p.remove(0) as u16;\n            key = p.drain(..len as usize).collect();\n            if p.len() > iter.plimit.len() {\n                return false;\n            }\n            if !pkey.is_empty() {\n                *pkey = String::from_utf8(key).unwrap();\n            }\n            true\n        },\n        _ => false,\n    };\n\n    if !result {\n        return false;\n    }\n\n    let new_pos = match AdvanceDataPos(&mut p, iter.plimit.len()) {\n        Some(pos) => pos,\n        None => return false,\n    };\n\n    let mut p_clone = p.clone();\n    iter.pnext = p;\n    if !iter.pnext.is_empty() && iter.pnext.len() < p_len {\n        return false;\n    }\n\n    GetValue(&mut p_clone, &mut iter.plimit, value)\n}\n\n",
        "is_integer": "pub fn is_integer(p: String) -> bool {\n    let mut retval = true;\n\n    if p.is_empty() {\n        return false;\n    }\n\n    let mut chars = p.chars();\n    if let Some(c) = chars.next() {\n        if c == '-' {\n            if chars.next().is_none() {\n                return false;\n            }\n        }\n    }\n\n    for c in chars {\n        if !c.is_ascii_digit() {\n            retval = false;\n        }\n    }\n\n    retval\n}\n\n",
        "atoi64": "pub fn atoi64(str: String) -> i64 {\n    let mut retval: i64 = 0;\n    let mut is_negative = false;\n    let mut chars = str.chars();\n\n    if let Some('-') = chars.next() {\n        is_negative = true;\n    } else {\n        chars = str.chars();\n    }\n\n    for c in chars {\n        if c.is_digit(10) {\n            retval = 10 * retval + c.to_digit(10).unwrap() as i64;\n        }\n    }\n\n    if is_negative {\n        retval *= -1;\n    }\n\n    retval\n}\n\n",
        "is_float": "pub fn is_float(p: &str) -> bool {\n    let mut number_found = false;\n    let mut retval = true;\n    let mut chars = p.chars();\n    \n    if p.is_empty() {\n        return false;\n    }\n    \n    let mut first_char = chars.next().unwrap();\n    if first_char == '-' {\n        if let Some(c) = chars.next() {\n            first_char = c;\n        } else {\n            return false;\n        }\n    }\n    \n    for c in chars {\n        if c == '.' || c == ',' {\n            if !number_found {\n                retval = false;\n            }\n        } else if c >= '0' && c <= '9' {\n            number_found = true;\n        } else {\n            return false;\n        }\n    }\n    \n    retval\n}\n\n",
        "binn_buf_type": "pub fn binn_buf_type(pbuf: &[u8]) -> i32 {\n    let mut type_ = 0;\n    if !IsValidBinnHeader(pbuf, &mut type_, &mut 0, &mut 0, &mut 0) {\n        return INVALID_BINN;\n    }\n    type_\n}\n\n",
        "binn_is_valid": "pub fn binn_is_valid(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    if ptype as *mut _ != std::ptr::null_mut() {\n        *ptype = 0;\n    }\n    if pcount as *mut _ != std::ptr::null_mut() {\n        *pcount = 0;\n    }\n    if psize as *mut _ != std::ptr::null_mut() {\n        *psize = 0;\n    }\n\n    binn_is_valid_ex(ptr, ptype, pcount, psize)\n}\n\n",
        "binn_value": "pub fn binn_value(type_: i32, pvalue: &Vec<u8>, size: i32, freefn: Option<fn(Vec<u8>)>) -> Option<Binn> {\n    let mut storage_type = 0;\n    let mut item = binn_alloc_item()?;\n    item.type_ = type_;\n    binn_get_type_info(type_, Some(&mut storage_type), None);\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_STRING => {\n            let mut adjusted_size = size;\n            if size == 0 {\n                adjusted_size = pvalue.len() as i32 + 1;\n            }\n            if freefn.is_none() {\n                item.ptr = binn_memdup(pvalue, adjusted_size)?;\n                item.freefn = Some(|v| {});\n                if storage_type == BINN_STORAGE_STRING {\n                    adjusted_size -= 1;\n                }\n            } else {\n                item.ptr = pvalue.clone();\n                item.freefn = freefn;\n            }\n            item.size = adjusted_size;\n        }\n        BINN_STORAGE_BLOB | BINN_STORAGE_CONTAINER => {\n            if freefn.is_none() {\n                item.ptr = binn_memdup(pvalue, size)?;\n                item.freefn = Some(|v| {});\n            } else {\n                item.ptr = pvalue.clone();\n                item.freefn = freefn;\n            }\n            item.size = size;\n        }\n        _ => {\n            item.ptr = Vec::new();\n            if pvalue.len() > 0 {\n                item.ptr.extend_from_slice(pvalue);\n            }\n        }\n    }\n    Some(item)\n}\n\n",
        "binn_map_get": "pub fn binn_map_get<T>(ptr: Option<&Vec<u8>>, id: i32, type_: i32, pvalue: &mut T, psize: &mut i32) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && std::mem::size_of_val(pvalue) == 0 {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_map_get_value(ptr, id, &mut value) {\n        return false;\n    }\n\n    let mut temp_value = value.ptr[0];\n    let temp_copy = temp_value;\n    if !copy_value(&temp_copy, &mut temp_value, value.type_, type_, storage_type) {\n        return false;\n    }\n\n    unsafe {\n        std::ptr::copy_nonoverlapping(&temp_value as *const u8, pvalue as *mut T as *mut u8, std::mem::size_of::<T>());\n    }\n\n    *psize = value.size;\n\n    true\n}\n\n",
        "binn_object_next": "pub fn binn_object_next(iter: &mut BinnIter, pkey: &mut String, value: &mut Binn) -> bool {\n    binn_read_next_pair(BINN_OBJECT, iter, &mut 0, pkey, value)\n}\n\n",
        "is_bool_str": "pub fn is_bool_str(str: String, pbool: &mut bool) -> bool {\n    let mut vint: i64;\n    let mut vdouble: f64;\n\n    if str.is_empty() {\n        return false;\n    }\n\n    if str.eq_ignore_ascii_case(\"true\") {\n        *pbool = true;\n        return true;\n    }\n    if str.eq_ignore_ascii_case(\"yes\") {\n        *pbool = true;\n        return true;\n    }\n    if str.eq_ignore_ascii_case(\"on\") {\n        *pbool = true;\n        return true;\n    }\n\n    if str.eq_ignore_ascii_case(\"false\") {\n        *pbool = false;\n        return true;\n    }\n    if str.eq_ignore_ascii_case(\"no\") {\n        *pbool = false;\n        return true;\n    }\n    if str.eq_ignore_ascii_case(\"off\") {\n        *pbool = false;\n        return true;\n    }\n\n    if is_integer(str.clone()) {\n        vint = atoi64(str);\n        *pbool = vint != 0;\n        true\n    } else {\n        let s = str.as_str();\n        if is_float(s) {\n            vdouble = s.parse::<f64>().unwrap();\n            *pbool = vdouble != 0.0;\n            true\n        } else {\n            false\n        }\n    }\n}\n\n",
        "binn_map_next": "pub fn binn_map_next(iter: &mut BinnIter, pid: &mut i32, value: &mut Binn) -> bool {\n    binn_read_next_pair(BINN_MAP, iter, pid, &mut String::new(), value)\n}\n\n",
        "binn_type": "pub fn binn_type(ptr: Option<&Vec<u8>>) -> i32 {\n    match binn_get_ptr_type(ptr) {\n        BINN_STRUCT => {\n            let item = ptr.unwrap();\n            if item.len() > 4 {\n                let type_byte = item[4];\n                type_byte as i32\n            } else {\n                -1\n            }\n        }\n        BINN_BUFFER => binn_buf_type(ptr.unwrap()),\n        _ => -1,\n    }\n}\n\n",
        "binn_load": "pub fn binn_load(data: &Vec<u8>, value: &mut Binn) -> bool {\n    if data.is_empty() || value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    if !binn_is_valid(data, &mut type_, &mut count, &mut size) {\n        return false;\n    }\n    value.type_ = type_;\n    value.count = count;\n    value.size = size;\n    value.ptr = data.clone();\n    true\n}\n\n",
        "binn_object_get_pair": "pub fn binn_object_get_pair(ptr: Option<&Vec<u8>>, pos: i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let mut dummy_id = 0;\n    binn_read_pair(BINN_OBJECT, ptr, pos, &mut dummy_id, pkey, value)\n}\n\n",
        "binn_map_set_value": "pub fn binn_map_set_value(map: &mut Binn, id: i32, value: &Binn) -> bool {\n    let ptr = value.ptr.clone();\n    binn_map_set(map, id, value.type_, Some(&ptr), binn_size(Some(value)))\n}\n\n",
        "binn_list_next": "pub fn binn_list_next(iter: &mut BinnIter, value: &mut Binn) -> bool {\n    let mut pnow: Vec<u8>;\n\n    if iter.is_null() || iter.pnext.is_empty() || iter.pnext > iter.plimit || iter.current > iter.count || iter.type_ != BINN_LIST {\n        return false;\n    }\n\n    iter.current += 1;\n    if iter.current > iter.count {\n        return false;\n    }\n\n    pnow = iter.pnext.clone();\n    if let Some(pos) = AdvanceDataPos(&mut pnow, iter.plimit.len()) {\n        iter.pnext = pnow[pos..].to_vec();\n    } else {\n        return false;\n    }\n\n    GetValue(&mut pnow, &mut iter.plimit, value)\n}\n\n",
        "binn_buf_count": "pub fn binn_buf_count(pbuf: &[u8]) -> i32 {\n    let mut nitems = 0;\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut nitems, &mut 0, &mut 0) {\n        return 0;\n    }\n    nitems\n}\n\n",
        "binn_object_set_value": "pub fn binn_object_set_value(obj: &mut Binn, key: &str, value: &Binn) -> bool {\n    let ptr = value.ptr.as_ref();\n    binn_object_set(obj, key, value.type_, Some(ptr), binn_size(Some(value)))\n}\n\n",
        "binn_load_ex": "pub fn binn_load_ex(data: &Vec<u8>, size: i32, value: &mut Binn) -> bool {\n    if data.is_empty() || size <= 0 {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC as i32;\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = size;\n    if !binn_is_valid_ex(data, &mut type_, &mut count, &mut size) {\n        return false;\n    }\n    value.type_ = type_;\n    value.count = count;\n    value.ptr = data.clone();\n    value.size = size;\n    true\n}\n\n",
        "binn_list_add_value": "pub fn binn_list_add_value(list: &mut Binn, value: &Binn) -> bool {\n    binn_list_add(list, value.type_, binn_ptr(Some(&value.ptr)).as_ref(), binn_size(Some(value)))\n}\n\n",
        "binn_is_struct": "pub fn binn_is_struct(ptr: &Vec<u8>) -> bool {\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if ptr.len() >= 4 && u32::from_le_bytes([ptr[0], ptr[1], ptr[2], ptr[3]]) == BINN_MAGIC {\n        true\n    } else {\n        false\n    }\n}\n\n",
        "binn_create_type": "pub fn binn_create_type(storage_type: i32, data_type_index: i32) -> i32 {\n  if data_type_index < 0 { return -1; }\n  if storage_type < BINN_STORAGE_MIN || storage_type > BINN_STORAGE_MAX { return -1; }\n  if data_type_index < 16 {\n    return storage_type | data_type_index;\n  } else if data_type_index < 4096 {\n    let mut storage_type = storage_type | (BINN_STORAGE_HAS_MORE as i32);\n    storage_type <<= 8;\n    let data_type_index = data_type_index >> 4;\n    return storage_type | data_type_index;\n  } else {\n    return -1;\n  }\n}\n\n",
        "binn_set_alloc_functions": "pub fn binn_set_alloc_functions(new_malloc: Option<fn(usize) -> Option<Box<[u8]>>>, new_realloc: Option<fn(Option<Box<[u8]>>, usize) -> Option<Box<[u8]>>>, new_free: Option<fn(Option<Box<[u8]>>)>) {\n    unsafe {\n        malloc_fn = new_malloc;\n        realloc_fn = new_realloc;\n        free_fn = new_free;\n    }\n}\n\n",
        "binn_is_container": "pub fn binn_is_container(item: Option<&Binn>) -> bool {\n    if item.is_none() {\n        return false;\n    }\n    let item = item.unwrap();\n    match item.type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => true,\n        _ => false,\n    }\n}\n\n",
        "binn_int64": "pub fn binn_int64(value: i64) -> Option<Binn> {\n    binn_value(BINN_INT64, &value.to_ne_bytes().to_vec(), 0, None)\n}\n\n",
        "binn_map_get_uint16": "pub fn binn_map_get_uint16(map: Option<&Vec<u8>>, id: i32, pvalue: &mut u16) -> bool {\n    let mut size = 0;\n    binn_map_get(map, id, BINN_UINT16, pvalue, &mut size)\n}\n\n",
        "binn_map_set_list": "pub fn binn_map_set_list(map: &mut Binn, id: i32, list: Option<&Binn>) -> bool {\n    let ptr = list.map(|x| &x.ptr);\n    binn_map_set(map, id, BINN_LIST, ptr, binn_size(list))\n}\n\n",
        "binn_object_set_int8": "pub fn binn_object_set_int8(obj: &mut Binn, key: &str, value: i8) -> bool {\n    binn_object_set(obj, key, BINN_INT8, Some(&vec![value as u8]), 0)\n}\n\n",
        "binn_list_add_null": "pub fn binn_list_add_null(list: &mut Binn) -> bool {\n    binn_list_add(list, BINN_NULL, None, 0)\n}\n\n",
        "binn_object_get_int64": "pub fn binn_object_get_int64(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut i64) -> bool {\n    binn_object_get(obj, key, BINN_INT64, pvalue, None)\n}\n\n",
        "binn_double": "pub fn binn_double(value: f64) -> Option<Binn> {\n    let value_bytes = value.to_ne_bytes().to_vec();\n    binn_value(BINN_DOUBLE, &value_bytes, 0, None)\n}\n\n",
        "binn_object_get_map": "pub fn binn_object_get_map(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut Option<Vec<u8>>) -> bool {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return false;\n    }\n    *pvalue = Some(value.ptr);\n    true\n}\n\n",
        "binn_map_get_float": "pub fn binn_map_get_float(map: Option<&Vec<u8>>, id: i32, pvalue: &mut f32) -> bool {\n    binn_map_get(map, id, BINN_FLOAT32, pvalue, &mut 0)\n}\n\n",
        "binn_object_get_uint32": "pub fn binn_object_get_uint32(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut u32) -> bool {\n    binn_object_get(obj, key, BINN_UINT32, pvalue, None)\n}\n\n",
        "binn_null": "pub fn binn_null() -> Option<Binn> {\n    binn_value(BINN_NULL, &Vec::new(), 0, None)\n}\n\n",
        "binn_map_get_int32": "pub fn binn_map_get_int32(map: Option<&Vec<u8>>, id: i32, pvalue: &mut i32) -> bool {\n    binn_map_get(map, id, BINN_INT32, pvalue, &mut 0)\n}\n\n",
        "binn_object_set_int64": "pub fn binn_object_set_int64(obj: &mut Binn, key: &str, value: i64) -> bool {\n    binn_object_set(obj, key, BINN_INT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_get_blob": "pub fn binn_map_get_blob<T: Copy + 'static>(ptr: Option<&Vec<u8>>, id: i32, pvalue: &mut T, psize: &mut i32) -> bool {\n    binn_map_get(ptr, id, BINN_BLOB, pvalue, psize)\n}\n\n",
        "binn_map_set_int64": "pub fn binn_map_set_int64(map: &mut Binn, id: i32, value: i64) -> bool {\n    binn_map_set(map, id, BINN_INT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_get_object": "pub fn binn_map_get_object<T: Copy + Default + 'static>(map: Option<&Vec<u8>>, id: i32, pvalue: &mut Option<Vec<T>>) -> bool {\n    let mut temp = T::default();\n    let mut size = 0;\n    let result = binn_map_get(map, id, BINN_OBJECT, &mut temp, &mut size);\n    if result {\n        *pvalue = Some(vec![temp]);\n    }\n    result\n}\n\n",
        "binn_uint32": "pub fn binn_uint32(value: u32) -> Option<Binn> {\n    binn_value(BINN_UINT32, &value.to_ne_bytes().to_vec(), 0, None)\n}\n\n",
        "binn_object_set_uint64": "pub fn binn_object_set_uint64(obj: &mut Binn, key: &str, value: u64) -> bool {\n    binn_object_set(obj, key, BINN_UINT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_list_add_uint32": "pub fn binn_list_add_uint32(list: &mut Binn, value: u32) -> bool {\n    binn_list_add(list, BINN_UINT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_object_get_int32": "pub fn binn_object_get_int32(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut i32) -> bool {\n    binn_object_get(obj, key, BINN_INT32, pvalue, None)\n}\n\n",
        "binn_object_get_int16": "pub fn binn_object_get_int16(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut i16) -> bool {\n    binn_object_get(obj, key, BINN_INT16, pvalue, None)\n}\n\n",
        "binn_map_get_bool": "pub fn binn_map_get_bool(map: Option<&Vec<u8>>, id: i32, pvalue: &mut bool) -> bool {\n    binn_map_get(map, id, BINN_BOOL, pvalue, &mut 0)\n}\n\n",
        "binn_list_add_int64": "pub fn binn_list_add_int64(list: &mut Binn, value: i64) -> bool {\n    binn_list_add(list, BINN_INT64, Some(&vec![value.to_be_bytes().to_vec()].concat()), 0)\n}\n\n",
        "binn_list_add_int8": "pub fn binn_list_add_int8(list: &mut Binn, value: i8) -> bool {\n    binn_list_add(list, BINN_INT8, Some(&vec![value as u8]), 0)\n}\n\n",
        "binn_uint16": "pub fn binn_uint16(value: u16) -> Option<Binn> {\n    binn_value(BINN_UINT16, &value.to_be_bytes().to_vec(), 0, None)\n}\n\n",
        "binn_list_get_float": "pub fn binn_list_get_float(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut f32) -> bool {\n    binn_list_get(list, pos, BINN_FLOAT32, pvalue, None)\n}\n\n",
        "binn_object_get_str": "pub fn binn_object_get_str(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut String) -> bool {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return false;\n    }\n    if value.type_ != BINN_STRING {\n        return false;\n    }\n    *pvalue = String::from_utf8_lossy(&value.ptr).into_owned();\n    true\n}\n\n",
        "binn_list_get_object": "pub fn binn_list_get_object(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut Option<Vec<u8>>) -> bool {\n    let mut temp = Vec::new();\n    let result = binn_list_get_value(list, pos, &mut Binn {\n        ptr: temp.clone(),\n        ..Default::default()\n    });\n    if result {\n        *pvalue = Some(temp);\n    }\n    result\n}\n\n",
        "binn_string": "pub fn binn_string(str: String, freefn: Option<fn(Vec<u8>)>) -> Option<Binn> {\n    binn_value(BINN_STRING, &str.into_bytes(), 0, freefn)\n}\n\n",
        "binn_map_get_str": "pub fn binn_map_get_str(map: Option<&Vec<u8>>, id: i32, pvalue: &mut String) -> bool {\n    let mut size = 0;\n    let mut temp = String::new();\n    let result = binn_map_get(map, id, BINN_STRING, &mut temp, &mut size);\n    if result {\n        *pvalue = temp;\n    }\n    result\n}\n\n",
        "binn_int8": "pub fn binn_int8(value: i8) -> Option<Binn> {\n    binn_value(BINN_INT8, &value.to_be_bytes().to_vec(), 0, None)\n}\n\n",
        "binn_list_get_int8": "pub fn binn_list_get_int8(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i8) -> bool {\n    binn_list_get(list, pos, BINN_INT8, pvalue, None)\n}\n\n",
        "binn_object_set_uint16": "pub fn binn_object_set_uint16(obj: &mut Binn, key: &str, value: u16) -> bool {\n    binn_object_set(obj, key, BINN_UINT16, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_get_map": "pub fn binn_map_get_map(ptr: Option<&Vec<u8>>, id: i32, pvalue: &mut Option<Vec<u8>>) -> bool {\n    let mut size = 0;\n    binn_map_get(ptr, id, BINN_MAP, pvalue, &mut size)\n}\n\n",
        "binn_object_set_list": "pub fn binn_object_set_list(obj: &mut Binn, key: &str, list: &Binn) -> bool {\n    let ptr = binn_ptr(Some(&list.ptr));\n    binn_object_set(obj, key, BINN_LIST, ptr.as_ref(), binn_size(Some(list)))\n}\n\n",
        "binn_map_set_map": "pub fn binn_map_set_map(map: &mut Binn, id: i32, map2: Option<&Binn>) -> bool {\n    let ptr = map2.map(|m| &m.ptr);\n    binn_map_set(map, id, BINN_MAP, ptr, binn_size(map2))\n}\n\n",
        "binn_bool": "pub fn binn_bool(value: bool) -> Option<Binn> {\n    let bytes = if value { [1u8] } else { [0u8] };\n    binn_value(BINN_BOOL, &bytes.to_vec(), 0, None)\n}\n\n",
        "binn_blob": "pub fn binn_blob(ptr: Vec<u8>, size: i32, freefn: Option<fn(Vec<u8>)>) -> Option<Binn> {\n    binn_value(BINN_BLOB, &ptr, size, freefn)\n}\n\n",
        "binn_object_get_uint8": "pub fn binn_object_get_uint8(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut u8) -> bool {\n    binn_object_get(obj, key, BINN_UINT8, pvalue, None)\n}\n\n",
        "binn_map_set_float": "pub fn binn_map_set_float(map: &mut Binn, id: i32, value: f32) -> bool {\n    binn_map_set(map, id, BINN_FLOAT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_set_null": "pub fn binn_map_set_null(map: &mut Binn, id: i32) -> bool {\n    binn_map_set(map, id, BINN_NULL, None, 0)\n}\n\n",
        "binn_object_get_object": "pub fn binn_object_get_object(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut Option<Vec<u8>>) -> bool {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return false;\n    }\n    *pvalue = Some(value.ptr);\n    true\n}\n\n",
        "binn_list_get_bool": "pub fn binn_list_get_bool(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut bool) -> bool {\n    binn_list_get(list, pos, BINN_BOOL, pvalue, None)\n}\n\n",
        "binn_uint64": "pub fn binn_uint64(value: u64) -> Option<Binn> {\n    binn_value(BINN_UINT64, &value.to_ne_bytes().to_vec(), 0, None)\n}\n\n",
        "binn_list_add_int16": "pub fn binn_list_add_int16(list: &mut Binn, value: i16) -> bool {\n    binn_list_add(list, BINN_INT16, Some(&vec![value as u8, (value >> 8) as u8]), 0)\n}\n\n",
        "binn_list_add_uint64": "pub fn binn_list_add_uint64(list: &mut Binn, value: u64) -> bool {\n    binn_list_add(list, BINN_UINT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_get_int64": "pub fn binn_map_get_int64(map: Option<&Vec<u8>>, id: i32, pvalue: &mut i64) -> bool {\n    let mut size = 0;\n    binn_map_get(map, id, BINN_INT64, pvalue, &mut size)\n}\n\n",
        "binn_object_get_list": "pub fn binn_object_get_list<T>(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut Option<Vec<T>>) -> bool {\n    let mut temp = Binn::default();\n    if !binn_object_get_value(obj, key, &mut temp) {\n        return false;\n    }\n    if temp.type_ != BINN_LIST {\n        return false;\n    }\n    *pvalue = Some(temp.ptr.chunks(std::mem::size_of::<T>()).map(|chunk| {\n        unsafe { std::ptr::read(chunk.as_ptr() as *const T) }\n    }).collect());\n    true\n}\n\n",
        "binn_object_get_uint16": "pub fn binn_object_get_uint16(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut u16) -> bool {\n    binn_object_get(obj, key, BINN_UINT16, pvalue, None)\n}\n\n",
        "binn_object_get_float": "pub fn binn_object_get_float(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut f32) -> bool {\n    binn_object_get(obj, key, BINN_FLOAT32, pvalue, None)\n}\n\n",
        "binn_map_set_uint32": "pub fn binn_map_set_uint32(map: &mut Binn, id: i32, value: u32) -> bool {\n    binn_map_set(map, id, BINN_UINT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_object_set_object": "pub fn binn_object_set_object(obj: &mut Binn, key: &str, obj2: Option<&Binn>) -> bool {\n    let ptr = obj2.map(|o| &o.ptr);\n    binn_object_set(obj, key, BINN_OBJECT, ptr, binn_size(obj2))\n}\n\n",
        "binn_list_add_uint8": "pub fn binn_list_add_uint8(list: &mut Binn, value: u8) -> bool {\n    let value_vec = vec![value];\n    binn_list_add(list, BINN_UINT8, Some(&value_vec), 0)\n}\n\n",
        "binn_list_get_uint64": "pub fn binn_list_get_uint64(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut u64) -> bool {\n    binn_list_get(list, pos, BINN_UINT64, pvalue, None)\n}\n\n",
        "binn_object_set_map": "pub fn binn_object_set_map(obj: &mut Binn, key: &str, map: Option<&Binn>) -> bool {\n    let ptr = match map {\n        Some(m) => Some(&m.ptr),\n        None => None\n    };\n    binn_object_set(obj, key, BINN_MAP, ptr, binn_size(map))\n}\n\n",
        "binn_list_get_list": "pub fn binn_list_get_list(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut Option<Vec<u8>>) -> bool {\n    let mut temp = [0u8; std::mem::size_of::<Vec<u8>>()];\n    let result = binn_list_get(list, pos, BINN_LIST, &mut temp, None);\n    if result {\n        *pvalue = Some(temp.to_vec());\n    }\n    result\n}\n\n",
        "binn_list_get_str": "pub fn binn_list_get_str(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut Option<String>) -> bool {\n    let mut temp: [u8; 256] = [0; 256];\n    let result = binn_list_get(list, pos, BINN_STRING, &mut temp, None);\n    if result {\n        *pvalue = Some(String::from_utf8_lossy(&temp).trim_end_matches('\\0').to_string());\n    }\n    result\n}\n\n",
        "binn_object_set_uint8": "pub fn binn_object_set_uint8(obj: &mut Binn, key: &str, value: u8) -> bool {\n    binn_object_set(obj, key, BINN_UINT8, Some(&vec![value]), 0)\n}\n\n",
        "binn_object_get_double": "pub fn binn_object_get_double(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut f64) -> bool {\n    binn_object_get(obj, key, BINN_FLOAT64, pvalue, None)\n}\n\n",
        "binn_int16": "pub fn binn_int16(value: i16) -> Option<Binn> {\n    binn_value(BINN_INT16, &value.to_ne_bytes().to_vec(), 0, None)\n}\n\n",
        "binn_object_set_uint32": "pub fn binn_object_set_uint32(obj: &mut Binn, key: &str, value: u32) -> bool {\n    binn_object_set(obj, key, BINN_UINT32, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_object_set_null": "pub fn binn_object_set_null(obj: &mut Binn, key: &str) -> bool {\n    binn_object_set(obj, key, BINN_NULL, None, 0)\n}\n\n",
        "binn_list_add_map": "pub fn binn_list_add_map(list: &mut Binn, map: Option<&Binn>) -> bool {\n    binn_list_add(list, BINN_MAP, binn_ptr(map.map(|m| &m.ptr)).as_ref(), binn_size(map))\n}\n\n",
        "binn_list_get_int64": "pub fn binn_list_get_int64(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i64) -> bool {\n    binn_list_get(list, pos, BINN_INT64, pvalue, None)\n}\n\n",
        "binn_list_get_int16": "pub fn binn_list_get_int16(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut i16) -> bool {\n    binn_list_get(list, pos, BINN_INT16, pvalue, None)\n}\n\n",
        "binn_list_get_blob": "pub fn binn_list_get_blob(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut Vec<u8>, psize: &mut i32) -> bool {\n    let mut value = Binn::default();\n    let result = binn_list_get_value(list, pos, &mut value);\n    if result {\n        *pvalue = value.ptr;\n        *psize = value.size;\n    }\n    result\n}\n\n",
        "binn_list_add_float": "pub fn binn_list_add_float(list: &mut Binn, value: f32) -> bool {\n    binn_list_add(list, BINN_FLOAT32, Some(&vec![value.to_le_bytes().to_vec()].concat()), 0)\n}\n\n",
        "binn_list_get_double": "pub fn binn_list_get_double(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut f64) -> bool {\n    binn_list_get(list, pos, BINN_FLOAT64, pvalue, None)\n}\n\n",
        "binn_list_add_uint16": "pub fn binn_list_add_uint16(list: &mut Binn, value: u16) -> bool {\n    binn_list_add(list, BINN_UINT16, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_object_get_bool": "pub fn binn_object_get_bool(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut bool) -> bool {\n    binn_object_get(obj, key, BINN_BOOL, pvalue, None)\n}\n\n",
        "binn_list_get_uint32": "pub fn binn_list_get_uint32(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut u32) -> bool {\n    binn_list_get(list, pos, BINN_UINT32, pvalue, None)\n}\n\n",
        "binn_map_set_uint64": "pub fn binn_map_set_uint64(map: &mut Binn, id: i32, value: u64) -> bool {\n    binn_map_set(map, id, BINN_UINT64, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_object_get_int8": "pub fn binn_object_get_int8(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut i8) -> bool {\n    binn_object_get(obj, key, BINN_INT8, pvalue, None)\n}\n\n",
        "binn_int32": "pub fn binn_int32(value: i32) -> Option<Binn> {\n    binn_value(BINN_INT32, &vec![], 0, None)\n}\n\n",
        "binn_map_get_int16": "pub fn binn_map_get_int16(map: Option<&Vec<u8>>, id: i32, pvalue: &mut i16) -> bool {\n    binn_map_get(map, id, BINN_INT16, pvalue, &mut 0)\n}\n\n",
        "binn_uint8": "pub fn binn_uint8(value: u8) -> Option<Binn> {\n    binn_value(BINN_UINT8, &vec![value], 0, None)\n}\n\n",
        "binn_map_get_uint8": "pub fn binn_map_get_uint8(map: Option<&Vec<u8>>, id: i32, pvalue: &mut u8) -> bool {\n    binn_map_get(map, id, BINN_UINT8, pvalue, &mut 0)\n}\n\n",
        "binn_object_set_float": "pub fn binn_object_set_float(obj: &mut Binn, key: &str, value: f32) -> bool {\n    let bytes = value.to_le_bytes();\n    binn_object_set(obj, key, BINN_FLOAT32, Some(&bytes.to_vec()), 0)\n}\n\n",
        "binn_object_get_uint64": "pub fn binn_object_get_uint64(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut u64) -> bool {\n    binn_object_get(obj, key, BINN_UINT64, pvalue, None)\n}\n\n",
        "binn_list_get_map": "pub fn binn_list_get_map(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut Option<Vec<u8>>) -> bool {\n    let mut value = Binn {\n        ptr: Vec::new(),\n        type_: BINN_MAP,\n        ..Default::default()\n    };\n    let result = binn_list_get_value(list, pos, &mut value);\n    if result {\n        *pvalue = Some(value.ptr);\n    }\n    result\n}\n\n",
        "binn_map_get_list": "pub fn binn_map_get_list<T>(map: Option<&Vec<u8>>, id: i32, pvalue: &mut T) -> bool {\n    binn_map_get(map, id, BINN_LIST, pvalue, &mut 0)\n}\n\n",
        "binn_map_get_double": "pub fn binn_map_get_double(map: Option<&Vec<u8>>, id: i32, pvalue: &mut f64) -> bool {\n    binn_map_get(map, id, BINN_FLOAT64, pvalue, &mut 0)\n}\n\n",
        "binn_map_set_uint16": "pub fn binn_map_set_uint16(map: &mut Binn, id: i32, value: u16) -> bool {\n    binn_map_set(map, id, BINN_UINT16, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_map_set_uint8": "pub fn binn_map_set_uint8(map: &mut Binn, id: i32, value: u8) -> bool {\n    binn_map_set(map, id, BINN_UINT8, Some(&vec![value]), 0)\n}\n\n",
        "binn_list_get_uint16": "pub fn binn_list_get_uint16(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut u16) -> bool {\n    binn_list_get(list, pos, BINN_UINT16, pvalue, None)\n}\n\n",
        "binn_map_set_int8": "pub fn binn_map_set_int8(map: &mut Binn, id: i32, value: i8) -> bool {\n    binn_map_set(map, id, BINN_INT8, Some(&vec![value as u8]), 0)\n}\n\n",
        "binn_list_get_uint8": "pub fn binn_list_get_uint8(list: Option<&Vec<u8>>, pos: i32, pvalue: &mut u8) -> bool {\n    binn_list_get(list, pos, BINN_UINT8, pvalue, None)\n}\n\n",
        "binn_object_get_blob": "pub fn binn_object_get_blob(obj: Option<&Vec<u8>>, key: &str, pvalue: &mut Option<Vec<u8>>, psize: Option<&mut i32>) -> bool {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return false;\n    }\n    \n    if value.type_ != BINN_BLOB {\n        return false;\n    }\n    \n    *pvalue = Some(value.ptr);\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n    true\n}\n\n",
        "binn_map_get_uint32": "pub fn binn_map_get_uint32(map: Option<&Vec<u8>>, id: i32, pvalue: &mut u32) -> bool {\n    let mut size = 0;\n    binn_map_get(map, id, BINN_UINT32, pvalue, &mut size)\n}\n\n",
        "binn_float": "pub fn binn_float(value: f32) -> Option<Binn> {\n    binn_value(BINN_FLOAT32, &value.to_ne_bytes().to_vec(), 0, None)\n}\n\n",
        "binn_map_set_object": "pub fn binn_map_set_object(map: &mut Binn, id: i32, obj: Option<&Binn>) -> bool {\n    binn_map_set(map, id, BINN_OBJECT, binn_ptr(obj.map(|o| &o.ptr)).as_ref(), binn_size(obj))\n}\n\n",
        "binn_list_add_list": "pub fn binn_list_add_list(list: &mut Binn, list2: Option<&Binn>) -> bool {\n    binn_list_add(list, BINN_LIST, binn_ptr(list2.map(|l| &l.ptr)).as_ref(), binn_size(list2))\n}\n\n",
        "binn_list_add_object": "pub fn binn_list_add_object(list: &mut Binn, obj: Option<&Binn>) -> bool {\n    binn_list_add(list, BINN_OBJECT, binn_ptr(obj.map(|o| &o.ptr)).as_ref(), binn_size(obj))\n}\n\n",
        "binn_map_set_int16": "pub fn binn_map_set_int16(map: &mut Binn, id: i32, value: i16) -> bool {\n    binn_map_set(map, id, BINN_INT16, Some(&value.to_be_bytes().to_vec()), 0)\n}\n\n",
        "binn_object_set_int16": "pub fn binn_object_set_int16(obj: &mut Binn, key: &str, value: i16) -> bool {\n    binn_object_set(obj, key, BINN_INT16, Some(&vec![value as u8]), 0)\n}\n\n",
        "binn_map_get_uint64": "pub fn binn_map_get_uint64(map: Option<&Vec<u8>>, id: i32, pvalue: &mut u64) -> bool {\n    binn_map_get(map, id, BINN_UINT64, pvalue, &mut 0)\n}\n\n",
        "binn_map_get_int8": "pub fn binn_map_get_int8(map: Option<&Vec<u8>>, id: i32, pvalue: &mut i8) -> bool {\n    binn_map_get(map, id, BINN_INT8, pvalue, &mut 0)\n}\n\n",
        "binn_object_next_value": "pub fn binn_object_next_value(iter: &mut BinnIter, pkey: &mut String) -> Option<Binn> {\n    let mut value = Binn::default();\n    if !binn_object_next(iter, pkey, &mut value) {\n        None\n    } else {\n        value.allocated = true;\n        Some(value)\n    }\n}\n\n",
        "binn_list_int16": "pub fn binn_list_int16(list: Option<&Vec<u8>>, pos: i32) -> i16 {\n    let mut value: i16 = 0;\n    binn_list_get(list, pos, BINN_INT16, &mut value, None);\n    value\n}\n\n",
        "binn_list_uint32": "pub fn binn_list_uint32(list: Option<&Vec<u8>>, pos: i32) -> u32 {\n    let mut value: u32 = 0;\n    binn_list_get(list, pos, BINN_UINT32, &mut value, None);\n    value\n}\n\n",
        "binn_list_map": "pub fn binn_list_map(list: Option<&Vec<u8>>, pos: i32) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if binn_list_get_value(list, pos, &mut value) {\n        Some(value.ptr)\n    } else {\n        None\n    }\n}\n\n",
        "binn_map_blob": "pub fn binn_map_blob(map: Option<&Vec<u8>>, id: i32, psize: &mut i32) -> Option<Vec<u8>> {\n    let mut value = Vec::new();\n    if !binn_map_get(map, id, BINN_BLOB, &mut value, psize) {\n        None\n    } else {\n        Some(value)\n    }\n}\n\n",
        "binn_list_value": "pub fn binn_list_value(ptr: Option<&Vec<u8>>, pos: i32) -> Option<Binn> {\n    let mut value = Binn::default();\n    \n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return None;\n    }\n\n    value.allocated = true;\n    Some(value)\n}\n\n",
        "binn_get_int32": "pub fn binn_get_int32(value: &Binn, pint: &mut i32) -> bool {\n    if value.is_null() {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT {\n        return copy_int_value(&value.ptr, pint, value.type_, BINN_INT32);\n    }\n\n    match value.type_ {\n        BINN_FLOAT32 => {\n            if value.vfloat < (INT32_MIN as f32) || value.vfloat > (INT32_MAX as f32) {\n                return false;\n            }\n            *pint = (value.vfloat + 0.5) as i32;\n            true\n        }\n        BINN_FLOAT64 => {\n            if value.vdouble < (INT32_MIN as f64) || value.vdouble > (INT32_MAX as f64) {\n                return false;\n            }\n            *pint = (value.vdouble + 0.5) as i32;\n            true\n        }\n        BINN_STRING => {\n            let s = String::from_utf8_lossy(&value.ptr).into_owned();\n            if is_integer(s.clone()) {\n                *pint = s.parse::<i32>().unwrap_or(0);\n                true\n            } else if is_float(&s) {\n                *pint = (s.parse::<f64>().unwrap_or(0.0) + 0.5) as i32;\n                true\n            } else {\n                false\n            }\n        }\n        BINN_BOOL => {\n            *pint = if value.vbool { 1 } else { 0 };\n            true\n        }\n        _ => false,\n    }\n}\n\n",
        "binn_list_uint8": "pub fn binn_list_uint8(list: Option<&Vec<u8>>, pos: i32) -> u8 {\n    let mut value: u8 = 0;\n    binn_list_get(list, pos, BINN_UINT8, &mut value, None);\n    value\n}\n\n",
        "binn_list_double": "pub fn binn_list_double(list: Option<&Vec<u8>>, pos: i32) -> f64 {\n    let mut value: f64 = 0.0;\n    binn_list_get(list, pos, BINN_FLOAT64, &mut value, None);\n    value\n}\n\n",
        "binn_get_bool": "pub fn binn_get_bool(value: &Binn, pbool: &mut bool) -> bool {\n    let mut vint: i64 = 0;\n\n    if value.is_null() {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT {\n        if !copy_int_value(&value.ptr, &mut vint, value.type_, BINN_INT64) {\n            return false;\n        }\n        *pbool = vint != 0;\n        return true;\n    }\n\n    match value.type_ {\n        BINN_BOOL => {\n            *pbool = value.vbool;\n        }\n        BINN_FLOAT => {\n            *pbool = value.vfloat != 0.0;\n        }\n        BINN_DOUBLE => {\n            *pbool = value.vdouble != 0.0;\n        }\n        BINN_STRING => {\n            let s = String::from_utf8_lossy(&value.ptr).into_owned();\n            return is_bool_str(s, pbool);\n        }\n        _ => {\n            return false;\n        }\n    }\n\n    true\n}\n\n",
        "binn_map_bool": "pub fn binn_map_bool(map: Option<&Vec<u8>>, id: i32) -> bool {\n    let mut value = false;\n    binn_map_get(map, id, BINN_BOOL, &mut value, &mut 0);\n    value\n}\n\n",
        "binn_map_uint16": "pub fn binn_map_uint16(map: Option<&Vec<u8>>, id: i32) -> u16 {\n    let mut value: u16 = 0;\n    let mut size = 0;\n    binn_map_get(map, id, BINN_UINT16, &mut value, &mut size);\n    value\n}\n\n",
        "binn_object_null": "pub fn binn_object_null(obj: Option<&Vec<u8>>, key: &str) -> bool {\n    binn_object_get(obj, key, BINN_NULL, &mut 0, None)\n}\n\n",
        "binn_object_uint32": "pub fn binn_object_uint32(obj: Option<&Vec<u8>>, key: &str) -> u32 {\n    let mut value: u32 = 0;\n    binn_object_get(obj, key, BINN_UINT32, &mut value, None);\n    value\n}\n\n",
        "binn_set_blob": "pub fn binn_set_blob(mut item: Binn, ptr: Vec<u8>, size: i32, pfree: Option<fn(Vec<u8>)>) -> bool {\n    if item.is_null() || ptr.is_empty() {\n        return false;\n    }\n\n    if pfree.is_none() {\n        item.ptr = binn_memdup(&ptr, size).unwrap_or_default();\n        if item.ptr.is_empty() {\n            return false;\n        }\n        item.freefn = Some(|_| {});\n    } else {\n        item.ptr = ptr;\n        item.freefn = pfree;\n    }\n\n    item.type_ = BINN_BLOB;\n    item.size = size;\n    true\n}\n\n",
        "binn_map_uint32": "pub fn binn_map_uint32(map: Option<&Vec<u8>>, id: i32) -> u32 {\n    let mut value: u32 = 0;\n    binn_map_get(map, id, BINN_UINT32, &mut value, &mut 0);\n    value\n}\n\n",
        "binn_map_int32": "pub fn binn_map_int32(map: Option<&Vec<u8>>, id: i32) -> i32 {\n    let mut value = 0;\n    binn_map_get(map, id, BINN_INT32, &mut value, &mut 0);\n    value\n}\n\n",
        "binn_map_float": "pub fn binn_map_float(map: Option<&Vec<u8>>, id: i32) -> f32 {\n    let mut value: f32 = 0.0;\n    binn_map_get(map, id, BINN_FLOAT32, &mut value, &mut 0);\n    value\n}\n\n",
        "binn_list_int8": "pub fn binn_list_int8(list: Option<&Vec<u8>>, pos: i32) -> i8 {\n    let mut value: i8 = 0;\n    binn_list_get(list, pos, BINN_INT8, &mut value, None);\n    value\n}\n\n",
        "binn_list_null": "pub fn binn_list_null(list: Option<&Vec<u8>>, pos: i32) -> bool {\n    binn_list_get::<i32>(list, pos, BINN_NULL, &mut 0, None)\n}\n\n",
        "binn_list_str": "pub fn binn_list_str(list: Option<&Vec<u8>>, pos: i32) -> String {\n    let mut value = String::new();\n    unsafe {\n        binn_list_get(list, pos, BINN_STRING, &mut value, None);\n    }\n    value\n}\n\n",
        "binn_map_read_pair": "pub fn binn_map_read_pair(ptr: Option<&Vec<u8>>, pos: i32, pid: &mut i32, ptype: &mut i32, psize: &mut i32) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_map_get_pair(ptr, pos, pid, &mut value) {\n        return None;\n    }\n    if *ptype != NULL {\n        *ptype = value.type_;\n    }\n    if *psize != NULL {\n        *psize = value.size;\n    }\n    if cfg!(target_endian = \"little\") {\n        Some(store_value(&value))\n    } else {\n        None\n    }\n}\n\n",
        "binn_object_double": "pub fn binn_object_double(obj: Option<&Vec<u8>>, key: &str) -> f64 {\n    let mut value = 0.0;\n    binn_object_get(obj, key, BINN_FLOAT64, &mut value, None);\n    value\n}\n\n",
        "binn_map_read_next": "pub fn binn_map_read_next(iter: &mut BinnIter, pid: &mut i32, ptype: &mut i32, psize: &mut i32) -> Vec<u8> {\n    let mut value = Binn::default();\n    if !binn_map_next(iter, pid, &mut value) {\n        return Vec::new();\n    }\n    if *ptype != NULL {\n        *ptype = value.type_;\n    }\n    if *psize != NULL {\n        *psize = value.size;\n    }\n    store_value(&value)\n}\n\n",
        "binn_create_list": "pub fn binn_create_list(list: &mut Binn) -> bool {\n    binn_create(list, BINN_LIST, 0, None)\n}\n\n",
        "binn_object_uint64": "pub fn binn_object_uint64(obj: Option<&Vec<u8>>, key: &str) -> u64 {\n    let mut value: u64 = 0;\n    binn_object_get(obj, key, BINN_UINT64, &mut value, None);\n    value\n}\n\n",
        "binn_object_int64": "pub fn binn_object_int64(obj: Option<&Vec<u8>>, key: &str) -> i64 {\n    let mut value: i64 = 0;\n    binn_object_get(obj, key, BINN_INT64, &mut value, None);\n    value\n}\n\n",
        "binn_object_int16": "pub fn binn_object_int16(obj: Option<&Vec<u8>>, key: &str) -> i16 {\n    let mut value: i16 = 0;\n    binn_object_get(obj, key, BINN_INT16, &mut value, None);\n    value\n}\n\n",
        "binn_object_uint16": "pub fn binn_object_uint16(obj: Option<&Vec<u8>>, key: &str) -> u16 {\n    let mut value: u16 = 0;\n    binn_object_get(obj, key, BINN_UINT16, &mut value, None);\n    value\n}\n\n",
        "binn_iter_init": "pub fn binn_iter_init(iter: &mut BinnIter, ptr: Option<&Vec<u8>>, expected_type: i32) -> bool {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = if let Some(p) = binn_ptr(ptr) {\n        p\n    } else {\n        return false;\n    };\n\n    if iter.is_null() {\n        return false;\n    }\n\n    *iter = BinnIter::default();\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type {\n        return false;\n    }\n\n    iter.plimit = ptr.clone();\n    iter.plimit.truncate(size as usize - 1);\n    iter.pnext = ptr.clone();\n    iter.pnext.drain(0..header_size as usize);\n    iter.count = count;\n    iter.current = 0;\n    iter.type_ = type_;\n\n    true\n}\n\n",
        "binn_add_value": "pub fn binn_add_value(item: &mut Binn, binn_type: i32, id: i32, name: &str, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    match binn_type {\n        BINN_LIST => binn_list_add(item, type_, pvalue, size),\n        BINN_MAP => binn_map_set(item, id, type_, pvalue, size),\n        BINN_OBJECT => binn_object_set(item, name, type_, pvalue, size),\n        _ => false,\n    }\n}\n\n",
        "binn_get_int64": "pub fn binn_get_int64(value: &Binn, pint: &mut i64) -> bool {\n    if value.is_null() {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT {\n        return copy_int_value(&value.ptr, pint, value.type_, BINN_INT64);\n    }\n\n    match value.type_ {\n        BINN_FLOAT32 => {\n            if value.vfloat < (INT64_MIN as f32) || value.vfloat > (INT64_MAX as f32) {\n                return false;\n            }\n            *pint = if value.vfloat >= 0.0 {\n                (value.vfloat + 0.5) as i64\n            } else {\n                if (value.vfloat - (value.vfloat as i64 as f32)) <= -0.5 {\n                    value.vfloat as i64\n                } else {\n                    (value.vfloat - 0.5) as i64\n                }\n            };\n            true\n        }\n        BINN_FLOAT64 => {\n            if value.vdouble < (INT64_MIN as f64) || value.vdouble > (INT64_MAX as f64) {\n                return false;\n            }\n            *pint = if value.vdouble >= 0.0 {\n                (value.vdouble + 0.5) as i64\n            } else {\n                if (value.vdouble - (value.vdouble as i64 as f64)) <= -0.5 {\n                    value.vdouble as i64\n                } else {\n                    (value.vdouble - 0.5) as i64\n                }\n            };\n            true\n        }\n        BINN_STRING => {\n            let s = String::from_utf8(value.ptr.clone()).unwrap_or_default();\n            if is_integer(s.clone()) {\n                *pint = atoi64(s);\n                true\n            } else if is_float(&s) {\n                *pint = if let Ok(f) = s.parse::<f64>() {\n                    if f >= 0.0 {\n                        (f + 0.5) as i64\n                    } else {\n                        if (f - (f as i64 as f64)) <= -0.5 {\n                            f as i64\n                        } else {\n                            (f - 0.5) as i64\n                        }\n                    }\n                } else {\n                    0\n                };\n                true\n            } else {\n                false\n            }\n        }\n        BINN_BOOL => {\n            *pint = if value.vbool { 1 } else { 0 };\n            true\n        }\n        _ => false,\n    }\n}\n\n",
        "binn_get_double": "pub fn binn_get_double(value: &Binn, pfloat: &mut f64) -> bool {\n    let mut vint: i64 = 0;\n\n    if value.is_null() {\n        return false;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT {\n        if !copy_int_value(&value.ptr, &mut vint, value.type_, BINN_INT64) {\n            return false;\n        }\n        *pfloat = vint as f64;\n        return true;\n    }\n\n    match value.type_ {\n        BINN_FLOAT32 => {\n            *pfloat = value.vfloat as f64;\n        }\n        BINN_FLOAT64 => {\n            *pfloat = value.vdouble;\n        }\n        BINN_STRING => {\n            if is_integer(String::from_utf8(value.ptr.clone()).unwrap()) {\n                *pfloat = atoi64(String::from_utf8(value.ptr.clone()).unwrap()) as f64;\n            } else if is_float(&String::from_utf8(value.ptr.clone()).unwrap()) {\n                *pfloat = String::from_utf8(value.ptr.clone())\n                    .unwrap()\n                    .parse::<f64>()\n                    .unwrap();\n            } else {\n                return false;\n            }\n        }\n        BINN_BOOL => {\n            *pfloat = value.vbool as i32 as f64;\n        }\n        _ => {\n            return false;\n        }\n    }\n\n    true\n}\n\n",
        "binn_object_bool": "pub fn binn_object_bool(obj: Option<&Vec<u8>>, key: &str) -> bool {\n    let mut value = false;\n    binn_object_get(obj, key, BINN_BOOL, &mut value, None);\n    value\n}\n\n",
        "binn_open": "pub fn binn_open(data: &Vec<u8>) -> Option<Binn> {\n    let mut item = Binn::default();\n    if !binn_load(data, &mut item) {\n        return None;\n    }\n    item.allocated = true;\n    Some(item)\n}\n\n",
        "binn_list_object": "pub fn binn_list_object(list: Option<&Vec<u8>>, pos: i32) -> Option<Vec<u8>> {\n    let mut value = Vec::new();\n    if !binn_list_get(list, pos, BINN_OBJECT, &mut value, None) {\n        None\n    } else {\n        Some(value)\n    }\n}\n\n",
        "binn_copy": "pub fn binn_copy(old: Option<&Vec<u8>>) -> Option<Box<Binn>> {\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    let old_ptr = binn_ptr(old)?;\n    let old_ptr_clone = old_ptr.clone();\n\n    if !IsValidBinnHeader(&old_ptr_clone, &mut type_, &mut count, &mut size, &mut header_size) {\n        return None;\n    }\n\n    let mut item = binn_new(type_, size - header_size + MAX_BINN_HEADER as i32, None)?;\n    let dest_start = MAX_BINN_HEADER;\n    let dest_end = dest_start + (size - header_size) as usize;\n    \n    item.pbuf[dest_start..dest_end].copy_from_slice(&old_ptr[header_size as usize..(header_size + size) as usize]);\n    item.used_size = MAX_BINN_HEADER as i32 + size - header_size;\n    item.count = count;\n\n    Some(item)\n}\n\n",
        "binn_map_map": "pub fn binn_map_map(map: Option<&Vec<u8>>, id: i32) -> Option<Vec<u8>> {\n    let mut value = Vec::new();\n    let mut size = 0;\n    if !binn_map_get(map, id, BINN_MAP, &mut value, &mut size) {\n        None\n    } else {\n        Some(value)\n    }\n}\n\n",
        "binn_object_map": "pub fn binn_object_map(obj: Option<&Vec<u8>>, key: &str) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        None\n    } else {\n        Some(value.ptr)\n    }\n}\n\n",
        "binn_map_int16": "pub fn binn_map_int16(map: Option<&Vec<u8>>, id: i32) -> i16 {\n    let mut value: i16 = 0;\n    let mut psize: i32 = 0;\n    binn_map_get(map, id, BINN_INT16, &mut value, &mut psize);\n    value\n}\n\n",
        "binn_map_null": "pub fn binn_map_null(map: Option<&Vec<u8>>, id: i32) -> bool {\n    let mut pvalue: i32 = 0;\n    let mut psize: i32 = 0;\n    binn_map_get(map, id, BINN_NULL, &mut pvalue, &mut psize)\n}\n\n",
        "binn_list_uint16": "pub fn binn_list_uint16(list: Option<&Vec<u8>>, pos: i32) -> u16 {\n    let mut value: u16 = 0;\n    binn_list_get(list, pos, BINN_UINT16, &mut value, None);\n    value\n}\n\n",
        "binn_map_str": "pub fn binn_map_str(map: Option<&Vec<u8>>, id: i32) -> Option<String> {\n    let mut value = String::new();\n    let mut size = 0;\n    if binn_map_get(map, id, BINN_STRING, &mut value, &mut size) {\n        Some(value)\n    } else {\n        None\n    }\n}\n\n",
        "binn_object_read_pair": "pub fn binn_object_read_pair(ptr: Option<&Vec<u8>>, pos: i32, pkey: &mut String, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_object_get_pair(ptr, pos, pkey, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n",
        "binn_map_next_value": "pub fn binn_map_next_value(iter: &mut BinnIter, pid: &mut i32) -> Option<Binn> {\n    let mut value = Binn::default();\n    if !binn_map_next(iter, pid, &mut value) {\n        return None;\n    }\n    value.allocated = true;\n    Some(value)\n}\n\n",
        "binn_map_pair": "pub fn binn_map_pair(map: Option<&Vec<u8>>, pos: i32, pid: &mut i32) -> Option<Binn> {\n    let mut value = Binn::default();\n\n    if !binn_read_pair(BINN_MAP, map, pos, pid, &mut String::new(), &mut value) {\n        return None;\n    }\n\n    value.allocated = true;\n    Some(value)\n}\n\n",
        "binn_get_str": "pub fn binn_get_str(value: &mut Binn) -> Option<String> {\n    let mut vint: i64 = 0;\n    let mut buf: String = String::with_capacity(128);\n\n    if value.is_null() {\n        return None;\n    }\n\n    if type_family(value.type_) == BINN_FAMILY_INT {\n        if !copy_int_value(&value.ptr, &mut vint, value.type_, BINN_INT64) {\n            return None;\n        }\n        buf = vint.to_string();\n        return Some(buf);\n    }\n\n    match value.type_ {\n        BINN_FLOAT => {\n            value.vdouble = value.vfloat as f64;\n            buf = value.vdouble.to_string();\n            Some(buf)\n        }\n        BINN_DOUBLE => {\n            buf = value.vdouble.to_string();\n            Some(buf)\n        }\n        BINN_STRING => {\n            Some(String::from_utf8_lossy(&value.ptr).into_owned())\n        }\n        BINN_BOOL => {\n            if value.vbool {\n                Some(\"true\".to_string())\n            } else {\n                Some(\"false\".to_string())\n            }\n        }\n        _ => None,\n    }\n}\n\n",
        "binn_object_value": "pub fn binn_object_value(ptr: Option<&Vec<u8>>, key: &str) -> Option<Box<Binn>> {\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return None;\n    }\n    value.allocated = true;\n    Some(Box::new(value))\n}\n\n",
        "binn_object_float": "pub fn binn_object_float(obj: Option<&Vec<u8>>, key: &str) -> f32 {\n    let mut value: f32 = 0.0;\n    binn_object_get(obj, key, BINN_FLOAT32, &mut value, None);\n    value\n}\n\n",
        "binn_map_value": "pub fn binn_map_value(ptr: Option<&Vec<u8>>, id: i32) -> Option<Binn> {\n    let mut value = Binn::default();\n    if !binn_map_get_value(ptr, id, &mut value) {\n        return None;\n    }\n    value.allocated = true;\n    Some(value)\n}\n\n",
        "binn_object_int32": "pub fn binn_object_int32(obj: Option<&Vec<u8>>, key: &str) -> i32 {\n    let mut value = 0;\n    binn_object_get(obj, key, BINN_INT32, &mut value, None);\n    value\n}\n\n",
        "binn_list_int32": "pub fn binn_list_int32(list: Option<&Vec<u8>>, pos: i32) -> i32 {\n    let mut value = 0i32;\n    binn_list_get(list, pos, BINN_INT32, &mut value, None);\n    value\n}\n\n",
        "binn_list_uint64": "pub fn binn_list_uint64(list: Option<&Vec<u8>>, pos: i32) -> u64 {\n    let mut value: u64 = 0;\n    binn_list_get(list, pos, BINN_UINT64, &mut value, None);\n    value\n}\n\n",
        "binn_map_list": "pub fn binn_map_list(map: Option<&Vec<u8>>, id: i32) -> Option<Vec<u8>> {\n    let mut value = Vec::new();\n    let mut size = 0;\n    if !binn_map_get(map, id, BINN_LIST, &mut value, &mut size) {\n        return None;\n    }\n    Some(value)\n}\n\n",
        "binn_set_string": "pub fn binn_set_string(mut item: Binn, str: String, pfree: Option<fn(Vec<u8>)>) -> bool {\n    if item.is_null() || str.is_empty() {\n        return false;\n    }\n\n    if pfree.is_none() {\n        let bytes = str.into_bytes();\n        item.ptr = binn_memdup(&bytes, bytes.len() as i32 + 1).unwrap_or_default();\n        if item.ptr.is_empty() {\n            return false;\n        }\n        item.freefn = None;\n    } else {\n        item.ptr = str.into_bytes();\n        item.freefn = pfree;\n    }\n\n    item.type_ = BINN_STRING;\n    true\n}\n\n",
        "binn_list_int64": "pub fn binn_list_int64(list: Option<&Vec<u8>>, pos: i32) -> i64 {\n    let mut value: i64 = 0;\n    binn_list_get(list, pos, BINN_INT64, &mut value, None);\n    value\n}\n\n",
        "binn_object_read_next": "pub fn binn_object_read_next(iter: &mut BinnIter, pkey: &mut String, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if !binn_object_next(iter, pkey, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n",
        "binn_map_set_new": "pub fn binn_map_set_new(map: &mut Binn, id: i32, value: Option<Binn>) -> bool {\n    let retval = match value {\n        Some(ref v) => binn_map_set_value(map, id, v),\n        None => false,\n    };\n    retval\n}\n\n",
        "binn_release": "pub fn binn_release(item: &mut Binn) -> Option<Vec<u8>> {\n    let mut data = binn_ptr(Some(&item.pbuf));\n\n    if let Some(ref mut data_vec) = data {\n        if data_vec.as_ptr() > item.pbuf.as_ptr() {\n            item.pbuf.copy_from_slice(data_vec);\n            data = Some(item.pbuf.clone());\n        }\n    }\n\n    if item.allocated {\n        if let Some(free_func) = unsafe { free_fn } {\n            let boxed_slice = item.pbuf.clone().into_boxed_slice();\n            free_func(Some(boxed_slice));\n        }\n    } else {\n        *item = Binn::default();\n        item.header = BINN_MAGIC as i32;\n    }\n\n    data\n}\n\n",
        "binn_list_float": "pub fn binn_list_float(list: Option<&Vec<u8>>, pos: i32) -> f32 {\n    let mut value = 0.0f32;\n    binn_list_get(list, pos, BINN_FLOAT32, &mut value, None);\n    value\n}\n\n",
        "binn_list_read_next": "pub fn binn_list_read_next(iter: &mut BinnIter, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    \n    if !binn_list_next(iter, &mut value) {\n        return None;\n    }\n    \n    if let Some(pt) = ptype {\n        *pt = value.type_;\n    }\n    if let Some(ps) = psize {\n        *ps = value.size;\n    }\n    \n    Some(store_value(&value))\n}\n\n",
        "binn_create_object": "pub fn binn_create_object(object: &mut Binn) -> bool {\n    binn_create(object, BINN_OBJECT, 0, None)\n}\n\n",
        "binn_count": "pub fn binn_count(ptr: Option<&Vec<u8>>) -> i32 {\n    match binn_get_ptr_type(ptr) {\n        BINN_STRUCT => {\n            let binn = unsafe { &*(ptr.unwrap().as_ptr() as *const Binn) };\n            binn.count\n        }\n        BINN_BUFFER => binn_buf_count(ptr.unwrap()),\n        _ => -1,\n    }\n}\n\n",
        "binn_map_uint8": "pub fn binn_map_uint8(map: Option<&Vec<u8>>, id: i32) -> u8 {\n    let mut value: u8 = 0;\n    let mut size: i32 = 0;\n    binn_map_get(map, id, BINN_UINT8, &mut value, &mut size);\n    value\n}\n\n",
        "binn_object_set_new": "pub fn binn_object_set_new(obj: &mut Binn, key: &str, value: Option<Binn>) -> bool {\n    let mut retval = false;\n    if let Some(mut val) = value {\n        retval = binn_object_set_value(obj, key, &val);\n        if let Some(free_func) = unsafe { free_fn } {\n            free_func(Some(Box::from(val.ptr)));\n        }\n    }\n    retval\n}\n\n",
        "binn_object_int8": "pub fn binn_object_int8(obj: Option<&Vec<u8>>, key: &str) -> i8 {\n    let mut value: i8 = 0;\n    binn_object_get(obj, key, BINN_INT8, &mut value, None);\n    value\n}\n\n",
        "binn_list_next_value": "pub fn binn_list_next_value(iter: &mut BinnIter) -> Option<Binn> {\n    let mut value = Binn::default();\n\n    if !binn_list_next(iter, &mut value) {\n        return None;\n    }\n\n    value.allocated = true;\n    Some(value)\n}\n\n",
        "binn_map_object": "pub fn binn_map_object<T>(map: Option<&Vec<u8>>, id: i32) -> Option<T> {\n    let mut value: T = unsafe { std::mem::zeroed() };\n    let mut size = 0;\n    \n    if !binn_map_get(map, id, BINN_OBJECT, &mut value, &mut size) {\n        None\n    } else {\n        Some(value)\n    }\n}\n\n",
        "binn_map_int64": "pub fn binn_map_int64(map: Option<&Vec<u8>>, id: i32) -> i64 {\n    let mut value: i64 = 0;\n    binn_map_get(map, id, BINN_INT64, &mut value, &mut 0);\n    value\n}\n\n",
        "binn_open_ex": "pub fn binn_open_ex<T>(data: &Vec<u8>, size: i32) -> Option<Binn> {\n    let mut item = Binn::default();\n    \n    if !binn_load_ex(data, size, &mut item) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n",
        "binn_create_map": "pub fn binn_create_map(map: &mut Binn) -> bool {\n    binn_create(map, BINN_MAP, 0, None)\n}\n\n",
        "binn_list_bool": "pub fn binn_list_bool(list: Option<&Vec<u8>>, pos: i32) -> bool {\n    let mut value = false;\n    binn_list_get(list, pos, BINN_BOOL, &mut value, None);\n    value\n}\n\n",
        "binn_object_pair": "pub fn binn_object_pair(obj: Option<&Vec<u8>>, pos: i32, pkey: &mut String) -> Option<Binn> {\n    let mut value = Binn::default();\n\n    if !binn_read_pair(BINN_OBJECT, obj, pos, &mut 0, pkey, &mut value) {\n        return None;\n    }\n\n    value.allocated = true;\n    Some(value)\n}\n\n",
        "binn_object_list": "pub fn binn_object_list(obj: Option<&Vec<u8>>, key: &str) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n    if binn_object_get_value(obj, key, &mut value) {\n        Some(value.ptr)\n    } else {\n        None\n    }\n}\n\n",
        "binn_list_add_new": "pub fn binn_list_add_new(list: &mut Binn, value: Option<Binn>) -> bool {\n    let retval = match &value {\n        Some(v) => binn_list_add_value(list, v),\n        None => false,\n    };\n    retval\n}\n\n",
        "binn_map_int8": "pub fn binn_map_int8(map: Option<&Vec<u8>>, id: i32) -> i8 {\n    let mut value: i8 = 0;\n    let mut _psize: i32 = 0;\n    binn_map_get(map, id, BINN_INT8, &mut value, &mut _psize);\n    value\n}\n\n",
        "binn_object_uint8": "pub fn binn_object_uint8(obj: Option<&Vec<u8>>, key: &str) -> u8 {\n    let mut value: u8 = 0;\n    binn_object_get(obj, key, BINN_UINT8, &mut value, None);\n    value\n}\n\n",
        "binn_map_double": "pub fn binn_map_double(map: Option<&Vec<u8>>, id: i32) -> f64 {\n    let mut value: f64 = 0.0;\n    let mut size: i32 = 0;\n    \n    binn_map_get(map, id, BINN_FLOAT64, &mut value, &mut size);\n    \n    value\n}\n\n",
        "binn_list_list": "pub fn binn_list_list(list: Option<&Vec<u8>>, pos: i32) -> Option<Vec<u8>> {\n    let mut value: Vec<u8> = Vec::new();\n    if binn_list_get(list, pos, BINN_LIST, &mut value, None) {\n        Some(value)\n    } else {\n        None\n    }\n}\n\n",
        "binn_map_uint64": "pub fn binn_map_uint64(map: Option<&Vec<u8>>, id: i32) -> u64 {\n    let mut value: u64 = 0;\n    let mut size: i32 = 0;\n    binn_map_get(map, id, BINN_UINT64, &mut value, &mut size);\n    value\n}\n\n"
    },
    "test-binn": {
        "main": "fn main(){}\n",
        "i64toa": "pub fn i64toa(value: i64, buf: &mut String, radix: i32) -> &mut String {\n    match radix {\n        10 => {\n            *buf = format!(\"{}{}\", INT64_FORMAT, value);\n        }\n        16 => {\n            *buf = format!(\"{}{}\", INT64_HEX_FORMAT, value);\n        }\n        _ => {\n            buf.clear();\n        }\n    }\n    buf\n}\n\n",
        "extra": "pub const INT64_FORMAT: &str = \"I64i\";\npub const INT64_HEX_FORMAT: &str = \"I64x\";\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;",
        "return_passed_int64": "pub fn return_passed_int64(a: i64) -> i64 {\n    a\n}\n\n",
        "return_int64": "pub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n",
        "pass_int64": "pub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n",
        "AlmostEqualDoubles": "pub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut absDiff = (a - b).abs();\n    if absDiff < VERYSMALL {\n        return TRUE;\n    }\n\n    let mut absA = a.abs();\n    let mut absB = b.abs();\n    let mut maxAbs = max(absA, absB);\n    if (absDiff / maxAbs) < EPSILON {\n        return TRUE;\n    }\n    println!(\"a={} b={}\", a, b);\n    FALSE\n}\n\n\npub fn max<T: PartialOrd>(a: T, b: T) -> T {\n    if a > b { a } else { b }\n}\n\n",
        "AlmostEqualFloats": "pub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: u32;\n    let mut bInt: u32;\n    let mut intDiff: u32;\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n    if (aInt as i32) < 0 {\n        aInt = 0x80000000u32 - aInt;\n    }\n    if (bInt as i32) < 0 {\n        bInt = 0x80000000u32 - bInt;\n    }\n    intDiff = (aInt as i32 - bInt as i32).abs() as u32;\n    if intDiff <= maxUlps as u32 {\n        true\n    } else {\n        false\n    }\n}\n\n",
        "memdup": "pub fn memdup<T: Clone>(src: Option<Vec<T>>, size: usize) -> Option<Vec<T>> {\n    if src.is_none() || size == 0 {\n        return None;\n    }\n    let src = src.unwrap();\n    if src.len() < size {\n        return None;\n    }\n    Some(src[..size].to_vec())\n}\n\n",
        "test_preallocated_binn": "pub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE).unwrap();\n    \n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.to_vec()));\n    assert!(obj1.is_some());\n    \n    let obj1 = obj1.as_mut().unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC as i32);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated);\n    \n    binn_free(Some(obj1.clone()));\n}\n\n",
        "test_read_values_with_compression": "pub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    assert_eq!(binn_list_add_int32(list.as_mut().unwrap(), 123), true);\n    assert_eq!(binn_map_set_int32(map.as_mut().unwrap(), 1001, 456), true);\n    assert_eq!(binn_object_set_int32(obj.as_mut().unwrap(), \"int\", 789), true);\n\n    let mut value = Binn::default();\n\n    assert_eq!(binn_list_get_value(Some(&list.as_ref().unwrap().pbuf), 1, &mut value), true);\n    assert_eq!(value.vint, 123);\n\n    value = Binn::default();\n    assert_eq!(binn_map_get_value(Some(&map.as_ref().unwrap().pbuf), 1001, &mut value), true);\n    assert_eq!(value.vint, 456);\n\n    value = Binn::default();\n    assert_eq!(binn_object_get_value(Some(&obj.as_ref().unwrap().pbuf), \"int\", &mut value), true);\n    assert_eq!(value.vint, 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_create_and_add_values_with_compression": "pub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    assert!(binn_list_add_double(&mut list, 1.23));\n    assert!(binn_map_set_double(&mut map, 1002, 4.56));\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89));\n\n    assert!(binn_list_add_bool(&mut list, true));\n    assert!(binn_map_set_bool(&mut map, 1003, true));\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n",
        "test_binn_blob_operations": "pub fn test_binn_blob_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n    let mut mutable_blobsize = blobsize;\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.as_ref().unwrap().pbuf), 1, Some(&mut mutable_blobsize));\n    assert!(ptr.is_some());\n    assert!(ptr.as_ref().unwrap().iter().zip(pblob.iter()).all(|(a, b)| a == b));\n\n    binn_free(list);\n}\n\n",
        "test_valid_binn_operations": "pub fn test_valid_binn_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n    let mut i = 0x1234i32;\n\n    assert!(binn_list_add(list.as_mut().unwrap(), BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_map_set(map.as_mut().unwrap(), 5501, BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n    assert!(!binn_object_set(obj.as_mut().unwrap(), \"test\", BINN_INT32, Some(&vec![i.to_be_bytes().to_vec()].concat()), 0));\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_invalid_binn_creation": "pub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let mut obj1: Option<Box<Binn>> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = unsafe { std::mem::transmute::<_, *mut u8>(&mut obj1) };\n    let ptr_vec1 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    let ptr_vec2 = unsafe { Vec::from_raw_parts(ptr_wrap, 0, 0) };\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_vec1)).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_vec2)).is_none());\n}\n\n",
        "test_int64": "pub fn test_int64() {\n    let mut i64: i64;\n    let mut buf = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    i64toa(i64, &mut buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n",
        "test_binn_size_operations": "pub fn test_binn_size_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None);\n    let mut map = binn_new(BINN_MAP, 0, None);\n    let mut obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert!(binn_size(list.as_deref()) == list.as_ref().unwrap().size);\n    assert!(binn_size(map.as_deref()) == map.as_ref().unwrap().size);\n    assert!(binn_size(obj.as_deref()) == obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_binn_size_and_validation": "pub fn test_binn_size_and_validation() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n    let ptr = binn_ptr(obj.as_ref().map(|b| &b.ptr));\n    assert!(ptr.is_some());\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_preallocated_binn_creation": "pub fn test_preallocated_binn_creation() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0u8; FIX_SIZE as usize];\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert!(obj1.header == BINN_MAGIC as i32);\n    assert!(obj1.type_ == BINN_OBJECT);\n    assert!(obj1.count == 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert!(obj1.alloc_size == FIX_SIZE);\n    assert!(obj1.used_size == MAX_BINN_HEADER as i32);\n    assert!(obj1.pre_allocated == true);\n\n    binn_free(Some(obj1));\n}\n\n",
        "test_add_and_read_blob": "pub fn test_add_and_read_blob() {\n    let mut list = binn_list().unwrap();\n    let blobsize = 150;\n    let mut pblob = vec![55u8; blobsize as usize];\n\n    assert!(binn_list_add(&mut list, BINN_BLOB, Some(&pblob), blobsize));\n\n    let ptr = binn_list_blob(Some(&list.pbuf), 1, None);\n    assert!(ptr.is_some());\n    let ptr = ptr.unwrap();\n    assert_eq!(ptr, pblob);\n\n    binn_free(Some(list));\n}\n\n",
        "test_floating_point_numbers": "pub fn test_floating_point_numbers() {\n    let mut buf = String::new();\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{:.3}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{:.2}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n",
        "test_read_values_no_compression": "pub fn test_read_values_no_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    list.disable_int_compression = true;\n    map.disable_int_compression = true;\n    obj.disable_int_compression = true;\n\n    assert!(binn_list_add_int32(&mut list, 123));\n    assert!(binn_map_set_int32(&mut map, 1001, 456));\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789));\n\n    let mut value = Binn::default();\n\n    assert!(binn_list_get_value(Some(&list.pbuf), 1, &mut value));\n    assert!(value.vint == 123);\n\n    value = Binn::default();\n    assert!(binn_map_get_value(Some(&map.pbuf), 1001, &mut value));\n    assert!(value.vint == 456);\n\n    value = Binn::default();\n    assert!(binn_object_get_value(Some(&obj.pbuf), \"int\", &mut value));\n    assert!(value.vint == 789);\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n",
        "print_binn": "pub fn print_binn(map: &Binn) {\n    let p = binn_ptr(Some(&map.ptr));\n    let size = binn_size(Some(map));\n    if let Some(data) = p {\n        for i in 0..size {\n            print!(\"{:02x} \", data[i as usize]);\n        }\n    }\n    println!();\n}\n\n",
        "test_add_and_read_integer": "pub fn test_add_and_read_integer() {\n    let mut list = binn_list();\n    let value: i32 = 123;\n    let bytes = value.to_ne_bytes();\n\n    assert!(binn_list_add(&mut list.as_mut().unwrap(), BINN_INT32, Some(&bytes.to_vec()), 0));\n\n    let mut read_value: i32 = 0;\n    assert!(binn_list_get_int32(list.as_ref().map(|b| &b.pbuf), 1, &mut read_value));\n    assert_eq!(read_value, value);\n\n    binn_free(list);\n}\n\n",
        "test_add_strings_and_blobs_no_compression": "pub fn test_add_strings_and_blobs_no_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    let str_list = \"test list\".to_string();\n    let str_map = \"test map\".to_string();\n    let str_obj = \"test object\".to_string();\n\n    let blobsize = 150;\n    let mut pblob = vec![55; blobsize as usize];\n\n    list.disable_int_compression = true;\n    map.disable_int_compression = true;\n    obj.disable_int_compression = true;\n\n    assert!(binn_list_add_str(&mut list, str_list.clone()));\n    assert!(binn_map_set_str(&mut map, 1004, str_map.clone()));\n    assert!(binn_object_set_str(&mut obj, \"text\", str_obj.clone()));\n\n    assert!(binn_list_add_blob(&mut list, Some(&pblob), blobsize));\n    assert!(binn_map_set_blob(&mut map, 1005, Some(&pblob), blobsize));\n    assert!(binn_object_set_blob(&mut obj, \"blob\", pblob.clone(), blobsize));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n"
    },
    "test-lil": {
        "do_system": "pub fn do_system(argc: usize, argv: Vec<String>) -> Option<String> {\n    if argc == 0 {\n        return None;\n    }\n\n    if argv[0] == \"echo\" && argc > 1 {\n        let mut result = argv[1].clone();\n        result.push('\\n');\n        return Some(result);\n    }\n\n    None\n}\n\n",
        "main": "fn main(){}\n",
        "extra": "pub static mut test_exit_code: i32 = 0;\npub static mut test_running: i32 = 1;",
        "do_exit": "pub fn do_exit<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) {\n    unsafe {\n        test_running = 0;\n        test_exit_code = lil_to_integer(val) as i32;\n    }\n}\n\n",
        "fnc_system": "pub fn fnc_system<T: Clone + FromStr + Into<String>>(lil: &LilStruct<T>, argc: usize, argv: Vec<LilValue<T>>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    if argc == 0 {\n        return None;\n    }\n\n    let mut sargv: Vec<String> = Vec::with_capacity(argc);\n    for arg in argv.iter().take(argc) {\n        sargv.push(lil_to_string(arg));\n    }\n\n    let rv = do_system(argc, sargv);\n    rv.and_then(|s| alloc_value(Some(s)))\n}\n\n",
        "fnc_readline": "pub fn fnc_readline<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<String>> {\n    lil_alloc_string(Some(\"test_input\".to_string()))\n}\n\n",
        "fnc_writechar": "pub fn fnc_writechar<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    print!(\"{}\", lil_to_integer(&argv[0]) as u8 as char);\n    None\n}\n\n"
    },
    "lil": {
        "hm_hash": "pub fn hm_hash(key: &str) -> u64 {\n    let mut hash: u64 = 5381;\n    for c in key.bytes() {\n        hash = ((hash << 5) + hash) + c as u64;\n    }\n    hash\n}\n\n",
        "extra": "use std::str::FromStr;\nuse std::fmt::Debug;\nuse std::rc::Rc;\nuse std::cell::RefCell;\nuse std::io::Read;\n\n#[derive(Debug, Clone)]\npub struct LilValue<T: Clone> {\n    pub l: usize,\n    pub d: Option<T>\n}\n\n#[derive(Debug)]\npub struct HashEntry<T> {\n    pub k: String,\n    pub v: Option<T>,\n}\n\n#[derive(Debug, Clone)]\npub struct HashCell<T> {\n    pub e: Vec<Rc<RefCell<HashEntry<T>>>>,\n    pub c: usize,\n}\n\n#[derive(Debug)]\npub struct HashMap<T> {\n    pub cell: Vec<HashCell<T>>,\n}\n\npub const HASHMAP_CELLMASK: u64 = 0xFF;\n\n#[derive(Debug, Clone)]\npub struct LilList<T: Clone> {\n    pub items: Vec<Rc<RefCell<LilValue<T>>>>,\n}\n\n#[derive(Debug)]\npub struct LilFunc<T: Clone> {\n    pub name: String,\n    pub code: LilValue<T>,\n    pub argnames: LilList<T>,\n    pub proc: Option<LilFuncProc<T>>,\n}\n\npub type LilFuncProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub type LilCallbackProc<T> = fn(&LilStruct<T>, &str, &[LilValue<T>]) -> LilValue<T>;\npub const CALLBACKS: usize = 16;\n\npub struct LilStruct<T: Clone> {\n    pub code: String,\n    pub rootcode: String,\n    pub clen: usize,\n    pub head: usize,\n    pub ignoreeol: i32,\n    pub cmd: Vec<Rc<RefCell<LilFunc<T>>>>,\n    pub cmds: usize,\n    pub syscmds: usize,\n    pub cmdmap: HashMap<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher: String,\n    pub in_catcher: i32,\n    pub dollarprefix: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub rootenv: Rc<RefCell<LilEnv<T>>>,\n    pub downenv: Rc<RefCell<LilEnv<T>>>,\n    pub empty: LilValue<T>,\n    pub error: i32,\n    pub err_head: usize,\n    pub err_msg: String,\n    pub callback: [LilCallbackProc<T>; CALLBACKS],\n    pub parse_depth: usize,\n    pub data: T,\n    pub embed: String,\n    pub embedlen: usize,\n}\n\n#[derive(Debug, Clone)]\npub struct LilVar<T: Clone> {\n    pub n: String,\n    pub w: String,\n    pub env: Rc<RefCell<LilEnv<T>>>,\n    pub v: LilValue<T>,\n}\n\n#[derive(Debug)]\npub struct LilEnv<T: Clone> {\n    pub parent: Option<Rc<RefCell<LilEnv<T>>>>,\n    pub func: Option<Rc<RefCell<LilFunc<T>>>>,\n    pub catcher_for: LilValue<T>,\n    pub var: Vec<Rc<RefCell<LilVar<T>>>>,\n    pub vars: usize,\n    pub varmap: HashMap<Rc<RefCell<LilVar<T>>>>,\n    pub retval: LilValue<T>,\n    pub retval_set: bool,\n    pub breakrun: bool,\n}\n\npub static mut listpool: Vec<Rc<RefCell<LilList<()>>>> = Vec::new();\npub static mut listpoolsize: usize = 0;\npub static mut listpoolcap: usize = 0;\n\n#[derive(Debug, Clone)]\npub enum ExprEvalType {\n    Int,\n    Float,\n}\n\n#[derive(Debug, Clone)]\npub struct Expreval {\n    pub type_: ExprEvalType,\n    pub ival: i64,\n    pub dval: f64,\n    pub head: usize,\n    pub len: usize,\n    pub code: String,\n}",
        "alloc_value_len": "pub fn alloc_value_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let mut val = LilValue {\n        l: 0,\n        d: None\n    };\n\n    if let Some(s) = str {\n        val.l = len;\n        val.d = Some(s.parse().unwrap());\n    } else {\n        val.l = 0;\n        val.d = None;\n    }\n\n    Some(val)\n}\n\n",
        "hm_get": "pub fn hm_get<T: Clone + Debug>(hm: &HashMap<T>, key: &str) -> Option<T> {\n    let cell = &hm.cell[(hm_hash(key) & HASHMAP_CELLMASK) as usize];\n    for i in 0..cell.c {\n        if key == cell.e[i].borrow().k {\n            return cell.e[i].borrow().v.clone();\n        }\n    }\n    None\n}\n\n",
        "lil_free_value": "pub fn lil_free_value<T: Clone>(val: Option<Rc<RefCell<LilValue<T>>>>) {\n    if val.is_none() {\n        return;\n    }\n    let val = val.unwrap();\n    let mut val = val.borrow_mut();\n    val.d = None;\n}\n\n",
        "strclone": "pub fn strclone(s: &str) -> Option<String> {\n    let mut ns = String::with_capacity(s.len() + 1);\n    ns.push_str(s);\n    Some(ns)\n}\n\n",
        "alloc_value": "pub fn alloc_value<T: Clone + FromStr>(str: Option<String>) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let len = str.as_ref().map_or(0, |s| s.len());\n    alloc_value_len(str, len)\n}\n\n",
        "find_cmd": "fn find_cmd<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    None\n}\n\n",
        "lil_free_list": "fn lil_free_list<T: Clone>(_list: LilList<T>) {}\n\n",
        "hm_put": "fn hm_put<T>(map: &mut HashMap<T>, key: &str, value: Option<T>) {\n}\n\n",
        "lil_append_val": "pub fn lil_append_val<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) -> i32 {\n    if v.d.is_none() || v.l == 0 {\n        return 1;\n    }\n\n    match (&mut val.d, &v.d) {\n        (Some(val_data), Some(v_data)) => {\n            let mut new_data = val_data.clone();\n            new_data = v_data.clone();\n            val.d = Some(new_data);\n            val.l += v.l;\n            1\n        }\n        _ => 1,\n    }\n}\n\n",
        "ateol": "pub fn ateol<T: Clone>(lil: &LilStruct<T>) -> bool {\n    !(lil.ignoreeol != 0) && (lil.code.chars().nth(lil.head) == Some('\\n') || lil.code.chars().nth(lil.head) == Some('\\r') || lil.code.chars().nth(lil.head) == Some(';'))\n}\n\n",
        "lil_append_char": "pub fn lil_append_char<T: Clone + Debug + FromStr>(val: Rc<RefCell<LilValue<T>>>, ch: char) -> i32 {\n    let mut val = val.borrow_mut();\n    if let Some(ref mut data) = val.d {\n        let mut s = format!(\"{:?}\", data);\n        s.push(ch);\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    } else {\n        let s = ch.to_string();\n        val.d = s.parse().ok();\n        val.l = s.len();\n        1\n    }\n}\n\n",
        "islilspecial": "pub fn islilspecial(ch: i8) -> i32 {\n    (ch == b'$' as i8 || ch == b'{' as i8 || ch == b'}' as i8 || ch == b'[' as i8 || ch == b']' as i8 || ch == b'\"' as i8 || ch == b'\\'' as i8 || ch == b';' as i8) as i32\n}\n\n",
        "skip_spaces": "pub fn skip_spaces<T: Clone>(lil: &mut LilStruct<T>) {\n    while lil.head < lil.clen {\n        let current_char = lil.code.chars().nth(lil.head).unwrap();\n        if current_char == '#' {\n            if lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                lil.head += 2;\n                while lil.head < lil.clen {\n                    let current_char = lil.code.chars().nth(lil.head).unwrap();\n                    if current_char == '#' && lil.code.chars().nth(lil.head + 1) == Some('#') && lil.code.chars().nth(lil.head + 2) != Some('#') {\n                        lil.head += 2;\n                        break;\n                    }\n                    lil.head += 1;\n                }\n            } else {\n                while lil.head < lil.clen && !ateol(lil) {\n                    lil.head += 1;\n                }\n            }\n        } else if current_char == '\\\\' && (lil.code.chars().nth(lil.head + 1) == Some('\\r') || lil.code.chars().nth(lil.head + 1) == Some('\\n')) {\n            lil.head += 1;\n            while lil.head < lil.clen && ateol(lil) {\n                lil.head += 1;\n            }\n        } else if current_char == '\\r' || current_char == '\\n' {\n            if lil.ignoreeol != 0 {\n                lil.head += 1;\n            } else {\n                break;\n            }\n        } else if current_char.is_whitespace() {\n            lil.head += 1;\n        } else {\n            break;\n        }\n    }\n}\n\n",
        "hm_destroy": "pub fn hm_destroy<T>(hm: &mut HashMap<T>) {\n    for cell in hm.cell.iter_mut() {\n        cell.e.clear();\n        cell.c = 0;\n    }\n}\n\n",
        "lil_find_local_var": "pub fn lil_find_local_var<T: Clone + Debug>(lil: &LilStruct<T>, env: &LilEnv<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    hm_get(&env.varmap, name)\n}\n\n",
        "lil_append_string_len": "pub fn lil_append_string_len<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str, len: usize) -> i32 {\n    if s.is_empty() {\n        return 1;\n    }\n\n    let s_slice = if len < s.len() { &s[..len] } else { s };\n    \n    match &mut val.d {\n        Some(data) => {\n            let str_data = data.as_mut();\n            str_data.push_str(s_slice);\n            val.l += s_slice.len();\n            1\n        },\n        None => {\n            val.d = Some(T::from(s_slice.to_string()));\n            val.l = s_slice.len();\n            1\n        }\n    }\n}\n\n",
        "add_func": "pub fn add_func<T: Clone + Debug>(lil: &mut LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilFunc<T>>>> {\n    let cmd = find_cmd(lil, name);\n    if let Some(cmd) = cmd {\n        let mut cmd_ref = cmd.borrow_mut();\n        if cmd_ref.argnames.items.len() > 0 {\n            let argnames = cmd_ref.argnames.clone();\n            lil_free_list(argnames);\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd_ref.code.clone()))));\n        cmd_ref.argnames = LilList { items: Vec::new() };\n        cmd_ref.code = LilValue { l: 0, d: None };\n        cmd_ref.proc = None;\n        return Some(Rc::clone(&cmd));\n    }\n    let new_cmd = Rc::new(RefCell::new(LilFunc {\n        name: strclone(name).unwrap(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: None,\n    }));\n    lil.cmd.push(Rc::clone(&new_cmd));\n    lil.cmds += 1;\n    hm_put(&mut lil.cmdmap, name, Some(Rc::clone(&new_cmd)));\n    Some(new_cmd)\n}\n\n",
        "lil_alloc_env": "pub fn lil_alloc_env<T: Clone>(parent: Option<Rc<RefCell<LilEnv<T>>>>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = Rc::new(RefCell::new(LilEnv {\n        parent,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap {\n            cell: (0..256).map(|_| HashCell { e: Vec::new(), c: 0 }).collect(),\n        },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    env\n}\n\n",
        "lil_list_append": "fn lil_list_append<T: Clone>(_list: &mut LilList<T>, _val: LilValue<T>) {}\n\n",
        "lil_alloc_list": "pub fn lil_alloc_list<T: Clone>() -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n",
        "lil_free_env": "pub fn lil_free_env<T: Clone>(env: Option<Rc<RefCell<LilEnv<T>>>>) {\n    if env.is_none() {\n        return;\n    }\n    let env = env.unwrap();\n    let mut env = env.borrow_mut();\n    lil_free_value(Some(Rc::new(RefCell::new(env.retval.clone()))));\n    hm_destroy(&mut env.varmap);\n    for i in 0..env.vars {\n        let var = env.var[i].borrow_mut();\n        lil_free_value(Some(Rc::new(RefCell::new(var.v.clone()))));\n    }\n    env.var.clear();\n    env.vars = 0;\n}\n\n",
        "lil_find_var": "fn lil_find_var<T: Clone>(_lil: &LilStruct<T>, _env: Rc<RefCell<LilEnv<T>>>, _name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n    None\n}\n\n",
        "lil_clone_value": "pub fn lil_clone_value<T: Clone>(val: &LilValue<T>) -> LilValue<T> {\n    val.clone()\n}\n\n",
        "lil_to_string": "fn lil_to_string<T: Clone>(value: &LilValue<T>) -> String {\n    String::new()\n}\n\n",
        "needs_escape": "pub fn needs_escape(str: &str) -> i32 {\n    if str.is_empty() {\n        return 1;\n    }\n    for c in str.chars() {\n        if c.is_ascii_punctuation() || c.is_whitespace() {\n            return 1;\n        }\n    }\n    0\n}\n\n",
        "lil_append_string": "pub fn lil_append_string<T: Clone + Debug + From<String> + AsRef<str> + AsMut<String>>(val: &mut LilValue<T>, s: &str) -> i32 {\n    lil_append_string_len(val, s, s.len())\n}\n\n",
        "fnc_exit": "pub fn fnc_exit<T: Clone>(lil: Rc<RefCell<LilStruct<T>>>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Option<Rc<RefCell<LilValue<T>>>> {\n    let lil_ref = lil.borrow();\n    if let Some(proc) = lil_ref.callback.get(0) {\n        let arg = if argc > 0 { Some(argv[0].clone()) } else { None };\n        let lil_wrap = &*lil_ref;\n        proc(lil_wrap, \"\", &[]);\n    }\n    None\n}\n\n",
        "fnc_return": "pub fn fnc_return<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    lil.env.borrow_mut().breakrun = true;\n    lil.env.borrow_mut().retval = if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() };\n    lil.env.borrow_mut().retval_set = true;\n    if argc < 1 { LilValue { l: 0, d: None } } else { argv[0].clone() }\n}\n\n",
        "fnc_expr": "pub fn fnc_expr<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_eval_expr_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(d: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, c: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, v: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_eval_expr_wrap(lil, &argv[0]);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_eval_expr_wrap(lil, &val);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n",
        "fnc_repstr": "pub fn fnc_repstr<T: Clone + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 1 {\n        return LilValue { l: 0, d: None };\n    }\n    if argc < 3 {\n        return argv[0].clone();\n    }\n\n    let from = lil_to_string(&argv[1]);\n    let to = lil_to_string(&argv[2]);\n    if from.is_empty() {\n        return LilValue { l: 0, d: None };\n    }\n\n    let mut src = lil_to_string(&argv[0]);\n    let from_len = from.len();\n    let to_len = to.len();\n\n    while let Some(idx) = src.find(&from) {\n        let mut new_src = String::with_capacity(src.len() - from_len + to_len);\n        new_src.push_str(&src[..idx]);\n        new_src.push_str(&to);\n        new_src.push_str(&src[idx + from_len..]);\n        src = new_src;\n    }\n\n    lil_alloc_string(&src)\n}\n\n",
        "fnc_reflect": "pub fn fnc_reflect<T: Clone + Debug + From<String> + From<&'static str> + From<i64> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc == 0 { return None; }\n    let type_str = lil_to_string(&argv[0]);\n    match type_str.as_str() {\n        \"version\" => Some(LilValue { l: 3, d: Some(\"0.1\".into()) }),\n        \"args\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().argnames.items.is_empty() { return None; }\n            Some(func.unwrap().borrow().argnames.items[0].borrow().clone())\n        },\n        \"body\" => {\n            if argc < 2 { return None; }\n            let func_name = lil_to_string(&argv[1]);\n            let func = find_cmd(lil, &func_name);\n            if func.is_none() || func.as_ref().unwrap().borrow().proc.is_some() { return None; }\n            Some(func.unwrap().borrow().code.clone())\n        },\n        \"func-count\" => Some(LilValue { l: 0, d: Some((lil.cmds as i64).into()) }),\n        \"funcs\" => {\n            let mut funcs = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.cmds {\n                funcs.items.push(Rc::new(RefCell::new(LilValue { l: lil.cmd[i].borrow().name.len(), d: Some(lil.cmd[i].borrow().name.clone().into()) })));\n            }\n            Some(LilValue { l: funcs.items.len(), d: None })\n        },\n        \"vars\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                for i in 0..e.borrow().vars {\n                    vars.items.push(Rc::new(RefCell::new(LilValue { l: e.borrow().var[i].borrow().n.len(), d: Some(e.borrow().var[i].borrow().n.clone().into()) })));\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"globals\" => {\n            let mut vars = LilList { items: Vec::<Rc<RefCell<LilValue<T>>>>::new() };\n            for i in 0..lil.rootenv.borrow().vars {\n                vars.items.push(Rc::new(RefCell::new(LilValue { l: lil.rootenv.borrow().var[i].borrow().n.len(), d: Some(lil.rootenv.borrow().var[i].borrow().n.clone().into()) })));\n            }\n            Some(LilValue { l: vars.items.len(), d: None })\n        },\n        \"has-func\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            if lil.cmdmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                Some(LilValue { l: 1, d: Some(\"1\".into()) })\n            } else {\n                None\n            }\n        },\n        \"has-var\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            let mut current_env = Some(lil.env.clone());\n            while let Some(e) = current_env {\n                if e.borrow().varmap.cell.iter().any(|cell| cell.e.iter().any(|entry| entry.borrow().k == target)) {\n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            None\n        },\n        \"has-global\" => {\n            if argc == 1 { return None; }\n            let target = lil_to_string(&argv[1]);\n            for i in 0..lil.rootenv.borrow().vars {\n                if target == lil.rootenv.borrow().var[i].borrow().n { \n                    return Some(LilValue { l: 1, d: Some(\"1\".into()) });\n                }\n            }\n            None\n        },\n        \"error\" => lil.err_msg.is_empty().then(|| LilValue { l: lil.err_msg.len(), d: Some(lil.err_msg.clone().into()) }),\n        \"dollar-prefix\" => {\n            if argc == 1 { return Some(LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) }); }\n            let r = LilValue { l: lil.dollarprefix.len(), d: Some(lil.dollarprefix.clone().into()) };\n            lil.dollarprefix = lil_to_string(&argv[1]);\n            Some(r)\n        },\n        \"this\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(LilValue { l: lil.catcher.len(), d: Some(lil.catcher.clone().into()) }); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return Some(LilValue { l: lil.rootcode.len(), d: Some(lil.rootcode.clone().into()) }); }\n                if let Some(func) = &e.borrow().func { return Some(func.borrow().code.clone()); }\n            }\n            None\n        },\n        \"name\" => {\n            let mut current_env = Some(lil.env.clone());\n            let mut result_env = None;\n            while let Some(e) = current_env {\n                if e.borrow().catcher_for.d.is_some() || e.borrow().func.is_some() {\n                    result_env = Some(e);\n                    break;\n                }\n                current_env = e.borrow().parent.as_ref().map(|p| p.clone());\n            }\n            if let Some(e) = result_env {\n                if e.borrow().catcher_for.d.is_some() { return Some(e.borrow().catcher_for.clone()); }\n                if Rc::ptr_eq(&e, &lil.rootenv) { return None; }\n                if let Some(func) = &e.borrow().func { return Some(LilValue { l: func.borrow().name.len(), d: Some(func.borrow().name.clone().into()) }); }\n            }\n            None\n        },\n        _ => None\n    }\n}\n\n",
        "lil_alloc_string": "fn lil_alloc_string(s: Option<String>) -> Option<LilValue<String>> {\n    s.map(|s| LilValue { l: s.len(), d: Some(s) })\n}\n\n",
        "lil_alloc_integer": "pub fn lil_alloc_integer<T: Clone + From<i64>>(i: i64) -> LilValue<T> {\n    LilValue { l: 0, d: Some(i.into()) }\n}\n\n",
        "lil_list_to_value": "fn lil_list_to_value<T: Clone>(_list: &LilList<T>, _flag: i32) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\n",
        "hm_has": "pub fn hm_has<T>(map: &HashMap<T>, _key: &str) -> bool {\n    false\n}\n\n",
        "fnc_indexof": "pub fn fnc_indexof<T: Clone + PartialEq + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 {\n        return None;\n    }\n\n    fn lil_subst_to_list_wrap<T: Clone>(_: &LilStruct<T>, _: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_to_string_wrap<T: Clone + Debug>(_: &Rc<RefCell<LilValue<T>>>) -> String {\n        String::new()\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(index: i32) -> LilValue<T> {\n        LilValue { l: index as usize, d: None }\n    }\n    fn lil_free_list_wrap<T: Clone>(_: LilList<T>) {}\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut result = None;\n\n    for (index, item) in list.items.iter().enumerate() {\n        let item_str = lil_to_string_wrap(item);\n        let arg_str = lil_to_string_wrap(&Rc::new(RefCell::new(argv[1].clone())));\n        if item_str == arg_str {\n            result = Some(lil_alloc_integer_wrap(index as i32));\n            break;\n        }\n    }\n\n    lil_free_list_wrap(list);\n    result\n}\n\n",
        "fnc_rand": "pub fn fnc_rand<T: Clone + From<f64>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    LilValue {\n        l: 8,\n        d: Some(0.5f64.into())\n    }\n}\n\n",
        "fnc_foreach": "pub fn fnc_foreach<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _flags: i32) {}\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _flags: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut rlist = LilList { items: Vec::new() };\n    let mut listidx = 0;\n    let mut codeidx = 1;\n    let mut varname = \"i\".to_string();\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    if argc >= 3 {\n        varname = argv[0].d.as_ref().unwrap().to_string();\n        listidx = 1;\n        codeidx = 2;\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[listidx]);\n    for i in 0..list.items.len() {\n        let item = list.items[i].clone();\n        lil_set_var_wrap(lil, &varname, item, 3);\n        let rv = lil_parse_value_wrap(lil, &argv[codeidx], 0);\n        if rv.l != 0 {\n            rlist.items.push(Rc::new(RefCell::new(rv)));\n        }\n        if lil.env.borrow().breakrun || lil.error != 0 { break; }\n    }\n    let r = lil_list_to_value_wrap(&rlist, 1);\n    r\n}\n\n",
        "fnc_subst": "pub fn fnc_subst<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    fn lil_subst_to_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        val.clone()\n    }\n    Some(lil_subst_to_value_wrap(lil, &argv[0]))\n}\n\n",
        "fnc_jaileval": "pub fn fnc_jaileval<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n\n    fn lil_register_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _proc: LilFuncProc<T>) {}\n\n    fn lil_parse_value_wrap<T: Clone>(_lil: &mut LilStruct<T>, _val: &LilValue<T>, _depth: usize) -> Option<LilValue<T>> {\n        None\n    }\n\n    let mut base = 0;\n    if argc == 0 {\n        return None;\n    }\n    if lil_to_string_wrap(&argv[0]) == \"clean\" {\n        base = 1;\n        if argc == 1 {\n            return None;\n        }\n    }\n    let mut sublil = LilStruct {\n        code: String::new(),\n        rootcode: String::new(),\n        clen: 0,\n        head: 0,\n        ignoreeol: 0,\n        cmd: Vec::new(),\n        cmds: 0,\n        syscmds: 0,\n        cmdmap: HashMap { cell: Vec::new() },\n        catcher: String::new(),\n        in_catcher: 0,\n        dollarprefix: String::new(),\n        env: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        rootenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        downenv: Rc::new(RefCell::new(LilEnv {\n            parent: None,\n            func: None,\n            catcher_for: LilValue { l: 0, d: None },\n            var: Vec::new(),\n            vars: 0,\n            varmap: HashMap { cell: Vec::new() },\n            retval: LilValue { l: 0, d: None },\n            retval_set: false,\n            breakrun: false,\n        })),\n        empty: LilValue { l: 0, d: None },\n        error: 0,\n        err_head: 0,\n        err_msg: String::new(),\n        callback: [|_, _, _| LilValue { l: 0, d: None }; CALLBACKS],\n        parse_depth: 0,\n        data: argv[0].d.as_ref().unwrap().clone(),\n        embed: String::new(),\n        embedlen: 0,\n    };\n    if base != 1 {\n        for i in lil.syscmds..lil.cmds {\n            let fnc = lil.cmd[i].clone();\n            if fnc.borrow().proc.is_none() {\n                continue;\n            }\n            lil_register_wrap(&mut sublil, &fnc.borrow().name, fnc.borrow().proc.unwrap());\n        }\n    }\n    let r = lil_parse_value_wrap(&mut sublil, &argv[base], 1);\n    r\n}\n\n",
        "lil_register": "pub fn lil_register<T: Clone>(lil: &mut LilStruct<T>, name: &str, proc: LilFuncProc<T>) {\n    let func = Rc::new(RefCell::new(LilFunc {\n        name: name.to_string(),\n        code: LilValue { l: 0, d: None },\n        argnames: LilList { items: Vec::new() },\n        proc: Some(proc),\n    }));\n    lil.cmd.push(func.clone());\n    lil.cmds += 1;\n}\n\n",
        "lil_parse_value": "pub fn lil_parse_value<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> Option<LilValue<T>> {\n    Some(val.clone())\n}\n\n",
        "fnc_concat": "pub fn fnc_concat<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut r = LilValue { l: 0, d: Some(String::new().into()) };\n    if argc < 1 { return r; }\n    for i in 0..argc {\n        let list = argv[i].clone();\n        let tmp = list;\n        lil_append_val_wrap(&mut r, tmp);\n    }\n    r\n}\n\n\nfn lil_append_val_wrap<T: Clone>(dst: &mut LilValue<T>, src: LilValue<T>) {\n    if let Some(d) = &mut dst.d {\n        if let Some(s) = src.d {\n            *d = s;\n        }\n    }\n}\n\n",
        "fnc_set": "pub fn fnc_set<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_get_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: &LilValue<T>, access: i32) -> Option<Rc<RefCell<LilVar<T>>>> {\n        None\n    }\n\n    let mut i = 0;\n    let mut var: Option<Rc<RefCell<LilVar<T>>>> = None;\n    let mut access = 1;\n    if argc == 0 { return None; }\n    if argv[0].d.as_ref().map_or(false, |d| d.to_string() == \"global\") {\n        i = 1;\n        access = 0;\n    }\n    while i < argc {\n        if argc == i + 1 {\n            return lil_get_var_wrap(lil, &argv[i].d.as_ref()?.to_string()).map(|v| v.borrow().v.clone());\n        }\n        var = lil_set_var_wrap(lil, &argv[i].d.as_ref()?.to_string(), &argv[i + 1], access);\n        i += 2;\n    }\n    var.map(|v| v.borrow().v.clone())\n}\n\n",
        "fnc_char": "pub fn fnc_char<T: Clone + From<String> + FromStr + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        return LilValue { l: 0, d: None };\n    }\n    let s = match &argv[0].d {\n        Some(val) => {\n            let mut buf = [0u8; 2];\n            buf[0] = format!(\"{:?}\", val).parse::<u8>().unwrap_or(0);\n            buf[1] = 0;\n            String::from_utf8_lossy(&buf).to_string()\n        },\n        None => String::new(),\n    };\n    LilValue { l: s.len(), d: Some(T::from(s)) }\n}\n\n",
        "fnc_while": "pub fn fnc_while<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut r: Option<LilValue<T>> = None;\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if lil_to_string(&argv[0]) == \"not\" {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr(lil, &argv[base]);\n        if val.is_none() || lil.error != 0 { return None; }\n        let mut v = lil_to_boolean(&val.unwrap());\n        if not { v = !v; }\n        if !v {\n            break;\n        }\n        if r.is_some() {\n            r = None;\n        }\n        r = lil_parse_value(lil, &argv[base + 1], 0);\n    }\n    r\n}\n\n",
        "lil_eval_expr": "pub fn lil_eval_expr<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> Option<LilValue<T>> {\n    None\n}\n\n",
        "lil_to_boolean": "pub fn lil_to_boolean<T: Clone>(_val: &LilValue<T>) -> bool {\n    false\n}\n\n",
        "fnc_topeval": "pub fn fnc_topeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    lil.env = Rc::clone(&lil.rootenv);\n    lil.downenv = Rc::clone(&thisenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = thisdownenv;\n    lil.env = thisenv;\n    r\n}\n\n",
        "fnc_error": "pub fn fnc_error<T: Clone + std::fmt::Display>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let err_msg = if argc > 0 {\n        match &argv[0].d {\n            Some(d) => d.to_string(),\n            None => String::new(),\n        }\n    } else {\n        String::new()\n    };\n    lil.error = 1;\n    lil.err_msg = err_msg;\n    LilValue { l: 0, d: None }\n}\n\n",
        "fnc_strcmp": "pub fn fnc_strcmp<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    let s1 = lil_to_string_wrap(&argv[0]);\n    let s2 = lil_to_string_wrap(&argv[1]);\n    LilValue { l: s1.cmp(&s2) as usize, d: None }\n}\n\n",
        "fnc_list": "pub fn fnc_list<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList { items: Vec::new() };\n    for i in 0..argc {\n        list.items.push(Rc::new(RefCell::new(argv[i].clone())));\n    }\n    LilValue { l: list.items.len(), d: None }\n}\n\n",
        "fnc_if": "pub fn fnc_if<T: Clone + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let mut base = 0;\n    let mut not = false;\n    if argc < 1 { return None; }\n    if argv[0].d.as_ref().map_or(false, |s| s.to_string() == \"not\") {\n        base = 1;\n        not = true;\n    }\n    if argc < base + 2 { return None; }\n    let val = lil_eval_expr(lil, &argv[base]);\n    if val.is_none() || lil.error != 0 { return None; }\n    let v = lil_to_boolean(&val.unwrap());\n    let v = if not { !v } else { v };\n    if v {\n        lil_parse_value(lil, &argv[base + 1], 0)\n    } else if argc > base + 2 {\n        lil_parse_value(lil, &argv[base + 2], 0)\n    } else {\n        None\n    }\n}\n\n",
        "fnc_for": "pub fn fnc_for<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_eval_expr_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(val: &LilValue<T>) -> bool {\n        false\n    }\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 4 { return LilValue { l: 0, d: None }; }\n    let _ = lil_parse_value_wrap(lil, &argv[0], 0);\n    while lil.error == 0 && !lil.env.borrow().breakrun {\n        let val = lil_eval_expr_wrap(lil, &argv[1]);\n        if val.l == 0 || lil.error != 0 { return LilValue { l: 0, d: None }; }\n        if !lil_to_boolean_wrap(&val) {\n            break;\n        }\n        r = lil_parse_value_wrap(lil, &argv[3], 0);\n        let _ = lil_parse_value_wrap(lil, &argv[2], 0);\n    }\n    r\n}\n\n",
        "fnc_split": "pub fn fnc_split<T: Clone + ToString + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut list = LilList::<T> { items: Vec::new() };\n    let mut sep = \" \".to_string();\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    if argc > 1 {\n        sep = argv[1].d.as_ref().map(|x| x.to_string()).unwrap_or_else(|| \" \".to_string());\n        if sep.is_empty() { return argv[0].clone(); }\n    }\n    let mut val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n    let str = argv[0].d.as_ref().map(|x| x.to_string()).unwrap_or_default();\n    for c in str.chars() {\n        if sep.contains(c) {\n            list.items.push(Rc::new(RefCell::new(val)));\n            val = LilValue { l: 0, d: Some(\"\".to_string().into()) };\n        } else {\n            if let Some(s) = val.d.as_mut() {\n                *s = format!(\"{}{}\", s.to_string(), c).into();\n            }\n        }\n    }\n    list.items.push(Rc::new(RefCell::new(val)));\n    let result_str = list.items.iter().map(|x| x.borrow().d.as_ref().map(|x| x.to_string()).unwrap_or_default()).collect::<Vec<_>>().join(\" \");\n    LilValue { l: 0, d: Some(result_str.into()) }\n}\n\n",
        "fnc_dec": "pub fn fnc_dec<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        String::new()\n    }\n    \n    fn lil_to_double_wrap<T: Clone>(val: &LilValue<T>) -> f64 {\n        0.0\n    }\n    \n    fn real_inc_wrap<T: Clone>(lil: &LilStruct<T>, s: String, d: f64) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    real_inc_wrap(lil, lil_to_string_wrap(&argv[0]), -(if argc > 1 { lil_to_double_wrap(&argv[1]) } else { 1.0 }))\n}\n\n",
        "fnc_lmap": "pub fn fnc_lmap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    \n    fn lil_to_string_wrap<T: Clone>(val: &LilValue<T>) -> String {\n        unimplemented!()\n    }\n    \n    fn lil_list_get_wrap<T: Clone>(list: &Rc<RefCell<LilList<T>>>, index: usize) -> LilValue<T> {\n        unimplemented!()\n    }\n    \n    fn lil_set_var_wrap<T: Clone>(lil: &LilStruct<T>, name: &str, value: LilValue<T>, flag: i32) {\n        unimplemented!()\n    }\n    \n    fn lil_free_list_wrap<T: Clone>(list: Rc<RefCell<LilList<T>>>) {\n        unimplemented!()\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    for i in 1..argc {\n        let var_name = lil_to_string_wrap(&argv[i]);\n        let value = lil_list_get_wrap(&list, i - 1);\n        lil_set_var_wrap(lil, &var_name, value, 1);\n    }\n    lil_free_list_wrap(list);\n    None\n}\n\n",
        "fnc_streq": "pub fn fnc_streq<T: Clone + FromStr + PartialEq + std::fmt::Display + From<bool>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return lil.empty.clone(); }\n    let s1 = argv[0].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    let s2 = argv[1].d.as_ref().map(|v| v.to_string()).unwrap_or_default();\n    LilValue { l: 1, d: Some((s1 == s2).into()) }\n}\n\n",
        "fnc_watch": "pub fn fnc_watch<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 2 { return None; }\n    let wcode = lil_to_string(&argv[argc - 1]);\n    for i in 0..(argc - 1) {\n        let vname = lil_to_string(&argv[i]);\n        if vname.is_empty() { continue; }\n        let mut v = lil_find_var(lil, lil.env.clone(), &vname);\n        if v.is_none() {\n            let empty_val = LilValue { l: 0, d: None };\n            lil_set_var(lil, &vname, empty_val, 2);\n            v = lil_find_var(lil, lil.env.clone(), &vname);\n        }\n        if let Some(var) = v {\n            var.borrow_mut().w = if !wcode.is_empty() { wcode.clone() } else { String::new() };\n        }\n    }\n    None\n}\n\n",
        "lil_set_var": "fn lil_set_var<T: Clone>(_lil: &LilStruct<T>, _name: &str, _val: LilValue<T>, _access: i32) {}\n\n",
        "fnc_count": "pub fn fnc_count<T: Clone + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> Rc<RefCell<LilList<T>>> {\n        unimplemented!()\n    }\n    let mut buff = String::with_capacity(64);\n    if argc == 0 {\n        return LilValue { l: 1, d: Some(T::from(\"0\".to_string())) };\n    }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    buff.push_str(&list.borrow().items.len().to_string());\n    LilValue { l: buff.len(), d: Some(T::from(buff)) }\n}\n\n",
        "fnc_print": "pub fn fnc_print<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_write_wrap<T: Clone>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) {\n        // \u7a7a\u5b9e\u73b0\n    }\n    fn lil_write_wrap<T: Clone>(lil: &LilStruct<T>, s: &str) {\n        // \u7a7a\u5b9e\u73b0\n    }\n    fnc_write_wrap(lil, argc, argv);\n    lil_write_wrap(lil, \"\\n\");\n    LilValue { l: 0, d: None }\n}\n\n",
        "fnc_index": "pub fn fnc_index<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: vec![Rc::new(RefCell::new(val.clone()))] }\n    }\n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i64 {\n        if let Some(d) = &val.d {\n            if let Ok(n) = i64::from_str(&d.to_string()) {\n                return n;\n            }\n        }\n        0\n    }\n    fn lil_free_list_wrap<T: Clone>(_list: LilList<T>) {}\n\n    let mut r = LilValue { l: 0, d: None };\n    if argc < 2 { return r; }\n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index < list.items.len() {\n        r = list.items[index].borrow().clone();\n    }\n    lil_free_list_wrap(list);\n    r\n}\n\n",
        "fnc_catcher": "pub fn fnc_catcher<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc == 0 {\n        LilValue {\n            l: lil.catcher.len(),\n            d: Some(T::from(lil.catcher.clone())),\n        }\n    } else {\n        let catcher = argv[0].d.as_ref().unwrap().to_string();\n        lil.catcher = if !catcher.is_empty() { catcher } else { String::new() };\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n}\n\n",
        "fnc_downeval": "pub fn fnc_downeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn fnc_eval_wrap<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    \n    let upenv = Rc::clone(&lil.env);\n    let downenv = Rc::clone(&lil.downenv);\n    if downenv.borrow().parent.is_none() {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.downenv = Rc::new(RefCell::new(LilEnv {\n        parent: None,\n        func: None,\n        catcher_for: LilValue { l: 0, d: None },\n        var: Vec::new(),\n        vars: 0,\n        varmap: HashMap { cell: Vec::new() },\n        retval: LilValue { l: 0, d: None },\n        retval_set: false,\n        breakrun: false,\n    }));\n    lil.env = Rc::clone(&downenv);\n    let r = fnc_eval_wrap(lil, argc, argv);\n    lil.downenv = downenv;\n    lil.env = upenv;\n    r\n}\n\n",
        "fnc_length": "pub fn fnc_length<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    fn lil_alloc_integer_wrap<T: Clone>(value: i64) -> LilValue<T> {\n        LilValue {\n            l: 0,\n            d: None,\n        }\n    }\n    let mut total = 0;\n    for (i, arg) in argv.iter().enumerate() {\n        if i != 0 {\n            total += 1;\n        }\n        let s = lil_to_string_wrap(arg);\n        total += s.len();\n    }\n    lil_alloc_integer_wrap(total as i64)\n}\n\n",
        "fnc_rtrim": "pub fn fnc_rtrim<T: Clone + Debug + FromStr>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(value: &LilValue<T>) -> String {\n        match &value.d {\n            Some(v) => format!(\"{:?}\", v),\n            None => String::new(),\n        }\n    }\n\n    fn real_trim(s: String, pat: String, _left: i32, _right: i32) -> LilValue<String> {\n        let trimmed = s.trim_end_matches(&pat[..]);\n        LilValue {\n            l: trimmed.len(),\n            d: Some(trimmed.to_string()),\n        }\n    }\n\n    if argc == 0 { return LilValue { l: 0, d: None }; }\n    let s = lil_to_string(&argv[0]);\n    let pat = if argc < 2 { \" \\u{000C}\\n\\r\\t\\u{000B}\".to_string() } else { lil_to_string(&argv[1]) };\n    let result = real_trim(s, pat, 0, 1);\n    LilValue { l: result.l, d: Some(result.d.unwrap().parse().ok().unwrap()) }\n}\n\n",
        "fnc_charat": "pub fn fnc_charat<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer<T: Clone + Debug>(val: &LilValue<T>) -> i64 {\n        match &val.d {\n            Some(d) => format!(\"{:?}\", d).parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_string<T: Clone>(s: &str) -> LilValue<T> {\n        LilValue {\n            l: s.len(),\n            d: None,\n        }\n    }\n\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    let str = lil_to_string(&argv[0]);\n    let index = lil_to_integer(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    let chstr = &str[index..=index];\n    lil_alloc_string(chstr)\n}\n\n",
        "fnc_eval": "pub fn fnc_eval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn alloc_value_wrap<T: Clone>(data: Option<T>) -> LilValue<T> {\n        LilValue { l: 0, d: data }\n    }\n    fn lil_append_char_wrap<T: Clone>(val: &mut LilValue<T>, ch: char) {}\n    fn lil_append_val_wrap<T: Clone>(val: &mut LilValue<T>, other: &LilValue<T>) {}\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc == 1 {\n        return lil_parse_value_wrap(lil, &argv[0], 0);\n    }\n    if argc > 1 {\n        let mut val = alloc_value_wrap::<T>(None);\n        let mut r;\n        for i in 0..argc {\n            if i != 0 {\n                lil_append_char_wrap(&mut val, ' ');\n            }\n            lil_append_val_wrap(&mut val, &argv[i]);\n        }\n        r = lil_parse_value_wrap(lil, &val, 0);\n        lil_free_value_wrap(val);\n        return r;\n    }\n    LilValue { l: 0, d: None }\n}\n\n",
        "fnc_write": "pub fn fnc_write<T: Clone + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let mut msg = String::new();\n    for i in 0..argc {\n        if i != 0 {\n            msg.push(' ');\n        }\n        msg.push_str(&argv[i].d.as_ref().unwrap().to_string());\n    }\n    println!(\"{}\", msg);\n    LilValue { l: 0, d: None }\n}\n\n",
        "fnc_try": "pub fn fnc_try<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    fn lil_parse_value_wrap<T: Clone>(lil: &mut LilStruct<T>, val: &LilValue<T>, depth: usize) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_free_value_wrap<T: Clone>(val: LilValue<T>) {}\n\n    if argc < 1 {\n        return None;\n    }\n    if lil.error != 0 {\n        return None;\n    }\n    let mut r = lil_parse_value_wrap(lil, &argv[0], 0);\n    if lil.error != 0 {\n        lil.error = 0;\n        lil_free_value_wrap(r.clone());\n        if argc > 1 {\n            r = lil_parse_value_wrap(lil, &argv[1], 0);\n        } else {\n            r = LilValue { l: 0, d: None };\n        }\n    }\n    Some(r)\n}\n\n",
        "fnc_read": "pub fn fnc_read<T: Clone + From<String> + AsRef<str>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let buffer;\n    if argc < 1 {\n        return None;\n    }\n    if let Some(proc) = lil.callback.get(2) {\n        let proc_wrap = |lil: &LilStruct<T>, name: &str| -> String {\n            let args = vec![LilValue { l: name.len(), d: Some(T::from(name.to_string())) }];\n            let result = proc(lil, \"read\", &args);\n            if let Some(s) = result.d {\n                return s.as_ref().to_string();\n            }\n            String::new()\n        };\n        buffer = proc_wrap(lil, argv[0].d.as_ref()?.as_ref());\n    } else {\n        let filename = argv[0].d.as_ref()?.as_ref();\n        let mut file = match std::fs::File::open(filename) {\n            Ok(f) => f,\n            Err(_) => return None,\n        };\n        let size = match file.metadata() {\n            Ok(m) => m.len() as usize,\n            Err(_) => return None,\n        };\n        let mut buf = vec![0; size];\n        if let Err(_) = file.read_exact(&mut buf) {\n            return None;\n        }\n        buffer = String::from_utf8_lossy(&buf).into_owned();\n    }\n    Some(LilValue { l: buffer.len(), d: Some(T::from(buffer)) })\n}\n\n",
        "fnc_result": "pub fn fnc_result<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc > 0 {\n        lil.env.borrow_mut().retval = argv[0].clone();\n        lil.env.borrow_mut().retval_set = true;\n    }\n    if lil.env.borrow().retval_set {\n        Some(lil.env.borrow().retval.clone())\n    } else {\n        None\n    }\n}\n\n",
        "fnc_append": "pub fn fnc_append<T: Clone + Debug + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let mut base = 1;\n    let mut access = 1;\n    let varname = argv[0].d.as_ref().unwrap().to_string();\n    let mut varname = if varname == \"global\" {\n        if argc < 3 { return LilValue { l: 0, d: None }; }\n        base = 2;\n        access = 0;\n        argv[1].d.as_ref().unwrap().to_string()\n    } else {\n        varname\n    };\n    let mut list = lil_subst_to_list(lil, lil_get_var(lil, &varname));\n    for i in base..argc {\n        lil_list_append(&mut list, argv[i].clone());\n    }\n    let r = lil_list_to_value(&list, 1);\n    lil_free_list(list);\n    lil_set_var(lil, &varname, r.clone(), access);\n    r\n}\n\n",
        "lil_get_var": "fn lil_get_var<T: Clone>(_lil: &LilStruct<T>, _name: &str) -> LilValue<T> {\n    LilValue { l: 0, d: None }\n}\n\n",
        "lil_subst_to_list": "fn lil_subst_to_list<T: Clone>(_lil: &LilStruct<T>, _val: LilValue<T>) -> LilList<T> {\n    LilList { items: Vec::new() }\n}\n\n",
        "fnc_quote": "pub fn fnc_quote<T: Clone + AsRef<str> + From<String>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 {\n        return None;\n    }\n    let mut r = LilValue { l: 0, d: None };\n    for i in 0..argc {\n        if i != 0 {\n            let lil_append_char_wrap = |r: &mut LilValue<T>, c: char| {\n                if let Some(ref mut data) = r.d {\n                    let mut s = String::new();\n                    s.push_str(data.as_ref());\n                    s.push(c);\n                    r.d = Some(T::from(s));\n                }\n            };\n            lil_append_char_wrap(&mut r, ' ');\n        }\n        let lil_append_val_wrap = |r: &mut LilValue<T>, val: &LilValue<T>| {\n            if let (Some(ref mut dst_data), Some(ref src_data)) = (&mut r.d, &val.d) {\n                let mut s = String::new();\n                s.push_str(dst_data.as_ref());\n                s.push_str(src_data.as_ref());\n                r.d = Some(T::from(s));\n            }\n        };\n        lil_append_val_wrap(&mut r, &argv[i]);\n    }\n    Some(r)\n}\n\n",
        "fnc_func": "pub fn fnc_func<T: Clone + Debug + From<String> + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: Vec<Rc<RefCell<LilValue<T>>>>) -> Rc<RefCell<LilValue<T>>> {\n    let name: Rc<RefCell<LilValue<T>>>;\n    let cmd: Rc<RefCell<LilFunc<T>>>;\n    let fargs: LilList<T>;\n    \n    fn lil_clone_value_wrap<T: Clone>(value: &Rc<RefCell<LilValue<T>>>) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new((*value.borrow()).clone()))\n    }\n    \n    fn lil_to_string_wrap<T: Clone + ToString>(value: &Rc<RefCell<LilValue<T>>>) -> String {\n        value.borrow().d.as_ref().map_or(String::new(), |v| v.to_string())\n    }\n    \n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, value: &Rc<RefCell<LilValue<T>>>) -> LilList<T> {\n        LilList { items: vec![Rc::clone(value)] }\n    }\n    \n    fn add_func_wrap<T: Clone>(_lil: &LilStruct<T>, name: &str) -> Rc<RefCell<LilFunc<T>>> {\n        Rc::new(RefCell::new(LilFunc {\n            name: name.to_string(),\n            code: LilValue { l: 0, d: None },\n            argnames: LilList { items: vec![] },\n            proc: None,\n        }))\n    }\n    \n    fn lil_unused_name_wrap<T: Clone>(_lil: &LilStruct<T>, prefix: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: None }))\n    }\n    \n    fn lil_alloc_string_wrap<T: Clone + From<String>>(s: &str) -> Rc<RefCell<LilValue<T>>> {\n        Rc::new(RefCell::new(LilValue { l: 0, d: Some(s.to_string().into()) }))\n    }\n\n    if argc < 1 {\n        return Rc::new(RefCell::new(LilValue { l: 0, d: None }));\n    }\n    if argc >= 3 {\n        name = lil_clone_value_wrap(&argv[0]);\n        fargs = lil_subst_to_list_wrap(lil, &argv[1]);\n        cmd = add_func_wrap(lil, &lil_to_string_wrap(&argv[0]));\n        cmd.borrow_mut().argnames = fargs;\n        cmd.borrow_mut().code = (*argv[2].borrow()).clone();\n    } else {\n        name = lil_unused_name_wrap(lil, \"anonymous-function\");\n        if argc < 2 {\n            let tmp = lil_alloc_string_wrap(\"args\");\n            fargs = lil_subst_to_list_wrap(lil, &tmp);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[0].borrow()).clone();\n        } else {\n            fargs = lil_subst_to_list_wrap(lil, &argv[0]);\n            cmd = add_func_wrap(lil, &lil_to_string_wrap(&name));\n            cmd.borrow_mut().argnames = fargs;\n            cmd.borrow_mut().code = (*argv[1].borrow()).clone();\n        }\n    }\n    name\n}\n\n",
        "fnc_slice": "pub fn fnc_slice<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_integer_wrap<T: Clone>(val: &LilValue<T>) -> i64 {\n        0\n    }\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_list_to_value_wrap<T: Clone>(list: &LilList<T>, _flag: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    \n    let mut from = lil_to_integer_wrap(&argv[1]);\n    if from < 0 { from = 0; }\n    \n    let list = lil_subst_to_list_wrap(lil, &argv[0]);\n    let mut to = if argc > 2 { lil_to_integer_wrap(&argv[2]) } else { list.items.len() as i64 };\n    if to > list.items.len() as i64 { to = list.items.len() as i64; }\n    if to < from { to = from; }\n    \n    let mut slice = LilList { items: Vec::new() };\n    for i in from as usize..to as usize {\n        slice.items.push(list.items[i].clone());\n    }\n    \n    let r = lil_list_to_value_wrap(&slice, 1);\n    r\n}\n\n",
        "fnc_inc": "pub fn fnc_inc<T: Clone + From<u32>>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    if argc < 1 { return None; }\n    let arg0 = if let Some(d) = &argv[0].d { d.clone() } else { return None; };\n    let arg1 = if argc > 1 { \n        if let Some(d) = &argv[1].d { d.clone() } else { return None; }\n    } else { T::from(1) };\n    Some(LilValue { l: 0, d: Some(arg0) })\n}\n\n",
        "fnc_rename": "pub fn fnc_rename<T: Clone + Debug + From<String>>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> Option<LilValue<T>> {\n    let oldname = lil_to_string(&argv[0]);\n    let newname = lil_to_string(&argv[1]);\n    if argc < 2 {\n        return None;\n    }\n\n    let func = find_cmd(lil, &oldname);\n    if func.is_none() {\n        let msg = format!(\"unknown function '{}'\", oldname);\n        lil_set_error_at(lil, lil.head, &msg);\n        return None;\n    }\n    let func = func.unwrap();\n\n    let r = lil_alloc_string(Some(func.borrow().name.clone()));\n    if !newname.is_empty() {\n        hm_put(&mut lil.cmdmap, &oldname, None);\n        hm_put(&mut lil.cmdmap, &newname, Some(func.clone()));\n        func.borrow_mut().name = newname.clone();\n    } else {\n        del_func(lil, &func);\n    }\n\n    r.map(|v| LilValue { l: v.l, d: v.d.map(|s| s.into()) })\n}\n\n",
        "lil_set_error_at": "fn lil_set_error_at<T: Clone>(lil: &mut LilStruct<T>, pos: usize, msg: &str) {\n}\n\n",
        "del_func": "fn del_func<T: Clone>(lil: &mut LilStruct<T>, func: &Rc<RefCell<LilFunc<T>>>) {\n}\n\n",
        "fnc_filter": "pub fn fnc_filter<T: Clone + Debug + ToString>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_subst_to_list_wrap<T: Clone>(_lil: &LilStruct<T>, _val: &LilValue<T>) -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_alloc_list_wrap<T: Clone>() -> LilList<T> {\n        LilList { items: Vec::new() }\n    }\n    fn lil_set_var_wrap<T: Clone>(_lil: &mut LilStruct<T>, _name: &str, _val: Rc<RefCell<LilValue<T>>>, _scope: i32) {}\n    fn lil_eval_expr_wrap<T: Clone>(_lil: &mut LilStruct<T>, _expr: &LilValue<T>) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n    fn lil_to_boolean_wrap<T: Clone>(_val: &LilValue<T>) -> bool {\n        false\n    }\n    fn lil_list_append_wrap<T: Clone>(_list: &mut LilList<T>, _val: Rc<RefCell<LilValue<T>>>) {}\n    fn lil_list_to_value_wrap<T: Clone>(_list: &LilList<T>, _deep: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let mut varname = \"x\".to_string();\n    let mut base = 0;\n    if argc < 1 { return LilValue { l: 0, d: None }; }\n    if argc < 2 { return argv[0].clone(); }\n    if argc > 2 {\n        base = 1;\n        varname = argv[0].d.as_ref().unwrap().to_string();\n    }\n\n    let list = lil_subst_to_list_wrap(lil, &argv[base]);\n    let mut filtered = lil_alloc_list_wrap();\n\n    for i in 0..list.items.len() {\n        if lil.env.borrow().breakrun { break; }\n        lil_set_var_wrap(lil, &varname, list.items[i].clone(), 3);\n        let r = lil_eval_expr_wrap(lil, &argv[base + 1]);\n        if lil_to_boolean_wrap(&r) {\n            lil_list_append_wrap(&mut filtered, list.items[i].clone());\n        }\n    }\n\n    let r = lil_list_to_value_wrap(&filtered, 1);\n    r\n}\n\n",
        "fnc_strpos": "pub fn fnc_strpos<T: Clone + From<i32> + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let hay;\n    let str;\n    let mut min = 0;\n    if argc < 2 {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    hay = argv[0].d.as_ref().unwrap().to_string();\n    if argc > 2 {\n        min = argv[2].d.as_ref().unwrap().to_string().parse::<usize>().unwrap();\n        if min >= hay.len() {\n            return LilValue { l: 0, d: Some(T::from(-1)) };\n        }\n    }\n    str = hay[min..].find(&argv[1].d.as_ref().unwrap().to_string());\n    if str.is_none() {\n        return LilValue { l: 0, d: Some(T::from(-1)) };\n    }\n    LilValue { l: 0, d: Some(T::from(str.unwrap() as i32)) }\n}\n\n",
        "fnc_store": "pub fn fnc_store<T: Clone + Debug>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + Debug>(val: &LilValue<T>) -> String {\n        if let Some(ref d) = val.d {\n            format!(\"{:?}\", d)\n        } else {\n            String::new()\n        }\n    }\n\n    if argc < 2 {\n        return LilValue { l: 0, d: None };\n    }\n    if let Some(proc) = lil.callback.get(3).copied() {\n        let name = lil_to_string_wrap(&argv[0]);\n        let data = lil_to_string_wrap(&argv[1]);\n        proc(lil, &name, &[argv[1].clone()]);\n    } else {\n        let filename = lil_to_string_wrap(&argv[0]);\n        let buffer = lil_to_string_wrap(&argv[1]);\n        if let Ok(mut file) = std::fs::File::create(&filename) {\n            let _ = std::io::Write::write_all(&mut file, buffer.as_bytes());\n        }\n    }\n    argv[1].clone()\n}\n\n",
        "fnc_unusedname": "pub fn fnc_unusedname(lil: &LilStruct<String>, argc: usize, argv: &[LilValue<String>]) -> LilValue<String> {\n    fn lil_to_string_wrap(val: &LilValue<String>) -> String {\n        match &val.d {\n            Some(v) => v.clone(),\n            None => String::new(),\n        }\n    }\n    fn lil_unused_name_wrap(lil: &LilStruct<String>, name: &str) -> LilValue<String> {\n        LilValue {\n            l: name.len(),\n            d: Some(name.to_string()),\n        }\n    }\n    let arg = if argc > 0 { lil_to_string_wrap(&argv[0]) } else { \"unusedname\".to_string() };\n    lil_unused_name_wrap(lil, &arg)\n}\n\n",
        "fnc_upeval": "pub fn fnc_upeval<T: Clone>(lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    let fnc_eval_wrap = |lil: &mut LilStruct<T>, argc: usize, argv: &[LilValue<T>]| -> LilValue<T> {\n        lil.empty.clone()\n    };\n    \n    let thisenv = Rc::clone(&lil.env);\n    let thisdownenv = Rc::clone(&lil.downenv);\n    let r;\n    if Rc::ptr_eq(&lil.rootenv, &thisenv) {\n        return fnc_eval_wrap(lil, argc, argv);\n    }\n    lil.env = match thisenv.borrow().parent.as_ref() {\n        Some(parent) => Rc::clone(parent),\n        None => Rc::clone(&thisenv),\n    };\n    lil.downenv = Rc::clone(&thisenv);\n    r = fnc_eval_wrap(lil, argc, argv);\n    lil.env = thisenv;\n    lil.downenv = thisdownenv;\n    r\n}\n\n",
        "fnc_codeat": "pub fn fnc_codeat<T: Clone + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    fn lil_to_string_wrap<T: Clone + ToString>(val: &LilValue<T>) -> String {\n        match &val.d {\n            Some(v) => v.to_string(),\n            None => String::new(),\n        }\n    }\n    \n    fn lil_to_integer_wrap<T: Clone + ToString>(val: &LilValue<T>) -> i32 {\n        match &val.d {\n            Some(v) => v.to_string().parse().unwrap_or(0),\n            None => 0,\n        }\n    }\n    \n    fn lil_alloc_integer_wrap<T: Clone>(val: i32) -> LilValue<T> {\n        LilValue { l: 0, d: None }\n    }\n\n    let index: usize;\n    let str: String;\n    if argc < 2 {\n        return lil.empty.clone();\n    }\n    str = lil_to_string_wrap(&argv[0]);\n    index = lil_to_integer_wrap(&argv[1]) as usize;\n    if index >= str.len() {\n        return lil.empty.clone();\n    }\n    lil_alloc_integer_wrap(str.chars().nth(index).unwrap() as i32)\n}\n\n",
        "fnc_substr": "pub fn fnc_substr<T: Clone + Debug + FromStr + ToString>(lil: &LilStruct<T>, argc: usize, argv: &[LilValue<T>]) -> LilValue<T> {\n    if argc < 2 { return LilValue { l: 0, d: None }; }\n    let str = match &argv[0].d {\n        Some(s) => s.to_string(),\n        None => return LilValue { l: 0, d: None },\n    };\n    if str.is_empty() { return LilValue { l: 0, d: None }; }\n    let slen = str.len();\n    let start = match argv[1].d.as_ref() {\n        Some(s) => s.to_string().parse::<usize>().unwrap_or(0),\n        None => 0,\n    };\n    let end = if argc > 2 {\n        match argv[2].d.as_ref() {\n            Some(s) => s.to_string().parse::<usize>().unwrap_or(slen),\n            None => slen,\n        }\n    } else { slen };\n    let end = if end > slen { slen } else { end };\n    if start >= end { return LilValue { l: 0, d: None }; }\n    let result = str.chars().skip(start).take(end - start).collect::<String>();\n    LilValue { l: result.len(), d: Some(result.parse().unwrap_or_else(|_| panic!(\"Failed to parse string\"))) }\n}\n\n",
        "lil_push_env": "pub fn lil_push_env<T: Clone>(lil: &mut LilStruct<T>) -> Rc<RefCell<LilEnv<T>>> {\n    let env = lil_alloc_env(Some(Rc::clone(&lil.env)));\n    lil.env = Rc::clone(&env);\n    env\n}\n\n",
        "lil_pop_env": "pub fn lil_pop_env<T: Clone>(lil: &mut LilStruct<T>) {\n    let parent = {\n        let env = lil.env.borrow();\n        env.parent.clone()\n    };\n    if let Some(next) = parent {\n        lil_free_env(Some(lil.env.clone()));\n        lil.env = next;\n    }\n}\n\n",
        "hm_init": "pub fn hm_init<T>(hm: &mut HashMap<T>) {\n    hm.cell.clear();\n}\n\n",
        "lil_to_integer": "pub fn lil_to_integer<T: Clone>(val: &LilValue<T>) -> i64 {\n    lil_to_string(val).parse::<i64>().unwrap_or(0)\n}\n\n",
        "lil_get_var_or": "pub fn lil_get_var_or<T: Clone + Debug>(lil: &LilStruct<T>, name: &str, defvalue: LilValue<T>) -> LilValue<T> {\n    let var = lil_find_var(lil, Rc::clone(&lil.env), name);\n    let var_clone = var.clone();\n    let mut retval = match var {\n        Some(v) => v.borrow().v.clone(),\n        None => defvalue,\n    };\n\n    if let Some(callback) = lil.callback.get(7) {\n        let is_root_env = match &var_clone {\n            Some(v) => Rc::ptr_eq(&v.borrow().env, &lil.rootenv),\n            None => true,\n        };\n        if is_root_env {\n            let newretval = callback(lil, name, &[retval.clone()]);\n            retval = newretval;\n        }\n    }\n\n    retval\n}\n\n",
        "lil_free": "pub fn lil_free<T: Clone>(lil: Option<Rc<RefCell<LilStruct<T>>>>) {\n    if lil.is_none() {\n        return;\n    }\n    let mut lil = lil.unwrap();\n    let mut lil = lil.borrow_mut();\n    lil.err_msg.clear();\n    lil_free_value(Some(Rc::new(RefCell::new(lil.empty.clone()))));\n    \n    let mut current_env = Some(lil.env.clone());\n    while let Some(env) = current_env {\n        let next = env.borrow().parent.clone();\n        lil_free_env(Some(env));\n        current_env = next;\n    }\n    \n    for i in 0..lil.cmds {\n        let cmd = lil.cmd[i].borrow();\n        if !cmd.argnames.items.is_empty() {\n            lil_free_list(cmd.argnames.clone());\n        }\n        lil_free_value(Some(Rc::new(RefCell::new(cmd.code.clone()))));\n    }\n    hm_destroy(&mut lil.cmdmap);\n    lil.cmd.clear();\n    lil.dollarprefix.clear();\n    lil.catcher.clear();\n}\n\n",
        "lil_callback": "pub fn lil_callback<T: Clone>(lil: &mut LilStruct<T>, cb: i32, proc: LilCallbackProc<T>) {\n    if cb < 0 || cb >= CALLBACKS as i32 { return; }\n    lil.callback[cb as usize] = proc;\n}\n\n",
        "lil_list_get": "pub fn lil_list_get<T: Clone>(list: Rc<RefCell<LilList<T>>>, index: usize) -> Option<Rc<RefCell<LilValue<T>>>> {\n    let list_ref = list.borrow();\n    if index >= list_ref.items.len() {\n        None\n    } else {\n        Some(list_ref.items[index].clone())\n    }\n}\n\n",
        "lil_list_size": "pub fn lil_list_size<T: Clone>(list: Rc<RefCell<LilList<T>>>) -> usize {\n    list.borrow().items.len()\n}\n\n",
        "lil_error": "pub fn lil_error<T: Clone>(lil: &mut LilStruct<T>, msg: &mut String, pos: &mut usize) -> i32 {\n    if lil.error == 0 {\n        return 0;\n    }\n    *msg = lil.err_msg.clone();\n    *pos = lil.err_head;\n    lil.error = 0;\n    1\n}\n\n",
        "ee_skip_spaces": "pub fn ee_skip_spaces<T: Clone>(ee: &mut LilStruct<T>) {\n    while ee.head < ee.clen && ee.code.chars().nth(ee.head).map_or(false, |c| c.is_whitespace()) {\n        ee.head += 1;\n    }\n}\n\n",
        "ee_numeric_element": "pub fn ee_numeric_element(ee: &mut Expreval) {\n    let mut fpart = 0;\n    let mut fpartlen = 1;\n    ee.type_ = ExprEvalType::Int;\n    while ee.head < ee.len && ee.code.chars().nth(ee.head).map_or(false, |c| c.is_whitespace()) {\n        ee.head += 1;\n    }\n    ee.ival = 0;\n    ee.dval = 0.0;\n    while ee.head < ee.len {\n        let c = ee.code.chars().nth(ee.head).unwrap();\n        if c == '.' {\n            if let ExprEvalType::Float = ee.type_ {\n                break;\n            }\n            ee.type_ = ExprEvalType::Float;\n            ee.head += 1;\n        } else if !c.is_digit(10) {\n            break;\n        }\n        match ee.type_ {\n            ExprEvalType::Int => {\n                ee.ival = ee.ival * 10 + (c.to_digit(10).unwrap() as i64);\n            }\n            ExprEvalType::Float => {\n                fpart = fpart * 10 + (c.to_digit(10).unwrap() as i64);\n                fpartlen *= 10;\n            }\n        }\n        ee.head += 1;\n    }\n    if let ExprEvalType::Float = ee.type_ {\n        ee.dval = ee.ival as f64 + (fpart as f64) / (fpartlen as f64);\n    }\n}\n\n",
        "ee_element": "pub fn ee_element(ee: &mut Expreval) {\n    if ee.code.chars().nth(ee.head).map_or(false, |c| c.is_digit(10)) {\n        ee_numeric_element(ee);\n        return;\n    }\n\n    ee.type_ = ExprEvalType::Int;\n    ee.ival = 1;\n    ee.dval = 1.0;\n}\n\n",
        "ee_invalidpunct": "pub fn ee_invalidpunct(ch: i32) -> bool {\n    let ch = ch as u8 as char;\n    ch.is_ascii_punctuation() && ch != '!' && ch != '~' && ch != '(' && ch != ')' && ch != '-' && ch != '+'\n}\n\n",
        "lil_alloc_double": "pub fn lil_alloc_double<T: Clone + FromStr>(num: f64) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    let buff = format!(\"{}\", num);\n    alloc_value(Some(buff))\n}\n\n",
        "lil_set_error": "pub fn lil_set_error<T: Clone>(lil: &mut LilStruct<T>, msg: &str) {\n    if lil.error != 0 {\n        return;\n    }\n    lil.err_msg = strclone(msg).unwrap_or_default();\n    lil.error = 2;\n    lil.err_head = 0;\n}\n\n",
        "lil_to_double": "pub fn lil_to_double<T: Clone>(val: &LilValue<T>) -> f64 {\n    lil_to_string(val).parse::<f64>().unwrap_or(0.0)\n}\n\n",
        "lil_write": "pub fn lil_write<T: Clone>(lil: &LilStruct<T>, msg: &str) {\n    if let Some(proc) = lil.callback.get(1) {\n        let empty_args: &[LilValue<T>] = &[];\n        proc(lil, msg, empty_args);\n    } else {\n        print!(\"{}\", msg);\n    }\n}\n\n",
        "real_trim": "pub fn real_trim(str: Option<String>, chars: Option<String>, left: bool, right: bool) -> Option<LilValue<String>> {\n    let mut base = 0;\n    let mut r: Option<LilValue<String>> = None;\n    \n    if let (Some(s), Some(c)) = (str.as_ref(), chars.as_ref()) {\n        if left {\n            while base < s.len() && c.contains(s.chars().nth(base).unwrap()) {\n                base += 1;\n            }\n            if !right {\n                let remaining_str = if base < s.len() { Some(s[base..].to_string()) } else { None };\n                r = lil_alloc_string(remaining_str);\n            }\n        }\n        \n        if right {\n            let mut s_clone = s[base..].to_string();\n            while !s_clone.is_empty() && c.contains(s_clone.chars().last().unwrap()) {\n                s_clone.pop();\n            }\n            r = lil_alloc_string(Some(s_clone));\n        }\n    }\n    \n    r\n}\n\n",
        "lil_unused_name": "pub fn lil_unused_name<T: Clone + Debug>(lil: &LilStruct<T>, part: &str) -> Option<LilValue<String>> {\n    let mut name = String::with_capacity(part.len() + 64);\n    for i in 0..usize::MAX {\n        name.clear();\n        name.push_str(\"!!un!\");\n        name.push_str(part);\n        name.push_str(\"!\");\n        name.push_str(&format!(\"{:09}\", i));\n        name.push_str(\"!nu!!\");\n        if find_cmd(lil, &name).is_some() {\n            continue;\n        }\n        if lil_find_var(lil, Rc::clone(&lil.env), &name).is_some() {\n            continue;\n        }\n        return lil_alloc_string(Some(name));\n    }\n    None\n}\n\n",
        "fnc_embed_write": "pub fn fnc_embed_write<T: Clone>(lil: &mut LilStruct<T>, msg: String) {\n    let len = msg.len() + 1;\n    lil.embed.reserve(len);\n    lil.embed.push_str(&msg);\n    lil.embedlen += len - 1;\n}\n\n",
        "lil_arg": "pub fn lil_arg<T: Clone>(argv: &[Rc<RefCell<LilValue<T>>>], index: usize) -> Option<Rc<RefCell<LilValue<T>>>> {\n    if !argv.is_empty() {\n        argv.get(index).cloned()\n    } else {\n        None\n    }\n}\n\n",
        "lil_freemem": "pub fn lil_freemem<T>(ptr: Option<Box<T>>) {\n}\n\n",
        "lil_get_data": "pub fn lil_get_data<T: Clone>(lil: &LilStruct<T>) -> &T {\n    &lil.data\n}\n\n",
        "lil_set_data": "pub fn lil_set_data<T: Clone>(lil: &mut LilStruct<T>, data: T) {\n    lil.data = data;\n}\n\n",
        "lil_alloc_string_len": "pub fn lil_alloc_string_len<T: Clone + FromStr>(str: Option<String>, len: usize) -> Option<LilValue<T>> \nwhere\n    <T as FromStr>::Err: Debug\n{\n    alloc_value_len(str, len)\n}\n\n"
    }
}