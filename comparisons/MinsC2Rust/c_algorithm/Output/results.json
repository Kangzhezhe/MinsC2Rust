{
    "hash-string": {
        "string_nocase_hash": "pub fn string_nocase_hash(string: &str) -> u32 {\n    let mut result: u32 = 5381;\n    let mut p = string.chars();\n\n    while let Some(c) = p.next() {\n        result = (result << 5) + result + c.to_ascii_lowercase() as u32;\n    }\n\n    result\n}\n\n",
        "extra": "// \u6d4b\u8bd5\u51fd\u6570\n\n// \u6d4b\u8bd5\u51fd\u6570\n\n\n// \u6d4b\u8bd5\u51fd\u6570"
    },
    "test-hash-functions": {
        "main": "fn main() {}\n\n",
        "extra": "// \u6d4b\u8bd5\u51fd\u6570\n\n// \u6d4b\u8bd5\u51fd\u6570\n\n\n// \u6d4b\u8bd5\u51fd\u6570",
        "test_pointer_hash": "pub fn test_pointer_hash() {\n    let value = 42;\n    let hash = pointer_hash(&value);\n    assert_eq!(hash, &value as *const i32 as usize as u32);\n}\n\n",
        "test_int_hash": "pub fn test_int_hash() {\n    let value: u64 = 42;\n    let result = int_hash(&value);\n    assert_eq!(result, 42);\n}\n\n"
    },
    "queue": {
        "queue_is_empty": "pub fn queue_is_empty<T>(queue: &Queue<T>) -> bool {\n    queue.head.is_none()\n}\n\n",
        "extra": "pub struct QueueEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<QueueEntry<T>>>,\n    pub next: Option<Box<QueueEntry<T>>>,\n}\n\nimpl<T> Clone for QueueEntry<T> where T: Clone {\n    fn clone(&self) -> Self {\n        QueueEntry {\n            data: self.data.clone(),\n            prev: self.prev.as_ref().map(|x| Box::new((**x).clone())),\n            next: self.next.as_ref().map(|x| Box::new((**x).clone())),\n        }\n    }\n}\n\npub struct Queue<T> {\n    pub head: Option<Box<QueueEntry<T>>>,\n    pub tail: Option<Box<QueueEntry<T>>>,\n}\n",
        "queue_push_head": "pub fn queue_push_head<T: Clone>(queue: &mut Queue<T>, data: T) -> bool {\n    let new_entry = Box::new(QueueEntry {\n        data,\n        prev: None,\n        next: queue.head.take(),\n    });\n\n    if let Some(ref mut head) = queue.head {\n        head.prev = Some(new_entry.clone());\n    } else {\n        queue.tail = Some(new_entry.clone());\n    }\n\n    queue.head = Some(new_entry);\n    true\n}\n\n",
        "queue_new": "pub fn queue_new<T>() -> Queue<T> {\n    Queue {\n        head: None,\n        tail: None,\n    }\n}\n\n",
        "queue_pop_head": "pub fn queue_pop_head<T>(queue: &mut Queue<T>) -> Option<T> where T: Clone {\n    if queue_is_empty(queue) {\n        return None;\n    }\n\n    let mut entry = queue.head.take().unwrap();\n    queue.head = entry.next.take();\n    let result = entry.data.clone();\n\n    if queue.head.is_none() {\n        queue.tail = None;\n    } else {\n        queue.head.as_mut().unwrap().prev = None;\n    }\n\n    Some(result)\n}\n\n",
        "queue_pop_tail": "pub fn queue_pop_tail<T>(queue: &mut Queue<T>) -> Option<T> where T: Clone {\n    if queue_is_empty(queue) {\n        return None;\n    }\n\n    let mut entry = queue.tail.take().unwrap();\n    queue.tail = entry.prev.take();\n    let result = entry.data.clone();\n\n    if queue.tail.is_none() {\n        queue.head = None;\n    } else {\n        queue.tail.as_mut().unwrap().next = None;\n    }\n\n    Some(result)\n}\n\n",
        "queue_push_tail": "pub fn queue_push_tail<T: Clone>(queue: &mut Queue<T>, data: T) -> bool {\n    let new_entry = Box::new(QueueEntry {\n        data,\n        prev: queue.tail.as_ref().map(|x| Box::new((**x).clone())),\n        next: None,\n    });\n\n    if queue.tail.is_none() {\n        queue.head = Some(new_entry.clone());\n        queue.tail = Some(new_entry);\n    } else {\n        if let Some(ref mut tail) = queue.tail {\n            tail.next = Some(new_entry.clone());\n        }\n        queue.tail = Some(new_entry);\n    }\n\n    true\n}\n\n",
        "queue_peek_head": "pub fn queue_peek_head<T>(queue: &Queue<T>) -> Option<T> where T: Clone {\n    if queue_is_empty(queue) {\n        None\n    } else {\n        queue.head.as_ref().map(|head| head.data.clone())\n    }\n}\n\n",
        "queue_peek_tail": "pub fn queue_peek_tail<T>(queue: &Queue<T>) -> Option<T> where T: Clone {\n    if queue_is_empty(queue) {\n        None\n    } else {\n        queue.tail.as_ref().map(|tail| tail.data.clone())\n    }\n}\n\n",
        "queue_free": "pub fn queue_free<T: Clone>(queue: &mut Queue<T>) {\n    while !queue_is_empty(queue) {\n        queue_pop_head(queue);\n    }\n}\n\n"
    },
    "test-queue": {
        "main": "fn main(){}\n",
        "extra": "",
        "generate_queue": "pub fn generate_queue() -> Queue<i32> {\n    let mut queue = queue_new::<i32>();\n    let variable1 = 0;\n    let variable2 = 1;\n    let variable3 = 2;\n    let variable4 = 3;\n\n    for _ in 0..1000 {\n        queue_push_head(&mut queue, variable1);\n        queue_push_head(&mut queue, variable2);\n        queue_push_head(&mut queue, variable3);\n        queue_push_head(&mut queue, variable4);\n    }\n\n    queue\n}\n\n",
        "test_queue_pop_head": "pub fn test_queue_pop_head() {\n    let mut queue: Queue<i32> = queue_new();\n\n    assert!(queue_pop_head(&mut queue).is_none());\n\n    queue_free(&mut queue);\n\n    let mut queue = generate_queue();\n\n    while !queue_is_empty(&queue) {\n        assert_eq!(queue_pop_head(&mut queue), Some(3));\n        assert_eq!(queue_pop_head(&mut queue), Some(2));\n        assert_eq!(queue_pop_head(&mut queue), Some(1));\n        assert_eq!(queue_pop_head(&mut queue), Some(0));\n    }\n\n    assert!(queue_pop_head(&mut queue).is_none());\n\n    queue_free(&mut queue);\n}\n\n",
        "test_queue_pop_tail": "pub fn test_queue_pop_tail() {\n    let mut queue: Queue<i32> = queue_new();\n\n    assert!(queue_pop_tail(&mut queue).is_none());\n\n    queue_free(&mut queue);\n\n    let mut queue = generate_queue();\n\n    while !queue_is_empty(&queue) {\n        assert_eq!(queue_pop_tail(&mut queue), Some(0));\n        assert_eq!(queue_pop_tail(&mut queue), Some(1));\n        assert_eq!(queue_pop_tail(&mut queue), Some(2));\n        assert_eq!(queue_pop_tail(&mut queue), Some(3));\n    }\n\n    assert!(queue_pop_tail(&mut queue).is_none());\n\n    queue_free(&mut queue);\n}\n\n",
        "test_queue_new_free": "pub fn test_queue_new_free() {\n    let mut queue: Queue<i32> = queue_new();\n\n    queue_free(&mut queue);\n\n    queue = queue_new();\n\n    for i in 0..1000 {\n        queue_push_head(&mut queue, i);\n    }\n\n    queue_free(&mut queue);\n}\n\n",
        "test_queue_is_empty": "pub fn test_queue_is_empty() {\n    let mut queue = queue_new::<i32>();\n\n    assert!(queue_is_empty(&queue));\n\n    let variable1 = 1;\n    queue_push_head(&mut queue, variable1);\n\n    assert!(!queue_is_empty(&queue));\n\n    queue_pop_head(&mut queue);\n\n    assert!(queue_is_empty(&queue));\n\n    queue_push_tail(&mut queue, variable1);\n\n    assert!(!queue_is_empty(&queue));\n\n    queue_pop_tail(&mut queue);\n\n    assert!(queue_is_empty(&queue));\n\n    queue_free(&mut queue);\n}\n\n",
        "test_queue_peek_head": "pub fn test_queue_peek_head() {\n    let mut queue = queue_new::<i32>();\n\n    assert!(queue_peek_head(&queue).is_none());\n\n    queue_free(&mut queue);\n\n    let mut queue = generate_queue();\n\n    while !queue_is_empty(&queue) {\n        assert_eq!(queue_peek_head(&queue), Some(3));\n        assert_eq!(queue_pop_head(&mut queue), Some(3));\n        assert_eq!(queue_peek_head(&queue), Some(2));\n        assert_eq!(queue_pop_head(&mut queue), Some(2));\n        assert_eq!(queue_peek_head(&queue), Some(1));\n        assert_eq!(queue_pop_head(&mut queue), Some(1));\n        assert_eq!(queue_peek_head(&queue), Some(0));\n        assert_eq!(queue_pop_head(&mut queue), Some(0));\n    }\n\n    assert!(queue_peek_head(&queue).is_none());\n\n    queue_free(&mut queue);\n}\n\n",
        "test_queue_push_tail": "pub fn test_queue_push_tail() {\n    let mut queue = queue_new();\n    let variable1 = 1;\n    let variable2 = 2;\n    let variable3 = 3;\n    let variable4 = 4;\n\n    for _ in 0..1000 {\n        queue_push_tail(&mut queue, &variable1);\n        queue_push_tail(&mut queue, &variable2);\n        queue_push_tail(&mut queue, &variable3);\n        queue_push_tail(&mut queue, &variable4);\n    }\n\n    assert!(!queue_is_empty(&queue));\n\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable1));\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable2));\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable3));\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable4));\n\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable4));\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable3));\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable2));\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable1));\n\n    queue_free(&mut queue);\n\n    let mut queue = queue_new();\n    assert!(!queue_push_tail(&mut queue, &variable1));\n    queue_free(&mut queue);\n}\n\n",
        "test_queue_push_head": "pub fn test_queue_push_head() {\n    let mut queue = queue_new();\n    let variable1 = 1;\n    let variable2 = 2;\n    let variable3 = 3;\n    let variable4 = 4;\n\n    for _ in 0..1000 {\n        queue_push_head(&mut queue, &variable1);\n        queue_push_head(&mut queue, &variable2);\n        queue_push_head(&mut queue, &variable3);\n        queue_push_head(&mut queue, &variable4);\n    }\n\n    assert!(!queue_is_empty(&queue));\n\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable1));\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable2));\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable3));\n    assert_eq!(queue_pop_tail(&mut queue), Some(&variable4));\n\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable4));\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable3));\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable2));\n    assert_eq!(queue_pop_head(&mut queue), Some(&variable1));\n\n    queue_free(&mut queue);\n\n    let mut queue = queue_new();\n    assert!(!queue_push_head(&mut queue, &variable1));\n    queue_free(&mut queue);\n}\n\n",
        "test_queue_peek_tail": "pub fn test_queue_peek_tail() {\n    let mut queue = queue_new::<i32>();\n\n    // Check peeking into an empty queue\n    assert!(queue_peek_tail(&queue).is_none());\n\n    queue_free(&mut queue);\n\n    // Pop off all the values from the queue, making sure that peek\n    // has the correct value beforehand\n    let mut queue = generate_queue();\n\n    while !queue_is_empty(&queue) {\n        assert_eq!(queue_peek_tail(&queue), Some(0));\n        assert_eq!(queue_pop_tail(&mut queue), Some(0));\n        assert_eq!(queue_peek_tail(&queue), Some(1));\n        assert_eq!(queue_pop_tail(&mut queue), Some(1));\n        assert_eq!(queue_peek_tail(&queue), Some(2));\n        assert_eq!(queue_pop_tail(&mut queue), Some(2));\n        assert_eq!(queue_peek_tail(&queue), Some(3));\n        assert_eq!(queue_pop_tail(&mut queue), Some(3));\n    }\n\n    assert!(queue_peek_tail(&queue).is_none());\n\n    queue_free(&mut queue);\n}\n\n"
    },
    "compare-string": {
        "string_nocase_compare": "pub fn string_nocase_compare(string1: &str, string2: &str) -> i32 {\n    let mut p1 = string1.chars();\n    let mut p2 = string2.chars();\n\n    loop {\n        let c1 = p1.next().map(|c| c.to_ascii_lowercase());\n        let c2 = p2.next().map(|c| c.to_ascii_lowercase());\n\n        match (c1, c2) {\n            (Some(c1), Some(c2)) => {\n                if c1 != c2 {\n                    return if c1 < c2 { -1 } else { 1 };\n                }\n            }\n            (Some(_), None) => return 1,\n            (None, Some(_)) => return -1,\n            (None, None) => return 0,\n        }\n    }\n}\n\n",
        "extra": "",
        "string_compare": "pub fn string_compare(string1: &str, string2: &str) -> i32 {\n    let result = string1.cmp(string2);\n\n    match result {\n        std::cmp::Ordering::Less => -1,\n        std::cmp::Ordering::Greater => 1,\n        std::cmp::Ordering::Equal => 0,\n    }\n}\n\n",
        "string_nocase_equal": "pub fn string_nocase_equal(string1: &str, string2: &str) -> bool {\n    string_nocase_compare(string1, string2) == 0\n}\n\n",
        "string_equal": "pub fn string_equal<T: AsRef<str>>(string1: T, string2: T) -> bool {\n    string1.as_ref() == string2.as_ref()\n}\n\n"
    },
    "test-compare-functions": {
        "main": "fn main(){}\n",
        "extra": "",
        "test_string_compare": "pub fn test_string_compare() {\n    let test1 = \"Apple\";\n    let test2 = \"Orange\";\n    let test3 = \"Apple\";\n\n    assert!(string_compare(test1, test2) < 0);\n    assert!(string_compare(test2, test1) > 0);\n    assert!(string_compare(test1, test3) == 0);\n}\n\n",
        "test_string_nocase_compare": "pub fn test_string_nocase_compare() {\n    let test1 = \"Apple\";\n    let test2 = \"Orange\";\n    let test3 = \"Apple\";\n    let test4 = \"Alpha\";\n    let test5 = \"bravo\";\n    let test6 = \"Charlie\";\n\n    // Negative if first argument should be sorted before the second\n    assert!(string_nocase_compare(test1, test2) < 0);\n\n    // Positive if the second argument should be sorted before the first\n    assert!(string_nocase_compare(test2, test1) > 0);\n\n    // Zero if the two arguments are equal\n    assert!(string_nocase_compare(test1, test3) == 0);\n\n    // Check ordering is independent of case\n    assert!(string_nocase_compare(test4, test5) < 0);\n    assert!(string_nocase_compare(test5, test6) < 0);\n}\n\n",
        "test_string_nocase_equal": "pub fn test_string_nocase_equal() {\n    let test1 = \"this is a test string\";\n    let test2 = \"this is a test string \";\n    let test3 = \"this is a test strin\";\n    let test4 = \"this is a test strinG\";\n    let test5 = \"this is a test string\";\n\n    // Non-zero (true) if the two strings are equal\n    assert!(string_nocase_equal(test1, test5));\n\n    // Zero (false) if the two strings are different\n\n    // Check that length affects the result\n    assert!(!string_nocase_equal(test1, test2));\n    assert!(!string_nocase_equal(test1, test3));\n\n    // Case insensitive\n    assert!(string_nocase_equal(test1, test4));\n}\n\n",
        "test_int_compare": "pub fn test_int_compare() {\n    let mut a = 4;\n    let mut b = 8;\n    let mut c = 4;\n\n    // If first is less than second, result is negative\n    assert!(int_compare(&a, &b) < 0);\n\n    // If first is more than second, result is positive\n    assert!(int_compare(&b, &a) > 0);\n\n    // If both are equal, result is zero\n    assert!(int_compare(&a, &c) == 0);\n}\n\n",
        "test_int_equal": "pub fn test_int_equal() {\n    let mut a: i32 = 4;\n    let mut b: i32 = 8;\n    let mut c: i32 = 4;\n\n    assert!(int_equal(&a, &c));\n    assert!(!int_equal(&a, &b));\n}\n\n",
        "test_pointer_equal": "pub fn test_pointer_equal() {\n    let mut a = 0;\n    let mut b = 0;\n\n    // Non-zero (true) if the two pointers are equal\n    assert!(pointer_equal(&a, &a));\n\n    // Zero (false) if the two pointers are not equal\n    assert!(!pointer_equal(&a, &b));\n}\n\n",
        "test_pointer_compare": "pub fn test_pointer_compare() {\n    let mut array = [0; 5];\n\n    // Negative if first argument is a lower memory address than the second\n    assert!(pointer_compare(&array[0], &array[4]) < 0);\n\n    // Positive if the first argument is a higher memory address than the second\n    assert!(pointer_compare(&array[3], &array[2]) > 0);\n\n    // Zero if the two arguments are equal\n    assert!(pointer_compare(&array[4], &array[4]) == 0);\n}\n\n",
        "test_string_equal": "pub fn test_string_equal() {\n    let test1 = \"this is a test string\";\n    let test2 = \"this is a test string \";\n    let test3 = \"this is a test strin\";\n    let test4 = \"this is a test strinG\";\n    let test5 = \"this is a test string\";\n\n    assert!(string_equal(test1, test5));\n\n    assert!(!string_equal(test1, test2));\n    assert!(!string_equal(test1, test3));\n    assert!(!string_equal(test1, test4));\n}\n\n"
    },
    "avl-tree": {
        "avl_tree_subtree_height": "pub fn avl_tree_subtree_height<T: Clone>(node: Option<&Box<AVLTreeNode<T>>>) -> i32 {\n    match node {\n        None => 0,\n        Some(n) => n.height,\n    }\n}\n\n",
        "extra": "use std::cmp::Ordering;\n\npub struct AVLTree<T: Clone> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>,\n    pub compare_func: fn(&T, &T) -> i32,\n    pub num_nodes: u32,\n}\n\n#[derive(PartialEq, Clone)]\npub struct AVLTreeNode<T: Clone> {\n    pub left: Option<Box<AVLTreeNode<T>>>,\n    pub right: Option<Box<AVLTreeNode<T>>>,\n    pub parent: Option<Box<AVLTreeNode<T>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\n#[derive(Clone, Copy)]\npub enum AVLTreeNodeSide {\n    Left = 0,\n    Right = 1,\n}",
        "avl_tree_update_height": "pub fn avl_tree_update_height<T: Clone>(node: &mut AVLTreeNode<T>) {\n    let left_subtree = node.left.as_ref();\n    let right_subtree = node.right.as_ref();\n    \n    let left_height = avl_tree_subtree_height(left_subtree);\n    let right_height = avl_tree_subtree_height(right_subtree);\n    \n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\n",
        "avl_tree_node_parent_side": "pub fn avl_tree_node_parent_side<T: Clone + PartialEq>(node: &Box<AVLTreeNode<T>>) -> AVLTreeNodeSide {\n    let parent = node.parent.as_ref().unwrap();\n    if parent.left.as_ref().unwrap().as_ref() == node.as_ref() {\n        AVLTreeNodeSide::Left\n    } else {\n        AVLTreeNodeSide::Right\n    }\n}\n\n",
        "avl_tree_node_replace": "pub fn avl_tree_node_replace<T: PartialEq + Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, mut node2: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(ref mut node2) = node2 {\n        node2.parent = node1.parent.clone();\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2;\n    } else {\n        let mut parent = node1.parent.clone();\n        let side = avl_tree_node_parent_side(&Box::new(AVLTreeNode {\n            left: None,\n            right: None,\n            parent: parent.clone(),\n            key: node1.key.clone(),\n            value: node1.value.clone(),\n            height: node1.height,\n        }));\n        match side {\n            AVLTreeNodeSide::Left => parent.as_mut().unwrap().left = node2,\n            AVLTreeNodeSide::Right => parent.as_mut().unwrap().right = node2,\n        }\n\n        avl_tree_update_height(parent.as_mut().unwrap());\n    }\n}\n\n",
        "avl_tree_rotate": "pub fn avl_tree_rotate<T: PartialEq + Clone>(\n    tree: &mut AVLTree<T>,\n    node: &mut AVLTreeNode<T>,\n    direction: AVLTreeNodeSide,\n) -> Box<AVLTreeNode<T>> {\n    let direction_clone = direction;\n    let mut new_root = match direction_clone {\n        AVLTreeNodeSide::Left => node.right.take().unwrap(),\n        AVLTreeNodeSide::Right => node.left.take().unwrap(),\n    };\n\n    avl_tree_node_replace(tree, node, Some(new_root.clone()));\n\n    match direction_clone {\n        AVLTreeNodeSide::Left => {\n            node.right = new_root.left.take();\n            new_root.left = Some(Box::new(node.clone()));\n        },\n        AVLTreeNodeSide::Right => {\n            node.left = new_root.right.take();\n            new_root.right = Some(Box::new(node.clone()));\n        },\n    }\n\n    node.parent = Some(new_root.clone());\n\n    let node_clone = node.clone();\n    if let Some(mut child) = match direction_clone {\n        AVLTreeNodeSide::Left => node.right.as_mut(),\n        AVLTreeNodeSide::Right => node.left.as_mut(),\n    } {\n        child.parent = Some(Box::new(node_clone));\n    }\n\n    avl_tree_update_height(&mut new_root);\n    avl_tree_update_height(node);\n\n    new_root\n}\n\n",
        "avl_tree_node_balance": "pub fn avl_tree_node_balance<T: PartialEq + Clone>(\n    tree: &mut AVLTree<T>,\n    node: &mut AVLTreeNode<T>,\n) -> Box<AVLTreeNode<T>> {\n    let left_subtree = node.left.as_ref();\n    let right_subtree = node.right.as_ref();\n\n    let diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let mut child = node.right.as_mut().unwrap();\n\n        if avl_tree_subtree_height(child.right.as_ref())\n            < avl_tree_subtree_height(child.left.as_ref())\n        {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::Right);\n        }\n\n        let mut node_clone = node.clone();\n        let mut new_node = avl_tree_rotate(tree, &mut node_clone, AVLTreeNodeSide::Left);\n        avl_tree_update_height(&mut new_node);\n        return new_node;\n    } else if diff <= -2 {\n        let mut child = node.left.as_mut().unwrap();\n\n        if avl_tree_subtree_height(child.left.as_ref())\n            < avl_tree_subtree_height(child.right.as_ref())\n        {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::Left);\n        }\n\n        let mut node_clone = node.clone();\n        let mut new_node = avl_tree_rotate(tree, &mut node_clone, AVLTreeNodeSide::Right);\n        avl_tree_update_height(&mut new_node);\n        return new_node;\n    }\n\n    avl_tree_update_height(node);\n    Box::new(node.clone())\n}\n\n",
        "avl_tree_balance_to_root": "pub fn avl_tree_balance_to_root<T: PartialEq + Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Box::new(node.clone());\n\n    while rover.parent.is_some() {\n        let mut balanced_node = avl_tree_node_balance(tree, &mut rover);\n        rover = balanced_node.parent.take().unwrap();\n    }\n}\n\n",
        "avl_tree_node_get_replacement": "pub fn avl_tree_node_get_replacement<T: PartialEq + Clone>(\n    tree: &mut AVLTree<T>,\n    node: &mut AVLTreeNode<T>,\n) -> Option<Box<AVLTreeNode<T>>> {\n    let left_subtree = node.left.as_ref();\n    let right_subtree = node.right.as_ref();\n\n    if left_subtree.is_none() && right_subtree.is_none() {\n        return None;\n    }\n\n    let left_height = avl_tree_subtree_height(left_subtree);\n    let right_height = avl_tree_subtree_height(right_subtree);\n\n    let side = if left_height < right_height {\n        AVLTreeNodeSide::Right\n    } else {\n        AVLTreeNodeSide::Left\n    };\n\n    let mut result = match side {\n        AVLTreeNodeSide::Left => node.left.clone(),\n        AVLTreeNodeSide::Right => node.right.clone(),\n    };\n\n    while result.as_ref().unwrap().left.is_some() || result.as_ref().unwrap().right.is_some() {\n        result = match side {\n            AVLTreeNodeSide::Left => result.unwrap().left.clone(),\n            AVLTreeNodeSide::Right => result.unwrap().right.clone(),\n        };\n    }\n\n    let child = match side {\n        AVLTreeNodeSide::Left => result.as_ref().unwrap().left.clone(),\n        AVLTreeNodeSide::Right => result.as_ref().unwrap().right.clone(),\n    };\n    avl_tree_node_replace(tree, result.as_mut().unwrap(), child);\n\n    avl_tree_update_height(result.as_mut().unwrap().parent.as_mut().unwrap());\n\n    result\n}\n\n",
        "avl_tree_node_key": "pub fn avl_tree_node_key<T>(node: &AVLTreeNode<T>) -> T \nwhere\n    T: Clone,\n{\n    node.key.clone()\n}\n\n",
        "avl_tree_node_parent": "pub fn avl_tree_node_parent<T: Clone>(node: &Box<AVLTreeNode<T>>) -> Option<Box<AVLTreeNode<T>>> {\n    node.parent.as_ref().map(|parent| Box::new((**parent).clone()))\n}\n\n",
        "avl_tree_node_child": "pub fn avl_tree_node_child<T: Clone>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> Option<&Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::Left => node.left.as_ref(),\n        AVLTreeNodeSide::Right => node.right.as_ref(),\n    }\n}\n\n",
        "avl_tree_free_subtree": "pub fn avl_tree_free_subtree<T: Clone>(tree: &mut AVLTree<T>, node: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(mut node) = node {\n        avl_tree_free_subtree(tree, node.left.take());\n        avl_tree_free_subtree(tree, node.right.take());\n    }\n}\n\n",
        "avl_tree_insert": "pub fn avl_tree_insert<T: PartialEq + Clone>(\n    tree: &mut AVLTree<T>,\n    key: T,\n    value: T,\n) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node: Option<Box<AVLTreeNode<T>>> = None;\n\n    while let Some(ref mut node) = rover {\n        previous_node = Some(node.clone());\n        if (tree.compare_func)(&key, &node.key) < 0 {\n            rover = &mut node.left;\n        } else {\n            rover = &mut node.right;\n        }\n    }\n\n    let mut new_node = Box::new(AVLTreeNode {\n        left: None,\n        right: None,\n        parent: previous_node.clone(),\n        key: key.clone(),\n        value: value.clone(),\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(ref mut prev_node) = previous_node {\n        avl_tree_balance_to_root(tree, prev_node);\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\n",
        "avl_tree_new": "pub fn avl_tree_new<T: Clone>(compare_func: fn(&T, &T) -> i32) -> Option<AVLTree<T>> {\n    let new_tree = AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\n",
        "avl_tree_lookup_node": "pub fn avl_tree_lookup_node<T: Clone>(tree: &AVLTree<T>, key: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut node = tree.root_node.clone();\n\n    while let Some(ref current_node) = node {\n        let diff = (tree.compare_func)(&key, &current_node.key);\n\n        match diff.cmp(&0) {\n            Ordering::Equal => return node,\n            Ordering::Less => node = current_node.left.clone(),\n            Ordering::Greater => node = current_node.right.clone(),\n        }\n    }\n\n    None\n}\n\n",
        "avl_tree_remove_node": "pub fn avl_tree_remove_node<T: PartialEq + Clone>(\n    tree: &mut AVLTree<T>,\n    node: &mut AVLTreeNode<T>,\n) {\n    let mut swap_node = avl_tree_node_get_replacement(tree, node);\n\n    let mut balance_startpoint: Option<Box<AVLTreeNode<T>>>;\n\n    if swap_node.is_none() {\n        avl_tree_node_replace(tree, node, None);\n        balance_startpoint = node.parent.clone();\n    } else {\n        let mut swap_node = swap_node.unwrap();\n\n        if swap_node.parent.as_ref().unwrap().as_ref() == node {\n            balance_startpoint = Some(swap_node.clone());\n        } else {\n            balance_startpoint = swap_node.parent.clone();\n        }\n\n        let children = [\n            node.left.clone(),\n            node.right.clone(),\n        ];\n\n        for i in 0..2 {\n            let mut child = children[i].clone();\n            if let Some(ref mut child) = child {\n                child.parent = Some(swap_node.clone());\n            }\n            match i {\n                0 => swap_node.left = child,\n                1 => swap_node.right = child,\n                _ => (),\n            }\n        }\n\n        swap_node.height = node.height;\n\n        avl_tree_node_replace(tree, node, Some(swap_node));\n    }\n\n    tree.num_nodes -= 1;\n\n    if let Some(ref mut balance_startpoint) = balance_startpoint {\n        avl_tree_balance_to_root(tree, balance_startpoint.as_mut());\n    }\n}\n\n",
        "avl_tree_root_node": "pub fn avl_tree_root_node<T: Clone>(tree: &AVLTree<T>) -> Option<&Box<AVLTreeNode<T>>> {\n    tree.root_node.as_ref()\n}\n\n",
        "avl_tree_to_array_add_subtree": "pub fn avl_tree_to_array_add_subtree<T: Clone>(\n    subtree: Option<Box<AVLTreeNode<T>>>,\n    array: &mut Vec<T>,\n    index: &mut usize,\n) {\n    if subtree.is_none() {\n        return;\n    }\n\n    let subtree = subtree.unwrap();\n\n    // Add left subtree first\n    avl_tree_to_array_add_subtree(subtree.left, array, index);\n\n    // Add this node\n    array[*index] = subtree.key.clone();\n    *index += 1;\n\n    // Finally add right subtree\n    avl_tree_to_array_add_subtree(subtree.right, array, index);\n}\n\n",
        "avl_tree_free": "pub fn avl_tree_free<T: Clone>(tree: &mut AVLTree<T>) {\n    let root_node = tree.root_node.take();\n    avl_tree_free_subtree(tree, root_node);\n}\n\n",
        "avl_tree_num_entries": "pub fn avl_tree_num_entries<T: Clone>(tree: &AVLTree<T>) -> u32 {\n    tree.num_nodes\n}\n\n",
        "avl_tree_remove": "pub fn avl_tree_remove<T: PartialEq + Clone>(tree: &mut AVLTree<T>, key: T) -> bool {\n    let node = avl_tree_lookup_node(tree, key);\n\n    if node.is_none() {\n        return false;\n    }\n\n    let mut node = node.unwrap();\n    avl_tree_remove_node(tree, &mut node);\n\n    true\n}\n\n",
        "avl_tree_node_value": "pub fn avl_tree_node_value<T: Clone>(node: &AVLTreeNode<T>) -> T {\n    node.value.clone()\n}\n\n",
        "avl_tree_to_array": "pub fn avl_tree_to_array<T: Clone>(tree: &AVLTree<T>) -> Option<Vec<T>> {\n    let mut array = Vec::with_capacity(tree.num_nodes as usize);\n    let mut index = 0;\n\n    avl_tree_to_array_add_subtree(tree.root_node.clone(), &mut array, &mut index);\n\n    Some(array)\n}\n\n",
        "avl_tree_lookup": "pub fn avl_tree_lookup<T: Clone>(tree: &AVLTree<T>, key: T) -> Option<T> {\n    let node = avl_tree_lookup_node(tree, key);\n\n    match node {\n        Some(n) => Some(n.value.clone()),\n        None => None,\n    }\n}\n\n"
    },
    "test-avl-tree": {
        "main": "fn main(){}\n\n",
        "extra": "",
        "find_subtree_height": "pub fn find_subtree_height<T: Clone>(node: Option<&Box<AVLTreeNode<T>>>) -> i32 {\n    let mut left_height = 0;\n    let mut right_height = 0;\n\n    if node.is_none() {\n        return 0;\n    }\n\n    let node = node.unwrap();\n\n    let left_subtree = avl_tree_node_child(node, AVLTreeNodeSide::Left);\n    let right_subtree = avl_tree_node_child(node, AVLTreeNodeSide::Right);\n\n    left_height = find_subtree_height(left_subtree);\n    right_height = find_subtree_height(right_subtree);\n\n    if left_height > right_height {\n        left_height + 1\n    } else {\n        right_height + 1\n    }\n}\n\n",
        "validate_subtree": "pub fn validate_subtree<T: Clone + PartialOrd + Default>(node: Option<&Box<AVLTreeNode<T>>>, counter: &mut T) -> i32 {\n    if node.is_none() {\n        return 0;\n    }\n\n    let node = node.unwrap();\n    let left_node = avl_tree_node_child(node, AVLTreeNodeSide::Left);\n    let right_node = avl_tree_node_child(node, AVLTreeNodeSide::Right);\n\n    if let Some(left_node) = left_node {\n        assert!(avl_tree_node_parent(left_node).as_ref().map(|p| &**p) == Some(&**node));\n    }\n\n    if let Some(right_node) = right_node {\n        assert!(avl_tree_node_parent(right_node).as_ref().map(|p| &**p) == Some(&**node));\n    }\n\n    let left_height = validate_subtree(left_node, counter);\n\n    let key = avl_tree_node_key(node);\n    assert!(key > *counter);\n    *counter = key.clone();\n\n    let right_height = validate_subtree(right_node, counter);\n\n    assert!(avl_tree_subtree_height(left_node) == left_height);\n    assert!(avl_tree_subtree_height(right_node) == right_height);\n\n    assert!(left_height - right_height < 2 && right_height - left_height < 2);\n\n    if left_height > right_height {\n        left_height + 1\n    } else {\n        right_height + 1\n    }\n}\n\n",
        "create_tree": "pub fn create_tree() -> Option<AVLTree<i32>> {\n    let mut tree = avl_tree_new(|a: &i32, b: &i32| a.cmp(b) as i32)?;\n    let mut test_array: [i32; 1000] = [0; 1000];\n\n    for i in 0..1000 {\n        test_array[i] = i as i32;\n        avl_tree_insert(&mut tree, test_array[i], test_array[i]);\n    }\n\n    Some(tree)\n}\n\n",
        "validate_tree": "pub fn validate_tree<T: Clone + PartialOrd + Default>(tree: &AVLTree<T>) {\n    let mut counter: T = Default::default();\n    let root_node = avl_tree_root_node(tree);\n\n    if let Some(root_node) = root_node {\n        let height = find_subtree_height(Some(root_node));\n        assert_eq!(avl_tree_subtree_height(Some(root_node)), height);\n    }\n\n    validate_subtree(root_node, &mut counter);\n}\n\n",
        "test_avl_tree_remove": "pub fn test_avl_tree_remove() {\n    let mut tree = create_tree().unwrap();\n\n    // Try removing invalid entries\n    let mut i = 1000 + 100;\n    assert!(!avl_tree_remove(&mut tree, i));\n    i = -1;\n    assert!(!avl_tree_remove(&mut tree, i));\n\n    // Delete the nodes from the tree\n    let mut expected_entries = 1000;\n\n    // This looping arrangement causes nodes to be removed in a\n    // randomish fashion from all over the tree.\n    for x in 0..10 {\n        for y in 0..10 {\n            for z in 0..10 {\n                let value = z * 100 + (9 - y) * 10 + x;\n                assert!(avl_tree_remove(&mut tree, value));\n                validate_tree(&tree);\n                expected_entries -= 1;\n                assert_eq!(avl_tree_num_entries(&tree), expected_entries);\n            }\n        }\n    }\n\n    // All entries removed, should be empty now\n    assert!(avl_tree_root_node(&tree).is_none());\n\n    avl_tree_free(&mut tree);\n}\n\n",
        "test_avl_tree_child": "pub fn test_avl_tree_child() {\n    let mut tree = avl_tree_new(|a: &i32, b: &i32| a.cmp(b) as i32).unwrap();\n    let values = [1, 2, 3];\n\n    for i in 0..3 {\n        avl_tree_insert(&mut tree, values[i], values[i]);\n    }\n\n    let root = avl_tree_root_node(&tree).unwrap();\n    let p = avl_tree_node_value(root);\n    assert_eq!(p, 2);\n\n    let left = avl_tree_node_child(root, AVLTreeNodeSide::Left).unwrap();\n    let p = avl_tree_node_value(left);\n    assert_eq!(p, 1);\n\n    let right = avl_tree_node_child(root, AVLTreeNodeSide::Right).unwrap();\n    let p = avl_tree_node_value(right);\n    assert_eq!(p, 3);\n\n    assert!(avl_tree_node_child(root, AVLTreeNodeSide::Left).is_some());\n    assert!(avl_tree_node_child(root, AVLTreeNodeSide::Right).is_some());\n\n    avl_tree_free(&mut tree);\n}\n\n",
        "test_avl_tree_to_array": "pub fn test_avl_tree_to_array() {\n    let entries = vec![89, 23, 42, 4, 16, 15, 8, 99, 50, 30];\n    let sorted = vec![4, 8, 15, 16, 23, 30, 42, 50, 89, 99];\n    let num_entries = entries.len();\n\n    let mut tree = avl_tree_new(|a: &i32, b: &i32| a.cmp(b) as i32).unwrap();\n\n    for i in 0..num_entries {\n        avl_tree_insert(&mut tree, entries[i], 0);\n    }\n\n    assert_eq!(avl_tree_num_entries(&tree), num_entries as u32);\n\n    let array = avl_tree_to_array(&tree).unwrap();\n\n    for i in 0..num_entries {\n        assert_eq!(array[i], sorted[i]);\n    }\n\n    validate_tree(&tree);\n\n    avl_tree_free(&mut tree);\n}\n\n",
        "test_avl_tree_lookup": "pub fn test_avl_tree_lookup() {\n    let mut tree = create_tree().expect(\"Failed to create tree\");\n\n    for i in 0..1000 {\n        let value = avl_tree_lookup(&tree, i);\n\n        assert!(value.is_some());\n        assert_eq!(value.unwrap(), i);\n    }\n\n    // Test invalid values\n    assert!(avl_tree_lookup(&tree, -1).is_none());\n    assert!(avl_tree_lookup(&tree, 1001).is_none());\n    assert!(avl_tree_lookup(&tree, 8724897).is_none());\n\n    avl_tree_free(&mut tree);\n}\n\n",
        "test_avl_tree_free": "pub fn test_avl_tree_free() {\n    let mut tree: Option<AVLTree<i32>>;\n\n    // Try freeing an empty tree\n    tree = avl_tree_new(|a: &i32, b: &i32| a.cmp(b) as i32);\n    if let Some(mut tree) = tree {\n        avl_tree_free(&mut tree);\n    }\n\n    // Create a big tree and free it\n    tree = create_tree();\n    if let Some(mut tree) = tree {\n        avl_tree_free(&mut tree);\n    }\n}\n\n",
        "test_avl_tree_new": "pub fn test_avl_tree_new() {\n    let mut tree = avl_tree_new(int_compare).unwrap();\n\n    assert!(avl_tree_root_node(&tree).is_none());\n    assert_eq!(avl_tree_num_entries(&tree), 0);\n\n    avl_tree_free(&mut tree);\n}\n\n",
        "test_out_of_memory": "pub fn test_out_of_memory() {\n    let mut tree = create_tree().expect(\"Failed to create tree\");\n\n    // Try to add some more nodes and verify that this fails.\n    for i in 10000..20000 {\n        let node = avl_tree_insert(&mut tree, i, i);\n        assert!(node.is_none());\n        validate_tree(&tree);\n    }\n\n    avl_tree_free(&mut tree);\n}\n\n",
        "test_avl_tree_insert_lookup": "pub fn test_avl_tree_insert_lookup() {\n    let mut tree = avl_tree_new(|a: &i32, b: &i32| a.cmp(b) as i32).unwrap();\n    let mut test_array: Vec<i32> = (0..1000).collect();\n    let mut i: u32 = 0;\n\n    for i in 0..1000 {\n        avl_tree_insert(&mut tree, test_array[i as usize], test_array[i as usize]);\n        assert_eq!(avl_tree_num_entries(&tree), i + 1);\n        validate_tree(&tree);\n    }\n\n    assert!(avl_tree_root_node(&tree).is_some());\n\n    for i in 0..1000 {\n        let node = avl_tree_lookup_node(&tree, i);\n        assert!(node.is_some());\n        let node_ref = node.as_ref().unwrap();\n        let value = avl_tree_node_key(node_ref);\n        assert_eq!(value, i);\n        let value = avl_tree_node_value(node_ref);\n        assert_eq!(value, i);\n    }\n\n    let i = 1000 + 100;\n    assert!(avl_tree_lookup_node(&tree, i).is_none());\n\n    avl_tree_free(&mut tree);\n}\n\npub fn int_compare(a: &i32, b: &i32) -> i32 {\n    match a.cmp(b) {\n        Ordering::Less => -1,\n        Ordering::Equal => 0,\n        Ordering::Greater => 1,\n    }\n}\n\n"
    },
    "hash-pointer": {
        "pointer_hash": "pub fn pointer_hash<T>(location: &T) -> u32 {\n    let ptr = location as *const T as usize;\n    ptr as u32\n}\n\n",
        "extra": "// \u6d4b\u8bd5\u51fd\u6570\n\n// \u6d4b\u8bd5\u51fd\u6570\n\n\n// \u6d4b\u8bd5\u51fd\u6570"
    },
    "rb-tree": {
        "rb_tree_node_side": "pub fn rb_tree_node_side<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> RBTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        if let Some(left_child) = &parent.children[RBTreeNodeSide::Left as usize] {\n            if std::ptr::eq(left_child.as_ref(), node) {\n                return RBTreeNodeSide::Left;\n            }\n        }\n    }\n    RBTreeNodeSide::Right\n}\n\n",
        "extra": "pub const NUM_TEST_VALUES: i32 = 1000;\n\n#[derive(Clone, Copy, PartialEq)]\npub enum RBTreeNodeSide {\n    Left = 0,\n    Right = 1,\n}\n\n#[derive(Clone, PartialEq)]\npub enum RBTreeNodeColor {\n    Red,\n    Black,\n}\n\n#[derive(Clone)]\npub struct RBTreeNode<T: Clone + PartialEq> {\n    pub color: RBTreeNodeColor,\n    pub key: T,\n    pub value: T,\n    pub parent: Option<Box<RBTreeNode<T>>>,\n    pub children: [Option<Box<RBTreeNode<T>>>; 2],\n}\n\npub struct RBTree<T: Clone + PartialEq> {\n    pub root_node: Option<Box<RBTreeNode<T>>>,\n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: i32,\n}\n\nimpl<T: Clone + PartialEq> RBTree<T> {\n    pub fn new(compare_func: fn(T, T) -> i32) -> Self {\n        RBTree {\n            root_node: None,\n            compare_func,\n            num_nodes: 0,\n        }\n    }\n}",
        "rb_tree_node_replace": "pub fn rb_tree_node_replace<T: Clone + PartialEq>(tree: &mut RBTree<T>, node1: &mut RBTreeNode<T>, mut node2: Option<Box<RBTreeNode<T>>>) {\n    let side;\n\n    if let Some(ref mut node2_inner) = node2 {\n        node2_inner.parent = node1.parent.take();\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2;\n    } else {\n        side = rb_tree_node_side(node1);\n        if let Some(ref mut parent) = node1.parent {\n            parent.children[side as usize] = node2;\n        }\n    }\n}\n\n",
        "rb_tree_insert_case5": "pub fn rb_tree_insert_case5<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: &mut RBTreeNode<T>) {\n    let side = rb_tree_node_side(node);\n    let parent = node.parent.as_mut().unwrap();\n    let grandparent = parent.parent.as_mut().unwrap();\n\n    rb_tree_rotate(tree, grandparent, 1 - side as usize);\n\n    parent.color = RBTreeNodeColor::Black;\n    grandparent.color = RBTreeNodeColor::Red;\n}\n\n",
        "rb_tree_rotate": "pub fn rb_tree_rotate<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: &mut RBTreeNode<T>, direction: usize) -> Box<RBTreeNode<T>> {\n    let mut new_root = node.children[1 - direction].take().unwrap();\n\n    rb_tree_node_replace(tree, node, Some(new_root.clone()));\n\n    node.children[1 - direction] = new_root.children[direction].take();\n    new_root.children[direction] = Some(Box::new(node.clone()));\n\n    node.parent = Some(new_root.clone());\n\n    let node_clone = node.clone();\n    if let Some(ref mut child) = node.children[1 - direction] {\n        child.parent = Some(Box::new(node_clone));\n    }\n\n    new_root\n}\n\n",
        "rb_tree_node_sibling": "pub fn rb_tree_node_sibling<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> Option<Box<RBTreeNode<T>>> {\n    let side = rb_tree_node_side(node);\n    if let Some(parent) = &node.parent {\n        return parent.children[1 - side as usize].clone();\n    }\n    None\n}\n\n",
        "rb_tree_insert_case4": "pub fn rb_tree_insert_case4<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: &mut RBTreeNode<T>) {\n    let mut next_node: Box<RBTreeNode<T>>;\n    let side = rb_tree_node_side(node);\n\n    if side != rb_tree_node_side(node.parent.as_ref().unwrap()) {\n        next_node = node.parent.take().unwrap();\n        rb_tree_rotate(tree, next_node.as_mut(), 1 - side as usize);\n    } else {\n        next_node = Box::new(node.clone());\n    }\n\n    rb_tree_insert_case5(tree, next_node.as_mut());\n}\n\n",
        "rb_tree_node_uncle": "pub fn rb_tree_node_uncle<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> Option<Box<RBTreeNode<T>>> {\n    if let Some(parent) = &node.parent {\n        return rb_tree_node_sibling(parent);\n    }\n    None\n}\n\n",
        "rb_tree_insert_case3": "pub fn rb_tree_insert_case3<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: &mut RBTreeNode<T>) {\n    let parent = node.parent.as_ref().unwrap().clone();\n    let grandparent = parent.parent.as_ref().unwrap().clone();\n    let uncle = rb_tree_node_uncle(node);\n\n    if let Some(mut uncle_node) = uncle {\n        if uncle_node.color == RBTreeNodeColor::Red {\n            node.parent.as_mut().unwrap().color = RBTreeNodeColor::Black;\n            uncle_node.color = RBTreeNodeColor::Black;\n            let mut grandparent_mut = grandparent.clone();\n            grandparent_mut.color = RBTreeNodeColor::Red;\n            rb_tree_insert_case1(tree, &mut grandparent_mut);\n        } else {\n            rb_tree_insert_case4(tree, node);\n        }\n    } else {\n        rb_tree_insert_case4(tree, node);\n    }\n}\n\n",
        "rb_tree_insert_case2": "pub fn rb_tree_insert_case2<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: &mut RBTreeNode<T>) {\n    if node.parent.as_ref().unwrap().color != RBTreeNodeColor::Black {\n        rb_tree_insert_case3(tree, node);\n    }\n}\n\n",
        "rb_tree_insert_case1": "pub fn rb_tree_insert_case1<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: &mut RBTreeNode<T>) {\n    if node.parent.is_none() {\n        node.color = RBTreeNodeColor::Black;\n    } else {\n        rb_tree_insert_case2(tree, node);\n    }\n}\n\n",
        "rb_tree_node_child": "pub fn rb_tree_node_child<T: Clone + PartialEq>(node: &RBTreeNode<T>, side: RBTreeNodeSide) -> Option<&Box<RBTreeNode<T>>> {\n    if side == RBTreeNodeSide::Left || side == RBTreeNodeSide::Right {\n        node.children[side as usize].as_ref()\n    } else {\n        None\n    }\n}\n\n",
        "rb_tree_new": "pub fn rb_tree_new<T: Clone + PartialEq>(compare_func: fn(T, T) -> i32) -> Option<Box<RBTree<T>>> {\n    let mut new_tree = Box::new(RBTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    });\n\n    Some(new_tree)\n}\n\n",
        "rb_tree_insert": "pub fn rb_tree_insert<T: Clone + PartialEq>(tree: &mut RBTree<T>, key: T, value: T) -> Option<Box<RBTreeNode<T>>> {\n    let mut node = RBTreeNode {\n        color: RBTreeNodeColor::Red,\n        key: key.clone(),\n        value: value.clone(),\n        parent: None,\n        children: [None, None],\n    };\n\n    let mut parent: Option<Box<RBTreeNode<T>>> = None;\n    let mut rover = &mut tree.root_node;\n\n    while let Some(ref mut current_node) = rover {\n        parent = Some(current_node.clone());\n        if (tree.compare_func)(value.clone(), current_node.value.clone()) < 0 {\n            rover = &mut current_node.children[RBTreeNodeSide::Left as usize];\n        } else {\n            rover = &mut current_node.children[RBTreeNodeSide::Right as usize];\n        }\n    }\n\n    *rover = Some(Box::new(node.clone()));\n    node.parent = parent;\n\n    rb_tree_insert_case1(tree, &mut node);\n\n    tree.num_nodes += 1;\n\n    Some(Box::new(node))\n}\n\n",
        "rb_tree_free_subtree": "pub fn rb_tree_free_subtree<T: Clone + PartialEq>(node: Option<Box<RBTreeNode<T>>>) {\n    if let Some(mut node) = node {\n        rb_tree_free_subtree(node.children[RBTreeNodeSide::Left as usize].take());\n        rb_tree_free_subtree(node.children[RBTreeNodeSide::Right as usize].take());\n    }\n}\n\n",
        "rb_tree_lookup_node": "pub fn rb_tree_lookup_node<T: Clone + PartialOrd>(tree: &RBTree<T>, key: T) -> Option<Box<RBTreeNode<T>>> {\n    let mut node = tree.root_node.clone();\n\n    while let Some(ref current_node) = node {\n        let diff = (tree.compare_func)(key.clone(), current_node.key.clone());\n\n        if diff == 0 {\n            return node;\n        } else if diff < 0 {\n            node = current_node.children[RBTreeNodeSide::Left as usize].clone();\n        } else {\n            node = current_node.children[RBTreeNodeSide::Right as usize].clone();\n        }\n    }\n\n    None\n}\n\n",
        "rb_tree_remove_node": "pub fn rb_tree_remove_node<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Box<RBTreeNode<T>>) {\n    let mut node_to_remove = node;\n    let mut child_node: Option<Box<RBTreeNode<T>>> = None;\n    let mut parent_node: Option<Box<RBTreeNode<T>>> = None;\n    let mut color: RBTreeNodeColor;\n\n    if node_to_remove.children[RBTreeNodeSide::Left as usize].is_none() {\n        child_node = node_to_remove.children[RBTreeNodeSide::Right as usize].take();\n    } else if node_to_remove.children[RBTreeNodeSide::Right as usize].is_none() {\n        child_node = node_to_remove.children[RBTreeNodeSide::Left as usize].take();\n    } else {\n        let mut successor = node_to_remove.children[RBTreeNodeSide::Right as usize].as_ref().unwrap().clone();\n        while successor.children[RBTreeNodeSide::Left as usize].is_some() {\n            successor = successor.children[RBTreeNodeSide::Left as usize].as_ref().unwrap().clone();\n        }\n        color = successor.color.clone();\n        child_node = successor.children[RBTreeNodeSide::Right as usize].take();\n        parent_node = successor.parent.take();\n\n        if parent_node.as_ref().unwrap().key == node_to_remove.key {\n            parent_node = Some(successor.clone());\n        } else {\n            if child_node.is_some() {\n                child_node.as_mut().unwrap().parent = parent_node.clone();\n            }\n            parent_node.as_mut().unwrap().children[RBTreeNodeSide::Left as usize] = child_node.clone();\n            successor.children[RBTreeNodeSide::Right as usize] = node_to_remove.children[RBTreeNodeSide::Right as usize].take();\n            node_to_remove.children[RBTreeNodeSide::Right as usize].as_mut().unwrap().parent = Some(successor.clone());\n        }\n\n        let parent_key = node_to_remove.parent.as_ref().unwrap().key.clone();\n        let node_key = node_to_remove.key.clone();\n        let side = if node_to_remove.parent.as_ref().unwrap().children[RBTreeNodeSide::Left as usize].as_ref().unwrap().key == node_key {\n            RBTreeNodeSide::Left as usize\n        } else {\n            RBTreeNodeSide::Right as usize\n        };\n\n        if tree.root_node.as_ref().unwrap().key == node_to_remove.key {\n            tree.root_node = Some(successor.clone());\n        } else {\n            node_to_remove.parent.as_mut().unwrap().children[side] = Some(successor.clone());\n        }\n        successor.parent = node_to_remove.parent.take();\n        successor.color = node_to_remove.color.clone();\n        successor.children[RBTreeNodeSide::Left as usize] = node_to_remove.children[RBTreeNodeSide::Left as usize].take();\n        node_to_remove.children[RBTreeNodeSide::Left as usize].as_mut().unwrap().parent = Some(successor.clone());\n    }\n\n    if node_to_remove.color == RBTreeNodeColor::Black {\n        if child_node.is_some() {\n            child_node.as_mut().unwrap().color = RBTreeNodeColor::Black;\n        } else {\n            if parent_node.is_some() {\n                if parent_node.as_ref().unwrap().children[RBTreeNodeSide::Left as usize].is_some() {\n                    parent_node.as_mut().unwrap().children[RBTreeNodeSide::Left as usize].as_mut().unwrap().color = RBTreeNodeColor::Black;\n                } else {\n                    parent_node.as_mut().unwrap().children[RBTreeNodeSide::Right as usize].as_mut().unwrap().color = RBTreeNodeColor::Black;\n                }\n            }\n        }\n    }\n\n    tree.num_nodes -= 1;\n}\n\n",
        "rb_tree_free": "pub fn rb_tree_free<T: Clone + PartialEq>(mut tree: Box<RBTree<T>>) {\n    rb_tree_free_subtree(tree.root_node.take());\n}\n\n",
        "rb_tree_num_entries": "pub fn rb_tree_num_entries<T: Clone + PartialEq>(tree: &RBTree<T>) -> i32 {\n    tree.num_nodes\n}\n\n",
        "rb_tree_root_node": "pub fn rb_tree_root_node<T: Clone + PartialEq>(tree: &RBTree<T>) -> Option<&Box<RBTreeNode<T>>> {\n    tree.root_node.as_ref()\n}\n\n",
        "rb_tree_remove": "pub fn rb_tree_remove<T: Clone + PartialEq + PartialOrd>(tree: &mut RBTree<T>, key: T) -> bool {\n    let node = rb_tree_lookup_node(tree, key.clone());\n\n    if node.is_none() {\n        return false;\n    }\n\n    rb_tree_remove_node(tree, node.unwrap());\n\n    true\n}\n\n",
        "rb_tree_lookup": "pub fn rb_tree_lookup<T: Clone + PartialOrd>(tree: &RBTree<T>, key: T) -> Option<T> {\n    let node = rb_tree_lookup_node(tree, key);\n\n    match node {\n        Some(ref current_node) => Some(current_node.value.clone()),\n        None => None,\n    }\n}\n\n",
        "rb_tree_to_array": "pub fn rb_tree_to_array<T: Clone + PartialEq>(tree: &RBTree<T>) -> Vec<T> {\n    let mut result = Vec::new();\n    let mut stack = Vec::new();\n    let mut current = tree.root_node.as_ref();\n\n    while !stack.is_empty() || current.is_some() {\n        while let Some(node) = current {\n            stack.push(node);\n            current = node.children[RBTreeNodeSide::Left as usize].as_ref();\n        }\n\n        if let Some(node) = stack.pop() {\n            result.push(node.value.clone());\n            current = node.children[RBTreeNodeSide::Right as usize].as_ref();\n        }\n    }\n\n    result\n}\n\n",
        "rb_tree_node_value": "pub fn rb_tree_node_value<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> T {\n    node.value.clone()\n}\n\n",
        "rb_tree_node_key": "pub fn rb_tree_node_key<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> T {\n    node.key.clone()\n}\n\n"
    },
    "test-rb-tree": {
        "main": "fn main(){}\n",
        "extra": "",
        "find_subtree_height": "pub fn find_subtree_height<T: Clone + PartialEq>(node: Option<&Box<RBTreeNode<T>>>) -> i32 {\n    let mut left_subtree: Option<&Box<RBTreeNode<T>>>;\n    let mut right_subtree: Option<&Box<RBTreeNode<T>>>;\n    let mut left_height: i32;\n    let mut right_height: i32;\n\n    if node.is_none() {\n        return 0;\n    }\n\n    left_subtree = rb_tree_node_child(node.unwrap(), RBTreeNodeSide::Left);\n    right_subtree = rb_tree_node_child(node.unwrap(), RBTreeNodeSide::Right);\n    left_height = find_subtree_height(left_subtree);\n    right_height = find_subtree_height(right_subtree);\n\n    if left_height > right_height {\n        left_height + 1\n    } else {\n        right_height + 1\n    }\n}\n\n",
        "create_tree": "pub fn create_tree() -> Option<Box<RBTree<i32>>> {\n    let compare_func = |a: i32, b: i32| a.cmp(&b) as i32;\n    let mut tree = RBTree::new(compare_func);\n    let mut test_array: [i32; 1000] = [0; 1000];\n\n    for i in 0..1000 {\n        test_array[i] = i as i32;\n        rb_tree_insert(&mut tree, test_array[i], test_array[i]);\n    }\n\n    Some(Box::new(tree))\n}\n\n",
        "validate_tree": "pub fn validate_tree<T: Clone + PartialEq>(tree: &RBTree<T>) -> bool {\n    if let Some(root) = &tree.root_node {\n        if root.color != RBTreeNodeColor::Black {\n            return false;\n        }\n    } else {\n        return true;\n    }\n\n    fn validate_red_black_property<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> bool {\n        if node.color == RBTreeNodeColor::Red {\n            for child in &node.children {\n                if let Some(child_node) = child {\n                    if child_node.color == RBTreeNodeColor::Red {\n                        return false;\n                    }\n                }\n            }\n        }\n        true\n    }\n\n    fn validate_black_height<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> (bool, i32) {\n        if node.children[0].is_none() && node.children[1].is_none() {\n            return (true, if node.color == RBTreeNodeColor::Black { 1 } else { 0 });\n        }\n\n        let mut left_valid = true;\n        let mut right_valid = true;\n        let mut left_height = 0;\n        let mut right_height = 0;\n\n        if let Some(left_child) = &node.children[0] {\n            let (valid, height) = validate_black_height(left_child);\n            left_valid = valid;\n            left_height = height;\n        }\n\n        if let Some(right_child) = &node.children[1] {\n            let (valid, height) = validate_black_height(right_child);\n            right_valid = valid;\n            right_height = height;\n        }\n\n        if !left_valid || !right_valid || left_height != right_height {\n            return (false, 0);\n        }\n\n        (true, left_height + if node.color == RBTreeNodeColor::Black { 1 } else { 0 })\n    }\n\n    fn validate_height_balance<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> bool {\n        let left_height = find_subtree_height(node.children[0].as_ref());\n        let right_height = find_subtree_height(node.children[1].as_ref());\n        (left_height - right_height).abs() <= 1\n    }\n\n    fn validate_tree_recursive<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> bool {\n        if !validate_red_black_property(node) {\n            return false;\n        }\n\n        if !validate_height_balance(node) {\n            return false;\n        }\n\n        for child in &node.children {\n            if let Some(child_node) = child {\n                if !validate_tree_recursive(child_node) {\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n\n    if let Some(root) = &tree.root_node {\n        if !validate_tree_recursive(root) {\n            return false;\n        }\n\n        let (valid, _) = validate_black_height(root);\n        if !valid {\n            return false;\n        }\n    }\n\n    true\n}\n\n",
        "test_rb_tree_free": "pub fn test_rb_tree_free() {\n    let mut tree = rb_tree_new(int_compare).unwrap();\n    rb_tree_free(tree);\n\n    let mut tree = create_tree().unwrap();\n    rb_tree_free(tree);\n}\n\n",
        "test_rb_tree_new": "pub fn test_rb_tree_new() {\n    let tree = rb_tree_new(int_compare);\n\n    assert!(tree.is_some());\n    let tree = tree.unwrap();\n    assert!(rb_tree_root_node(&tree).is_none());\n    assert_eq!(rb_tree_num_entries(&tree), 0);\n\n    rb_tree_free(tree);\n}\n\n",
        "test_rb_tree_remove": "pub fn test_rb_tree_remove() {\n    let mut tree = create_tree().unwrap();\n\n    let invalid_key1 = 1000 + 100;\n    assert!(!rb_tree_remove(&mut tree, invalid_key1));\n    let invalid_key2 = -1;\n    assert!(!rb_tree_remove(&mut tree, invalid_key2));\n\n    let mut expected_entries = 1000;\n\n    for x in 0..10 {\n        for y in 0..10 {\n            for z in 0..10 {\n                let value = z * 100 + (9 - y) * 10 + x;\n                assert!(rb_tree_remove(&mut tree, value));\n                assert!(validate_tree(&tree));\n                expected_entries -= 1;\n                assert_eq!(rb_tree_num_entries(&tree), expected_entries);\n            }\n        }\n    }\n\n    assert!(rb_tree_root_node(&tree).is_none());\n\n    rb_tree_free(tree);\n}\n\n",
        "test_rb_tree_to_array": "pub fn test_rb_tree_to_array() {\n    let entries = vec![89, 23, 42, 4, 16, 15, 8, 99, 50, 30];\n    let sorted = vec![4, 8, 15, 16, 23, 30, 42, 50, 89, 99];\n    let num_entries = entries.len();\n\n    let mut tree = RBTree::new(|a: i32, b: i32| a.cmp(&b) as i32);\n\n    for i in 0..num_entries {\n        rb_tree_insert(&mut tree, entries[i], entries[i]);\n    }\n\n    assert_eq!(rb_tree_num_entries(&tree), num_entries as i32);\n\n    let array = rb_tree_to_array(&tree);\n\n    for i in 0..num_entries {\n        assert_eq!(array[i], sorted[i]);\n    }\n\n    validate_tree(&tree);\n\n    rb_tree_free(Box::new(tree));\n}\n\n",
        "test_rb_tree_lookup": "pub fn test_rb_tree_lookup() {\n    let tree = create_tree().unwrap();\n\n    for i in 0..NUM_TEST_VALUES {\n        let value = rb_tree_lookup(&tree, i);\n\n        assert!(value.is_some());\n        assert_eq!(value.unwrap(), i);\n    }\n\n    // Test invalid values\n    assert!(rb_tree_lookup(&tree, -1).is_none());\n    assert!(rb_tree_lookup(&tree, NUM_TEST_VALUES + 1).is_none());\n    assert!(rb_tree_lookup(&tree, 8724897).is_none());\n\n    rb_tree_free(tree);\n}\n\n",
        "test_rb_tree_insert_lookup": "pub fn test_rb_tree_insert_lookup() {\n    pub const NUM_TEST_VALUES: i32 = 1000;\n    let mut test_array: Vec<i32> = Vec::with_capacity(NUM_TEST_VALUES as usize);\n\n    let mut tree = RBTree::new(int_compare);\n\n    for i in 0..NUM_TEST_VALUES {\n        test_array.push(i);\n        rb_tree_insert(&mut tree, test_array[i as usize], test_array[i as usize]);\n\n        assert_eq!(rb_tree_num_entries(&tree), i + 1);\n        assert!(validate_tree(&tree));\n    }\n\n    assert!(rb_tree_root_node(&tree).is_some());\n\n    for i in 0..NUM_TEST_VALUES {\n        let node = rb_tree_lookup_node(&tree, i);\n        assert!(node.is_some());\n        let value = rb_tree_node_key(node.as_ref().unwrap());\n        assert_eq!(value, i);\n        let value = rb_tree_node_value(node.as_ref().unwrap());\n        assert_eq!(value, i);\n    }\n\n    let invalid_key1 = -1;\n    assert!(rb_tree_lookup_node(&tree, invalid_key1).is_none());\n\n    let invalid_key2 = NUM_TEST_VALUES + 100;\n    assert!(rb_tree_lookup_node(&tree, invalid_key2).is_none());\n\n    rb_tree_free(Box::new(tree));\n}\n\n",
        "test_out_of_memory": "pub fn test_out_of_memory() {\n    let mut tree = create_tree().unwrap();\n\n    // Try to add some more nodes and verify that this fails.\n    for i in 10000..20000 {\n        let node = rb_tree_insert(&mut tree, i, i);\n        assert!(node.is_none());\n        assert!(validate_tree(&tree));\n    }\n\n    rb_tree_free(tree);\n}\n\n",
        "test_rb_tree_child": "pub fn test_rb_tree_child() {\n    let mut tree = RBTree::new(int_compare);\n    let values = [1, 2, 3];\n\n    for i in 0..3 {\n        rb_tree_insert(&mut tree, values[i], values[i]);\n    }\n\n    let root = rb_tree_root_node(&tree).unwrap();\n    let p = rb_tree_node_value(root);\n    assert_eq!(p, 2);\n\n    let left = rb_tree_node_child(root, RBTreeNodeSide::Left).unwrap();\n    let p = rb_tree_node_value(left);\n    assert_eq!(p, 1);\n\n    let right = rb_tree_node_child(root, RBTreeNodeSide::Right).unwrap();\n    let p = rb_tree_node_value(right);\n    assert_eq!(p, 3);\n\n    assert!(rb_tree_node_child(root, RBTreeNodeSide::Left).is_some());\n    assert!(rb_tree_node_child(root, RBTreeNodeSide::Right).is_some());\n\n    rb_tree_free(Box::new(tree));\n}\n\npub fn int_compare(a: i32, b: i32) -> i32 {\n    if a < b {\n        -1\n    } else if a > b {\n        1\n    } else {\n        0\n    }\n}\n\n"
    },
    "binomial-heap": {
        "binomial_tree_unref": "pub fn binomial_tree_unref<T>(tree: Rc<RefCell<BinomialTree<T>>>) {\n    let mut tree = tree.borrow_mut();\n\n    if tree.refcount == 0 {\n        return;\n    }\n\n    tree.refcount -= 1;\n\n    if tree.refcount == 0 {\n        for subtree in &tree.subtrees {\n            binomial_tree_unref(Rc::clone(subtree));\n        }\n\n        tree.subtrees.clear();\n    }\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Clone)]\npub enum BinomialHeapType {\n    Min,\n    Max,\n}\n\npub struct BinomialTree<T> {\n    pub value: T,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Rc<RefCell<BinomialTree<T>>>>,\n}\n\npub struct BinomialHeap<T> {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: fn(&T, &T) -> i32,\n    pub trees: Vec<Rc<RefCell<BinomialTree<T>>>>,\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub const TEST_VALUE: usize = NUM_TEST_VALUES / 2;",
        "binomial_heap_cmp": "pub fn binomial_heap_cmp<T>(heap: &BinomialHeap<T>, data1: &T, data2: &T) -> i32 {\n    match heap.heap_type {\n        BinomialHeapType::Min => (heap.compare_func)(data1, data2),\n        BinomialHeapType::Max => -((heap.compare_func)(data1, data2)),\n    }\n}\n\n",
        "binomial_tree_ref": "pub fn binomial_tree_ref<T>(tree: Option<Rc<RefCell<BinomialTree<T>>>>) {\n    if let Some(tree) = tree {\n        tree.borrow_mut().refcount += 1;\n    }\n}\n\n",
        "binomial_heap_merge_undo": "pub fn binomial_heap_merge_undo<T>(new_roots: Vec<Rc<RefCell<BinomialTree<T>>>>, count: usize) {\n    for i in 0..=count {\n        binomial_tree_unref(Rc::clone(&new_roots[i]));\n    }\n}\n\n",
        "binomial_tree_merge": "pub fn binomial_tree_merge<T: Clone>(\n    heap: &BinomialHeap<T>,\n    tree1: Rc<RefCell<BinomialTree<T>>>,\n    tree2: Rc<RefCell<BinomialTree<T>>>,\n) -> Option<Rc<RefCell<BinomialTree<T>>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, &tree1.borrow().value, &tree2.borrow().value) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: Vec::with_capacity((tree1.borrow().order + 1) as usize),\n    }));\n\n    let mut subtrees = Vec::with_capacity((tree1.borrow().order + 1) as usize);\n    for subtree in &tree1.borrow().subtrees {\n        subtrees.push(Rc::clone(subtree));\n    }\n    subtrees.push(Rc::clone(&tree2));\n\n    new_tree.borrow_mut().subtrees = subtrees;\n\n    for subtree in &new_tree.borrow().subtrees {\n        binomial_tree_ref(Some(Rc::clone(subtree)));\n    }\n\n    Some(new_tree)\n}\n\n",
        "binomial_heap_merge": "pub fn binomial_heap_merge<T: Clone>(\n    heap: &mut BinomialHeap<T>,\n    other: &BinomialHeap<T>,\n) -> bool {\n    let max = if heap.trees.len() > other.trees.len() {\n        heap.trees.len() + 1\n    } else {\n        other.trees.len() + 1\n    };\n\n    let mut new_roots: Vec<Rc<RefCell<BinomialTree<T>>>> = Vec::with_capacity(max);\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree<T>>>> = None;\n\n    for i in 0..max {\n        let mut vals: Vec<Rc<RefCell<BinomialTree<T>>>> = Vec::new();\n\n        if i < heap.trees.len() && heap.trees[i].borrow().refcount > 0 {\n            vals.push(Rc::clone(&heap.trees[i]));\n        }\n\n        if i < other.trees.len() && other.trees[i].borrow().refcount > 0 {\n            vals.push(Rc::clone(&other.trees[i]));\n        }\n\n        if carry.is_some() {\n            vals.push(Rc::clone(carry.as_ref().unwrap()));\n        }\n\n        if (vals.len() & 1) != 0 {\n            new_roots.push(Rc::clone(&vals[vals.len() - 1]));\n            binomial_tree_ref(Some(Rc::clone(&new_roots[i])));\n            new_roots_length = i + 1;\n        } else {\n            new_roots.push(Rc::new(RefCell::new(BinomialTree {\n                value: unsafe { std::mem::zeroed() },\n                order: 0,\n                refcount: 0,\n                subtrees: Vec::new(),\n            })));\n        }\n\n        let new_carry = if (vals.len() & 2) != 0 {\n            let merged = binomial_tree_merge(heap, Rc::clone(&vals[0]), Rc::clone(&vals[1]));\n            if merged.is_none() {\n                binomial_heap_merge_undo(new_roots, i);\n                binomial_tree_unref(carry.unwrap());\n                return false;\n            }\n            merged\n        } else {\n            None\n        };\n\n        if carry.is_some() {\n            binomial_tree_unref(carry.unwrap());\n        }\n\n        carry = new_carry;\n        if carry.is_some() {\n            binomial_tree_ref(carry.clone());\n        }\n    }\n\n    for i in 0..heap.trees.len() {\n        if heap.trees[i].borrow().refcount > 0 {\n            binomial_tree_unref(Rc::clone(&heap.trees[i]));\n        }\n    }\n\n    heap.trees = new_roots.into_iter().collect();\n    heap.trees.truncate(new_roots_length);\n\n    true\n}\n\n",
        "binomial_heap_new": "pub fn binomial_heap_new<T>(heap_type: BinomialHeapType, compare_func: fn(&T, &T) -> i32) -> Option<BinomialHeap<T>> {\n    let new_heap = BinomialHeap {\n        heap_type,\n        compare_func,\n        trees: Vec::new(),\n    };\n\n    Some(new_heap)\n}\n\n",
        "binomial_heap_insert": "pub fn binomial_heap_insert<T: Clone>(\n    heap: &mut BinomialHeap<T>,\n    value: T,\n) -> bool {\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: value.clone(),\n        order: 0,\n        refcount: 1,\n        subtrees: Vec::new(),\n    }));\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func,\n        trees: vec![Rc::clone(&new_tree)],\n    };\n\n    let result = binomial_heap_merge(heap, &fake_heap);\n\n    if result {\n        binomial_tree_unref(Rc::clone(&new_tree));\n    }\n\n    result\n}\n\n",
        "binomial_heap_num_entries": "pub fn binomial_heap_num_entries<T>(heap: &BinomialHeap<T>) -> usize {\n    heap.trees.iter().map(|tree| tree.borrow().refcount as usize).sum()\n}\n\n",
        "binomial_heap_pop": "pub fn binomial_heap_pop<T: Clone>(heap: &mut BinomialHeap<T>) -> Option<T> {\n    if heap.trees.is_empty() {\n        return None;\n    }\n\n    let mut least_index = 0;\n    let mut least_tree = Rc::clone(&heap.trees[least_index]);\n\n    for i in 1..heap.trees.len() {\n        if heap.trees[i].borrow().refcount == 0 {\n            continue;\n        }\n\n        if binomial_heap_cmp(heap, &heap.trees[i].borrow().value, &least_tree.borrow().value) < 0 {\n            least_index = i;\n            least_tree = Rc::clone(&heap.trees[i]);\n        }\n    }\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func,\n        trees: Vec::new(),\n    };\n\n    for subtree in &least_tree.borrow().subtrees {\n        fake_heap.trees.push(Rc::clone(subtree));\n    }\n\n    if binomial_heap_merge(heap, &fake_heap) {\n        let result = least_tree.borrow().value.clone();\n        binomial_tree_unref(Rc::clone(&least_tree));\n        Some(result)\n    } else {\n        heap.trees[least_index] = least_tree;\n        None\n    }\n}\n\n",
        "binomial_heap_free": "pub fn binomial_heap_free<T>(heap: BinomialHeap<T>) {\n    let mut heap = heap;\n\n    for tree in heap.trees.iter() {\n        binomial_tree_unref(Rc::clone(tree));\n    }\n}\n\n"
    },
    "test-binomial-heap": {
        "main": "fn main() {}\n\n",
        "extra": "",
        "generate_heap": "pub fn generate_heap() -> Option<BinomialHeap<i32>> {\n    let mut heap = binomial_heap_new(BinomialHeapType::Min, |a: &i32, b: &i32| a.cmp(b) as i32)?;\n\n    let mut test_array = vec![0; NUM_TEST_VALUES];\n\n    for i in 0..NUM_TEST_VALUES {\n        test_array[i] = i as i32;\n        if i != TEST_VALUE {\n            assert!(binomial_heap_insert(&mut heap, test_array[i]));\n        }\n    }\n\n    Some(heap)\n}\n\n",
        "verify_heap": "pub fn verify_heap<T: Clone + PartialEq + std::fmt::Debug>(\n    heap: &mut BinomialHeap<T>,\n    test_values: &[T],\n    test_value_index: usize,\n) {\n    let mut num_vals = binomial_heap_num_entries(heap);\n    assert_eq!(num_vals, test_values.len() - 1);\n\n    for i in 0..test_values.len() {\n        if i == test_value_index {\n            continue;\n        }\n\n        let val = binomial_heap_pop(heap);\n        assert_eq!(val.as_ref(), Some(&test_values[i]));\n\n        num_vals -= 1;\n        assert_eq!(binomial_heap_num_entries(heap), num_vals);\n    }\n}\n\n",
        "test_min_heap": "pub fn test_min_heap() {\n    let mut heap = binomial_heap_new(BinomialHeapType::Min, int_compare).unwrap();\n    let mut test_array: Vec<i32> = (0..NUM_TEST_VALUES as i32).collect();\n\n    for i in 0..NUM_TEST_VALUES {\n        assert!(binomial_heap_insert(&mut heap, test_array[i]));\n    }\n\n    let mut i = -1;\n    while binomial_heap_num_entries(&heap) > 0 {\n        let val = binomial_heap_pop(&mut heap).unwrap();\n        assert_eq!(val, i + 1);\n        i = val;\n    }\n\n    let val = binomial_heap_pop(&mut heap);\n    assert!(val.is_none());\n\n    binomial_heap_free(heap);\n}\n\n",
        "test_insert_out_of_memory": "pub fn test_insert_out_of_memory() {\n    let mut heap: Option<BinomialHeap<i32>>;\n\n    for _ in 0..6 {\n        heap = generate_heap();\n\n        let mut test_array = vec![0; NUM_TEST_VALUES];\n        for i in 0..NUM_TEST_VALUES {\n            test_array[i] = i as i32;\n        }\n\n        test_array[TEST_VALUE] = TEST_VALUE as i32;\n        assert!(!binomial_heap_insert(heap.as_mut().unwrap(), test_array[TEST_VALUE]));\n\n        verify_heap(heap.as_mut().unwrap(), &test_array, TEST_VALUE);\n\n        binomial_heap_free(heap.unwrap());\n    }\n}\n\n",
        "test_pop_out_of_memory": "pub fn test_pop_out_of_memory() {\n    for _ in 0..6 {\n        let mut heap = generate_heap().unwrap();\n\n        // Pop should fail\n        assert!(binomial_heap_pop(&mut heap).is_none());\n\n        // Check the heap is unharmed\n        binomial_heap_free(heap);\n    }\n}\n\n",
        "test_binomial_heap_new_free": "pub fn test_binomial_heap_new_free() {\n    for _ in 0..NUM_TEST_VALUES {\n        let heap = binomial_heap_new(BinomialHeapType::Min, |a: &i32, b: &i32| match a.cmp(b) {\n            std::cmp::Ordering::Less => -1,\n            std::cmp::Ordering::Equal => 0,\n            std::cmp::Ordering::Greater => 1,\n        });\n        if let Some(heap) = heap {\n            binomial_heap_free(heap);\n        }\n    }\n}\n\n",
        "test_max_heap": "pub fn test_max_heap() {\n    let mut heap = binomial_heap_new(BinomialHeapType::Max, |a: &i32, b: &i32| a.cmp(b) as i32).unwrap();\n    let mut test_array: Vec<i32> = (0..NUM_TEST_VALUES as i32).collect();\n\n    for i in 0..NUM_TEST_VALUES {\n        assert!(binomial_heap_insert(&mut heap, test_array[i]));\n    }\n\n    let mut i = NUM_TEST_VALUES as i32;\n    while binomial_heap_num_entries(&heap) > 0 {\n        let val = binomial_heap_pop(&mut heap).unwrap();\n        assert_eq!(val, i - 1);\n        i = val;\n    }\n\n    let val = binomial_heap_pop(&mut heap);\n    assert!(val.is_none());\n\n    binomial_heap_free(heap);\n}\n\n",
        "test_binomial_heap_insert": "pub fn test_binomial_heap_insert() {\n    let mut heap = binomial_heap_new(BinomialHeapType::Min, int_compare).unwrap();\n    let test_array: Vec<i32> = (0..NUM_TEST_VALUES as i32).collect();\n\n    for i in 0..NUM_TEST_VALUES {\n        assert!(binomial_heap_insert(&mut heap, test_array[i]));\n    }\n    assert_eq!(binomial_heap_num_entries(&heap), NUM_TEST_VALUES);\n\n    binomial_heap_free(heap);\n}\n\npub fn int_compare(a: &i32, b: &i32) -> i32 {\n    if a < b {\n        -1\n    } else if a > b {\n        1\n    } else {\n        0\n    }\n}\n\n"
    },
    "arraylist": {
        "arraylist_enlarge": "pub fn arraylist_enlarge<T: Clone>(arraylist: &mut ArrayList<T>) -> bool {\n    let newsize = arraylist._alloced * 2;\n    let mut new_data = Vec::with_capacity(newsize);\n\n    new_data.extend_from_slice(&arraylist.data);\n\n    arraylist.data = new_data;\n    arraylist._alloced = newsize;\n\n    true\n}\n\n",
        "extra": "pub struct ArrayList<T> {\n    pub data: Vec<T>,\n    pub length: usize,\n    pub _alloced: usize,\n}\n\npub type ArrayListCompareFunc<T> = fn(value1: &T, value2: &T) -> i32;\npub type ArrayListEqualFunc<T> = fn(value1: &T, value2: &T) -> i32;\n\nimpl<T> Clone for ArrayList<T> where T: Clone {\n    fn clone(&self) -> Self {\n        ArrayList {\n            data: self.data.clone(),\n            length: self.length,\n            _alloced: self._alloced,\n        }\n    }\n}",
        "arraylist_insert": "pub fn arraylist_insert<T: Clone>(arraylist: &mut ArrayList<T>, index: usize, data: T) -> bool {\n    if index > arraylist.length {\n        return false;\n    }\n\n    if arraylist.length + 1 > arraylist._alloced {\n        if !arraylist_enlarge(arraylist) {\n            return false;\n        }\n    }\n\n    arraylist.data.insert(index, data);\n    arraylist.length += 1;\n\n    true\n}\n\n",
        "arraylist_sort_internal": "pub fn arraylist_sort_internal<T: Clone>(list_data: &mut [T], list_length: usize, compare_func: ArrayListCompareFunc<T>) {\n    if list_length <= 1 {\n        return;\n    }\n\n    let pivot = list_data[list_length - 1].clone();\n    let mut list1_length = 0;\n\n    for i in 0..list_length - 1 {\n        if compare_func(&list_data[i], &pivot) < 0 {\n            list_data.swap(i, list1_length);\n            list1_length += 1;\n        }\n    }\n\n    let list2_length = list_length - list1_length - 1;\n\n    list_data.swap(list_length - 1, list1_length);\n\n    arraylist_sort_internal(&mut list_data[0..list1_length], list1_length, compare_func);\n    arraylist_sort_internal(&mut list_data[list1_length + 1..], list2_length, compare_func);\n}\n\n",
        "arraylist_append": "pub fn arraylist_append<T: Clone>(arraylist: &mut Box<ArrayList<T>>, data: T) -> bool {\n    arraylist_insert(arraylist, arraylist.length, data)\n}\n\n",
        "arraylist_new": "pub fn arraylist_new<T>(length: usize) -> Option<Box<ArrayList<T>>> {\n    let mut new_length = length;\n\n    if new_length == 0 {\n        new_length = 16;\n    }\n\n    let new_arraylist = ArrayList {\n        data: Vec::with_capacity(new_length),\n        length: 0,\n        _alloced: new_length,\n    };\n\n    Some(Box::new(new_arraylist))\n}\n\n",
        "arraylist_remove_range": "pub fn arraylist_remove_range<T>(arraylist: &mut ArrayList<T>, index: usize, length: usize) {\n    if index > arraylist.length || index + length > arraylist.length {\n        return;\n    }\n\n    let start = index + length;\n    let end = arraylist.length;\n    let range_to_remove = start..end;\n\n    arraylist.data.drain(index..index + length);\n\n    arraylist.length -= length;\n}\n\n",
        "arraylist_free": "pub fn arraylist_free<T>(arraylist: Option<Box<ArrayList<T>>>) {\n    if let Some(mut arraylist) = arraylist {\n        arraylist.data.clear();\n    }\n}\n\n",
        "arraylist_prepend": "pub fn arraylist_prepend<T: Clone>(arraylist: &mut ArrayList<T>, data: T) -> bool {\n    arraylist_insert(arraylist, 0, data)\n}\n\n",
        "arraylist_sort": "pub fn arraylist_sort<T: Clone>(arraylist: &mut ArrayList<T>, compare_func: ArrayListCompareFunc<T>) {\n    arraylist_sort_internal(&mut arraylist.data, arraylist.length, compare_func);\n}\n\n",
        "arraylist_index_of": "pub fn arraylist_index_of<T>(arraylist: &ArrayList<T>, callback: ArrayListEqualFunc<T>, data: &T) -> i32 {\n    for i in 0..arraylist.length {\n        if callback(&arraylist.data[i], data) != 0 {\n            return i as i32;\n        }\n    }\n    -1\n}\n\n",
        "arraylist_clear": "pub fn arraylist_clear<T>(arraylist: &mut ArrayList<T>) {\n    arraylist.length = 0;\n}\n\n",
        "arraylist_remove": "pub fn arraylist_remove<T>(arraylist: &mut ArrayList<T>, index: usize) {\n    arraylist_remove_range(arraylist, index, 1);\n}\n\n"
    },
    "test-arraylist": {
        "main": "fn main(){}\n",
        "extra": "",
        "generate_arraylist": "pub fn generate_arraylist<T: Clone + Default>() -> Option<Box<ArrayList<T>>> {\n    let mut arraylist = arraylist_new(0)?;\n\n    for _ in 0..4 {\n        arraylist_append(&mut arraylist, T::default());\n        arraylist_append(&mut arraylist, T::default());\n        arraylist_append(&mut arraylist, T::default());\n        arraylist_append(&mut arraylist, T::default());\n    }\n\n    Some(arraylist)\n}\n\n",
        "test_arraylist_new_free": "pub fn test_arraylist_new_free() {\n    // Use a default size when given zero\n    let arraylist = arraylist_new::<i32>(0);\n    assert!(arraylist.is_some());\n    arraylist_free(arraylist);\n\n    // Normal allocated\n    let arraylist = arraylist_new::<i32>(10);\n    assert!(arraylist.is_some());\n    arraylist_free(arraylist);\n\n    // Freeing a null arraylist works\n    arraylist_free::<i32>(None);\n}\n\n",
        "test_arraylist_sort": "pub fn test_arraylist_sort() {\n    let mut arraylist: Option<Box<ArrayList<i32>>>;\n    let entries = vec![89, 4, 23, 42, 4, 16, 15, 4, 8, 99, 50, 30, 4];\n    let sorted = vec![4, 4, 4, 4, 8, 15, 16, 23, 30, 42, 50, 89, 99];\n    let num_entries = entries.len();\n\n    arraylist = arraylist_new(10);\n\n    for i in 0..num_entries {\n        arraylist_prepend(arraylist.as_mut().unwrap(), entries[i]);\n    }\n\n    arraylist_sort(arraylist.as_mut().unwrap(), int_compare);\n\n    assert_eq!(arraylist.as_ref().unwrap().length, num_entries);\n\n    for i in 0..num_entries {\n        let value = arraylist.as_ref().unwrap().data[i];\n        assert_eq!(value, sorted[i]);\n    }\n\n    arraylist_free(arraylist);\n\n    arraylist = arraylist_new(5);\n\n    arraylist_sort(arraylist.as_mut().unwrap(), int_compare);\n\n    assert_eq!(arraylist.as_ref().unwrap().length, 0);\n\n    arraylist_free(arraylist);\n\n    arraylist = arraylist_new(5);\n\n    arraylist_prepend(arraylist.as_mut().unwrap(), entries[0]);\n    arraylist_sort(arraylist.as_mut().unwrap(), int_compare);\n\n    assert_eq!(arraylist.as_ref().unwrap().length, 1);\n    assert_eq!(arraylist.as_ref().unwrap().data[0], entries[0]);\n\n    arraylist_free(arraylist);\n}\n\n",
        "test_arraylist_insert": "pub fn test_arraylist_insert() {\n    let mut arraylist = generate_arraylist::<i32>().unwrap();\n\n    // Check for out of range insert\n    assert_eq!(arraylist.length, 16);\n    assert!(!arraylist_insert(&mut arraylist, 17, 1));\n    assert_eq!(arraylist.length, 16);\n\n    // Insert a new entry at index 5\n    assert_eq!(arraylist.length, 16);\n    assert_eq!(arraylist.data[4], 0);\n    assert_eq!(arraylist.data[5], 0);\n    assert_eq!(arraylist.data[6], 0);\n\n    assert!(arraylist_insert(&mut arraylist, 5, 4));\n\n    assert_eq!(arraylist.length, 17);\n    assert_eq!(arraylist.data[4], 0);\n    assert_eq!(arraylist.data[5], 4);\n    assert_eq!(arraylist.data[6], 0);\n    assert_eq!(arraylist.data[7], 0);\n\n    // Inserting at the start\n    assert_eq!(arraylist.data[0], 0);\n    assert_eq!(arraylist.data[1], 0);\n    assert_eq!(arraylist.data[2], 0);\n\n    assert!(arraylist_insert(&mut arraylist, 0, 4));\n\n    assert_eq!(arraylist.length, 18);\n    assert_eq!(arraylist.data[0], 4);\n    assert_eq!(arraylist.data[1], 0);\n    assert_eq!(arraylist.data[2], 0);\n    assert_eq!(arraylist.data[3], 0);\n\n    // Inserting at the end\n    assert_eq!(arraylist.data[15], 0);\n    assert_eq!(arraylist.data[16], 0);\n    assert_eq!(arraylist.data[17], 4);\n\n    assert!(arraylist_insert(&mut arraylist, 18, 1));\n\n    assert_eq!(arraylist.length, 19);\n    assert_eq!(arraylist.data[15], 0);\n    assert_eq!(arraylist.data[16], 0);\n    assert_eq!(arraylist.data[17], 4);\n    assert_eq!(arraylist.data[18], 1);\n\n    // Test inserting many entries\n    for _ in 0..10000 {\n        arraylist_insert(&mut arraylist, 10, 1);\n    }\n\n    arraylist_free(Some(arraylist));\n}\n\n",
        "test_arraylist_prepend": "pub fn test_arraylist_prepend() {\n    let mut arraylist = arraylist_new(0).unwrap();\n\n    assert_eq!(arraylist.length, 0);\n\n    let variable1 = 1;\n    let variable2 = 2;\n    let variable3 = 3;\n    let variable4 = 4;\n\n    assert!(arraylist_prepend(&mut arraylist, variable1));\n    assert_eq!(arraylist.length, 1);\n\n    assert!(arraylist_prepend(&mut arraylist, variable2));\n    assert_eq!(arraylist.length, 2);\n\n    assert!(arraylist_prepend(&mut arraylist, variable3));\n    assert_eq!(arraylist.length, 3);\n\n    assert!(arraylist_prepend(&mut arraylist, variable4));\n    assert_eq!(arraylist.length, 4);\n\n    assert_eq!(arraylist.data[0], variable4);\n    assert_eq!(arraylist.data[1], variable3);\n    assert_eq!(arraylist.data[2], variable2);\n    assert_eq!(arraylist.data[3], variable1);\n\n    for _ in 0..10000 {\n        assert!(arraylist_prepend(&mut arraylist, 0));\n    }\n\n    arraylist_free(Some(arraylist));\n\n    let mut arraylist = arraylist_new(100).unwrap();\n\n    for _ in 0..100 {\n        assert!(arraylist_prepend(&mut arraylist, 0));\n    }\n\n    assert_eq!(arraylist.length, 100);\n    assert!(!arraylist_prepend(&mut arraylist, 0));\n    assert_eq!(arraylist.length, 100);\n\n    arraylist_free(Some(arraylist));\n}\n\n",
        "test_arraylist_index_of": "pub fn test_arraylist_index_of() {\n    let entries = vec![89, 4, 23, 42, 16, 15, 8, 99, 50, 30];\n    let num_entries = entries.len();\n    let mut arraylist = arraylist_new::<i32>(0).unwrap();\n\n    for i in 0..num_entries {\n        arraylist_append(&mut arraylist, entries[i]);\n    }\n\n    for i in 0..num_entries {\n        let val = entries[i];\n        let index = arraylist_index_of(&arraylist, int_equal, &val);\n        assert_eq!(index, i as i32);\n    }\n\n    let val = 0;\n    assert!(arraylist_index_of(&arraylist, int_equal, &val) < 0);\n    let val = 57;\n    assert!(arraylist_index_of(&arraylist, int_equal, &val) < 0);\n\n    arraylist_free(Some(arraylist));\n}\n\n",
        "test_arraylist_clear": "pub fn test_arraylist_clear() {\n    let mut arraylist = arraylist_new(0).unwrap();\n\n    // Emptying an already-empty arraylist\n    arraylist_clear(&mut arraylist);\n    assert_eq!(arraylist.length, 0);\n\n    // Add some items and then empty it\n    let variable1 = 1;\n    let variable2 = 2;\n    let variable3 = 3;\n    let variable4 = 4;\n\n    arraylist_append(&mut arraylist, variable1);\n    arraylist_append(&mut arraylist, variable2);\n    arraylist_append(&mut arraylist, variable3);\n    arraylist_append(&mut arraylist, variable4);\n\n    arraylist_clear(&mut arraylist);\n\n    assert_eq!(arraylist.length, 0);\n\n    arraylist_free(Some(arraylist));\n}\n\n",
        "test_arraylist_remove": "pub fn test_arraylist_remove() {\n    let mut arraylist = generate_arraylist::<i32>().expect(\"Failed to generate arraylist\");\n\n    assert_eq!(arraylist.length, 16);\n    assert_eq!(arraylist.data[3], 0);\n    assert_eq!(arraylist.data[4], 0);\n    assert_eq!(arraylist.data[5], 0);\n    assert_eq!(arraylist.data[6], 0);\n\n    arraylist_remove(&mut arraylist, 4);\n\n    assert_eq!(arraylist.length, 15);\n    assert_eq!(arraylist.data[3], 0);\n    assert_eq!(arraylist.data[4], 0);\n    assert_eq!(arraylist.data[5], 0);\n    assert_eq!(arraylist.data[6], 0);\n\n    // Try some invalid removes\n    arraylist_remove(&mut arraylist, 15);\n\n    assert_eq!(arraylist.length, 15);\n\n    arraylist_free(Some(arraylist));\n}\n\n",
        "test_arraylist_remove_range": "pub fn test_arraylist_remove_range() {\n    let mut arraylist = generate_arraylist::<i32>().expect(\"Failed to generate arraylist\");\n\n    assert_eq!(arraylist.length, 16);\n    assert_eq!(arraylist.data[3], 0);\n    assert_eq!(arraylist.data[4], 0);\n    assert_eq!(arraylist.data[5], 0);\n    assert_eq!(arraylist.data[6], 0);\n\n    arraylist_remove_range(&mut arraylist, 4, 3);\n\n    assert_eq!(arraylist.length, 13);\n    assert_eq!(arraylist.data[3], 0);\n    assert_eq!(arraylist.data[4], 0);\n    assert_eq!(arraylist.data[5], 0);\n    assert_eq!(arraylist.data[6], 0);\n\n    // Try some invalid ones and check they don't do anything\n    arraylist_remove_range(&mut arraylist, 10, 10);\n    arraylist_remove_range(&mut arraylist, 0, 16);\n\n    assert_eq!(arraylist.length, 13);\n\n    arraylist_free(Some(arraylist));\n}\n\n",
        "test_arraylist_append": "pub fn test_arraylist_append() {\n    let mut arraylist = arraylist_new(0).unwrap();\n\n    assert_eq!(arraylist.length, 0);\n\n    let variable1 = 1;\n    let variable2 = 2;\n    let variable3 = 3;\n    let variable4 = 4;\n\n    assert!(arraylist_append(&mut arraylist, variable1));\n    assert_eq!(arraylist.length, 1);\n\n    assert!(arraylist_append(&mut arraylist, variable2));\n    assert_eq!(arraylist.length, 2);\n\n    assert!(arraylist_append(&mut arraylist, variable3));\n    assert_eq!(arraylist.length, 3);\n\n    assert!(arraylist_append(&mut arraylist, variable4));\n    assert_eq!(arraylist.length, 4);\n\n    assert_eq!(arraylist.data[0], variable1);\n    assert_eq!(arraylist.data[1], variable2);\n    assert_eq!(arraylist.data[2], variable3);\n    assert_eq!(arraylist.data[3], variable4);\n\n    for _ in 0..10000 {\n        assert!(arraylist_append(&mut arraylist, 0));\n    }\n\n    arraylist_free(Some(arraylist));\n\n    let mut arraylist = arraylist_new(100).unwrap();\n\n    for _ in 0..100 {\n        assert!(arraylist_append(&mut arraylist, 0));\n    }\n\n    assert_eq!(arraylist.length, 100);\n    assert!(arraylist_append(&mut arraylist, 0));\n    assert_eq!(arraylist.length, 101);\n\n    arraylist_free(Some(arraylist));\n}\n\nfn int_compare(value1: &i32, value2: &i32) -> i32 {\n    if value1 < value2 {\n        -1\n    } else if value1 > value2 {\n        1\n    } else {\n        0\n    }\n}\n\n\npub fn int_equal(value1: &i32, value2: &i32) -> i32 {\n    if value1 == value2 {\n        1\n    } else {\n        0\n    }\n}\n\n"
    },
    "binary-heap": {
        "binary_heap_cmp": "pub fn binary_heap_cmp<T: std::cmp::PartialOrd>(heap: &BinaryHeap<T>, data1: &T, data2: &T) -> i32 {\n    match heap.heap_type {\n        BinaryHeapType::Min => (heap.compare_func)(data1, data2),\n        BinaryHeapType::Max => -(heap.compare_func)(data1, data2),\n    }\n}\n\n",
        "extra": "pub enum BinaryHeapType {\n    Min,\n    Max,\n}\n\npub type BinaryHeapValue<T> = Box<dyn std::cmp::PartialOrd<T>>;\n\npub struct BinaryHeap<T: std::cmp::PartialOrd> {\n    pub heap_type: BinaryHeapType,\n    pub values: Vec<T>,\n    pub num_values: usize,\n    pub alloced_size: usize,\n    pub compare_func: fn(&T, &T) -> i32,\n}\n",
        "binary_heap_insert": "pub fn binary_heap_insert<T: std::cmp::PartialOrd + Clone>(heap: &mut BinaryHeap<T>, value: T) -> bool {\n    let mut index = heap.num_values;\n    heap.num_values += 1;\n\n    if heap.num_values >= heap.alloced_size {\n        let new_size = heap.alloced_size * 2;\n        let mut new_values = Vec::with_capacity(new_size);\n        new_values.extend_from_slice(&heap.values);\n        heap.alloced_size = new_size;\n        heap.values = new_values;\n    }\n\n    while index > 0 {\n        let parent = (index - 1) / 2;\n\n        if binary_heap_cmp(heap, &heap.values[parent], &value) < 0 {\n            break;\n        } else {\n            heap.values[index] = heap.values[parent].clone();\n            index = parent;\n        }\n    }\n\n    heap.values[index] = value;\n    true\n}\n\n",
        "binary_heap_new": "pub fn binary_heap_new<T: std::cmp::PartialOrd + Clone>(heap_type: BinaryHeapType, compare_func: fn(&T, &T) -> i32) -> Option<BinaryHeap<T>> {\n    let mut heap = BinaryHeap {\n        heap_type,\n        values: Vec::with_capacity(16),\n        num_values: 0,\n        alloced_size: 16,\n        compare_func,\n    };\n\n    Some(heap)\n}\n\n",
        "binary_heap_free": "pub fn binary_heap_free<T: std::cmp::PartialOrd>(heap: BinaryHeap<T>) {\n    // Rust\u7684Vec\u4f1a\u81ea\u52a8\u7ba1\u7406\u5185\u5b58\uff0c\u4e0d\u9700\u8981\u624b\u52a8\u91ca\u653e\n    // heap.values\u4f1a\u5728heap\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u81ea\u52a8\u91ca\u653e\n    // heap\u672c\u8eab\u4e5f\u4f1a\u5728\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\u81ea\u52a8\u91ca\u653e\n}\n\n",
        "binary_heap_num_entries": "pub fn binary_heap_num_entries<T: std::cmp::PartialOrd>(heap: &BinaryHeap<T>) -> usize {\n    heap.num_values\n}\n\n",
        "binary_heap_pop": "pub fn binary_heap_pop<T: std::cmp::PartialOrd + Clone>(heap: &mut BinaryHeap<T>) -> Option<T> {\n    if heap.num_values == 0 {\n        return None;\n    }\n\n    let result = heap.values[0].clone();\n\n    let new_value = heap.values[heap.num_values - 1].clone();\n    heap.num_values -= 1;\n\n    let mut index = 0;\n\n    loop {\n        let child1 = index * 2 + 1;\n        let child2 = index * 2 + 2;\n\n        if child1 < heap.num_values && binary_heap_cmp(heap, &new_value, &heap.values[child1]) > 0 {\n            let next_index = if child2 < heap.num_values && binary_heap_cmp(heap, &heap.values[child1], &heap.values[child2]) > 0 {\n                child2\n            } else {\n                child1\n            };\n\n            heap.values[index] = heap.values[next_index].clone();\n            index = next_index;\n        } else if child2 < heap.num_values && binary_heap_cmp(heap, &new_value, &heap.values[child2]) > 0 {\n            heap.values[index] = heap.values[child2].clone();\n            index = child2;\n        } else {\n            heap.values[index] = new_value;\n            break;\n        }\n    }\n\n    Some(result)\n}\n\n"
    },
    "test-binary-heap": {
        "main": "fn main() {}\n\n",
        "extra": "pub const NUM_TEST_VALUES: usize = 10000;",
        "test_binary_heap_insert": "pub fn test_binary_heap_insert() {\n    let mut heap = binary_heap_new(BinaryHeapType::Min, int_compare).unwrap();\n    let mut test_array: Vec<i32> = (0..NUM_TEST_VALUES as i32).collect();\n\n    for i in 0..NUM_TEST_VALUES {\n        assert!(binary_heap_insert(&mut heap, test_array[i]));\n    }\n\n    assert_eq!(binary_heap_num_entries(&heap), NUM_TEST_VALUES);\n\n    binary_heap_free(heap);\n}\n\n",
        "test_binary_heap_new_free": "pub fn test_binary_heap_new_free() {\n    for _ in 0..NUM_TEST_VALUES {\n        let heap = binary_heap_new::<i32>(BinaryHeapType::Min, int_compare);\n        binary_heap_free(heap.unwrap());\n    }\n}\n\n",
        "test_out_of_memory": "pub fn test_out_of_memory() {\n    let mut heap = binary_heap_new(BinaryHeapType::Min, int_compare).unwrap();\n    let values = vec![15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];\n\n    for i in 0..16 {\n        assert!(binary_heap_insert(&mut heap, values[i]));\n    }\n\n    assert_eq!(binary_heap_num_entries(&heap), 16);\n\n    for i in 0..16 {\n        assert!(!binary_heap_insert(&mut heap, values[i]));\n        assert_eq!(binary_heap_num_entries(&heap), 16);\n    }\n\n    for i in 0..16 {\n        let value = binary_heap_pop(&mut heap).unwrap();\n        assert_eq!(value, i);\n    }\n\n    assert_eq!(binary_heap_num_entries(&heap), 0);\n\n    binary_heap_free(heap);\n}\n\n",
        "test_min_heap": "pub fn test_min_heap() {\n    let mut heap = binary_heap_new(BinaryHeapType::Min, int_compare).unwrap();\n    let mut test_array: Vec<i32> = (0..NUM_TEST_VALUES as i32).collect();\n\n    for i in 0..NUM_TEST_VALUES {\n        assert!(binary_heap_insert(&mut heap, test_array[i]));\n    }\n\n    let mut i = -1;\n    while binary_heap_num_entries(&heap) > 0 {\n        let val = binary_heap_pop(&mut heap).unwrap();\n        assert!(val == i + 1);\n        i = val;\n    }\n\n    assert_eq!(binary_heap_num_entries(&heap), 0);\n    assert!(binary_heap_pop(&mut heap).is_none());\n\n    binary_heap_free(heap);\n}\n\n",
        "test_max_heap": "pub fn test_max_heap() {\n    pub const NUM_TEST_VALUES: usize = 10000;\n    let mut test_array: Vec<i32> = Vec::with_capacity(NUM_TEST_VALUES);\n\n    let mut heap = binary_heap_new(BinaryHeapType::Max, |a: &i32, b: &i32| {\n        if a < b {\n            -1\n        } else if a > b {\n            1\n        } else {\n            0\n        }\n    }).unwrap();\n\n    for i in 0..NUM_TEST_VALUES {\n        test_array.push(i as i32);\n        assert!(binary_heap_insert(&mut heap, test_array[i]));\n    }\n\n    let mut i = NUM_TEST_VALUES as i32;\n    while binary_heap_num_entries(&heap) > 0 {\n        let val = binary_heap_pop(&mut heap).unwrap();\n        assert_eq!(val, i - 1);\n        i = val;\n    }\n\n    binary_heap_free(heap);\n}\n\npub fn int_compare(a: &i32, b: &i32) -> i32 {\n    if a < b {\n        -1\n    } else if a > b {\n        1\n    } else {\n        0\n    }\n}\n\n"
    },
    "compare-int": {
        "int_compare": "pub fn int_compare<T: PartialOrd>(location1: &T, location2: &T) -> i32 {\n    if location1 < location2 {\n        -1\n    } else if location1 > location2 {\n        1\n    } else {\n        0\n    }\n}\n\n",
        "extra": "",
        "int_equal": "pub fn int_equal<T: PartialEq>(vlocation1: &T, vlocation2: &T) -> bool {\n    vlocation1 == vlocation2\n}\n\n"
    },
    "set": {
        "set_allocate_table": "pub fn set_allocate_table<T>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = Vec::with_capacity(set.table_size);\n    for _ in 0..set.table_size {\n        set.table.push(None);\n    }\n\n    true\n}\n\n",
        "extra": "pub struct Set<T> {\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub entries: usize,\n    pub table_size: usize,\n    pub prime_index: usize,\n    pub hash_func: fn(&T) -> u32,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(Box<SetValue<T>>)>,\n}\n\n#[derive(Clone)]\npub struct SetEntry<T> {\n    pub value: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\npub const SET_NUM_PRIMES: usize = 24;\npub const SET_PRIMES: [usize; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct SetIterator<'a, T> {\n    pub set: &'a Set<T>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\npub struct SetValue<T> {\n    pub value: T,\n}\n\npub static mut ALLOCATED_VALUES: usize = 0;",
        "set_enlarge": "pub fn set_enlarge<T>(set: &mut Set<T>) -> bool {\n    let mut old_table = std::mem::take(&mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let hash_func = set.hash_func;\n            let index = (hash_func(&entry.value) as usize) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\n",
        "set_free_entry": "pub fn set_free_entry<T>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(Box::new(SetValue { value: entry.value }));\n    }\n}\n\n",
        "set_new": "pub fn set_new<T>(hash_func: fn(&T) -> u32, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        table: Vec::new(),\n        entries: 0,\n        table_size: 0,\n        prime_index: 0,\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\n",
        "set_num_entries": "pub fn set_num_entries<T>(set: &Set<T>) -> usize {\n    set.entries\n}\n\n",
        "set_register_free_function": "pub fn set_register_free_function<T>(set: &mut Set<T>, free_func: Option<fn(Box<SetValue<T>>)>) {\n    set.free_func = free_func;\n}\n\n",
        "set_insert": "pub fn set_insert<T>(set: &mut Set<T>, data: T) -> bool {\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let hash_func = set.hash_func;\n    let index = (hash_func(&data) as usize) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    let newentry = Box::new(SetEntry {\n        value: data,\n        next: set.table[index].take(),\n    });\n\n    set.table[index] = Some(newentry);\n\n    set.entries += 1;\n\n    true\n}\n\n",
        "set_query": "pub fn set_query<T>(set: &Set<T>, data: T) -> bool \nwhere\n    T: Clone + PartialEq,\n{\n    let index = (set.hash_func)(&data) % set.table_size as u32;\n\n    let mut rover = &set.table[index as usize];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            return true;\n        }\n        rover = &entry.next;\n    }\n\n    false\n}\n\n",
        "set_free": "pub fn set_free<T>(mut set: Box<Set<T>>) {\n    for i in 0..set.table_size {\n        let mut rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            set_free_entry(&mut set, entry);\n            rover = next;\n        }\n    }\n}\n\n",
        "set_iter_next": "pub fn set_iter_next<T: Clone>(iterator: &mut SetIterator<T>) -> Option<T> {\n    let set = &iterator.set;\n\n    if iterator.next_entry.is_none() {\n        return None;\n    }\n\n    let current_entry = iterator.next_entry.as_ref().unwrap();\n    let result = current_entry.value.clone();\n\n    if let Some(next) = &current_entry.next {\n        iterator.next_entry = Some(Box::new(SetEntry {\n            value: next.value.clone(),\n            next: next.next.clone(),\n        }));\n    } else {\n        iterator.next_entry = None;\n\n        let mut chain = iterator.next_chain + 1;\n\n        while chain < set.table_size {\n            if let Some(entry) = &set.table[chain] {\n                iterator.next_entry = Some(Box::new(SetEntry {\n                    value: entry.value.clone(),\n                    next: entry.next.clone(),\n                }));\n                break;\n            }\n\n            chain += 1;\n        }\n\n        iterator.next_chain = chain;\n    }\n\n    Some(result)\n}\n\n",
        "set_intersection": "pub fn set_intersection<T: Clone + PartialEq>(\n    set1: &Set<T>,\n    set2: &Set<T>,\n) -> Option<Set<T>> {\n    let mut new_set = set_new(set1.hash_func, set2.equal_func)?;\n\n    let mut iterator = SetIterator {\n        set: set1,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator)?;\n\n        if set_query(set2, value.clone()) {\n            if !set_insert(&mut new_set, value) {\n                set_free(Box::new(new_set));\n                return None;\n            }\n        }\n    }\n\n    Some(new_set)\n}\n\n",
        "set_iterate": "pub fn set_iterate<T: Clone>(iterator: &mut SetIterator<T>) {\n    iterator.next_entry = None;\n\n    for chain in 0..iterator.set.table_size {\n        if let Some(entry) = &iterator.set.table[chain] {\n            iterator.next_entry = Some(Box::new(SetEntry {\n                value: entry.value.clone(),\n                next: entry.next.clone(),\n            }));\n            break;\n        }\n    }\n\n    iterator.next_chain = 0;\n}\n\n",
        "set_iter_has_more": "pub fn set_iter_has_more<T>(iterator: &SetIterator<T>) -> bool {\n    iterator.next_entry.is_some()\n}\n\n",
        "set_to_array": "pub fn set_to_array<T>(set: &Set<T>) -> Vec<T> where T: Clone {\n    let mut array: Vec<T> = Vec::with_capacity(set.entries);\n\n    for i in 0..set.table_size {\n        let mut rover = set.table[i].as_ref();\n\n        while let Some(entry) = rover {\n            array.push(entry.value.clone());\n            rover = entry.next.as_ref();\n        }\n    }\n\n    array\n}\n\n",
        "set_union": "pub fn set_union<T: Clone + PartialEq>(set1: &Set<T>, set2: &Set<T>) -> Option<Set<T>> {\n    let mut new_set = set_new(set1.hash_func, set1.equal_func)?;\n\n    let mut iterator = SetIterator {\n        set: set1,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator).unwrap();\n\n        if !set_insert(&mut new_set, value) {\n            set_free(Box::new(new_set));\n            return None;\n        }\n    }\n\n    let mut iterator = SetIterator {\n        set: set2,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator).unwrap();\n\n        if !set_query(&new_set, value.clone()) {\n            if !set_insert(&mut new_set, value) {\n                set_free(Box::new(new_set));\n                return None;\n            }\n        }\n    }\n\n    Some(new_set)\n}\n\n",
        "set_remove": "pub fn set_remove<T>(set: &mut Set<T>, data: T) -> bool \nwhere\n    T: Clone + PartialEq,\n{\n    let index = (set.hash_func)(&data) % set.table_size as u32;\n\n    let mut rover = &mut set.table[index as usize];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            let mut entry = rover.take().unwrap();\n            *rover = entry.next.take();\n            set.entries -= 1;\n            set_free_entry(set, entry);\n            return true;\n        }\n        rover = &mut rover.as_mut().unwrap().next;\n    }\n\n    false\n}\n\n"
    },
    "test-set": {
        "main": "fn main() {}\n\n",
        "extra": "",
        "generate_set": "pub fn generate_set() -> Option<Set<String>> {\n    fn string_hash(s: &String) -> u32 {\n        s.len() as u32\n    }\n\n    fn string_equal(s1: &String, s2: &String) -> bool {\n        s1 == s2\n    }\n\n    let mut set = set_new(string_hash, string_equal)?;\n\n    for i in 0..10000 {\n        let value = i.to_string();\n        set_insert(&mut set, value.clone());\n\n        assert_eq!(set_num_entries(&set), i + 1);\n    }\n\n    set_register_free_function(&mut set, Some(|value| {\n        // No need to explicitly free the value as Rust's ownership system handles it\n    }));\n\n    Some(set)\n}\n\n",
        "new_value": "pub fn new_value<T: Clone>(value: T) -> Box<SetValue<T>> {\n    let result = Box::new(SetValue { value: value.clone() });\n    unsafe {\n        ALLOCATED_VALUES += 1;\n    }\n    result\n}\n\n",
        "test_set_query": "pub fn test_set_query() {\n    let mut set = generate_set().expect(\"Failed to generate set\");\n\n    // Test all values\n    for i in 0..10000 {\n        let buf = i.to_string();\n        assert!(set_query(&set, buf.clone()));\n    }\n\n    // Test invalid values returning false\n    assert!(!set_query(&set, \"-1\".to_string()));\n    assert!(!set_query(&set, \"100001\".to_string()));\n\n    set_free(Box::new(set));\n}\n\n",
        "test_set_iterating": "pub fn test_set_iterating() {\n    let mut set = generate_set().expect(\"Failed to generate set\");\n\n    let mut count = 0;\n    let mut iterator = SetIterator {\n        set: &set,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        set_iter_next(&mut iterator);\n        count += 1;\n    }\n\n    assert!(set_iter_next(&mut iterator).is_none());\n    assert_eq!(count, 10000);\n\n    set_free(Box::new(set));\n\n    let mut empty_set = set_new(int_hash, int_equal).expect(\"Failed to create empty set\");\n    let mut empty_iterator = SetIterator {\n        set: &empty_set,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut empty_iterator);\n    assert!(!set_iter_has_more(&empty_iterator));\n\n    set_free(Box::new(empty_set));\n}\n\n",
        "test_set_out_of_memory": "pub fn test_set_out_of_memory() {\n    let mut set = set_new(int_hash, int_equal).unwrap();\n    let mut values = [0; 66];\n\n    // Test normal failure\n    values[0] = 0;\n    assert!(!set_insert(&mut set, values[0]));\n    assert_eq!(set_num_entries(&set), 0);\n\n    // Test failure when increasing table size.\n    // The initial table size is 193 entries. The table increases in\n    // size when 1/3 full, so the 66th entry should cause the insert\n    // to fail.\n    for i in 0..65 {\n        values[i] = i as i32;\n        assert!(set_insert(&mut set, values[i]));\n        assert_eq!(set_num_entries(&set), i + 1);\n    }\n\n    assert_eq!(set_num_entries(&set), 65);\n\n    // Test the 66th insert\n    values[65] = 65;\n    assert!(!set_insert(&mut set, values[65]));\n    assert_eq!(set_num_entries(&set), 65);\n\n    set_free(Box::new(set));\n}\n\n",
        "test_set_union": "pub fn test_set_union() {\n    let numbers1 = vec![1, 2, 3, 4, 5, 6, 7];\n    let numbers2 = vec![5, 6, 7, 8, 9, 10, 11];\n    let result = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n    let mut set1 = set_new(int_hash, int_equal).unwrap();\n    for num in &numbers1 {\n        set_insert(&mut set1, *num);\n    }\n\n    let mut set2 = set_new(int_hash, int_equal).unwrap();\n    for num in &numbers2 {\n        set_insert(&mut set2, *num);\n    }\n\n    let result_set = set_union(&set1, &set2).unwrap();\n\n    assert_eq!(set_num_entries(&result_set), 11);\n\n    for num in &result {\n        assert!(set_query(&result_set, *num));\n    }\n\n    set_free(Box::new(result_set));\n\n    set_free(Box::new(set1));\n    set_free(Box::new(set2));\n}\n\n",
        "test_set_remove": "pub fn test_set_remove() {\n    let mut set = generate_set().expect(\"Failed to generate set\");\n\n    let mut num_entries = set_num_entries(&set);\n    assert_eq!(num_entries, 10000);\n\n    for i in 4000..6000 {\n        let buf = i.to_string();\n\n        assert!(set_query(&set, buf.clone()));\n\n        assert!(set_remove(&mut set, buf.clone()));\n\n        assert_eq!(set_num_entries(&set), num_entries - 1);\n\n        assert!(!set_query(&set, buf.clone()));\n\n        num_entries -= 1;\n    }\n\n    for i in -1000..-500 {\n        let buf = i.to_string();\n\n        assert!(!set_remove(&mut set, buf.clone()));\n        assert_eq!(set_num_entries(&set), num_entries);\n    }\n\n    for i in 50000..51000 {\n        let buf = i.to_string();\n\n        assert!(!set_remove(&mut set, buf.clone()));\n        assert_eq!(set_num_entries(&set), num_entries);\n    }\n\n    set_free(Box::new(set));\n}\n\n",
        "test_set_free_function": "pub fn test_set_free_function() {\n    let mut set = set_new(int_hash, int_equal).unwrap();\n    set_register_free_function(&mut set, Some(free));\n\n    unsafe {\n        ALLOCATED_VALUES = 0;\n    }\n\n    for i in 0..1000 {\n        let value = new_value(i);\n        set_insert(&mut set, value.value);\n    }\n\n    unsafe {\n        assert_eq!(ALLOCATED_VALUES, 1000);\n    }\n\n    let i = 500;\n    set_remove(&mut set, i);\n\n    unsafe {\n        assert_eq!(ALLOCATED_VALUES, 999);\n    }\n\n    set_free(Box::new(set));\n\n    unsafe {\n        assert_eq!(ALLOCATED_VALUES, 0);\n    }\n}\n\n",
        "free_value": "pub fn free_value(value: Box<SetValue<i32>>) {\n    unsafe {\n        ALLOCATED_VALUES -= 1;\n    }\n}\n\n",
        "test_set_new_free": "pub fn test_set_new_free() {\n    let mut set = set_new(int_hash, int_equal).unwrap();\n\n    set_register_free_function(&mut set, Some(free));\n\n    for i in 0..10000 {\n        set_insert(&mut set, i);\n    }\n\n    set_free(Box::new(set));\n}\n\n",
        "test_set_intersection": "pub fn test_set_intersection() {\n    let numbers1 = vec![1, 2, 3, 4, 5, 6, 7];\n    let numbers2 = vec![5, 6, 7, 8, 9, 10, 11];\n    let result = vec![5, 6, 7];\n\n    let mut set1 = set_new(int_hash, int_equal).unwrap();\n    for num in &numbers1 {\n        set_insert(&mut set1, *num);\n    }\n\n    let mut set2 = set_new(int_hash, int_equal).unwrap();\n    for num in &numbers2 {\n        set_insert(&mut set2, *num);\n    }\n\n    let result_set = set_intersection(&set1, &set2).unwrap();\n\n    assert_eq!(set_num_entries(&result_set), 3);\n\n    for num in &result {\n        assert!(set_query(&result_set, *num));\n    }\n\n    set_free(Box::new(set1));\n    set_free(Box::new(set2));\n    set_free(Box::new(result_set));\n}\n\n",
        "test_set_to_array": "pub fn test_set_to_array() {\n    let mut set = set_new(pointer_hash, pointer_equal).unwrap();\n    let values = vec![1; 100];\n\n    for i in 0..100 {\n        set_insert(&mut set, &values[i]);\n    }\n\n    let array = set_to_array(&set);\n\n    for i in 0..100 {\n        assert_eq!(*array[i], 1);\n    }\n\n    set_free(Box::new(set));\n}\n\npub fn string_hash(s: &String) -> u32 {\n    s.bytes().fold(0, |acc, b| acc.wrapping_mul(31).wrapping_add(b as u32))\n}\n\n\npub fn string_equal(s1: &String, s2: &String) -> bool {\n    s1 == s2\n}\n\n\npub fn int_hash(value: &i32) -> u32 {\n    *value as u32\n}\n\n\npub fn int_equal(value1: &i32, value2: &i32) -> bool {\n    value1 == value2\n}\n\n\npub fn free<T>(_value: Box<SetValue<T>>) {\n    unsafe {\n        ALLOCATED_VALUES -= 1;\n    }\n}\n\n\npub fn pointer_hash<T>(value: &T) -> u32 {\n    // Placeholder for pointer hash function\n    // In Rust, we typically don't use raw pointers, so this would need to be adapted\n    // to the specific use case.\n    0\n}\n\n\npub fn pointer_equal<T: PartialEq>(value1: &T, value2: &T) -> bool {\n    value1 == value2\n}\n\n"
    },
    "hash-table": {
        "hash_table_allocate_table": "pub fn hash_table_allocate_table<K, V>(hash_table: &mut HashTable<K, V>) -> bool {\n    let new_table_size = if hash_table.prime_index < HASH_TABLE_NUM_PRIMES {\n        HASH_TABLE_PRIMES[hash_table.prime_index]\n    } else {\n        hash_table.entries * 10\n    };\n\n    hash_table.table_size = new_table_size;\n\n    hash_table.table = Vec::with_capacity(hash_table.table_size);\n    for _ in 0..hash_table.table_size {\n        hash_table.table.push(None);\n    }\n\n    true\n}\n\n",
        "extra": "pub struct HashTablePair<K, V> {\n    pub key: K,\n    pub value: V,\n}\n\nimpl<K: Clone, V: Clone> Clone for HashTablePair<K, V> {\n    fn clone(&self) -> Self {\n        HashTablePair {\n            key: self.key.clone(),\n            value: self.value.clone(),\n        }\n    }\n}\n\npub struct HashTableEntry<K, V> {\n    pub pair: HashTablePair<K, V>,\n    pub next: Option<Box<HashTableEntry<K, V>>>,\n}\n\nimpl<K: Clone, V: Clone> Clone for HashTableEntry<K, V> {\n    fn clone(&self) -> Self {\n        HashTableEntry {\n            pair: self.pair.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct HashTable<K, V> {\n    pub table: Vec<Option<Box<HashTableEntry<K, V>>>>,\n    pub table_size: usize,\n    pub hash_func: fn(&K) -> u32,\n    pub equal_func: fn(&K, &K) -> bool,\n    pub key_free_func: Option<fn(K)>,\n    pub value_free_func: Option<fn(V)>,\n    pub entries: usize,\n    pub prime_index: usize,\n}\n\nimpl<K: Clone, V: Clone> Clone for HashTable<K, V> {\n    fn clone(&self) -> Self {\n        HashTable {\n            table: self.table.clone(),\n            table_size: self.table_size,\n            hash_func: self.hash_func,\n            equal_func: self.equal_func,\n            key_free_func: self.key_free_func,\n            value_free_func: self.value_free_func,\n            entries: self.entries,\n            prime_index: self.prime_index,\n        }\n    }\n}\n\npub const HASH_TABLE_NUM_PRIMES: usize = 24;\npub const HASH_TABLE_PRIMES: [usize; HASH_TABLE_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct HashTableIterator<K, V> {\n    pub hash_table: Box<HashTable<K, V>>,\n    pub next_entry: Option<Box<HashTableEntry<K, V>>>,\n    pub next_chain: usize,\n}",
        "hash_table_enlarge": "pub fn hash_table_enlarge<K, V>(hash_table: &mut HashTable<K, V>) -> bool {\n    let mut old_table = std::mem::take(&mut hash_table.table);\n    let old_table_size = hash_table.table_size;\n    let old_prime_index = hash_table.prime_index;\n\n    hash_table.prime_index += 1;\n\n    if !hash_table_allocate_table(hash_table) {\n        hash_table.table = old_table;\n        hash_table.table_size = old_table_size;\n        hash_table.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let pair = &entry.pair;\n            let index = ((hash_table.hash_func)(&pair.key) as usize) % hash_table.table_size;\n\n            entry.next = hash_table.table[index].take();\n            hash_table.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\n",
        "hash_table_free_entry": "pub fn hash_table_free_entry<K, V>(hash_table: &mut HashTable<K, V>, entry: Box<HashTableEntry<K, V>>) {\n    let pair = entry.pair;\n\n    if let Some(key_free_func) = hash_table.key_free_func {\n        key_free_func(pair.key);\n    }\n\n    if let Some(value_free_func) = hash_table.value_free_func {\n        value_free_func(pair.value);\n    }\n}\n\n",
        "hash_table_new": "pub fn hash_table_new<K, V>(hash_func: fn(&K) -> u32, equal_func: fn(&K, &K) -> bool) -> Option<HashTable<K, V>> {\n    let mut hash_table = HashTable {\n        table: Vec::new(),\n        table_size: 0,\n        hash_func,\n        equal_func,\n        key_free_func: None,\n        value_free_func: None,\n        entries: 0,\n        prime_index: 0,\n    };\n\n    if !hash_table_allocate_table(&mut hash_table) {\n        return None;\n    }\n\n    Some(hash_table)\n}\n\n",
        "hash_table_register_free_functions": "pub fn hash_table_register_free_functions<K, V>(\n    hash_table: &mut HashTable<K, V>,\n    key_free_func: Option<fn(K)>,\n    value_free_func: Option<fn(V)>,\n) {\n    hash_table.key_free_func = key_free_func;\n    hash_table.value_free_func = value_free_func;\n}\n\n",
        "hash_table_insert": "pub fn hash_table_insert<K, V>(hash_table: &mut HashTable<K, V>, key: K, value: V) -> bool {\n    if (hash_table.entries * 3) / hash_table.table_size > 0 {\n        if !hash_table_enlarge(hash_table) {\n            return false;\n        }\n    }\n\n    let index = ((hash_table.hash_func)(&key) as usize) % hash_table.table_size;\n\n    let mut rover = &mut hash_table.table[index];\n\n    while let Some(entry) = rover {\n        if (hash_table.equal_func)(&entry.pair.key, &key) {\n            if let Some(value_free_func) = hash_table.value_free_func {\n                let value = std::mem::replace(&mut entry.pair.value, value);\n                value_free_func(value);\n            }\n            if let Some(key_free_func) = hash_table.key_free_func {\n                let key = std::mem::replace(&mut entry.pair.key, key);\n                key_free_func(key);\n            }\n            return true;\n        }\n        rover = &mut entry.next;\n    }\n\n    let new_entry = Box::new(HashTableEntry {\n        pair: HashTablePair { key, value },\n        next: hash_table.table[index].take(),\n    });\n\n    hash_table.table[index] = Some(new_entry);\n    hash_table.entries += 1;\n\n    true\n}\n\n",
        "hash_table_free": "pub fn hash_table_free<K, V>(mut hash_table: HashTable<K, V>) {\n    for i in 0..hash_table.table_size {\n        let mut rover = hash_table.table[i].take();\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            hash_table_free_entry(&mut hash_table, entry);\n            rover = next;\n        }\n    }\n}\n\n",
        "hash_table_num_entries": "pub fn hash_table_num_entries<K, V>(hash_table: &HashTable<K, V>) -> usize {\n    hash_table.entries\n}\n\n",
        "hash_table_lookup": "pub fn hash_table_lookup<K, V>(hash_table: &HashTable<K, V>, key: K) -> Option<V>\nwhere\n    K: Clone + PartialEq,\n    V: Clone,\n{\n    let index = (hash_table.hash_func)(&key) as usize % hash_table.table_size;\n\n    let mut rover = &hash_table.table[index];\n\n    while let Some(entry) = rover {\n        let pair = &entry.pair;\n\n        if (hash_table.equal_func)(&key, &pair.key) {\n            return Some(pair.value.clone());\n        }\n\n        rover = &entry.next;\n    }\n\n    None\n}\n\n",
        "hash_table_iter_next": "pub fn hash_table_iter_next<K: Clone, V: Clone>(iterator: &mut HashTableIterator<K, V>) -> Option<HashTablePair<K, V>> {\n    let mut current_entry: Option<Box<HashTableEntry<K, V>>> = iterator.next_entry.take();\n    let hash_table: &HashTable<K, V> = &iterator.hash_table;\n\n    if current_entry.is_none() {\n        return None;\n    }\n\n    let pair: HashTablePair<K, V> = current_entry.as_ref().unwrap().pair.clone();\n\n    if let Some(next_entry) = current_entry.as_ref().unwrap().next.clone() {\n        iterator.next_entry = Some(next_entry);\n    } else {\n        let mut chain: usize = iterator.next_chain + 1;\n        iterator.next_entry = None;\n\n        while chain < hash_table.table_size {\n            if let Some(entry) = hash_table.table[chain].clone() {\n                iterator.next_entry = Some(entry);\n                break;\n            }\n            chain += 1;\n        }\n\n        iterator.next_chain = chain;\n    }\n\n    Some(pair)\n}\n\n",
        "hash_table_iter_has_more": "pub fn hash_table_iter_has_more<K, V>(iterator: &HashTableIterator<K, V>) -> bool {\n    iterator.next_entry.is_some()\n}\n\n",
        "hash_table_iterate": "pub fn hash_table_iterate<K: Clone, V: Clone>(hash_table: Box<HashTable<K, V>>, iterator: &mut HashTableIterator<K, V>) {\n    let mut chain: usize = 0;\n\n    iterator.hash_table = hash_table;\n\n    iterator.next_entry = None;\n\n    while chain < iterator.hash_table.table_size {\n        if let Some(entry) = &iterator.hash_table.table[chain] {\n            iterator.next_entry = Some(Box::new((**entry).clone()));\n            iterator.next_chain = chain;\n            break;\n        }\n        chain += 1;\n    }\n}\n\n",
        "hash_table_remove": "pub fn hash_table_remove<K, V>(hash_table: &mut HashTable<K, V>, key: K) -> bool\nwhere\n    K: Clone + PartialEq,\n    V: Clone,\n{\n    let index = (hash_table.hash_func)(&key) as usize % hash_table.table_size;\n\n    let mut rover = &mut hash_table.table[index];\n    let mut result = false;\n\n    while let Some(entry) = rover {\n        if (hash_table.equal_func)(&key, &entry.pair.key) {\n            let mut entry_to_remove = rover.take().unwrap();\n            *rover = entry_to_remove.next.take();\n\n            hash_table_free_entry(hash_table, entry_to_remove);\n            hash_table.entries -= 1;\n            result = true;\n            break;\n        }\n        rover = &mut rover.as_mut().unwrap().next;\n    }\n\n    result\n}\n\n"
    },
    "test-hash-table": {
        "main": "fn main() {}\n\n",
        "extra": "pub static mut allocated_values: i32 = 0;\n\npub static mut allocated_keys: i32 = 0;",
        "new_value": "pub fn new_value(value: i32) -> Box<i32> {\n    let mut result = Box::new(value);\n    unsafe {\n        allocated_values += 1;\n    }\n    result\n}\n\n",
        "new_key": "pub fn new_key(value: i32) -> Box<i32> {\n    let mut result = Box::new(value);\n    unsafe {\n        allocated_keys += 1;\n    }\n    result\n}\n\n",
        "generate_hash_table": "pub fn generate_hash_table() -> Option<HashTable<String, String>> {\n    let mut hash_table = hash_table_new(string_hash, string_equal)?;\n\n    for i in 0..10000 {\n        let key = i.to_string();\n        let value = key.clone();\n\n        hash_table_insert(&mut hash_table, key, value);\n    }\n\n    hash_table_register_free_functions(&mut hash_table, None, Some(|v: String| { drop(v); }));\n\n    Some(hash_table)\n}\n\n",
        "test_hash_table_new_free": "pub fn test_hash_table_new_free() {\n    let value1 = 1;\n    let value2 = 2;\n    let value3 = 3;\n    let value4 = 4;\n\n    let mut hash_table = hash_table_new(int_hash, int_equal);\n\n    assert!(hash_table.is_some());\n\n    let mut hash_table = hash_table.unwrap();\n\n    assert!(hash_table_insert(&mut hash_table, value1, value1));\n    assert!(hash_table_insert(&mut hash_table, value2, value2));\n    assert!(hash_table_insert(&mut hash_table, value3, value3));\n    assert!(hash_table_insert(&mut hash_table, value4, value4));\n\n    hash_table_free(hash_table);\n}\n\n",
        "test_hash_table_insert_lookup": "pub fn test_hash_table_insert_lookup() {\n    let mut hash_table = generate_hash_table().expect(\"Failed to generate hash table\");\n\n    assert_eq!(hash_table_num_entries(&hash_table), 10000);\n\n    for i in 0..10000 {\n        let key = i.to_string();\n        let value = hash_table_lookup(&hash_table, key.clone()).expect(\"Value not found\");\n\n        assert_eq!(value, key);\n    }\n\n    let invalid_key1 = (-1).to_string();\n    assert!(hash_table_lookup(&hash_table, invalid_key1).is_none());\n\n    let invalid_key2 = 10000.to_string();\n    assert!(hash_table_lookup(&hash_table, invalid_key2).is_none());\n\n    let key = 12345.to_string();\n    hash_table_insert(&mut hash_table, key.clone(), \"hello world\".to_string());\n    let value = hash_table_lookup(&hash_table, key).expect(\"Value not found\");\n\n    assert_eq!(value, \"hello world\");\n\n    hash_table_free(hash_table);\n}\n\n",
        "test_hash_table_iterating": "pub fn test_hash_table_iterating() {\n    let mut hash_table = generate_hash_table().unwrap();\n    let mut iterator = HashTableIterator {\n        hash_table: Box::new(hash_table.clone()),\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    let mut count = 0;\n\n    hash_table_iterate(Box::new(hash_table.clone()), &mut iterator);\n\n    while hash_table_iter_has_more(&iterator) {\n        hash_table_iter_next(&mut iterator);\n        count += 1;\n    }\n\n    assert_eq!(count, 10000);\n\n    let pair = hash_table_iter_next(&mut iterator);\n    assert!(pair.is_none());\n\n    hash_table_free(hash_table);\n\n    let mut empty_hash_table: HashTable<i32, i32> = hash_table_new(int_hash, int_equal).unwrap();\n    let mut empty_iterator = HashTableIterator {\n        hash_table: Box::new(empty_hash_table.clone()),\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    hash_table_iterate(Box::new(empty_hash_table.clone()), &mut empty_iterator);\n\n    assert!(!hash_table_iter_has_more(&empty_iterator));\n\n    hash_table_free(empty_hash_table);\n}\n\n",
        "test_hash_table_remove": "pub fn test_hash_table_remove() {\n    let mut hash_table = generate_hash_table().unwrap();\n    let mut buf = String::new();\n\n    assert_eq!(hash_table_num_entries(&hash_table), 10000);\n    buf = 5000.to_string();\n    assert!(hash_table_lookup(&hash_table, buf.clone()).is_some());\n\n    // Remove an entry\n    hash_table_remove(&mut hash_table, buf.clone());\n\n    // Check entry counter\n    assert_eq!(hash_table_num_entries(&hash_table), 9999);\n\n    // Check that None is returned now\n    assert!(hash_table_lookup(&hash_table, buf.clone()).is_none());\n\n    // Try removing a non-existent entry\n    buf = (-1).to_string();\n    hash_table_remove(&mut hash_table, buf.clone());\n\n    assert_eq!(hash_table_num_entries(&hash_table), 9999);\n\n    hash_table_free(hash_table);\n}\n\n",
        "test_hash_table_iterating_remove": "pub fn test_hash_table_iterating_remove() {\n    let mut hash_table = generate_hash_table().expect(\"Failed to generate hash table\");\n\n    let mut iterator = HashTableIterator {\n        hash_table: Box::new(hash_table.clone()),\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    let mut count = 0;\n    let mut removed = 0;\n\n    hash_table_iterate(Box::new(hash_table.clone()), &mut iterator);\n\n    while hash_table_iter_has_more(&iterator) {\n        let pair = hash_table_iter_next(&mut iterator).expect(\"Failed to get next pair\");\n        let val = pair.value;\n\n        if val.parse::<i32>().unwrap() % 100 == 0 {\n            hash_table_remove(&mut hash_table, val.clone());\n            removed += 1;\n        }\n\n        count += 1;\n    }\n\n    assert_eq!(removed, 100);\n    assert_eq!(count, 10000);\n\n    assert_eq!(hash_table_num_entries(&hash_table), 10000 - removed);\n\n    for i in 0..10000 {\n        let buf = i.to_string();\n\n        if i % 100 == 0 {\n            assert!(hash_table_lookup(&hash_table, buf.clone()).is_none());\n        } else {\n            assert!(hash_table_lookup(&hash_table, buf.clone()).is_some());\n        }\n    }\n\n    hash_table_free(hash_table);\n}\n\n",
        "test_hash_iterator_key_pair": "pub fn test_hash_iterator_key_pair() {\n    let mut hash_table = hash_table_new(int_hash, int_equal).unwrap();\n    let mut iterator = HashTableIterator {\n        hash_table: Box::new(hash_table.clone()),\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    let value1 = 1;\n    let value2 = 2;\n\n    hash_table_insert(&mut hash_table, value1, value1);\n    hash_table_insert(&mut hash_table, value2, value2);\n\n    hash_table_iterate(Box::new(hash_table.clone()), &mut iterator);\n\n    while hash_table_iter_has_more(&iterator) {\n        let pair = hash_table_iter_next(&mut iterator).unwrap();\n        let key = pair.key;\n        let val = pair.value;\n\n        assert_eq!(key, val);\n    }\n\n    hash_table_free(hash_table);\n}\n\n",
        "test_hash_table_out_of_memory": "pub fn test_hash_table_out_of_memory() {\n    let mut hash_table = hash_table_new(int_hash, int_equal).unwrap();\n    let mut values = [0; 66];\n\n    // Test normal failure\n    values[0] = 0;\n    assert!(!hash_table_insert(&mut hash_table, values[0], values[0]));\n    assert_eq!(hash_table_num_entries(&hash_table), 0);\n\n    // Test failure when increasing table size.\n    // The initial table size is 193 entries. The table increases in\n    // size when 1/3 full, so the 66th entry should cause the insert\n    // to fail.\n    for i in 0..65 {\n        values[i] = i as i32;\n        assert!(hash_table_insert(&mut hash_table, values[i], values[i]));\n        assert_eq!(hash_table_num_entries(&hash_table), i + 1);\n    }\n\n    assert_eq!(hash_table_num_entries(&hash_table), 65);\n\n    // Test the 66th insert\n    values[65] = 65;\n    assert!(!hash_table_insert(&mut hash_table, values[65], values[65]));\n    assert_eq!(hash_table_num_entries(&hash_table), 65);\n\n    hash_table_free(hash_table);\n}\n\npub fn string_hash(key: &String) -> u32 {\n    key.len() as u32\n}\n\n\npub fn string_equal(key1: &String, key2: &String) -> bool {\n    key1 == key2\n}\n\n\npub fn int_hash(key: &i32) -> u32 {\n    *key as u32\n}\n\n\npub fn int_equal(key1: &i32, key2: &i32) -> bool {\n    key1 == key2\n}\n\n"
    },
    "compare-pointer": {
        "pointer_equal": "pub fn pointer_equal<T>(location1: &T, location2: &T) -> bool {\n    std::ptr::eq(location1, location2)\n}\n\n",
        "extra": "",
        "pointer_compare": "pub fn pointer_compare<T>(location1: &T, location2: &T) -> i32 {\n    if location1 as *const _ < location2 as *const _ {\n        -1\n    } else if location1 as *const _ > location2 as *const _ {\n        1\n    } else {\n        0\n    }\n}\n\n"
    },
    "bloom-filter": {
        "bloom_filter_new": "pub fn bloom_filter_new<T>(table_size: usize, hash_func: fn(T) -> u32, num_functions: usize) -> Option<BloomFilter<T>> {\n    if num_functions > SALTS.len() {\n        return None;\n    }\n\n    let mut table = vec![0u8; (table_size + 7) / 8];\n\n    Some(BloomFilter {\n        hash_func,\n        table,\n        table_size,\n        num_functions,\n    })\n}\n\n",
        "extra": "pub struct BloomFilter<T> {\n    pub hash_func: fn(T) -> u32,\n    pub table: Vec<u8>,\n    pub table_size: usize,\n    pub num_functions: usize,\n}\n\npub const SALTS: [u32; 64] = [\n    0x1953c322, 0x588ccf17, 0x64bf600c, 0xa6be3f3d,\n    0x341a02ea, 0x15b03217, 0x3b062858, 0x5956fd06,\n    0x18b5624f, 0xe3be0b46, 0x20ffcd5c, 0xa35dfd2b,\n    0x1fc4a9bf, 0x57c45d5c, 0xa8661c4a, 0x4f1b74d2,\n    0x5a6dde13, 0x3b18dac6, 0x05a8afbf, 0xbbda2fe2,\n    0xa2520d78, 0xe7934849, 0xd541bc75, 0x09a55b57,\n    0x9b345ae2, 0xfc2d26af, 0x38679cef, 0x81bd1e0d,\n    0x654681ae, 0x4b3d87ad, 0xd5ff10fb, 0x23b32f67,\n    0xafc7e366, 0xdd955ead, 0xe7c34b1c, 0xfeace0a6,\n    0xeb16f09d, 0x3c57a72d, 0x2c8294c5, 0xba92662a,\n    0xcd5b2d14, 0x743936c8, 0x2489beff, 0xc6c56e00,\n    0x74a4f606, 0xb244a94a, 0x5edfc423, 0xf1901934,\n    0x24af7691, 0xf6c98b25, 0xea25af46, 0x76d5f2e6,\n    0x5e33cdf2, 0x445eb357, 0x88556bd2, 0x70d1da7a,\n    0x54449368, 0x381020bc, 0x1c0520bf, 0xf7e44942,\n    0xa27e2a58, 0x66866fc5, 0x12519ce7, 0x437a8456,\n];",
        "bloom_filter_union": "pub fn bloom_filter_union<T>(filter1: &BloomFilter<T>, filter2: &BloomFilter<T>) -> Option<BloomFilter<T>> {\n    if filter1.table_size != filter2.table_size\n        || filter1.num_functions != filter2.num_functions\n        || filter1.hash_func as usize != filter2.hash_func as usize\n    {\n        return None;\n    }\n\n    let mut result = bloom_filter_new(filter1.table_size, filter1.hash_func, filter1.num_functions)?;\n\n    let array_size = (filter1.table_size + 7) / 8;\n\n    for i in 0..array_size {\n        result.table[i] = filter1.table[i] | filter2.table[i];\n    }\n\n    Some(result)\n}\n\n",
        "bloom_filter_intersection": "pub fn bloom_filter_intersection<T>(filter1: &BloomFilter<T>, filter2: &BloomFilter<T>) -> Option<BloomFilter<T>> {\n    if filter1.table_size != filter2.table_size\n        || filter1.num_functions != filter2.num_functions\n        || filter1.hash_func as usize != filter2.hash_func as usize\n    {\n        return None;\n    }\n\n    let mut result = bloom_filter_new(filter1.table_size, filter1.hash_func, filter1.num_functions)?;\n\n    let array_size = (filter1.table_size + 7) / 8;\n\n    for i in 0..array_size {\n        result.table[i] = filter1.table[i] & filter2.table[i];\n    }\n\n    Some(result)\n}\n\n",
        "bloom_filter_free": "pub fn bloom_filter_free<T>(bloomfilter: Box<BloomFilter<T>>) {\n    // \u7531\u4e8eBloomFilter<T>\u7684\u6240\u6709\u6743\u5728Box\u4e2d\uff0c\u5f53Box\u79bb\u5f00\u4f5c\u7528\u57df\u65f6\uff0c\u5176\u5185\u90e8\u6570\u636e\u4f1a\u81ea\u52a8\u91ca\u653e\n    // \u56e0\u6b64\u4e0d\u9700\u8981\u663e\u5f0f\u8c03\u7528free\u6216drop\n}\n\n",
        "bloom_filter_read": "pub fn bloom_filter_read<T>(bloomfilter: &BloomFilter<T>, array: &mut Vec<u8>) {\n    let array_size = (bloomfilter.table_size + 7) / 8;\n    array.resize(array_size, 0);\n    array.copy_from_slice(&bloomfilter.table[..array_size]);\n}\n\n",
        "bloom_filter_query": "pub fn bloom_filter_query<T>(bloomfilter: &BloomFilter<T>, value: T) -> i32 {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: usize;\n    let mut b: u8;\n    let mut bit: u8;\n\n    hash = (bloomfilter.hash_func)(value);\n\n    for i in 0..bloomfilter.num_functions {\n        subhash = hash ^ SALTS[i];\n\n        index = subhash as usize % bloomfilter.table_size;\n\n        b = bloomfilter.table[index / 8];\n        bit = 1 << (index % 8);\n\n        if (b & bit) == 0 {\n            return 0;\n        }\n    }\n\n    1\n}\n\n",
        "bloom_filter_insert": "pub fn bloom_filter_insert<T>(bloomfilter: &mut BloomFilter<T>, value: T) {\n    let mut hash: u32;\n    let mut subhash: u32;\n    let mut index: usize;\n    let mut b: u8;\n\n    hash = (bloomfilter.hash_func)(value);\n\n    for i in 0..bloomfilter.num_functions {\n        subhash = hash ^ SALTS[i];\n\n        index = (subhash as usize) % bloomfilter.table_size;\n\n        b = (1 << (index % 8)) as u8;\n        bloomfilter.table[index / 8] |= b;\n    }\n}\n\n",
        "bloom_filter_load": "pub fn bloom_filter_load<T>(bloomfilter: &mut BloomFilter<T>, array: &[u8]) {\n    let array_size = (bloomfilter.table_size + 7) / 8;\n    bloomfilter.table[..array_size].copy_from_slice(&array[..array_size]);\n}\n\n"
    },
    "test-bloom-filter": {
        "main": "fn main() {}\n\n",
        "extra": "",
        "test_bloom_filter_mismatch": "pub fn test_bloom_filter_mismatch() {\n    // Create one filter with both values set\n    let mut filter1 = bloom_filter_new(128, string_hash, 4).unwrap();\n\n    // Different buffer size\n    let mut filter2 = bloom_filter_new(64, string_hash, 4).unwrap();\n    assert!(bloom_filter_intersection(&filter1, &filter2).is_none());\n    assert!(bloom_filter_union(&filter1, &filter2).is_none());\n    bloom_filter_free(Box::new(filter2));\n\n    // Different hash function\n    let mut filter2 = bloom_filter_new(128, string_nocase_hash, 4).unwrap();\n    assert!(bloom_filter_intersection(&filter1, &filter2).is_none());\n    assert!(bloom_filter_union(&filter1, &filter2).is_none());\n    bloom_filter_free(Box::new(filter2));\n\n    // Different number of salts\n    let mut filter2 = bloom_filter_new(128, string_hash, 32).unwrap();\n    assert!(bloom_filter_intersection(&filter1, &filter2).is_none());\n    assert!(bloom_filter_union(&filter1, &filter2).is_none());\n    bloom_filter_free(Box::new(filter2));\n\n    bloom_filter_free(Box::new(filter1));\n}\n\n",
        "test_bloom_filter_read_load": "pub fn test_bloom_filter_read_load() {\n    let mut state: Vec<u8> = vec![0; 16];\n\n    // Create a filter with some values set\n    let mut filter1 = bloom_filter_new(128, string_hash, 4).unwrap();\n\n    bloom_filter_insert(&mut filter1, \"test 1\");\n    bloom_filter_insert(&mut filter1, \"test 2\");\n\n    // Read the current state into an array\n    bloom_filter_read(&filter1, &mut state);\n\n    // Create a new filter and load the state\n    let mut filter2 = bloom_filter_new(128, string_hash, 4).unwrap();\n    bloom_filter_load(&mut filter2, &state);\n\n    // Check the values are set in the new filter\n    assert!(bloom_filter_query(&filter2, \"test 1\") != 0);\n    assert!(bloom_filter_query(&filter2, \"test 2\") != 0);\n}\n\n",
        "test_bloom_filter_insert_query": "pub fn test_bloom_filter_insert_query() {\n    // Create a filter\n    let mut filter = bloom_filter_new(128, string_hash, 4).expect(\"Failed to create Bloom filter\");\n\n    // Check values are not present at the start\n    assert_eq!(bloom_filter_query(&filter, \"test 1\"), 0);\n    assert_eq!(bloom_filter_query(&filter, \"test 2\"), 0);\n\n    // Insert some values\n    bloom_filter_insert(&mut filter, \"test 1\");\n    bloom_filter_insert(&mut filter, \"test 2\");\n\n    // Check they are set\n    assert_ne!(bloom_filter_query(&filter, \"test 1\"), 0);\n    assert_ne!(bloom_filter_query(&filter, \"test 2\"), 0);\n\n    // Free the filter\n    bloom_filter_free(Box::new(filter));\n}\n\n",
        "test_bloom_filter_intersection": "pub fn test_bloom_filter_intersection() {\n    let mut filter1 = bloom_filter_new(128, string_hash, 4).unwrap();\n    let mut filter2 = bloom_filter_new(128, string_hash, 4).unwrap();\n\n    bloom_filter_insert(&mut filter1, \"test 1\");\n    bloom_filter_insert(&mut filter1, \"test 2\");\n\n    bloom_filter_insert(&mut filter2, \"test 1\");\n\n    assert_eq!(bloom_filter_query(&filter2, \"test 2\"), 0);\n\n    let result = bloom_filter_intersection(&filter1, &filter2).unwrap();\n\n    assert_ne!(bloom_filter_query(&result, \"test 1\"), 0);\n    assert_eq!(bloom_filter_query(&result, \"test 2\"), 0);\n\n    bloom_filter_free(Box::new(result));\n\n    bloom_filter_free(Box::new(filter1));\n    bloom_filter_free(Box::new(filter2));\n}\n\n",
        "test_bloom_filter_new_free": "pub fn test_bloom_filter_new_free() {\n    // One salt\n    let filter = bloom_filter_new::<&str>(128, string_hash as fn(&str) -> u32, 1);\n    assert!(filter.is_some());\n    if let Some(filter) = filter {\n        bloom_filter_free(Box::new(filter));\n    }\n\n    // Maximum number of salts\n    let filter = bloom_filter_new::<&str>(128, string_hash as fn(&str) -> u32, 64);\n    assert!(filter.is_some());\n    if let Some(filter) = filter {\n        bloom_filter_free(Box::new(filter));\n    }\n\n    // Test creation with too many salts\n    let filter = bloom_filter_new::<&str>(128, string_hash as fn(&str) -> u32, 50000);\n    assert!(filter.is_none());\n}\n\n",
        "test_bloom_filter_union": "pub fn test_bloom_filter_union() {\n    let mut filter1 = bloom_filter_new(128, string_hash as fn(&str) -> u32, 4).expect(\"Failed to create filter1\");\n    bloom_filter_insert(&mut filter1, \"test 1\");\n\n    let mut filter2 = bloom_filter_new(128, string_hash as fn(&str) -> u32, 4).expect(\"Failed to create filter2\");\n    bloom_filter_insert(&mut filter2, \"test 2\");\n\n    let result = bloom_filter_union(&filter1, &filter2).expect(\"Failed to create union filter\");\n\n    assert!(bloom_filter_query(&result, \"test 1\") != 0);\n    assert!(bloom_filter_query(&result, \"test 2\") != 0);\n\n    bloom_filter_free(Box::new(result));\n    bloom_filter_free(Box::new(filter1));\n    bloom_filter_free(Box::new(filter2));\n}\n\npub fn string_nocase_hash(s: &str) -> u32 {\n    let mut hash: u32 = 5381;\n    for c in s.to_lowercase().bytes() {\n        hash = ((hash << 5).wrapping_add(hash)) + c as u32;\n    }\n    hash\n}\n\n\npub fn string_hash(s: &str) -> u32 {\n    let mut hash: u32 = 5381;\n    for c in s.bytes() {\n        hash = ((hash << 5).wrapping_add(hash)) + c as u32;\n    }\n    hash\n}\n\n"
    },
    "hash-int": {
        "int_hash": "pub fn int_hash<T: Clone + Into<u64>>(vlocation: &T) -> u32 {\n    let location = vlocation.clone();\n    location.into() as u32\n}\n\n",
        "extra": "// \u6d4b\u8bd5\u51fd\u6570\n\n// \u6d4b\u8bd5\u51fd\u6570\n\n\n// \u6d4b\u8bd5\u51fd\u6570"
    },
    "list": {
        "list_append": "pub fn list_append<T>(list: &mut Option<Box<ListEntry<T>>>, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut newentry = Box::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    });\n\n    if list.is_none() {\n        *list = Some(newentry);\n        return list.clone();\n    }\n\n    let mut rover = list.as_mut().unwrap();\n    while rover.next.is_some() {\n        rover = rover.next.as_mut().unwrap();\n    }\n\n    newentry.prev = Some(Box::new(ListEntry {\n        data: rover.data.clone(),\n        prev: rover.prev.clone(),\n        next: None,\n    }));\n    rover.next = Some(newentry);\n\n    rover.next.clone()\n}\n\n",
        "extra": "pub static variable1: i32 = 50;\npub static variable2: i32 = 0;\npub static variable3: i32 = 0;\npub static variable4: i32 = 0;\n\n#[derive(Debug)]\npub struct ListEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<ListEntry<T>>>,\n    pub next: Option<Box<ListEntry<T>>>,\n}\n\nimpl<T> Clone for ListEntry<T>\nwhere\n    T: Clone,\n{\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T> PartialEq for ListEntry<T>\nwhere\n    T: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.prev == other.prev && self.next == other.next\n    }\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Box<ListEntry<T>>>,\n    pub current: Option<Box<ListEntry<T>>>,\n}",
        "list_prev": "pub fn list_prev<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.prev,\n        None => None,\n    }\n}\n\n",
        "list_next": "pub fn list_next<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.next,\n        None => None,\n    }\n}\n\n",
        "list_nth_entry": "pub fn list_nth_entry<T>(list: Option<Box<ListEntry<T>>>, n: usize) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut entry = list;\n\n    for _ in 0..n {\n        if entry.is_none() {\n            return None;\n        }\n        entry = entry.and_then(|e| e.next);\n    }\n\n    entry\n}\n\n",
        "list_length": "pub fn list_length<T>(list: Option<Box<ListEntry<T>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(node) = entry {\n        length += 1;\n        entry = node.next;\n    }\n\n    length\n}\n\n",
        "list_sort_internal": "pub fn list_sort_internal<T, F>(list: &mut Option<Box<ListEntry<T>>>, compare_func: F) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> i32,\n{\n    if list.is_none() {\n        return None;\n    }\n\n    let mut pivot = list.take().unwrap();\n    if pivot.next.is_none() {\n        let pivot_clone = pivot.clone();\n        *list = Some(pivot);\n        return Some(pivot_clone);\n    }\n\n    let mut less_list: Option<Box<ListEntry<T>>> = None;\n    let mut more_list: Option<Box<ListEntry<T>>> = None;\n    let mut rover = pivot.next.take();\n\n    while let Some(mut current) = rover {\n        let next = current.next.take();\n        let current_data = current.data.clone();\n        if compare_func(&current_data, &pivot.data) < 0 {\n            current.prev = None;\n            current.next = less_list.take();\n            let current_clone = current.clone();\n            if let Some(ref mut less) = current.next {\n                less.prev = Some(current_clone);\n            }\n            less_list = Some(current);\n        } else {\n            current.prev = None;\n            current.next = more_list.take();\n            let current_clone = current.clone();\n            if let Some(ref mut more) = current.next {\n                more.prev = Some(current_clone);\n            }\n            more_list = Some(current);\n        }\n        rover = next;\n    }\n\n    let mut less_list_end = list_sort_internal(&mut less_list, &compare_func);\n    let more_list_end = list_sort_internal(&mut more_list, &compare_func);\n\n    *list = less_list.take();\n    if let Some(ref mut less_end) = less_list_end {\n        let pivot_clone = pivot.clone();\n        pivot.prev = Some(less_end.clone());\n        less_end.next = Some(pivot_clone);\n    } else {\n        pivot.prev = None;\n        *list = Some(pivot.clone());\n    }\n\n    pivot.next = more_list.take();\n    let pivot_clone = pivot.clone();\n    if let Some(ref mut more) = pivot.next {\n        more.prev = Some(pivot_clone);\n    }\n\n    if more_list_end.is_none() {\n        Some(pivot)\n    } else {\n        more_list_end\n    }\n}\n\n",
        "list_free": "pub fn list_free<T>(list: Option<Box<ListEntry<T>>>) {\n    let mut entry = list;\n\n    while let Some(mut current_entry) = entry {\n        entry = current_entry.next.take();\n    }\n}\n\n",
        "list_nth_data": "pub fn list_nth_data<T>(list: Option<Box<ListEntry<T>>>, n: usize) -> Option<T>\nwhere\n    T: Clone,\n{\n    let entry = list_nth_entry(list, n);\n\n    if entry.is_none() {\n        None\n    } else {\n        entry.map(|e| e.data)\n    }\n}\n\n",
        "list_iterate": "pub fn list_iterate<T>(list: &mut Option<Box<ListEntry<T>>>, iter: &mut ListIterator<T>) {\n    iter.prev_next = list.take();\n    iter.current = None;\n}\n\n",
        "list_remove_data": "pub fn list_remove_data<T, F>(list: &mut Option<Box<ListEntry<T>>>, callback: F, data: T) -> usize\nwhere\n    T: Clone + PartialEq,\n    F: Fn(&T, &T) -> bool,\n{\n    let mut entries_removed = 0;\n    let mut rover = list.take();\n\n    while let Some(mut current) = rover {\n        let next = current.next.take();\n\n        if callback(&current.data, &data) {\n            if let Some(mut prev) = current.prev.take() {\n                prev.next = current.next.take();\n            } else {\n                *list = current.next.take();\n            }\n\n            if let Some(next_node) = current.next.as_mut() {\n                next_node.prev = current.prev.take();\n            }\n\n            entries_removed += 1;\n        } else {\n            let current_clone = current.clone();\n            if let Some(mut prev) = current.prev.take() {\n                prev.next = Some(current_clone.clone());\n            } else {\n                *list = Some(current_clone.clone());\n            }\n\n            if let Some(next_node) = current.next.as_mut() {\n                next_node.prev = Some(current_clone);\n            }\n        }\n\n        rover = next;\n    }\n\n    entries_removed\n}\n\n",
        "list_iter_has_more": "pub fn list_iter_has_more<T>(iter: &ListIterator<T>) -> bool\nwhere\n    T: PartialEq,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|x| &**x) != iter.prev_next.as_ref().map(|x| &**x) {\n        iter.prev_next.is_some()\n    } else {\n        iter.current.as_ref().unwrap().next.is_some()\n    }\n}\n\n",
        "list_prepend": "pub fn list_prepend<T>(list: &mut Option<Box<ListEntry<T>>>, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut newentry = Box::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    });\n\n    if let Some(ref mut head) = list {\n        head.prev = Some(newentry.clone());\n        newentry.next = Some(head.clone());\n    }\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\n",
        "list_iter_remove": "pub fn list_iter_remove<T>(iter: &mut ListIterator<T>)\nwhere\n    T: Clone + PartialEq,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|x| &**x) != iter.prev_next.as_ref().map(|x| &**x) {\n        // Either we have not yet read the first item, we have\n        // reached the end of the list, or we have already removed\n        // the current value. Either way, do nothing.\n    } else {\n        // Remove the current entry\n        let mut current = iter.current.take().unwrap();\n        if let Some(ref mut prev_next) = iter.prev_next {\n            *prev_next = current.next.take().unwrap_or_else(|| Box::new(ListEntry {\n                data: current.data.clone(),\n                prev: None,\n                next: None,\n            }));\n        }\n\n        if let Some(ref mut next) = current.next {\n            next.prev = current.prev.clone();\n        }\n\n        iter.current = None;\n    }\n}\n\n",
        "list_to_array": "pub fn list_to_array<T: Clone>(list: Option<Box<ListEntry<T>>>) -> Vec<T> {\n    let length = list_length(list.clone());\n    let mut array = Vec::with_capacity(length);\n\n    let mut rover = list;\n\n    for _ in 0..length {\n        if let Some(node) = rover {\n            array.push(node.data.clone());\n            rover = node.next;\n        }\n    }\n\n    array\n}\n\n",
        "list_data": "pub fn list_data<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<T>\nwhere\n    T: Clone,\n{\n    match listentry {\n        Some(entry) => Some(entry.data.clone()),\n        None => None,\n    }\n}\n\n",
        "list_sort": "pub fn list_sort<T, F>(list: &mut Option<Box<ListEntry<T>>>, compare_func: F)\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> i32,\n{\n    *list = list_sort_internal(list, compare_func);\n}\n\n",
        "list_find_data": "pub fn list_find_data<T, F>(list: Option<Box<ListEntry<T>>>, callback: F, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone + PartialEq,\n    F: Fn(T, T) -> bool,\n{\n    let mut rover = list;\n\n    while let Some(node) = rover {\n        if callback(node.data.clone(), data.clone()) {\n            return Some(node);\n        }\n        rover = node.next;\n    }\n\n    None\n}\n\n",
        "list_remove_entry": "pub fn list_remove_entry<T>(list: &mut Option<Box<ListEntry<T>>>, entry: Option<Box<ListEntry<T>>>) -> bool\nwhere\n    T: Clone,\n{\n    if list.is_none() || entry.is_none() {\n        return false;\n    }\n\n    let mut entry = entry.unwrap();\n\n    if entry.prev.is_none() {\n        *list = entry.next.take();\n\n        if let Some(ref mut next_entry) = list {\n            next_entry.prev = None;\n        }\n    } else {\n        let mut prev_entry = entry.prev.take().unwrap();\n        let mut next_entry = entry.next.take();\n\n        if let Some(ref mut next_entry_inner) = next_entry {\n            next_entry_inner.prev = Some(Box::new((*prev_entry).clone()));\n        }\n\n        if let Some(ref mut prev_entry_inner) = prev_entry.next {\n            prev_entry_inner.next = next_entry;\n        }\n    }\n\n    true\n}\n\n",
        "list_iter_next": "pub fn list_iter_next<T>(iter: &mut ListIterator<T>) -> Option<T>\nwhere\n    T: Clone + PartialEq,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|x| &**x) != iter.prev_next.as_ref().map(|x| &**x) {\n        iter.current = iter.prev_next.take();\n    } else {\n        if let Some(ref mut current) = iter.current {\n            iter.prev_next = current.next.clone();\n            iter.current = current.next.clone();\n        }\n    }\n\n    if iter.current.is_none() {\n        None\n    } else {\n        Some(iter.current.as_ref().unwrap().data.clone())\n    }\n}\n\n"
    },
    "test-list": {
        "main": "fn main() {}\n\n",
        "extra": "",
        "generate_list": "pub fn generate_list() -> Option<Box<ListEntry<i32>>> {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n\n    assert!(list_append(&mut list, variable1).is_some());\n    assert!(list_append(&mut list, variable2).is_some());\n    assert!(list_append(&mut list, variable3).is_some());\n    assert!(list_append(&mut list, variable4).is_some());\n\n    list\n}\n\n",
        "test_list_free": "pub fn test_list_free() {\n    let mut list = generate_list();\n    list_free(list);\n\n    list_free::<i32>(None);\n}\n\n",
        "test_list_iterate_bad_remove": "pub fn test_list_iterate_bad_remove() {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n    let mut iter = ListIterator {\n        prev_next: None,\n        current: None,\n    };\n    let mut values = [0; 49];\n\n    for i in 0..49 {\n        values[i] = i as i32; // Convert usize to i32\n        assert!(list_prepend(&mut list, values[i]).is_some());\n    }\n\n    list_iterate(&mut list, &mut iter);\n\n    while list_iter_has_more(&iter) {\n        let val = list_iter_next(&mut iter).unwrap();\n\n        if val % 2 == 0 {\n            assert_ne!(list_remove_data(&mut list, |a: &i32, b: &i32| a == b, val), 0);\n            list_iter_remove(&mut iter);\n        }\n    }\n\n    list_free(list);\n}\n\n",
        "test_list_nth_data": "pub fn test_list_nth_data() {\n    let list = generate_list();\n\n    // Check all values in the list\n    assert_eq!(list_nth_data(list.clone(), 0), Some(50));\n    assert_eq!(list_nth_data(list.clone(), 1), Some(0));\n    assert_eq!(list_nth_data(list.clone(), 2), Some(0));\n    assert_eq!(list_nth_data(list.clone(), 3), Some(0));\n\n    // Check out of range values\n    assert_eq!(list_nth_data(list.clone(), 4), None);\n    assert_eq!(list_nth_data(list.clone(), 400), None);\n\n    list_free(list);\n}\n\n",
        "test_list_to_array": "pub fn test_list_to_array() {\n    let list = generate_list();\n    let array = list_to_array(list.clone());\n\n    assert_eq!(array[0], 50);\n    assert_eq!(array[1], 0);\n    assert_eq!(array[2], 0);\n    assert_eq!(array[3], 0);\n\n    list_free(list);\n}\n\n",
        "test_list_next": "pub fn test_list_next() {\n    let mut list = generate_list();\n    let mut rover = list.clone();\n\n    assert_eq!(list_data(rover.clone()), Some(50));\n    rover = list_next(rover);\n    assert_eq!(list_data(rover.clone()), Some(0));\n    rover = list_next(rover);\n    assert_eq!(list_data(rover.clone()), Some(0));\n    rover = list_next(rover);\n    assert_eq!(list_data(rover.clone()), Some(0));\n    rover = list_next(rover);\n    assert_eq!(rover, None);\n\n    list_free(list);\n}\n\n",
        "test_list_sort": "pub fn test_list_sort() {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n    let entries = vec![89, 4, 23, 42, 4, 16, 15, 4, 8, 99, 50, 30, 4];\n    let sorted = vec![4, 4, 4, 4, 8, 15, 16, 23, 30, 42, 50, 89, 99];\n    let num_entries = entries.len();\n\n    for i in 0..num_entries {\n        assert!(list_prepend(&mut list, entries[i]).is_some());\n    }\n\n    list_sort(&mut list, |a, b| match a.cmp(b) {\n        std::cmp::Ordering::Less => -1,\n        std::cmp::Ordering::Equal => 0,\n        std::cmp::Ordering::Greater => 1,\n    });\n\n    assert_eq!(list_length(list.clone()), num_entries);\n\n    for i in 0..num_entries {\n        let value = list_nth_data(list.clone(), i);\n        assert_eq!(value, Some(sorted[i]));\n    }\n\n    list_free(list);\n\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n    list_sort(&mut list, |a, b| match a.cmp(b) {\n        std::cmp::Ordering::Less => -1,\n        std::cmp::Ordering::Equal => 0,\n        std::cmp::Ordering::Greater => 1,\n    });\n    assert!(list.is_none());\n}\n\n",
        "test_list_iterate": "pub fn test_list_iterate() {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n    let mut iter = ListIterator {\n        prev_next: None,\n        current: None,\n    };\n    let a = 0;\n    let mut counter = 0;\n\n    // Create a list with 50 entries\n    for _ in 0..50 {\n        assert!(list_prepend(&mut list, a).is_some());\n    }\n\n    // Iterate over the list and count the number of entries visited\n    list_iterate(&mut list, &mut iter);\n\n    // Test remove before list_iter_next has been called\n    list_iter_remove(&mut iter);\n\n    // Iterate over the list\n    while list_iter_has_more(&iter) {\n        let data = list_iter_next(&mut iter);\n        assert!(data.is_some());\n        counter += 1;\n\n        if (counter % 2) == 0 {\n            // Delete half the entries in the list\n            list_iter_remove(&mut iter);\n\n            // Test double remove\n            list_iter_remove(&mut iter);\n        }\n    }\n\n    // Test iter_next after iteration has completed\n    assert!(list_iter_next(&mut iter).is_none());\n\n    // Test remove at the end of a list\n    list_iter_remove(&mut iter);\n\n    assert_eq!(counter, 50);\n    assert_eq!(list_length(list.clone()), 25);\n\n    list_free(list);\n\n    // Test iterating over an empty list\n    list = None;\n    counter = 0;\n\n    list_iterate(&mut list, &mut iter);\n\n    while list_iter_has_more(&iter) {\n        let data = list_iter_next(&mut iter);\n        assert!(data.is_some());\n        counter += 1;\n    }\n\n    assert_eq!(counter, 0);\n}\n\n",
        "test_list_find_data": "pub fn test_list_find_data() {\n    let entries = vec![89, 23, 42, 16, 15, 4, 8, 99, 50, 30];\n    let num_entries = entries.len();\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n\n    // Generate a list containing the entries\n    for i in 0..num_entries {\n        assert!(list_append(&mut list, entries[i]).is_some());\n    }\n\n    // Check that each value can be searched for correctly\n    for i in 0..num_entries {\n        let val = entries[i];\n\n        let result = list_find_data(list.clone(), |a, b| a == b, val);\n\n        assert!(result.is_some());\n\n        let data = list_data(result);\n        assert_eq!(data, Some(val));\n    }\n\n    // Check some invalid values return None\n    let val = 0;\n    assert!(list_find_data(list.clone(), |a, b| a == b, val).is_none());\n    let val = 56;\n    assert!(list_find_data(list.clone(), |a, b| a == b, val).is_none());\n\n    list_free(list);\n}\n\n",
        "test_list_nth_entry": "pub fn test_list_nth_entry() {\n    let mut list = generate_list();\n\n    // Check all values in the list\n    let mut entry = list_nth_entry(list.clone(), 0);\n    assert_eq!(list_data(entry), Some(50));\n    entry = list_nth_entry(list.clone(), 1);\n    assert_eq!(list_data(entry), Some(0));\n    entry = list_nth_entry(list.clone(), 2);\n    assert_eq!(list_data(entry), Some(0));\n    entry = list_nth_entry(list.clone(), 3);\n    assert_eq!(list_data(entry), Some(0));\n\n    // Check out of range values\n    entry = list_nth_entry(list.clone(), 4);\n    assert_eq!(entry, None);\n    entry = list_nth_entry(list.clone(), 400);\n    assert_eq!(entry, None);\n\n    list_free(list);\n}\n\n",
        "test_list_prepend": "pub fn test_list_prepend() {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n\n    assert!(list_prepend(&mut list, unsafe { variable1 }).is_some());\n    check_list_integrity(&list);\n    assert!(list_prepend(&mut list, unsafe { variable2 }).is_some());\n    check_list_integrity(&list);\n    assert!(list_prepend(&mut list, unsafe { variable3 }).is_some());\n    check_list_integrity(&list);\n    assert!(list_prepend(&mut list, unsafe { variable4 }).is_some());\n    check_list_integrity(&list);\n\n    assert_eq!(list_nth_data(list.clone(), 0), Some(unsafe { variable4 }));\n    assert_eq!(list_nth_data(list.clone(), 1), Some(unsafe { variable3 }));\n    assert_eq!(list_nth_data(list.clone(), 2), Some(unsafe { variable2 }));\n    assert_eq!(list_nth_data(list.clone(), 3), Some(unsafe { variable1 }));\n\n    assert_eq!(list_length(list.clone()), 4);\n\n    list_free(list);\n}\n\n",
        "check_list_integrity": "pub fn check_list_integrity<T>(list: &Option<Box<ListEntry<T>>>)\nwhere\n    T: Clone + PartialEq + std::fmt::Debug,\n{\n    let mut prev: Option<Box<ListEntry<T>>> = None;\n    let mut rover = list.clone();\n\n    while let Some(ref node) = rover {\n        assert_eq!(list_prev(rover.clone()), prev);\n        prev = rover.clone();\n        rover = list_next(rover.clone());\n    }\n}\n\n",
        "test_list_length": "pub fn test_list_length() {\n    let mut list = generate_list();\n\n    // Generate a list and check that it is four entries long\n    assert_eq!(list_length(list.clone()), 4);\n\n    // Add an entry and check that it still works properly\n    unsafe {\n        assert!(list_prepend(&mut list, variable1).is_some());\n    }\n    assert_eq!(list_length(list.clone()), 5);\n\n    list_free(list);\n\n    // Check the length of the empty list\n    assert_eq!(list_length::<i32>(None), 0);\n}\n\n",
        "test_list_remove_entry": "pub fn test_list_remove_entry() {\n    let mut empty_list: Option<Box<ListEntry<i32>>> = None;\n    let mut list: Option<Box<ListEntry<i32>>>;\n    let mut entry: Option<Box<ListEntry<i32>>>;\n\n    list = generate_list();\n\n    /* Remove the third entry */\n    entry = list_nth_entry(list.clone(), 2);\n    assert!(list_remove_entry(&mut list, entry) != false);\n    assert!(list_length(list.clone()) == 3);\n    check_list_integrity(&list);\n\n    /* Remove the first entry */\n    entry = list_nth_entry(list.clone(), 0);\n    assert!(list_remove_entry(&mut list, entry) != false);\n    assert!(list_length(list.clone()) == 2);\n    check_list_integrity(&list);\n\n    /* Try some invalid removes */\n    /* NULL */\n    assert!(list_remove_entry(&mut list, None) == false);\n\n    /* Removing NULL from an empty list */\n    assert!(list_remove_entry(&mut empty_list, None) == false);\n\n    list_free(list);\n\n    /* Test removing an entry when it is the only entry. */\n    list = None;\n    let list_clone = list.clone();\n    assert!(list_append(&mut list, variable1).is_some());\n    assert!(list.is_some());\n    assert!(list_remove_entry(&mut list, list_clone) != false);\n    assert!(list.is_none());\n\n    /* Test removing the last entry */\n    list = generate_list();\n    entry = list_nth_entry(list.clone(), 3);\n    assert!(list_remove_entry(&mut list, entry) != false);\n    check_list_integrity(&list);\n    list_free(list);\n}\n\n"
    },
    "slist": {
        "slist_append": "pub fn slist_append<T>(list: &mut Option<Box<SListEntry<T>>>, data: T) -> &mut Option<Box<SListEntry<T>>> {\n    let newentry = Box::new(SListEntry {\n        data,\n        next: None,\n    });\n\n    if list.is_none() {\n        *list = Some(newentry);\n    } else {\n        let mut rover = list.as_mut().unwrap();\n        while rover.next.is_some() {\n            rover = rover.next.as_mut().unwrap();\n        }\n        rover.next = Some(newentry);\n    }\n\n    list\n}\n\n",
        "extra": "pub struct SListEntry<T> {\n    pub data: T,\n    pub next: Option<Box<SListEntry<T>>>,\n}\n\nimpl<T: Clone> Clone for SListEntry<T> {\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for SListEntry<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.next == other.next\n    }\n}\n\npub struct SListIterator<T> {\n    pub prev_next: Option<Box<SListEntry<T>>>,\n    pub current: Option<Box<SListEntry<T>>>,\n}",
        "slist_nth_entry": "pub fn slist_nth_entry<T>(list: Option<Box<SListEntry<T>>>, n: usize) -> Option<Box<SListEntry<T>>> {\n    let mut entry = list;\n    let mut i = 0;\n\n    while i < n {\n        match entry {\n            Some(ref mut current) => {\n                entry = current.next.take();\n                i += 1;\n            }\n            None => return None,\n        }\n    }\n\n    entry\n}\n\n",
        "slist_length": "pub fn slist_length<T>(list: Option<Box<SListEntry<T>>>) -> usize {\n    let mut length: usize = 0;\n    let mut entry = list;\n\n    while let Some(node) = entry {\n        length += 1;\n        entry = node.next;\n    }\n\n    length\n}\n\n",
        "slist_sort_internal": "pub fn slist_sort_internal<T, F>(list: &mut Option<Box<SListEntry<T>>>, compare_func: F) -> Option<Box<SListEntry<T>>>\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> std::cmp::Ordering,\n{\n    if list.is_none() || list.as_ref().unwrap().next.is_none() {\n        return list.take();\n    }\n\n    let mut pivot = list.take().unwrap();\n    let mut less_list: Option<Box<SListEntry<T>>> = None;\n    let mut more_list: Option<Box<SListEntry<T>>> = None;\n    let mut rover = pivot.next.take();\n\n    while let Some(mut node) = rover {\n        let next = node.next.take();\n        match compare_func(&node.data, &pivot.data) {\n            std::cmp::Ordering::Less => {\n                node.next = less_list.take();\n                less_list = Some(node);\n            }\n            _ => {\n                node.next = more_list.take();\n                more_list = Some(node);\n            }\n        }\n        rover = next;\n    }\n\n    let less_list_end = slist_sort_internal(&mut less_list, &compare_func);\n    let more_list_end = slist_sort_internal(&mut more_list, &compare_func);\n\n    *list = less_list.take();\n    if list.is_none() {\n        *list = Some(pivot.clone());\n    } else {\n        less_list_end.unwrap().next = Some(pivot.clone());\n    }\n\n    pivot.next = more_list.take();\n\n    if more_list.is_none() {\n        Some(pivot)\n    } else {\n        more_list_end\n    }\n}\n\n",
        "slist_prepend": "pub fn slist_prepend<T: Clone>(list: &mut Option<Box<SListEntry<T>>>, data: T) -> Option<Box<SListEntry<T>>> {\n    let newentry = Box::new(SListEntry {\n        data,\n        next: list.take(),\n    });\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\n",
        "slist_free": "pub fn slist_free<T>(list: Option<Box<SListEntry<T>>>) {\n    let mut entry = list;\n\n    while let Some(mut current_entry) = entry {\n        entry = current_entry.next.take();\n    }\n}\n\n",
        "slist_data": "pub fn slist_data<T>(listentry: &SListEntry<T>) -> T \nwhere\n    T: Clone,\n{\n    listentry.data.clone()\n}\n\n",
        "slist_nth_data": "pub fn slist_nth_data<T: Clone>(list: Option<Box<SListEntry<T>>>, n: usize) -> Option<T> {\n    let entry = slist_nth_entry(list, n);\n\n    match entry {\n        Some(entry) => Some(entry.data.clone()),\n        None => None,\n    }\n}\n\n",
        "slist_iter_next": "pub fn slist_iter_next<T>(iter: &mut SListIterator<T>) -> Option<T>\nwhere\n    T: Clone + PartialEq,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|x| &**x) != iter.prev_next.as_ref().map(|x| &**x) {\n        iter.current = iter.prev_next.clone();\n    } else {\n        if let Some(current) = &iter.current {\n            iter.prev_next = current.next.clone();\n            iter.current = current.next.clone();\n        }\n    }\n\n    if iter.current.is_none() {\n        None\n    } else {\n        iter.current.as_ref().map(|x| x.data.clone())\n    }\n}\n\n",
        "slist_iterate": "pub fn slist_iterate<T>(list: &mut Option<Box<SListEntry<T>>>, iter: &mut SListIterator<T>) {\n    iter.prev_next = list.take();\n    iter.current = None;\n}\n\n",
        "slist_iter_has_more": "pub fn slist_iter_has_more<T: PartialEq>(iter: &SListIterator<T>) -> bool {\n    let current_ref = iter.current.as_ref().map(|x| &**x);\n    let prev_next_ref = iter.prev_next.as_ref().map(|x| &**x);\n\n    if iter.current.is_none() || current_ref != prev_next_ref {\n        iter.prev_next.is_some()\n    } else {\n        iter.current.as_ref().unwrap().next.is_some()\n    }\n}\n\n",
        "slist_iter_remove": "pub fn slist_iter_remove<T: PartialEq>(iter: &mut SListIterator<T>) {\n    let current_ref = iter.current.as_ref().map(|x| &**x);\n    let prev_next_ref = iter.prev_next.as_ref().map(|x| &**x);\n\n    if iter.current.is_none() || current_ref != prev_next_ref {\n        // Either we have not yet read the first item, we have\n        // reached the end of the list, or we have already removed\n        // the current value. Either way, do nothing.\n    } else {\n        // Remove the current entry\n        if let Some(current) = iter.current.take() {\n            if let Some(prev_next) = &mut iter.prev_next {\n                prev_next.next = current.next;\n            }\n        }\n    }\n}\n\n",
        "slist_find_data": "pub fn slist_find_data<T, F>(list: Option<Box<SListEntry<T>>>, callback: F, data: T) -> Option<Box<SListEntry<T>>>\nwhere\n    T: PartialEq + Clone,\n    F: Fn(&T, &T) -> bool,\n{\n    let mut rover = list;\n\n    while let Some(entry) = rover {\n        if callback(&entry.data, &data) {\n            return Some(entry);\n        }\n        rover = entry.next;\n    }\n\n    None\n}\n\n",
        "slist_to_array": "pub fn slist_to_array<T: Clone>(list: Option<Box<SListEntry<T>>>) -> Option<Vec<T>> {\n    let length = slist_length(list.clone());\n\n    let mut array = Vec::with_capacity(length);\n\n    let mut rover = list;\n\n    for _ in 0..length {\n        if let Some(node) = rover {\n            array.push(node.data.clone());\n            rover = node.next;\n        } else {\n            return None;\n        }\n    }\n\n    Some(array)\n}\n\n",
        "slist_sort": "pub fn slist_sort<T, F>(list: &mut Option<Box<SListEntry<T>>>, compare_func: F)\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> std::cmp::Ordering,\n{\n    *list = slist_sort_internal(list, compare_func);\n}\n\n",
        "slist_remove_entry": "pub fn slist_remove_entry<T: PartialEq>(list: &mut Option<Box<SListEntry<T>>>, entry: &Option<Box<SListEntry<T>>>) -> bool {\n    if list.is_none() || entry.is_none() {\n        return false;\n    }\n\n    let entry = entry.as_ref().unwrap();\n\n    if let Some(ref mut head) = list {\n        if **head == **entry {\n            *list = head.next.take();\n            return true;\n        }\n    }\n\n    let mut rover = list.as_mut();\n\n    while let Some(current) = rover {\n        if let Some(ref mut next) = current.next {\n            if **next == **entry {\n                current.next = next.next.take();\n                return true;\n            }\n        }\n        rover = current.next.as_mut();\n    }\n\n    false\n}\n\n",
        "slist_next": "pub fn slist_next<T>(listentry: Option<Box<SListEntry<T>>>) -> Option<Box<SListEntry<T>>> {\n    listentry.and_then(|entry| entry.next)\n}\n\n"
    },
    "test-slist": {
        "main": "fn main(){}\n",
        "extra": "",
        "generate_list": "pub fn generate_list() -> Option<Box<SListEntry<i32>>> {\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n    let mut variable1 = 50;\n    let mut variable2 = 0;\n    let mut variable3 = 0;\n    let mut variable4 = 0;\n\n    slist_append(&mut list, variable1);\n    slist_append(&mut list, variable2);\n    slist_append(&mut list, variable3);\n    slist_append(&mut list, variable4);\n\n    list\n}\n\n",
        "test_slist_length": "pub fn test_slist_length() {\n    let mut list = generate_list();\n\n    assert_eq!(slist_length(list.clone()), 4);\n\n    slist_prepend(&mut list, 50);\n\n    assert_eq!(slist_length(list.clone()), 5);\n\n    assert_eq!(slist_length::<i32>(None), 0);\n\n    slist_free(list);\n}\n\n",
        "test_slist_nth_entry": "pub fn test_slist_nth_entry() {\n    let list = generate_list();\n\n    // Check all values in the list\n    let entry = slist_nth_entry(list.clone(), 0);\n    assert!(entry.is_some() && slist_data(entry.as_ref().unwrap()) == 50);\n\n    let entry = slist_nth_entry(list.clone(), 1);\n    assert!(entry.is_some() && slist_data(entry.as_ref().unwrap()) == 0);\n\n    let entry = slist_nth_entry(list.clone(), 2);\n    assert!(entry.is_some() && slist_data(entry.as_ref().unwrap()) == 0);\n\n    let entry = slist_nth_entry(list.clone(), 3);\n    assert!(entry.is_some() && slist_data(entry.as_ref().unwrap()) == 0);\n\n    // Check out of range values\n    let entry = slist_nth_entry(list.clone(), 4);\n    assert!(entry.is_none());\n\n    let entry = slist_nth_entry(list.clone(), 400);\n    assert!(entry.is_none());\n\n    slist_free(list);\n}\n\n",
        "test_slist_nth_data": "pub fn test_slist_nth_data() {\n    let list = generate_list();\n\n    // Check all values in the list\n    assert_eq!(slist_nth_data(list.clone(), 0), Some(50));\n    assert_eq!(slist_nth_data(list.clone(), 1), Some(0));\n    assert_eq!(slist_nth_data(list.clone(), 2), Some(0));\n    assert_eq!(slist_nth_data(list.clone(), 3), Some(0));\n\n    // Check out of range values\n    assert_eq!(slist_nth_data(list.clone(), 4), None);\n    assert_eq!(slist_nth_data(list.clone(), 400), None);\n\n    slist_free(list);\n}\n\n",
        "test_slist_prepend": "pub fn test_slist_prepend() {\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n\n    let variable1 = 50;\n    let variable2 = 0;\n    let variable3 = 0;\n    let variable4 = 0;\n\n    assert!(slist_prepend(&mut list, variable1).is_some());\n    assert!(slist_prepend(&mut list, variable2).is_some());\n    assert!(slist_prepend(&mut list, variable3).is_some());\n    assert!(slist_prepend(&mut list, variable4).is_some());\n\n    assert_eq!(slist_nth_data(list.clone(), 0), Some(variable4));\n    assert_eq!(slist_nth_data(list.clone(), 1), Some(variable3));\n    assert_eq!(slist_nth_data(list.clone(), 2), Some(variable2));\n    assert_eq!(slist_nth_data(list.clone(), 3), Some(variable1));\n\n    assert_eq!(slist_length(list.clone()), 4);\n\n    slist_free(list);\n}\n\n",
        "test_slist_iterate": "pub fn test_slist_iterate() {\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n    let mut iter = SListIterator {\n        prev_next: None,\n        current: None,\n    };\n    let a = 0;\n    let mut counter = 0;\n\n    // Create a list with 50 entries\n    for _ in 0..50 {\n        slist_prepend(&mut list, a);\n    }\n\n    // Iterate over the list and count the number of entries visited\n    slist_iterate(&mut list, &mut iter);\n\n    // Test remove before slist_iter_next has been called\n    slist_iter_remove(&mut iter);\n\n    // Iterate over the list\n    while slist_iter_has_more(&iter) {\n        let data = slist_iter_next(&mut iter);\n\n        counter += 1;\n\n        // Remove half the entries from the list\n        if counter % 2 == 0 {\n            slist_iter_remove(&mut iter);\n\n            // Test double remove\n            slist_iter_remove(&mut iter);\n        }\n    }\n\n    // Test iter_next after iteration has completed\n    assert!(slist_iter_next(&mut iter).is_none());\n\n    // Test remove at the end of a list\n    slist_iter_remove(&mut iter);\n\n    assert_eq!(counter, 50);\n    assert_eq!(slist_length(list.clone()), 25);\n\n    slist_free(list);\n\n    // Test iterating over an empty list\n    list = None;\n    counter = 0;\n\n    slist_iterate(&mut list, &mut iter);\n\n    while slist_iter_has_more(&iter) {\n        let _data = slist_iter_next(&mut iter);\n\n        counter += 1;\n\n        // Remove half the entries from the list\n        if counter % 2 == 0 {\n            slist_iter_remove(&mut iter);\n        }\n    }\n\n    assert_eq!(counter, 0);\n}\n\n",
        "test_slist_find_data": "pub fn test_slist_find_data() {\n    let entries = [89, 23, 42, 16, 15, 4, 8, 99, 50, 30];\n    let num_entries = entries.len();\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n\n    // Generate a list containing the entries\n    for i in 0..num_entries {\n        slist_append(&mut list, entries[i]);\n    }\n\n    // Check that each value can be searched for correctly\n    for i in 0..num_entries {\n        let val = entries[i];\n        let result = slist_find_data(list.clone(), |a, b| a == b, val);\n\n        assert!(result.is_some());\n\n        let data = slist_data(result.as_ref().unwrap());\n        assert_eq!(data, val);\n    }\n\n    // Check some invalid values return None\n    let val = 0;\n    assert!(slist_find_data(list.clone(), |a, b| a == b, val).is_none());\n    let val = 56;\n    assert!(slist_find_data(list.clone(), |a, b| a == b, val).is_none());\n\n    slist_free(list);\n}\n\n",
        "test_slist_append": "pub fn test_slist_append() {\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n    let variable1 = 50;\n    let variable2 = 0;\n    let variable3 = 0;\n    let variable4 = 0;\n\n    assert!(slist_append(&mut list, variable1).is_some());\n    assert!(slist_append(&mut list, variable2).is_some());\n    assert!(slist_append(&mut list, variable3).is_some());\n    assert!(slist_append(&mut list, variable4).is_some());\n    assert_eq!(slist_length(list.clone()), 4);\n\n    assert_eq!(slist_nth_data(list.clone(), 0), Some(variable1));\n    assert_eq!(slist_nth_data(list.clone(), 1), Some(variable2));\n    assert_eq!(slist_nth_data(list.clone(), 2), Some(variable3));\n    assert_eq!(slist_nth_data(list.clone(), 3), Some(variable4));\n\n    slist_free(list);\n}\n\n",
        "test_slist_free": "pub fn test_slist_free() {\n    let list = generate_list();\n    slist_free(list);\n    slist_free::<i32>(None);\n}\n\n",
        "test_slist_to_array": "pub fn test_slist_to_array() {\n    let list = generate_list();\n\n    let array = slist_to_array(list.clone());\n\n    assert!(array.is_some());\n    let array = array.unwrap();\n\n    assert_eq!(array[0], 50);\n    assert_eq!(array[1], 0);\n    assert_eq!(array[2], 0);\n    assert_eq!(array[3], 0);\n\n    slist_free(list);\n}\n\n",
        "test_slist_sort": "pub fn test_slist_sort() {\n    pub struct SListEntry<T> {\n        pub data: T,\n        pub next: Option<Box<SListEntry<T>>>,\n    }\n\n    impl<T: Clone> Clone for SListEntry<T> {\n        fn clone(&self) -> Self {\n            SListEntry {\n                data: self.data.clone(),\n                next: self.next.clone(),\n            }\n        }\n    }\n\n    impl<T: PartialEq> PartialEq for SListEntry<T> {\n        fn eq(&self, other: &Self) -> bool {\n            self.data == other.data && self.next == other.next\n        }\n    }\n\n    pub struct SListIterator<T> {\n        pub prev_next: Option<Box<SListEntry<T>>>,\n        pub current: Option<Box<SListEntry<T>>>,\n    }\n\n    pub fn slist_prepend<T: Clone>(list: &mut Option<Box<SListEntry<T>>>, data: T) -> Option<Box<SListEntry<T>>> {\n        let newentry = Box::new(SListEntry {\n            data,\n            next: list.take(),\n        });\n\n        *list = Some(newentry.clone());\n\n        Some(newentry)\n    }\n\n    pub fn slist_sort_internal<T, F>(list: &mut Option<Box<SListEntry<T>>>, compare_func: F) -> Option<Box<SListEntry<T>>>\n    where\n        T: Clone,\n        F: Fn(&T, &T) -> std::cmp::Ordering,\n    {\n        if list.is_none() || list.as_ref().unwrap().next.is_none() {\n            return list.take();\n        }\n\n        let mut pivot = list.take().unwrap();\n        let mut less_list: Option<Box<SListEntry<T>>> = None;\n        let mut more_list: Option<Box<SListEntry<T>>> = None;\n        let mut rover = pivot.next.take();\n\n        while let Some(mut node) = rover {\n            let next = node.next.take();\n            match compare_func(&node.data, &pivot.data) {\n                std::cmp::Ordering::Less => {\n                    node.next = less_list.take();\n                    less_list = Some(node);\n                }\n                _ => {\n                    node.next = more_list.take();\n                    more_list = Some(node);\n                }\n            }\n            rover = next;\n        }\n\n        let less_list_end = slist_sort_internal(&mut less_list, &compare_func);\n        let more_list_end = slist_sort_internal(&mut more_list, &compare_func);\n\n        *list = less_list.take();\n        if list.is_none() {\n            *list = Some(pivot.clone());\n        } else {\n            less_list_end.unwrap().next = Some(pivot.clone());\n        }\n\n        pivot.next = more_list.take();\n\n        if more_list.is_none() {\n            Some(pivot)\n        } else {\n            more_list_end\n        }\n    }\n\n    pub fn slist_nth_entry<T>(list: Option<Box<SListEntry<T>>>, n: usize) -> Option<Box<SListEntry<T>>> {\n        let mut entry = list;\n        let mut i = 0;\n\n        while i < n {\n            match entry {\n                Some(ref mut current) => {\n                    entry = current.next.take();\n                    i += 1;\n                }\n                None => return None,\n            }\n        }\n\n        entry\n    }\n\n    pub fn slist_free<T>(list: Option<Box<SListEntry<T>>>) {\n        let mut entry = list;\n\n        while let Some(mut current_entry) = entry {\n            entry = current_entry.next.take();\n        }\n    }\n\n    pub fn slist_length<T>(list: Option<Box<SListEntry<T>>>) -> usize {\n        let mut length: usize = 0;\n        let mut entry = list;\n\n        while let Some(node) = entry {\n            length += 1;\n            entry = node.next;\n        }\n\n        length\n    }\n\n    pub fn slist_nth_data<T: Clone>(list: Option<Box<SListEntry<T>>>, n: usize) -> Option<T> {\n        let entry = slist_nth_entry(list, n);\n\n        match entry {\n            Some(entry) => Some(entry.data.clone()),\n            None => None,\n        }\n    }\n\n    pub fn slist_sort<T, F>(list: &mut Option<Box<SListEntry<T>>>, compare_func: F)\n    where\n        T: Clone,\n        F: Fn(&T, &T) -> std::cmp::Ordering,\n    {\n        *list = slist_sort_internal(list, compare_func);\n    }\n\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n    let entries = vec![89, 4, 23, 42, 4, 16, 15, 4, 8, 99, 50, 30, 4];\n    let sorted = vec![4, 4, 4, 4, 8, 15, 16, 23, 30, 42, 50, 89, 99];\n    let num_entries = entries.len();\n\n    for i in 0..num_entries {\n        slist_prepend(&mut list, entries[i]);\n    }\n\n    slist_sort(&mut list, |a, b| a.cmp(b));\n\n    assert_eq!(slist_length(list.clone()), num_entries);\n\n    for i in 0..num_entries {\n        let value = slist_nth_data(list.clone(), i);\n        assert_eq!(value.unwrap(), sorted[i]);\n    }\n\n    slist_free(list);\n\n    list = None;\n\n    slist_sort(&mut list, |a, b| a.cmp(b));\n\n    assert!(list.is_none());\n}\n\n",
        "test_slist_remove_entry": "pub fn test_slist_remove_entry() {\n    let mut empty_list: Option<Box<SListEntry<i32>>> = None;\n    let mut list = generate_list();\n\n    // Remove the third entry\n    let entry = slist_nth_entry(list.clone(), 2);\n    assert!(slist_remove_entry(&mut list, &entry));\n    assert_eq!(slist_length(list.clone()), 3);\n\n    // Remove the first entry\n    let entry = slist_nth_entry(list.clone(), 0);\n    assert!(slist_remove_entry(&mut list, &entry));\n    assert_eq!(slist_length(list.clone()), 2);\n\n    // Try some invalid removes\n    // This was already removed:\n    assert!(!slist_remove_entry(&mut list, &entry));\n\n    // NULL\n    assert!(!slist_remove_entry(&mut list, &None));\n\n    // Removing NULL from an empty list\n    assert!(!slist_remove_entry(&mut empty_list, &None));\n\n    slist_free(list);\n}\n\n",
        "test_slist_next": "pub fn test_slist_next() {\n    let mut list = generate_list();\n    let mut rover = list.clone();\n\n    assert_eq!(slist_data(rover.as_ref().unwrap()), 50);\n    rover = slist_next(rover);\n    assert_eq!(slist_data(rover.as_ref().unwrap()), 0);\n    rover = slist_next(rover);\n    assert_eq!(slist_data(rover.as_ref().unwrap()), 0);\n    rover = slist_next(rover);\n    assert_eq!(slist_data(rover.as_ref().unwrap()), 0);\n    rover = slist_next(rover);\n    assert!(rover.is_none());\n\n    slist_free(list);\n}\n\n"
    },
    "trie": {
        "trie_insert_rollback": "pub fn trie_insert_rollback<T>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = Rc::clone(&trie.root_node);\n    let mut prev_ptr = Rc::clone(&trie.root_node);\n    let mut p = 0;\n\n    while !node.borrow().next.is_empty() {\n        let next_prev_ptr = {\n            let node_borrow = node.borrow();\n            let next_node = node_borrow.next.get(&key[p]).map(Rc::clone);\n            p += 1;\n            next_node\n        };\n\n        if let Some(next_node) = next_prev_ptr {\n            node.borrow_mut().use_count -= 1;\n\n            if node.borrow().use_count == 0 {\n                let key_to_remove = key[p - 1];\n                let mut prev_node_borrow = prev_ptr.borrow_mut();\n                if let Some(prev_node) = prev_node_borrow.next.get_mut(&key_to_remove) {\n                    *prev_node = Rc::new(RefCell::new(TrieNode {\n                        data: None,\n                        use_count: 0,\n                        next: HashMap::new(),\n                    }));\n                }\n            }\n\n            prev_ptr = Rc::clone(&node);\n            node = next_node;\n        } else {\n            break;\n        }\n    }\n}\n\n",
        "extra": "use std::collections::HashMap;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: usize,\n    pub next: HashMap<u8, Rc<RefCell<TrieNode<T>>>>,\n}\n\npub struct Trie<T> {\n    pub root_node: Rc<RefCell<TrieNode<T>>>,\n}\n\nimpl<T> Trie<T> {\n    pub fn new() -> Self {\n        Trie {\n            root_node: Rc::new(RefCell::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: HashMap::new(),\n            })),\n        }\n    }\n}",
        "trie_find_end_binary": "pub fn trie_find_end_binary<T>(trie: &Trie<T>, key: &[u8], key_length: usize) -> Option<Rc<RefCell<TrieNode<T>>>> {\n    let mut node = Some(trie.root_node.clone());\n\n    for j in 0..key_length {\n        if let Some(current_node) = node {\n            let c = key[j];\n            let next_node = current_node.borrow().next.get(&c).cloned();\n            node = next_node;\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\n",
        "trie_find_end": "pub fn trie_find_end<T>(trie: &Trie<T>, key: &str) -> Option<Rc<RefCell<TrieNode<T>>>> {\n    let mut node = Rc::clone(&trie.root_node);\n    let mut p = key.as_bytes().iter();\n\n    while let Some(&c) = p.next() {\n        let next_node = {\n            let node_ref = node.borrow();\n            node_ref.next.get(&c).map(|n| Rc::clone(n))\n        };\n\n        if let Some(next) = next_node {\n            node = next;\n        } else {\n            return None;\n        }\n    }\n\n    Some(node)\n}\n\n",
        "trie_new": "pub fn trie_new<T>() -> Option<Trie<T>> {\n    Some(Trie {\n        root_node: Rc::new(RefCell::new(TrieNode {\n            data: None,\n            use_count: 0,\n            next: HashMap::new(),\n        })),\n    })\n}\n\n",
        "trie_insert_binary": "pub fn trie_insert_binary<T: Clone + PartialEq>(trie: &mut Trie<T>, key: &[u8], key_length: usize, value: T) -> bool {\n    if let None = Some(&value) {\n        return false;\n    }\n\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(node) = node {\n        if node.borrow().data.is_some() {\n            node.borrow_mut().data = Some(value);\n            return true;\n        }\n    }\n\n    let mut rover = Rc::clone(&trie.root_node);\n    let mut p = 0;\n\n    loop {\n        let new_node = {\n            let mut node = rover.borrow_mut();\n\n            if node.next.is_empty() {\n                let new_node = Rc::new(RefCell::new(TrieNode {\n                    data: None,\n                    use_count: 0,\n                    next: HashMap::new(),\n                }));\n\n                node.next.insert(key[p], new_node.clone());\n                new_node\n            } else {\n                node.next.get(&key[p]).unwrap().clone()\n            }\n        };\n\n        new_node.borrow_mut().use_count += 1;\n\n        if p == key_length {\n            new_node.borrow_mut().data = Some(value);\n            break;\n        }\n\n        rover = new_node;\n        p += 1;\n    }\n\n    true\n}\n\n",
        "trie_free_list_push": "pub fn trie_free_list_push<T: Clone>(list: &mut Option<Rc<RefCell<TrieNode<T>>>>, node: Rc<RefCell<TrieNode<T>>>) {\n    let data = list.take().and_then(|n| n.borrow().data.clone());\n    {\n        let mut node_borrow = node.borrow_mut();\n        node_borrow.data = data;\n    }\n    *list = Some(node);\n}\n\n",
        "trie_free_list_pop": "pub fn trie_free_list_pop<T>(list: &mut Option<Rc<RefCell<TrieNode<T>>>>) -> Option<Rc<RefCell<TrieNode<T>>>> {\n    if let Some(node) = list.take() {\n        let mut node_ref = node.borrow_mut();\n        *list = node_ref.data.take().map(|data| Rc::new(RefCell::new(TrieNode {\n            data: Some(data),\n            use_count: 0,\n            next: HashMap::new(),\n        })));\n        Some(node.clone())\n    } else {\n        None\n    }\n}\n\n",
        "trie_insert": "pub fn trie_insert<T: Clone + PartialEq>(trie: &mut Trie<T>, key: &str, value: T) -> bool {\n    if let Some(node) = trie_find_end(trie, key) {\n        if node.borrow().data.is_some() {\n            node.borrow_mut().data = Some(value);\n            return true;\n        }\n    }\n\n    let mut node = Rc::clone(&trie.root_node);\n    let mut p = key.as_bytes().iter();\n\n    loop {\n        let c = if let Some(&c) = p.next() {\n            c\n        } else {\n            node.borrow_mut().data = Some(value);\n            break;\n        };\n\n        let next_node = {\n            let mut node_borrow = node.borrow_mut();\n            node_borrow.next.entry(c).or_insert_with(|| {\n                Rc::new(RefCell::new(TrieNode {\n                    data: None,\n                    use_count: 0,\n                    next: HashMap::new(),\n                }))\n            }).clone()\n        };\n\n        node.borrow_mut().use_count += 1;\n        node = next_node;\n    }\n\n    true\n}\n\n",
        "trie_num_entries": "pub fn trie_num_entries<T>(trie: &Trie<T>) -> usize {\n    if Rc::ptr_eq(&trie.root_node, &Rc::new(RefCell::new(TrieNode {\n        data: None,\n        use_count: 0,\n        next: HashMap::new(),\n    }))) {\n        0\n    } else {\n        trie.root_node.borrow().use_count\n    }\n}\n\n",
        "trie_remove_binary": "pub fn trie_remove_binary<T>(trie: &Trie<T>, key: &[u8], key_length: usize) -> bool {\n    let mut node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(end_node) = node {\n        let mut end_node = end_node.borrow_mut();\n        if end_node.data.is_some() {\n            end_node.data = None;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    let mut node = Some(trie.root_node.clone());\n    let mut last_next_ptr: Option<Rc<RefCell<TrieNode<T>>>> = None;\n    let mut p = 0;\n\n    loop {\n        if let Some(current_node) = node {\n            let c = key[p];\n            let next_node = current_node.borrow().next.get(&c).cloned();\n\n            {\n                let mut current_node = current_node.borrow_mut();\n                current_node.use_count -= 1;\n\n                if current_node.use_count == 0 {\n                    if let Some(ref last_next) = last_next_ptr {\n                        let mut last_next = last_next.borrow_mut();\n                        last_next.next.remove(&c);\n                    }\n                }\n            }\n\n            if p == key_length {\n                break;\n            } else {\n                p += 1;\n            }\n\n            last_next_ptr = Some(current_node.clone());\n\n            node = next_node;\n        } else {\n            break;\n        }\n    }\n\n    true\n}\n\n",
        "trie_lookup_binary": "pub fn trie_lookup_binary<T: Clone>(trie: &Trie<T>, key: &[u8], key_length: usize) -> Option<T> {\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        node_ref.data.clone()\n    } else {\n        None\n    }\n}\n\n",
        "trie_free": "pub fn trie_free<T: Clone>(trie: Trie<T>) {\n    let mut free_list: Option<Rc<RefCell<TrieNode<T>>>> = None;\n\n    // Start with the root node\n    if trie.root_node.borrow().use_count > 0 {\n        trie_free_list_push(&mut free_list, trie.root_node.clone());\n    }\n\n    // Go through the free list, freeing nodes. We add new nodes as\n    // we encounter them; in this way, all the nodes are freed\n    // non-recursively.\n    while let Some(node) = trie_free_list_pop(&mut free_list) {\n        let mut node_borrow = node.borrow_mut();\n\n        // Add all children of this node to the free list\n        for (_, child) in node_borrow.next.drain() {\n            if child.borrow().use_count > 0 {\n                trie_free_list_push(&mut free_list, child);\n            }\n        }\n\n        // Free the node by dropping it\n        node_borrow.use_count = 0;\n    }\n\n    // The trie itself is automatically dropped when it goes out of scope\n}\n\n",
        "trie_remove": "pub fn trie_remove<T>(trie: &Trie<T>, key: &str) -> bool {\n    let node = trie_find_end(trie, key);\n\n    if let Some(node) = node {\n        let mut node_ref = node.borrow_mut();\n        if node_ref.data.is_some() {\n            node_ref.data = None;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    let mut node = Rc::clone(&trie.root_node);\n    let mut last_next_ptr: Option<Rc<RefCell<TrieNode<T>>>> = None;\n    let mut p = key.as_bytes().iter();\n\n    loop {\n        let c = if let Some(&c) = p.next() { c } else { break };\n\n        let next_node = {\n            let node_ref = node.borrow();\n            node_ref.next.get(&c).map(|n| Rc::clone(n))\n        };\n\n        if let Some(next) = next_node {\n            {\n                let mut node_ref = node.borrow_mut();\n                node_ref.use_count -= 1;\n\n                if node_ref.use_count == 0 {\n                    if let Some(last_next) = &last_next_ptr {\n                        let mut last_next_ref = last_next.borrow_mut();\n                        last_next_ref.next.remove(&c);\n                    }\n                }\n            }\n\n            last_next_ptr = Some(Rc::clone(&node));\n            node = next;\n        } else {\n            break;\n        }\n    }\n\n    true\n}\n\n",
        "trie_lookup": "pub fn trie_lookup<T>(trie: &Trie<T>, key: &str) -> Option<T>\nwhere\n    T: Clone,\n{\n    let node = trie_find_end(trie, key);\n\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        node_ref.data.clone()\n    } else {\n        None\n    }\n}\n\n"
    },
    "test-trie": {
        "main": "fn main(){}\n",
        "extra": "pub const NUM_TEST_VALUES: usize = 10000;\npub const LONG_STRING_LEN: usize = 4096;",
        "generate_binary_trie": "pub fn generate_binary_trie() -> Option<Trie<String>> {\n    let mut trie = trie_new()?;\n\n    let bin_key2: [u8; 8] = ['a' as u8, 'b' as u8, 'c' as u8, 0, 1, 2, 0xff, 0];\n    let bin_key: [u8; 7] = ['a' as u8, 'b' as u8, 'c' as u8, 0, 1, 2, 0xff];\n\n    assert!(trie_insert_binary(&mut trie, &bin_key2, bin_key2.len(), \"goodbye world\".to_string()));\n    assert!(trie_insert_binary(&mut trie, &bin_key, bin_key.len(), \"hello world\".to_string()));\n\n    Some(trie)\n}\n\n",
        "generate_trie": "pub fn generate_trie() -> Option<Trie<i32>> {\n    let mut trie = Trie::new();\n    let mut entries = 0;\n\n    for i in 0..NUM_TEST_VALUES {\n        let test_string = format!(\"{}\", i);\n        let test_array = i as i32;\n\n        assert!(trie_insert(&mut trie, &test_string, test_array));\n        entries += 1;\n\n        assert_eq!(trie_num_entries(&trie), entries);\n    }\n\n    Some(trie)\n}\n\n",
        "test_trie_remove_binary": "pub fn test_trie_remove_binary() {\n    let trie = generate_binary_trie().expect(\"Failed to generate binary trie\");\n\n    // Test look up and remove of invalid values\n    let bin_key3: [u8; 3] = ['a' as u8, 'b' as u8, 'c' as u8];\n    let bin_key4: [u8; 4] = ['z' as u8, 0, 'z' as u8, 'z' as u8];\n\n    let value = trie_lookup_binary(&trie, &bin_key3, bin_key3.len());\n    assert!(value.is_none());\n\n    assert!(!trie_remove_binary(&trie, &bin_key3, bin_key3.len()));\n\n    assert!(trie_lookup_binary(&trie, &bin_key4, bin_key4.len()).is_none());\n    assert!(!trie_remove_binary(&trie, &bin_key4, bin_key4.len()));\n\n    // Remove the two values\n    let bin_key2: [u8; 8] = ['a' as u8, 'b' as u8, 'c' as u8, 0, 1, 2, 0xff, 0];\n    let bin_key: [u8; 7] = ['a' as u8, 'b' as u8, 'c' as u8, 0, 1, 2, 0xff];\n\n    assert!(trie_remove_binary(&trie, &bin_key2, bin_key2.len()));\n    assert!(trie_lookup_binary(&trie, &bin_key2, bin_key2.len()).is_none());\n    assert!(trie_lookup_binary(&trie, &bin_key, bin_key.len()).is_some());\n\n    assert!(trie_remove_binary(&trie, &bin_key, bin_key.len()));\n    assert!(trie_lookup_binary(&trie, &bin_key, bin_key.len()).is_none());\n\n    trie_free(trie);\n}\n\n",
        "test_trie_new_free": "pub fn test_trie_new_free() {\n    let mut trie: Option<Trie<String>>;\n\n    // Allocate and free an empty trie\n    trie = trie_new();\n    assert!(trie.is_some());\n    if let Some(trie) = trie {\n        trie_free(trie);\n    }\n\n    // Add some values before freeing\n    trie = trie_new();\n    assert!(trie.is_some());\n    if let Some(mut trie) = trie {\n        assert!(trie_insert(&mut trie, \"hello\", \"there\".to_string()));\n        assert!(trie_insert(&mut trie, \"hell\", \"testing\".to_string()));\n        assert!(trie_insert(&mut trie, \"testing\", \"testing\".to_string()));\n        assert!(trie_insert(&mut trie, \"\", \"asfasf\".to_string()));\n        trie_free(trie);\n    }\n\n    // Add a value, remove it and then free\n    trie = trie_new();\n    assert!(trie.is_some());\n    if let Some(mut trie) = trie {\n        assert!(trie_insert(&mut trie, \"hello\", \"there\".to_string()));\n        assert!(trie_remove(&trie, \"hello\"));\n        trie_free(trie);\n    }\n\n    // Test out of memory scenario (removed as per requirements)\n}\n\n",
        "test_trie_replace": "pub fn test_trie_replace() {\n    let mut trie = generate_trie().expect(\"Failed to generate trie\");\n\n    // Test replacing values\n    let mut val = 999;\n    assert!(trie_insert(&mut trie, \"999\", val));\n    assert_eq!(trie_num_entries(&trie), NUM_TEST_VALUES);\n\n    assert_eq!(trie_lookup(&trie, \"999\"), Some(val));\n    trie_free(trie);\n}\n\n",
        "test_trie_lookup": "pub fn test_trie_lookup() {\n    let mut trie = generate_trie().expect(\"Failed to generate trie\");\n\n    // Test lookup for non-existent values\n    assert!(trie_lookup(&trie, \"000000000000000\").is_none());\n    assert!(trie_lookup(&trie, \"\").is_none());\n\n    // Look up all values\n    for i in 0..NUM_TEST_VALUES {\n        let buf = format!(\"{}\", i);\n        let val = trie_lookup(&trie, &buf);\n\n        assert!(val.is_some());\n        assert_eq!(val.unwrap(), i as i32);\n    }\n\n    trie_free(trie);\n}\n\n",
        "test_trie_free_long": "pub fn test_trie_free_long() {\n    let mut long_string = vec![b'A'; LONG_STRING_LEN];\n    long_string[LONG_STRING_LEN - 1] = b'\\0';\n\n    let mut trie = trie_new().expect(\"Failed to create trie\");\n    let key = String::from_utf8(long_string.clone()).expect(\"Invalid UTF-8 sequence\");\n    trie_insert(&mut trie, &key, key.clone());\n\n    trie_free(trie);\n}\n\n",
        "test_trie_negative_keys": "pub fn test_trie_negative_keys() {\n    let my_key = vec![b'a', b'b', b'c', 206, 236, 0];\n    let mut trie = trie_new().unwrap();\n    let value = \"hello world\";\n\n    assert!(trie_insert(&mut trie, std::str::from_utf8(&my_key).unwrap(), value));\n\n    let lookup_value = trie_lookup(&trie, std::str::from_utf8(&my_key).unwrap());\n    assert_eq!(lookup_value, Some(value));\n\n    assert!(trie_remove(&trie, std::str::from_utf8(&my_key).unwrap()));\n    assert!(!trie_remove(&trie, std::str::from_utf8(&my_key).unwrap()));\n    assert_eq!(trie_lookup(&trie, std::str::from_utf8(&my_key).unwrap()), None);\n\n    trie_free(trie);\n}\n\n",
        "test_trie_insert_empty": "pub fn test_trie_insert_empty() {\n    let mut trie = trie_new().unwrap();\n    let buf = String::from(\"test\");\n\n    // Test insert on empty string\n    assert!(trie_insert(&mut trie, \"\", buf.clone()));\n    assert_ne!(trie_num_entries(&trie), 0);\n    assert_eq!(trie_lookup(&trie, \"\"), Some(buf.clone()));\n    assert!(trie_remove(&trie, \"\"));\n\n    assert_eq!(trie_num_entries(&trie), 0);\n\n    trie_free(trie);\n}\n\n",
        "test_trie_insert": "pub fn test_trie_insert() {\n    let mut trie = generate_trie().expect(\"Failed to generate trie\");\n    let mut entries = trie_num_entries(&trie);\n\n    // Test insert of None value has no effect\n    assert!(!trie_insert(&mut trie, \"hello world\", 0));\n    assert_eq!(trie_num_entries(&trie), entries);\n\n    // Test rollback\n    assert!(!trie_insert(&mut trie, \"hello world\", 1));\n    assert_eq!(trie_num_entries(&trie), entries);\n\n    trie_free(trie);\n}\n\n",
        "test_trie_remove": "pub fn test_trie_remove() {\n    let mut trie = generate_trie().expect(\"Failed to generate trie\");\n\n    // Test remove on non-existent values.\n    assert!(!trie_remove(&trie, \"000000000000000\"));\n    assert!(!trie_remove(&trie, \"\"));\n\n    let mut entries = trie_num_entries(&trie);\n\n    assert_eq!(entries, NUM_TEST_VALUES);\n\n    // Remove all values\n    for i in 0..NUM_TEST_VALUES {\n        let buf = format!(\"{}\", i);\n\n        // Remove value and check counter\n        assert!(trie_remove(&trie, &buf));\n        entries -= 1;\n        assert_eq!(trie_num_entries(&trie), entries);\n    }\n\n    trie_free(trie);\n}\n\n",
        "test_trie_insert_out_of_memory": "pub fn test_trie_insert_out_of_memory() {\n    let mut trie = generate_binary_trie().expect(\"Failed to generate binary trie\");\n\n    let bin_key4: [u8; 4] = ['z' as u8, 0, 'z' as u8, 'z' as u8];\n\n    assert!(!trie_insert_binary(&mut trie, &bin_key4, bin_key4.len(), \"test value\".to_string()));\n    assert!(trie_lookup_binary(&trie, &bin_key4, bin_key4.len()).is_none());\n    assert_eq!(trie_num_entries(&trie), 2);\n\n    trie_free(trie);\n}\n\n",
        "test_trie_insert_binary": "pub fn test_trie_insert_binary() {\n    let mut trie = generate_binary_trie().expect(\"Failed to generate binary trie\");\n\n    // Overwrite a value\n    let bin_key: [u8; 7] = ['a' as u8, 'b' as u8, 'c' as u8, 0, 1, 2, 0xff];\n    assert!(trie_insert_binary(&mut trie, &bin_key, bin_key.len(), \"hi world\".to_string()));\n\n    // Insert NULL value doesn't work\n    let bin_key3: [u8; 3] = ['a' as u8, 'b' as u8, 'c' as u8];\n    assert!(!trie_insert_binary(&mut trie, &bin_key3, bin_key3.len(), \"\".to_string()));\n\n    // Read them back\n    let value = trie_lookup_binary(&trie, &bin_key, bin_key.len());\n    assert_eq!(value, Some(\"hi world\".to_string()));\n\n    let bin_key2: [u8; 8] = ['a' as u8, 'b' as u8, 'c' as u8, 0, 1, 2, 0xff, 0];\n    let value = trie_lookup_binary(&trie, &bin_key2, bin_key2.len());\n    assert_eq!(value, Some(\"goodbye world\".to_string()));\n\n    trie_free(trie);\n}\n\n"
    },
    "sortedarray": {
        "sortedarray_insert": "pub fn sortedarray_insert<T>(sortedarray: &mut SortedArray<T>, data: T) -> bool {\n    let mut left = 0;\n    let mut right = sortedarray.length;\n    let mut index = 0;\n\n    right = if right > 1 { right } else { 0 };\n\n    while left != right {\n        index = (left + right) / 2;\n\n        let order = (sortedarray.cmp_func)(&data, &sortedarray.data[index]);\n        match order {\n            std::cmp::Ordering::Less => right = index,\n            std::cmp::Ordering::Greater => left = index + 1,\n            std::cmp::Ordering::Equal => break,\n        }\n    }\n\n    if sortedarray.length > 0 && (sortedarray.cmp_func)(&data, &sortedarray.data[index]) == std::cmp::Ordering::Greater {\n        index += 1;\n    }\n\n    if sortedarray.length + 1 > sortedarray._alloced {\n        let newsize = sortedarray._alloced * 2;\n        sortedarray.data.reserve(newsize);\n        sortedarray._alloced = newsize;\n    }\n\n    sortedarray.data.insert(index, data);\n    sortedarray.length += 1;\n\n    true\n}\n\n",
        "extra": "pub struct SortedArray<T> {\n    pub data: Vec<T>,\n    pub length: usize,\n    pub _alloced: usize,\n    pub equ_func: fn(&T, &T) -> bool,\n    pub cmp_func: fn(&T, &T) -> std::cmp::Ordering,\n}",
        "sortedarray_new": "pub fn sortedarray_new<T>(length: usize, equ_func: fn(&T, &T) -> bool, cmp_func: fn(&T, &T) -> std::cmp::Ordering) -> Option<SortedArray<T>> {\n    let mut length = length;\n    if length == 0 {\n        length = 16;\n    }\n\n    let mut data = Vec::<T>::with_capacity(length);\n\n    let sortedarray = SortedArray {\n        data: data,\n        length: 0,\n        _alloced: length,\n        equ_func: equ_func,\n        cmp_func: cmp_func,\n    };\n\n    Some(sortedarray)\n}\n\n",
        "sortedarray_last_index": "pub fn sortedarray_last_index<T: Clone>(\n    sortedarray: &SortedArray<T>,\n    data: T,\n    left: usize,\n    right: usize,\n) -> usize {\n    let mut index = right;\n    let mut left = left;\n    let mut right = right;\n\n    while left < right {\n        index = (left + right) / 2;\n\n        let order = (sortedarray.cmp_func)(&data, &sortedarray.data[index]);\n        if order <= std::cmp::Ordering::Equal {\n            left = index + 1;\n        } else {\n            right = index;\n        }\n    }\n\n    index\n}\n\n",
        "sortedarray_first_index": "pub fn sortedarray_first_index<T: Clone>(\n    sortedarray: &SortedArray<T>,\n    data: T,\n    left: usize,\n    right: usize,\n) -> usize {\n    let mut left = left;\n    let mut right = right;\n    let mut index = left;\n\n    while left < right {\n        index = (left + right) / 2;\n\n        let order = (sortedarray.cmp_func)(&data, &sortedarray.data[index]);\n\n        if order == std::cmp::Ordering::Greater {\n            left = index + 1;\n        } else {\n            right = index;\n        }\n    }\n\n    index\n}\n\n",
        "sortedarray_get": "pub fn sortedarray_get<T>(array: &SortedArray<T>, i: usize) -> Option<&T> {\n    if i >= array.length {\n        return None;\n    }\n    Some(&array.data[i])\n}\n\n",
        "sortedarray_length": "pub fn sortedarray_length<T>(array: &SortedArray<T>) -> usize {\n    array.length\n}\n\n",
        "sortedarray_free": "pub fn sortedarray_free<T>(sortedarray: Option<Box<SortedArray<T>>>) {\n    if let Some(mut sortedarray) = sortedarray {\n        sortedarray.data.clear();\n    }\n}\n\n",
        "sortedarray_remove_range": "pub fn sortedarray_remove_range<T>(sortedarray: &mut SortedArray<T>, index: usize, length: usize) {\n    if index > sortedarray.length || index + length > sortedarray.length {\n        return;\n    }\n\n    let start = index + length;\n    let end = sortedarray.length;\n    let range_to_remove = start..end;\n\n    sortedarray.data.drain(index..index + length);\n\n    sortedarray.length -= length;\n}\n\n",
        "sortedarray_index_of": "pub fn sortedarray_index_of<T: Clone>(\n    sortedarray: &SortedArray<T>,\n    data: T,\n) -> isize {\n    if sortedarray.data.is_empty() {\n        return -1;\n    }\n\n    let mut left = 0;\n    let mut right = sortedarray.length;\n    let mut index = 0;\n\n    right = if right > 1 { right } else { 0 };\n\n    while left != right {\n        index = (left + right) / 2;\n\n        let order = (sortedarray.cmp_func)(&data, &sortedarray.data[index]);\n\n        if order == std::cmp::Ordering::Less {\n            right = index;\n        } else if order == std::cmp::Ordering::Greater {\n            left = index + 1;\n        } else {\n            left = sortedarray_first_index(sortedarray, data.clone(), left, index);\n            right = sortedarray_last_index(sortedarray, data.clone(), index, right);\n\n            for i in left..=right {\n                if (sortedarray.equ_func)(&data, &sortedarray.data[i]) {\n                    return i as isize;\n                }\n            }\n\n            return -1;\n        }\n    }\n\n    -1\n}\n\n",
        "sortedarray_remove": "pub fn sortedarray_remove<T>(sortedarray: &mut SortedArray<T>, index: usize) {\n    sortedarray_remove_range(sortedarray, index, 1);\n}\n\n"
    },
    "test-sortedarray": {
        "main": "fn main(){}\n",
        "extra": "pub const TEST_SIZE: usize = 20;",
        "generate_sortedarray_equ": "pub fn generate_sortedarray_equ<T>(equ_func: fn(&T, &T) -> bool) -> Option<SortedArray<T>> \nwhere\n    T: Clone + Ord + From<i32>,\n{\n    const TEST_SIZE: usize = 20;\n    const TEST_ARRAY: [i32; TEST_SIZE] = [10, 12, 12, 1, 2, 3, 6, 7, 2, 23, 13, 23, 23, 34, 31, 9, 0, 0, 0, 0];\n\n    let mut sortedarray = sortedarray_new(0, equ_func, |a: &T, b: &T| a.cmp(b))?;\n\n    for i in 0..TEST_SIZE {\n        let value = T::from(TEST_ARRAY[i]);\n        sortedarray_insert(&mut sortedarray, value);\n    }\n\n    Some(sortedarray)\n}\n\n",
        "free_sorted_ints": "pub fn free_sorted_ints<T>(sortedarray: Option<Box<SortedArray<T>>>) {\n    if let Some(mut sortedarray) = sortedarray {\n        for i in 0..sortedarray_length(&sortedarray) {\n            if let Some(pi) = sortedarray_get(&sortedarray, i) {\n                // In Rust, we don't need to manually free memory as it is managed by the ownership system.\n                // The Vec<T> inside SortedArray will automatically deallocate its memory when it goes out of scope.\n            }\n        }\n        sortedarray_free(Some(sortedarray));\n    }\n}\n\n",
        "generate_sortedarray": "pub fn generate_sortedarray<T>() -> Option<SortedArray<T>>\nwhere\n    T: Clone + Ord + From<i32>,\n{\n    generate_sortedarray_equ(|a: &T, b: &T| a == b)\n}\n\n",
        "check_sorted_prop": "pub fn check_sorted_prop<T: PartialOrd>(sortedarray: &SortedArray<T>) {\n    for i in 1..sortedarray_length(sortedarray) {\n        let prev = sortedarray_get(sortedarray, i - 1).unwrap();\n        let curr = sortedarray_get(sortedarray, i).unwrap();\n        assert!(int_compare(prev, curr) <= 0);\n    }\n}\n\n",
        "test_sortedarray_index_of": "pub fn test_sortedarray_index_of() {\n    const TEST_SIZE: usize = 20;\n    let sortedarray = generate_sortedarray::<i32>();\n\n    if let Some(sortedarray) = sortedarray {\n        for i in 0..TEST_SIZE {\n            if let Some(value) = sortedarray_get(&sortedarray, i) {\n                let r = sortedarray_index_of(&sortedarray, *value);\n                assert!(r >= 0);\n                assert_eq!(*sortedarray_get(&sortedarray, r as usize).unwrap(), *value);\n            }\n        }\n\n        free_sorted_ints(Some(Box::new(sortedarray)));\n    }\n}\n\n",
        "test_sortedarray_index_of_equ_key": "pub fn test_sortedarray_index_of_equ_key<T: Clone + Ord + From<i32>>() {\n    // replace equal function by function which checks pointers\n    let sortedarray = generate_sortedarray_equ(ptr_equal as fn(&T, &T) -> bool);\n    let sortedarray = match sortedarray {\n        Some(array) => array,\n        None => return,\n    };\n\n    // check if all search value return the same index\n    for i in 0..TEST_SIZE {\n        let value = match sortedarray_get(&sortedarray, i) {\n            Some(v) => v.clone(),\n            None => continue,\n        };\n        let r = sortedarray_index_of(&sortedarray, value);\n        assert!(r >= 0);\n        assert_eq!(i, r as usize);\n    }\n\n    free_sorted_ints(Some(Box::new(sortedarray)));\n}\n\n",
        "ptr_equal": "pub fn ptr_equal<T>(a: &T, b: &T) -> bool {\n    std::ptr::eq(a, b)\n}\n\n",
        "test_sortedarray_remove_range": "pub fn test_sortedarray_remove_range() {\n    const TEST_REMOVE_RANGE: usize = 7;\n    const TEST_REMOVE_RANGE_LENGTH: usize = 4;\n\n    let mut sortedarray = generate_sortedarray::<i32>().expect(\"Failed to generate sorted array\");\n\n    let mut new_values = Vec::with_capacity(TEST_REMOVE_RANGE_LENGTH);\n    for i in 0..TEST_REMOVE_RANGE_LENGTH {\n        let value = *sortedarray_get(&sortedarray, TEST_REMOVE_RANGE + TEST_REMOVE_RANGE_LENGTH + i).unwrap();\n        new_values.push(value);\n    }\n\n    sortedarray_remove_range(&mut sortedarray, TEST_REMOVE_RANGE, TEST_REMOVE_RANGE_LENGTH);\n\n    for i in 0..TEST_REMOVE_RANGE_LENGTH {\n        let value = *sortedarray_get(&sortedarray, TEST_REMOVE_RANGE + i).unwrap();\n        assert_eq!(value, new_values[i]);\n    }\n\n    check_sorted_prop(&sortedarray);\n    free_sorted_ints(Some(Box::new(sortedarray)));\n}\n\n",
        "test_sortedarray_remove": "pub fn test_sortedarray_remove() {\n    let mut sortedarray = generate_sortedarray::<i32>().expect(\"Failed to generate sorted array\");\n\n    let test_remove_el = 15;\n\n    let ip = sortedarray_get(&sortedarray, test_remove_el + 1).expect(\"Failed to get element at index\");\n    let i = *ip;\n\n    sortedarray_remove(&mut sortedarray, test_remove_el);\n\n    let new_element = sortedarray_get(&sortedarray, test_remove_el).expect(\"Failed to get element at index after removal\");\n    assert_eq!(*new_element, i);\n\n    check_sorted_prop(&sortedarray);\n    free_sorted_ints(Some(Box::new(sortedarray)));\n}\n\n",
        "test_sortedarray_get": "pub fn test_sortedarray_get() {\n    let mut i: usize;\n\n    let arr = generate_sortedarray::<i32>();\n\n    if let Some(arr) = arr {\n        for i in 0..sortedarray_length(&arr) {\n            let value1 = sortedarray_get(&arr, i);\n            let value2 = sortedarray_get(&arr, i);\n            assert!(value1 == value2);\n            assert!(value1.unwrap() == value2.unwrap());\n        }\n\n        free_sorted_ints(Some(Box::new(arr)));\n    }\n}\n\n"
    }
}