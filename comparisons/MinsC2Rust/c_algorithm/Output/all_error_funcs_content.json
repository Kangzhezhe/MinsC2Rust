{
    "hash-string": {
        "string_hash": "// 测试函数\n\npub fn string_hash<T: AsRef<str>>(string: T) -> u32 {\n    let mut result: u32 = 5381;\n    let mut p = string.as_ref().as_bytes().iter();\n\n    while let Some(&c) = p.next() {\n        result = (result << 5).wrapping_add(result).wrapping_add(c as u32);\n    }\n\n    result\n}\n\nfn main(){}\n //编译报错信息："
    },
    "test-hash-functions": {
        "test_string_nocase_hash": "// 测试函数\n\n// 测试函数\n\n\n// 测试函数\npub fn string_nocase_hash(string: &str) -> u32 {\n    let mut result: u32 = 5381;\n    let mut p = string.chars();\n\n    while let Some(c) = p.next() {\n        result = (result << 5) + result + c.to_ascii_lowercase() as u32;\n    }\n\n    result\n}\n\n\n\npub fn test_string_nocase_hash() {\n    let test1 = \"this is a test\";\n    let test2 = \"this is a tesu\";\n    let test3 = \"this is a test \";\n    let test4 = \"this is a test\";\n    let test5 = \"This is a test\";\n\n    // Contents affect the hash\n    assert_ne!(string_nocase_hash(test1), string_nocase_hash(test2));\n\n    // Length affects the hash\n    assert_ne!(string_nocase_hash(test1), string_nocase_hash(test3));\n\n    // Case insensitive\n    assert_eq!(string_nocase_hash(test1), string_nocase_hash(test5));\n\n    // The same strings give the same hash\n    assert_eq!(string_nocase_hash(test1), string_nocase_hash(test4));\n}\n\nfn main(){}\n //编译报错信息：",
        "test_string_hash": "// 测试函数\n\n// 测试函数\n\n\n// 测试函数\n\npub fn test_string_hash() {\n    let test1 = \"this is a test\";\n    let test2 = \"this is a tesu\";\n    let test3 = \"this is a test \";\n    let test4 = \"this is a test\";\n    let test5 = \"This is a test\";\n\n    // Contents affect the hash\n    assert!(string_hash(test1) != string_hash(test2));\n\n    // Length affects the hash\n    assert!(string_hash(test1) != string_hash(test3));\n\n    // Case sensitive\n    assert!(string_hash(test1) != string_hash(test5));\n\n    // The same strings give the same hash\n    assert!(string_hash(test1) == string_hash(test4));\n}\n\npub fn string_hash<T: AsRef<str>>(string: T) -> u32 {\n    let mut result: u32 = 5381;\n    let string_ref = string.as_ref();\n\n    for c in string_ref.bytes() {\n        result = (result << 5).wrapping_add(result).wrapping_add(c as u32);\n    }\n\n    result\n}\n\nfn main(){}\n //编译报错信息："
    },
    "queue": {
        "queue_free": "\npub struct QueueEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<QueueEntry<T>>>,\n    pub next: Option<Box<QueueEntry<T>>>,\n}\n\nimpl<T> Clone for QueueEntry<T> where T: Clone {\n    fn clone(&self) -> Self {\n        QueueEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Queue<T> {\n    pub head: Option<Box<QueueEntry<T>>>,\n    pub tail: Option<Box<QueueEntry<T>>>,\n}\n\npub fn queue_pop_head<T>(queue: &mut Queue<T>) -> Option<T> where T: Clone {\n    if queue_is_empty(queue) {\n        return None;\n    }\n\n    let mut entry = queue.head.take().unwrap();\n    queue.head = entry.next.take();\n    let result = entry.data.clone();\n\n    if queue.head.is_none() {\n        queue.tail = None;\n    } else {\n        queue.head.as_mut().unwrap().prev = None;\n    }\n\n    Some(result)\n}\n\npub fn queue_is_empty<T>(queue: &Queue<T>) -> bool {\n    queue.head.is_none()\n}\n\npub fn queue_free<T>(queue: &mut Queue<T>) {\n    while !queue_is_empty(queue) {\n        queue_pop_head(queue);\n    }\n}\n\nfn main() {}\n\n //编译报错信息：error[E0277]: the trait bound `T: Clone` is not satisfied\n  --> ../../Test_max12/tmp/test-queue_queue_free/temp.rs:47:24\n   |\n47 |         queue_pop_head(queue);\n   |         -------------- ^^^^^ the trait `Clone` is not implemented for `T`\n   |         |\n   |         required by a bound introduced by this call\n   |\nnote: required by a bound in `queue_pop_head`\n  --> ../../Test_max12/tmp/test-queue_queue_free/temp.rs:23:70\n   |\n23 | pub fn queue_pop_head<T>(queue: &mut Queue<T>) -> Option<T> where T: Clone {\n   |                                                                      ^^^^^ required by this bound in `queue_pop_head`\n"
    },
    "set": {
        "set_iter_has_more": "pub struct Set<T> {\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub entries: usize,\n    pub table_size: usize,\n    pub prime_index: usize,\n    pub hash_func: fn(&T) -> u32,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\npub struct SetEntry<T> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\npub const SET_NUM_PRIMES: usize = 24;\npub const SET_PRIMES: [usize; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\npub fn set_allocate_table<T>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = Vec::with_capacity(set.table_size);\n    for _ in 0..set.table_size {\n        set.table.push(None);\n    }\n\n    true\n}\n\n\npub fn set_enlarge<T>(set: &mut Set<T>) -> bool {\n    let mut old_table = std::mem::take(&mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let hash_func = set.hash_func;\n            let index = (hash_func(&entry.data) as usize) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\n\npub fn set_free_entry<T>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\n\npub fn set_new<T>(hash_func: fn(&T) -> u32, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        table: Vec::new(),\n        entries: 0,\n        table_size: 0,\n        prime_index: 0,\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\n\npub fn set_num_entries<T>(set: &Set<T>) -> usize {\n    set.entries\n}\n\n\npub fn set_register_free_function<T>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\n\npub fn set_insert<T>(set: &mut Set<T>, data: T) -> bool {\n    // The hash table becomes less efficient as the number of entries\n    // increases. Check if the percentage used becomes large.\n    if (set.entries * 3) / set.table_size > 0 {\n        // The table is more than 1/3 full and must be increased in size\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    // Use the hash of the data to determine an index to insert into the table at.\n    let hash_func = set.hash_func;\n    let index = (hash_func(&data) as usize) % set.table_size;\n\n    // Walk along this chain and attempt to determine if this data has\n    // already been added to the table\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            // This data is already in the set\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    // Not in the set. We must add a new entry.\n    // Make a new entry for this data\n    let newentry = Box::new(SetEntry {\n        data,\n        next: set.table[index].take(),\n    });\n\n    // Link into chain\n    set.table[index] = Some(newentry);\n\n    // Keep track of the number of entries in the set\n    set.entries += 1;\n\n    // Added successfully\n    true\n}\n\n\npub fn set_iter_has_more<T>(iterator: &SetIterator<T>) -> bool {\n    iterator.next_entry.is_some()\n}\n\n\nfn main(){}\n //insert编译报错信息：error[E0412]: cannot find type `SetIterator` in this scope\n   --> ../../Test_max12/tmp/test-set_set_iter_has_more/test_source.rs:152:40\n    |\n152 | pub fn set_iter_has_more<T>(iterator: &SetIterator<T>) -> bool {\n    |                                        ^^^^^^^^^^^ help: a trait with a similar name exists: `IntoIterator`\n    |\n   ::: /home/mins01/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/collect.rs:318:1\n    |\n318 | pub trait IntoIterator {\n    | ---------------------- similarly named trait `IntoIterator` defined here\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0412`.\n",
        "set_iterate": "pub struct Set<T> {\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub entries: usize,\n    pub table_size: usize,\n    pub prime_index: usize,\n    pub hash_func: fn(&T) -> u32,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetEntry<T> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\npub const SET_NUM_PRIMES: usize = 24;\npub const SET_PRIMES: [usize; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct SetIterator<T> {\n    pub set: Set<T>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\npub fn set_allocate_table<T>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = Vec::with_capacity(set.table_size);\n    for _ in 0..set.table_size {\n        set.table.push(None);\n    }\n\n    true\n}\n\n\npub fn set_enlarge<T>(set: &mut Set<T>) -> bool {\n    let mut old_table = std::mem::take(&mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let hash_func = set.hash_func;\n            let index = (hash_func(&entry.data) as usize) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\n\npub fn set_free_entry<T>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\n\npub fn set_new<T>(hash_func: fn(&T) -> u32, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        table: Vec::new(),\n        entries: 0,\n        table_size: 0,\n        prime_index: 0,\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\n\npub fn set_num_entries<T>(set: &Set<T>) -> usize {\n    set.entries\n}\n\n\npub fn set_register_free_function<T>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\n\npub fn set_insert<T>(set: &mut Set<T>, data: T) -> bool {\n    // The hash table becomes less efficient as the number of entries\n    // increases. Check if the percentage used becomes large.\n    if (set.entries * 3) / set.table_size > 0 {\n        // The table is more than 1/3 full and must be increased in size\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    // Use the hash of the data to determine an index to insert into the table at.\n    let hash_func = set.hash_func;\n    let index = (hash_func(&data) as usize) % set.table_size;\n\n    // Walk along this chain and attempt to determine if this data has\n    // already been added to the table\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            // This data is already in the set\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    // Not in the set. We must add a new entry.\n    // Make a new entry for this data\n    let newentry = Box::new(SetEntry {\n        data,\n        next: set.table[index].take(),\n    });\n\n    // Link into chain\n    set.table[index] = Some(newentry);\n\n    // Keep track of the number of entries in the set\n    set.entries += 1;\n\n    // Added successfully\n    true\n}\n\n\npub fn set_query<T>(set: &Set<T>, data: T) -> bool \nwhere\n    T: Clone + PartialEq,\n{\n    let mut index = (set.hash_func)(&data) % set.table_size as u32;\n\n    let mut rover = &set.table[index as usize];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            return true;\n        }\n        rover = &entry.next;\n    }\n\n    false\n}\n\n\npub fn set_free<T>(mut set: Box<Set<T>>) {\n    // Free all entries in all chains\n    for i in 0..set.table_size {\n        let mut rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            set_free_entry(&mut set, entry);\n            rover = next;\n        }\n    }\n\n    // The table is automatically freed when the set is dropped\n    // The set structure is automatically freed when the Box is dropped\n}\n\n\npub fn set_iter_next<T: Clone>(iterator: &mut SetIterator<T>) -> Option<T> {\n    let set = &iterator.set;\n\n    if iterator.next_entry.is_none() {\n        return None;\n    }\n\n    let current_entry = iterator.next_entry.as_ref().unwrap();\n    let result = current_entry.data.clone();\n\n    if let Some(next) = &current_entry.next {\n        iterator.next_entry = Some(Box::new(next.as_ref().clone()));\n    } else {\n        iterator.next_entry = None;\n\n        let mut chain = iterator.next_chain + 1;\n\n        while chain < set.table_size {\n            if let Some(entry) = &set.table[chain] {\n                iterator.next_entry = Some(Box::new(entry.as_ref().clone()));\n                break;\n            }\n\n            chain += 1;\n        }\n\n        iterator.next_chain = chain;\n    }\n\n    Some(result)\n}\n\n\npub fn set_iterate<T: Clone>(set: Set<T>, iter: &mut SetIterator<T>) {\n    let mut chain: usize = 0;\n\n    iter.set = set.clone();\n    iter.next_entry = None;\n\n    // Find the first entry\n    while chain < set.table_size {\n        // There is a value at the start of this chain\n        if set.table[chain].is_some() {\n            iter.next_entry = set.table[chain].clone();\n            break;\n        }\n        chain += 1;\n    }\n\n    iter.next_chain = chain;\n}\n\n\nfn main(){}\n //insert编译报错信息：error[E0599]: no method named `clone` found for struct `Set` in the current scope\n   --> ../../Test_max12/tmp/test-set_set_iterate/test_source.rs:231:20\n    |\n1   | pub struct Set<T> {\n    | ----------------- method `clone` not found for this struct\n...\n231 |     iter.set = set.clone();\n    |                    ^^^^^ method not found in `Set<T>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
        "set_union": "\n\n\npub struct Set<T: Clone> {\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub entries: usize,\n    pub table_size: usize,\n    pub prime_index: usize,\n    pub hash_func: fn(&T) -> u32,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetEntry<T: Clone> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\npub const SET_NUM_PRIMES: usize = 24;\npub const SET_PRIMES: [usize; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct SetIterator<'a, T: Clone> {\n    pub set: &'a Set<T>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\npub fn set_new<T: Clone>(hash_func: fn(&T) -> u32, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        table: Vec::new(),\n        entries: 0,\n        table_size: 0,\n        prime_index: 0,\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\npub fn set_allocate_table<T: Clone>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = Vec::with_capacity(set.table_size);\n    for _ in 0..set.table_size {\n        set.table.push(None);\n    }\n\n    true\n}\n\npub fn set_iter_next<T: Clone>(iterator: &mut SetIterator<T>) -> Option<T> {\n    let set = iterator.set;\n\n    if iterator.next_entry.is_none() {\n        return None;\n    }\n\n    let current_entry = iterator.next_entry.as_ref().unwrap();\n    let result = current_entry.data.clone();\n\n    if let Some(next) = &current_entry.next {\n        iterator.next_entry = Some(Box::new(SetEntry {\n            data: next.data.clone(),\n            next: next.next.clone(),\n        }));\n    } else {\n        iterator.next_entry = None;\n\n        let mut chain = iterator.next_chain + 1;\n\n        while chain < set.table_size {\n            if let Some(entry) = &set.table[chain] {\n                iterator.next_entry = Some(Box::new(SetEntry {\n                    data: entry.data.clone(),\n                    next: entry.next.clone(),\n                }));\n                break;\n            }\n\n            chain += 1;\n        }\n\n        iterator.next_chain = chain;\n    }\n\n    Some(result)\n}\n\npub fn set_free_entry<T: Clone>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\npub fn set_insert<T: Clone>(set: &mut Set<T>, data: T) -> bool {\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let hash_func = set.hash_func;\n    let index = (hash_func(&data) as usize) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    let newentry = Box::new(SetEntry {\n        data,\n        next: set.table[index].take(),\n    });\n\n    set.table[index] = Some(newentry);\n    set.entries += 1;\n\n    true\n}\n\npub fn set_query<T: Clone + PartialEq>(set: &Set<T>, data: T) -> bool {\n    let mut index = (set.hash_func)(&data) % set.table_size as u32;\n\n    let mut rover = &set.table[index as usize];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            return true;\n        }\n        rover = &entry.next;\n    }\n\n    false\n}\n\npub fn set_enlarge<T: Clone>(set: &mut Set<T>) -> bool {\n    let mut old_table = std::mem::take(&mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let hash_func = set.hash_func;\n            let index = (hash_func(&entry.data) as usize) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn set_free<T: Clone>(mut set: Box<Set<T>>) {\n    for i in 0..set.table_size {\n        let mut rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            set_free_entry(&mut set, entry);\n            rover = next;\n        }\n    }\n}\n\npub fn set_union<T: Clone + PartialEq>(\n    set1: &Set<T>,\n    set2: &Set<T>,\n) -> Option<Set<T>> {\n    let mut new_set = set_new(set1.hash_func, set1.equal_func)?;\n\n    let mut iterator = SetIterator {\n        set: set1,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator)?;\n\n        if !set_insert(&mut new_set, value.clone()) {\n            set_free(Box::new(new_set));\n            return None;\n        }\n    }\n\n    let mut iterator = SetIterator {\n        set: set2,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator)?;\n\n        if !set_query(&new_set, value.clone()) {\n            if !set_insert(&mut new_set, value.clone()) {\n                set_free(Box::new(new_set));\n                return None;\n            }\n        }\n    }\n\n    Some(new_set)\n}\n\npub fn set_iterate<T: Clone>(iterator: &mut SetIterator<T>) {\n    iterator.next_entry = None;\n\n    for chain in 0..iterator.set.table_size {\n        if let Some(entry) = &iterator.set.table[chain] {\n            iterator.next_entry = Some(Box::new(SetEntry {\n                data: entry.data.clone(),\n                next: entry.next.clone(),\n            }));\n            break;\n        }\n    }\n\n    iterator.next_chain = 0;\n}\n\npub fn set_iter_has_more<T: Clone>(iterator: &SetIterator<T>) -> bool {\n    iterator.next_entry.is_some()\n}\n\nfn main() {}\n\npub fn set_num_entries<T>(set: &Set<T>) -> usize {\n    set.entries\n}\n\n\npub fn set_register_free_function<T>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\n\n //编译报错信息：",
        "set_remove": "\npub struct Set<T> {\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub entries: usize,\n    pub table_size: usize,\n    pub prime_index: usize,\n    pub hash_func: fn(&T) -> u32,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetEntry<T> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\npub const SET_NUM_PRIMES: usize = 24;\npub const SET_PRIMES: [usize; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct SetIterator<T> {\n    pub set: Set<T>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\npub fn set_free_entry<T>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\npub fn set_remove<T>(set: &mut Set<T>, data: T) -> bool {\n    let index = (set.hash_func)(&data) as usize % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            let next = entry.next.take();\n            let entry = rover.take().unwrap();\n            set.entries -= 1;\n            set_free_entry(set, entry);\n            *rover = next;\n            return true;\n        }\n        rover = &mut entry.next;\n    }\n\n    false\n}\n\nfn main() {}\n\n //编译报错信息：error[E0499]: cannot borrow `*rover` as mutable more than once at a time\n  --> ../../Test_max12/tmp/test-set_set_remove/temp.rs:46:25\n   |\n43 |     while let Some(entry) = rover {\n   |                    ----- first mutable borrow occurs here\n...\n46 |             let entry = rover.take().unwrap();\n   |                         ^^^^^\n   |                         |\n   |                         second mutable borrow occurs here\n   |                         first borrow later used here\n\nerror[E0499]: cannot borrow `*set` as mutable more than once at a time\n  --> ../../Test_max12/tmp/test-set_set_remove/temp.rs:48:28\n   |\n41 |     let mut rover = &mut set.table[index];\n   |                          --------- first mutable borrow occurs here\n...\n48 |             set_free_entry(set, entry);\n   |                            ^^^ second mutable borrow occurs here\n49 |             *rover = next;\n   |             ------ first borrow later used here\n\nerror[E0506]: cannot assign to `*rover` because it is borrowed\n  --> ../../Test_max12/tmp/test-set_set_remove/temp.rs:49:13\n   |\n43 |     while let Some(entry) = rover {\n   |                    ----- `*rover` is borrowed here\n...\n49 |             *rover = next;\n   |             ^^^^^^\n   |             |\n   |             `*rover` is assigned to here but it was already borrowed\n   |             borrow later used here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0499, E0506.\nFor more information about an error, try `rustc --explain E0499`.\n"
    },
    "test-list": {
        "check_list_integrity": "pub struct ListEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<ListEntry<T>>>,\n    pub next: Option<Box<ListEntry<T>>>,\n}\n\nimpl<T> Clone for ListEntry<T>\nwhere\n    T: Clone,\n{\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Box<ListEntry<T>>>,\n    pub current: Option<Box<ListEntry<T>>>,\n}\npub static mut variable1: i32 = 50;\npub static mut variable2: i32 = 0;\npub static mut variable3: i32 = 0;\npub static mut variable4: i32 = 0;\npub fn list_append<T>(list: &mut Option<Box<ListEntry<T>>>, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut newentry = Box::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    });\n\n    if list.is_none() {\n        *list = Some(newentry);\n        return list.clone();\n    }\n\n    let mut rover = list.as_mut().unwrap();\n    while rover.next.is_some() {\n        rover = rover.next.as_mut().unwrap();\n    }\n\n    newentry.prev = Some(Box::new(ListEntry {\n        data: rover.data.clone(),\n        prev: rover.prev.clone(),\n        next: None,\n    }));\n    rover.next = Some(newentry);\n\n    rover.next.clone()\n}\n\n\npub fn list_prev<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.prev,\n        None => None,\n    }\n}\n\n\npub fn list_next<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.next,\n        None => None,\n    }\n}\n\n\npub fn list_nth_entry<T>(list: Option<Box<ListEntry<T>>>, n: usize) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut entry = list;\n\n    for _ in 0..n {\n        if entry.is_none() {\n            return None;\n        }\n        entry = entry.and_then(|e| e.next);\n    }\n\n    entry\n}\n\n\npub fn list_length<T>(list: Option<Box<ListEntry<T>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(node) = entry {\n        length += 1;\n        entry = node.next;\n    }\n\n    length\n}\n\n\npub fn list_sort_internal<T, F>(list: &mut Option<Box<ListEntry<T>>>, compare_func: F) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> i32,\n{\n    if list.is_none() {\n        return None;\n    }\n\n    let mut pivot = list.take().unwrap();\n    if pivot.next.is_none() {\n        let pivot_clone = pivot.clone();\n        *list = Some(pivot);\n        return Some(pivot_clone);\n    }\n\n    let mut less_list: Option<Box<ListEntry<T>>> = None;\n    let mut more_list: Option<Box<ListEntry<T>>> = None;\n    let mut rover = pivot.next.take();\n\n    while let Some(mut current) = rover {\n        let next = current.next.take();\n        let current_data = current.data.clone();\n        if compare_func(&current_data, &pivot.data) < 0 {\n            current.prev = None;\n            current.next = less_list.take();\n            let current_clone = current.clone();\n            if let Some(ref mut less) = current.next {\n                less.prev = Some(current_clone);\n            }\n            less_list = Some(current);\n        } else {\n            current.prev = None;\n            current.next = more_list.take();\n            let current_clone = current.clone();\n            if let Some(ref mut more) = current.next {\n                more.prev = Some(current_clone);\n            }\n            more_list = Some(current);\n        }\n        rover = next;\n    }\n\n    let mut less_list_end = list_sort_internal(&mut less_list, &compare_func);\n    let more_list_end = list_sort_internal(&mut more_list, &compare_func);\n\n    *list = less_list.take();\n    if let Some(ref mut less_end) = less_list_end {\n        let pivot_clone = pivot.clone();\n        pivot.prev = Some(less_end.clone());\n        less_end.next = Some(pivot_clone);\n    } else {\n        pivot.prev = None;\n        *list = Some(pivot.clone());\n    }\n\n    pivot.next = more_list.take();\n    let pivot_clone = pivot.clone();\n    if let Some(ref mut more) = pivot.next {\n        more.prev = Some(pivot_clone);\n    }\n\n    if more_list_end.is_none() {\n        Some(pivot)\n    } else {\n        more_list_end\n    }\n}\n\n\npub fn list_free<T>(list: Option<Box<ListEntry<T>>>) {\n    let mut entry = list;\n\n    while let Some(mut current_entry) = entry {\n        entry = current_entry.next.take();\n    }\n}\n\n\npub fn generate_list() -> Option<Box<ListEntry<i32>>> {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n\n    unsafe {\n        assert!(list_append(&mut list, variable1).is_some());\n        assert!(list_append(&mut list, variable2).is_some());\n        assert!(list_append(&mut list, variable3).is_some());\n        assert!(list_append(&mut list, variable4).is_some());\n    }\n\n    list\n}\n\n\npub fn check_list_integrity<T>(list: Option<Box<ListEntry<T>>>) -> bool\nwhere\n    T: Clone + PartialEq,\n{\n    let mut prev: Option<Box<ListEntry<T>>> = None;\n    let mut rover = list;\n\n    while let Some(rover_entry) = rover {\n        let cloned_entry = Box::new((*rover_entry).clone());\n        assert!(list_prev(Some(cloned_entry.clone())) == prev);\n        prev = Some(cloned_entry);\n        rover = list_next(Some(rover_entry));\n    }\n\n    true\n}\n\n\nfn main(){}\n //insert编译报错信息：error[E0369]: binary operation `==` cannot be applied to type `Option<Box<ListEntry<T>>>`\n   --> ../../Test_max12/tmp/test-list_check_list_integrity/test_source.rs:207:55\n    |\n207 |         assert!(list_prev(Some(cloned_entry.clone())) == prev);\n    |                 ------------------------------------- ^^ ---- Option<Box<ListEntry<T>>>\n    |                 |\n    |                 Option<Box<ListEntry<T>>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ListEntry<T>`\n   --> ../../Test_max12/tmp/test-list_check_list_integrity/test_source.rs:1:1\n    |\n1   | pub struct ListEntry<T> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\nhelp: consider annotating `ListEntry<T>` with `#[derive(PartialEq)]`\n    |\n1   + #[derive(PartialEq)]\n2   | pub struct ListEntry<T> {\n    |\nhelp: consider extending the `where` clause, but there might be an alternative better way to express this requirement\n    |\n200 |     T: Clone + PartialEq, ListEntry<T>: PartialEq\n    |                         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
        "test_list_append": "pub struct ListEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<ListEntry<T>>>,\n    pub next: Option<Box<ListEntry<T>>>,\n}\n\nimpl<T> Clone for ListEntry<T>\nwhere\n    T: Clone,\n{\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T> PartialEq for ListEntry<T>\nwhere\n    T: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.prev == other.prev && self.next == other.next\n    }\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Box<ListEntry<T>>>,\n    pub current: Option<Box<ListEntry<T>>>,\n}\npub static mut variable1: i32 = 50;\npub static mut variable2: i32 = 0;\npub static mut variable3: i32 = 0;\npub static mut variable4: i32 = 0;\n\n#[derive(Debug)]\npub struct ListEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<ListEntry<T>>>,\n    pub next: Option<Box<ListEntry<T>>>,\n}\n\nimpl<T> Clone for ListEntry<T>\nwhere\n    T: Clone,\n{\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T> PartialEq for ListEntry<T>\nwhere\n    T: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.prev == other.prev && self.next == other.next\n    }\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Box<ListEntry<T>>>,\n    pub current: Option<Box<ListEntry<T>>>,\n}\npub fn list_append<T>(list: &mut Option<Box<ListEntry<T>>>, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut newentry = Box::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    });\n\n    if list.is_none() {\n        *list = Some(newentry);\n        return list.clone();\n    }\n\n    let mut rover = list.as_mut().unwrap();\n    while rover.next.is_some() {\n        rover = rover.next.as_mut().unwrap();\n    }\n\n    newentry.prev = Some(Box::new(ListEntry {\n        data: rover.data.clone(),\n        prev: rover.prev.clone(),\n        next: None,\n    }));\n    rover.next = Some(newentry);\n\n    rover.next.clone()\n}\n\n\npub fn list_prev<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.prev,\n        None => None,\n    }\n}\n\n\npub fn list_next<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.next,\n        None => None,\n    }\n}\n\n\npub fn list_nth_entry<T>(list: Option<Box<ListEntry<T>>>, n: usize) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut entry = list;\n\n    for _ in 0..n {\n        if entry.is_none() {\n            return None;\n        }\n        entry = entry.and_then(|e| e.next);\n    }\n\n    entry\n}\n\n\npub fn list_length<T>(list: Option<Box<ListEntry<T>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(node) = entry {\n        length += 1;\n        entry = node.next;\n    }\n\n    length\n}\n\n\npub fn list_sort_internal<T, F>(list: &mut Option<Box<ListEntry<T>>>, compare_func: F) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> i32,\n{\n    if list.is_none() {\n        return None;\n    }\n\n    let mut pivot = list.take().unwrap();\n    if pivot.next.is_none() {\n        let pivot_clone = pivot.clone();\n        *list = Some(pivot);\n        return Some(pivot_clone);\n    }\n\n    let mut less_list: Option<Box<ListEntry<T>>> = None;\n    let mut more_list: Option<Box<ListEntry<T>>> = None;\n    let mut rover = pivot.next.take();\n\n    while let Some(mut current) = rover {\n        let next = current.next.take();\n        let current_data = current.data.clone();\n        if compare_func(&current_data, &pivot.data) < 0 {\n            current.prev = None;\n            current.next = less_list.take();\n            let current_clone = current.clone();\n            if let Some(ref mut less) = current.next {\n                less.prev = Some(current_clone);\n            }\n            less_list = Some(current);\n        } else {\n            current.prev = None;\n            current.next = more_list.take();\n            let current_clone = current.clone();\n            if let Some(ref mut more) = current.next {\n                more.prev = Some(current_clone);\n            }\n            more_list = Some(current);\n        }\n        rover = next;\n    }\n\n    let mut less_list_end = list_sort_internal(&mut less_list, &compare_func);\n    let more_list_end = list_sort_internal(&mut more_list, &compare_func);\n\n    *list = less_list.take();\n    if let Some(ref mut less_end) = less_list_end {\n        let pivot_clone = pivot.clone();\n        pivot.prev = Some(less_end.clone());\n        less_end.next = Some(pivot_clone);\n    } else {\n        pivot.prev = None;\n        *list = Some(pivot.clone());\n    }\n\n    pivot.next = more_list.take();\n    let pivot_clone = pivot.clone();\n    if let Some(ref mut more) = pivot.next {\n        more.prev = Some(pivot_clone);\n    }\n\n    if more_list_end.is_none() {\n        Some(pivot)\n    } else {\n        more_list_end\n    }\n}\n\n\npub fn list_free<T>(list: Option<Box<ListEntry<T>>>) {\n    let mut entry = list;\n\n    while let Some(mut current_entry) = entry {\n        entry = current_entry.next.take();\n    }\n}\n\n\npub fn list_nth_data<T>(list: Option<Box<ListEntry<T>>>, n: usize) -> Option<T>\nwhere\n    T: Clone,\n{\n    let entry = list_nth_entry(list, n);\n\n    if entry.is_none() {\n        None\n    } else {\n        entry.map(|e| e.data)\n    }\n}\n\n\npub fn list_iterate<T>(list: &mut Option<Box<ListEntry<T>>>, iter: &mut ListIterator<T>) {\n    iter.prev_next = list.take();\n    iter.current = None;\n}\n\n\npub fn list_remove_data<T, F>(list: &mut Option<Box<ListEntry<T>>>, callback: F, data: T) -> usize\nwhere\n    T: Clone + PartialEq,\n    F: Fn(&T, &T) -> bool,\n{\n    let mut entries_removed = 0;\n    let mut rover = list.take();\n\n    while let Some(mut current) = rover {\n        let next = current.next.take();\n\n        if callback(&current.data, &data) {\n            if let Some(mut prev) = current.prev.take() {\n                prev.next = current.next.take();\n            } else {\n                *list = current.next.take();\n            }\n\n            if let Some(next_node) = current.next.as_mut() {\n                next_node.prev = current.prev.take();\n            }\n\n            entries_removed += 1;\n        } else {\n            let current_clone = current.clone();\n            if let Some(mut prev) = current.prev.take() {\n                prev.next = Some(current_clone.clone());\n            } else {\n                *list = Some(current_clone.clone());\n            }\n\n            if let Some(next_node) = current.next.as_mut() {\n                next_node.prev = Some(current_clone);\n            }\n        }\n\n        rover = next;\n    }\n\n    entries_removed\n}\n\n\npub fn list_iter_has_more<T>(iter: &ListIterator<T>) -> bool\nwhere\n    T: PartialEq,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|x| &**x) != iter.prev_next.as_ref().map(|x| &**x) {\n        iter.prev_next.is_some()\n    } else {\n        iter.current.as_ref().unwrap().next.is_some()\n    }\n}\n\n\npub fn list_prepend<T>(list: &mut Option<Box<ListEntry<T>>>, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut newentry = Box::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    });\n\n    if let Some(ref mut head) = list {\n        head.prev = Some(newentry.clone());\n        newentry.next = Some(head.clone());\n    }\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\n\npub fn list_iter_remove<T>(iter: &mut ListIterator<T>)\nwhere\n    T: Clone + PartialEq,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|x| &**x) != iter.prev_next.as_ref().map(|x| &**x) {\n        // Either we have not yet read the first item, we have\n        // reached the end of the list, or we have already removed\n        // the current value. Either way, do nothing.\n    } else {\n        // Remove the current entry\n        let mut current = iter.current.take().unwrap();\n        if let Some(ref mut prev_next) = iter.prev_next {\n            *prev_next = current.next.take().unwrap_or_else(|| Box::new(ListEntry {\n                data: current.data.clone(),\n                prev: None,\n                next: None,\n            }));\n        }\n\n        if let Some(ref mut next) = current.next {\n            next.prev = current.prev.clone();\n        }\n\n        iter.current = None;\n    }\n}\n\n\npub fn list_to_array<T: Clone>(list: Option<Box<ListEntry<T>>>) -> Vec<T> {\n    let length = list_length(list.clone());\n    let mut array = Vec::with_capacity(length);\n\n    let mut rover = list;\n\n    for _ in 0..length {\n        if let Some(node) = rover {\n            array.push(node.data.clone());\n            rover = node.next;\n        }\n    }\n\n    array\n}\n\n\npub fn list_data<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<T>\nwhere\n    T: Clone,\n{\n    match listentry {\n        Some(entry) => Some(entry.data.clone()),\n        None => None,\n    }\n}\n\n\npub fn list_sort<T, F>(list: &mut Option<Box<ListEntry<T>>>, compare_func: F)\nwhere\n    T: Clone,\n    F: Fn(&T, &T) -> i32,\n{\n    *list = list_sort_internal(list, compare_func);\n}\n\n\npub fn list_find_data<T, F>(list: Option<Box<ListEntry<T>>>, callback: F, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone + PartialEq,\n    F: Fn(T, T) -> bool,\n{\n    let mut rover = list;\n\n    while let Some(node) = rover {\n        if callback(node.data.clone(), data.clone()) {\n            return Some(node);\n        }\n        rover = node.next;\n    }\n\n    None\n}\n\n\npub fn list_remove_entry<T>(list: &mut Option<Box<ListEntry<T>>>, entry: Option<Box<ListEntry<T>>>) -> bool\nwhere\n    T: Clone,\n{\n    if list.is_none() || entry.is_none() {\n        return false;\n    }\n\n    let mut entry = entry.unwrap();\n\n    if entry.prev.is_none() {\n        *list = entry.next.take();\n\n        if let Some(ref mut next_entry) = list {\n            next_entry.prev = None;\n        }\n    } else {\n        let mut prev_entry = entry.prev.take().unwrap();\n        let mut next_entry = entry.next.take();\n\n        if let Some(ref mut next_entry_inner) = next_entry {\n            next_entry_inner.prev = Some(Box::new((*prev_entry).clone()));\n        }\n\n        if let Some(ref mut prev_entry_inner) = prev_entry.next {\n            prev_entry_inner.next = next_entry;\n        }\n    }\n\n    true\n}\n\n\npub fn generate_list() -> Option<Box<ListEntry<i32>>> {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n\n    unsafe {\n        assert!(list_append(&mut list, variable1).is_some());\n        assert!(list_append(&mut list, variable2).is_some());\n        assert!(list_append(&mut list, variable3).is_some());\n        assert!(list_append(&mut list, variable4).is_some());\n    }\n\n    list\n}\n\n\npub fn test_list_free() {\n    let mut list = generate_list();\n    list_free(list);\n\n    list_free::<i32>(None);\n}\n\n\npub fn test_list_append() {\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n\n    assert!(list_append(&mut list, unsafe { variable1 }).is_some());\n    check_list_integrity(&list);\n    assert!(list_append(&mut list, unsafe { variable2 }).is_some());\n    check_list_integrity(&list);\n    assert!(list_append(&mut list, unsafe { variable3 }).is_some());\n    check_list_integrity(&list);\n    assert!(list_append(&mut list, unsafe { variable4 }).is_some());\n    check_list_integrity(&list);\n\n    assert_eq!(list_length(list.clone()), 4);\n\n    assert_eq!(list_nth_data(list.clone(), 0), Some(unsafe { variable1 }));\n    assert_eq!(list_nth_data(list.clone(), 1), Some(unsafe { variable2 }));\n    assert_eq!(list_nth_data(list.clone(), 2), Some(unsafe { variable3 }));\n    assert_eq!(list_nth_data(list.clone(), 3), Some(unsafe { variable4 }));\n\n    list_free(list);\n}\n\n\npub fn check_list_integrity<T>(list: &Option<Box<ListEntry<T>>>)\nwhere\n    T: Clone + PartialEq + std::fmt::Debug,\n{\n    let mut prev: Option<Box<ListEntry<T>>> = None;\n    let mut rover = list.clone();\n\n    while let Some(node) = rover {\n        assert_eq!(list_prev(Some(node.clone())), prev);\n        prev = Some(node.clone());\n        rover = list_next(Some(node));\n    }\n}\n\n\nfn main(){}\n //insert编译报错信息：error[E0428]: the name `ListIterator` is defined multiple times\n  --> ../../Test_max12/tmp/test-list_test_list_append/test_source.rs:67:1\n   |\n29 | pub struct ListIterator<T> {\n   | -------------------------- previous definition of the type `ListIterator` here\n...\n67 | pub struct ListIterator<T> {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ `ListIterator` redefined here\n   |\n   = note: `ListIterator` must be defined only once in the type namespace of this module\n\nerror[E0428]: the name `ListEntry` is defined multiple times\n  --> ../../Test_max12/tmp/test-list_test_list_append/test_source.rs:39:1\n   |\n1  | pub struct ListEntry<T> {\n   | ----------------------- previous definition of the type `ListEntry` here\n...\n39 | pub struct ListEntry<T> {\n   | ^^^^^^^^^^^^^^^^^^^^^^^ `ListEntry` redefined here\n   |\n   = note: `ListEntry` must be defined only once in the type namespace of this module\n\nerror[E0119]: conflicting implementations of trait `Clone` for type `ListEntry<_>`\n  --> ../../Test_max12/tmp/test-list_test_list_append/test_source.rs:45:1\n   |\n7  | / impl<T> Clone for ListEntry<T>\n8  | | where\n9  | |     T: Clone,\n   | |_____________- first implementation here\n...\n45 | / impl<T> Clone for ListEntry<T>\n46 | | where\n47 | |     T: Clone,\n   | |_____________^ conflicting implementation for `ListEntry<_>`\n\nerror[E0119]: conflicting implementations of trait `PartialEq` for type `ListEntry<_>`\n  --> ../../Test_max12/tmp/test-list_test_list_append/test_source.rs:58:1\n   |\n20 | / impl<T> PartialEq for ListEntry<T>\n21 | | where\n22 | |     T: PartialEq,\n   | |_________________- first implementation here\n...\n58 | / impl<T> PartialEq for ListEntry<T>\n59 | | where\n60 | |     T: PartialEq,\n   | |_________________^ conflicting implementation for `ListEntry<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0119, E0428.\nFor more information about an error, try `rustc --explain E0119`.\n",
        "test_list_remove_data": "\npub static mut variable1: i32 = 50;\npub static mut variable2: i32 = 0;\npub static mut variable3: i32 = 0;\npub static mut variable4: i32 = 0;\n\n#[derive(Debug, Clone)]\npub struct ListEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<ListEntry<T>>>,\n    pub next: Option<Box<ListEntry<T>>>,\n}\n\nimpl<T> PartialEq for ListEntry<T>\nwhere\n    T: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.prev == other.prev && self.next == other.next\n    }\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Box<ListEntry<T>>>,\n    pub current: Option<Box<ListEntry<T>>>,\n}\n\npub fn list_length<T>(list: Option<Box<ListEntry<T>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(node) = entry {\n        length += 1;\n        entry = node.next;\n    }\n\n    length\n}\n\npub fn list_remove_data<T, F>(list: &mut Option<Box<ListEntry<T>>>, callback: F, data: &T) -> usize\nwhere\n    T: Clone + PartialEq,\n    F: Fn(&T, &T) -> bool,\n{\n    let mut entries_removed = 0;\n    let mut rover = list.take();\n\n    while let Some(mut current) = rover {\n        let next = current.next.take();\n\n        if callback(&current.data, data) {\n            if let Some(mut prev) = current.prev.take() {\n                prev.next = current.next.take();\n            } else {\n                *list = current.next.take();\n            }\n\n            if let Some(next_node) = current.next.as_mut() {\n                next_node.prev = current.prev.take();\n            }\n\n            entries_removed += 1;\n        } else {\n            let current_clone = current.clone();\n            if let Some(mut prev) = current.prev.take() {\n                prev.next = Some(current_clone.clone());\n            } else {\n                *list = Some(current_clone.clone());\n            }\n\n            if let Some(next_node) = current.next.as_mut() {\n                next_node.prev = Some(current_clone);\n            }\n        }\n\n        rover = next;\n    }\n\n    entries_removed\n}\n\npub fn list_prev<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.prev,\n        None => None,\n    }\n}\n\npub fn list_prepend<T>(list: &mut Option<Box<ListEntry<T>>>, data: T) -> Option<Box<ListEntry<T>>>\nwhere\n    T: Clone,\n{\n    let mut newentry = Box::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    });\n\n    if let Some(ref mut head) = list {\n        head.prev = Some(newentry.clone());\n        newentry.next = Some(head.clone());\n    }\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\npub fn list_next<T>(listentry: Option<Box<ListEntry<T>>>) -> Option<Box<ListEntry<T>>> {\n    match listentry {\n        Some(entry) => entry.next,\n        None => None,\n    }\n}\n\npub fn list_free<T>(list: Option<Box<ListEntry<T>>>) {\n    let mut entry = list;\n\n    while let Some(mut current_entry) = entry {\n        entry = current_entry.next.take();\n    }\n}\n\npub fn test_list_remove_data()\nwhere\n    T: std::fmt::Debug,\n{\n    let entries = vec![89, 4, 23, 42, 4, 16, 15, 4, 8, 99, 50, 30, 4];\n    let num_entries = entries.len();\n    let mut list: Option<Box<ListEntry<i32>>> = None;\n\n    for entry in entries.iter() {\n        assert!(list_prepend(&mut list, *entry).is_some());\n    }\n\n    let mut val = 0;\n    assert_eq!(list_remove_data(&mut list, |a, b| a == b, &val), 0);\n    val = 56;\n    assert_eq!(list_remove_data(&mut list, |a, b| a == b, &val), 0);\n    check_list_integrity(&list);\n\n    val = 8;\n    assert_eq!(list_remove_data(&mut list, |a, b| a == b, &val), 1);\n    assert_eq!(list_length(list.clone()), num_entries - 1);\n    check_list_integrity(&list);\n\n    val = 4;\n    assert_eq!(list_remove_data(&mut list, |a, b| a == b, &val), 4);\n    assert_eq!(list_length(list.clone()), num_entries - 5);\n    check_list_integrity(&list);\n\n    val = 89;\n    assert_eq!(list_remove_data(&mut list, |a, b| a == b, &val), 1);\n    assert_eq!(list_length(list.clone()), num_entries - 6);\n    check_list_integrity(&list);\n\n    list_free(list);\n}\n\npub fn check_list_integrity<T>(list: &Option<Box<ListEntry<T>>>)\nwhere\n    T: Clone + PartialEq + std::fmt::Debug,\n{\n    let mut prev: Option<Box<ListEntry<T>>> = None;\n    let mut rover = list.clone();\n\n    while let Some(node) = rover {\n        assert_eq!(list_prev(Some(node.clone())), prev);\n        prev = Some(node.clone());\n        rover = list_next(Some(node));\n    }\n}\n\nfn main() {}\n\n //编译报错信息：error[E0412]: cannot find type `T` in this scope\n   --> ../../Test_max12/tmp/test-list_test_list_remove_data/temp.rs:126:5\n    |\n126 |     T: std::fmt::Debug,\n    |     ^ not found in this scope\n    |\n"
    },
    "hash-table": {
        "hash_table_remove": "\npub struct HashTablePair<K, V> {\n    pub key: K,\n    pub value: V,\n}\n\npub struct HashTableEntry<K, V> {\n    pub pair: HashTablePair<K, V>,\n    pub next: Option<Box<HashTableEntry<K, V>>>,\n}\n\npub struct HashTable<K, V> {\n    pub table: Vec<Option<Box<HashTableEntry<K, V>>>>,\n    pub table_size: usize,\n    pub hash_func: fn(&K) -> u32,\n    pub equal_func: fn(&K, &K) -> bool,\n    pub key_free_func: Option<fn(K)>,\n    pub value_free_func: Option<fn(V)>,\n    pub entries: usize,\n    pub prime_index: usize,\n}\n\npub const HASH_TABLE_NUM_PRIMES: usize = 24;\npub const HASH_TABLE_PRIMES: [usize; HASH_TABLE_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub fn hash_table_free_entry<K, V>(hash_table: &mut HashTable<K, V>, entry: Box<HashTableEntry<K, V>>) {\n    let pair = entry.pair;\n\n    if let Some(key_free_func) = hash_table.key_free_func {\n        key_free_func(pair.key);\n    }\n\n    if let Some(value_free_func) = hash_table.value_free_func {\n        value_free_func(pair.value);\n    }\n}\n\npub fn hash_table_remove<K, V>(hash_table: &mut HashTable<K, V>, key: K) -> bool {\n    let index = (hash_table.hash_func)(&key) as usize % hash_table.table_size;\n\n    let mut result = false;\n    let mut prev = &mut hash_table.table[index];\n\n    while let Some(entry) = prev {\n        if (hash_table.equal_func)(&key, &entry.pair.key) {\n            let entry_to_remove = prev.take().unwrap();\n            *prev = entry_to_remove.next;\n            hash_table_free_entry(hash_table, entry_to_remove);\n            hash_table.entries -= 1;\n            result = true;\n            break;\n        }\n        prev = &mut entry.next;\n    }\n\n    result\n}\n\nfn main() {}\n\n //编译报错信息：error[E0499]: cannot borrow `*prev` as mutable more than once at a time\n  --> ../../Test_max12/tmp/test-hash-table_hash_table_remove/temp.rs:51:35\n   |\n49 |     while let Some(entry) = prev {\n   |                    ----- first mutable borrow occurs here\n50 |         if (hash_table.equal_func)(&key, &entry.pair.key) {\n51 |             let entry_to_remove = prev.take().unwrap();\n   |                                   ^^^^\n   |                                   |\n   |                                   second mutable borrow occurs here\n   |                                   first borrow later used here\n\nerror[E0506]: cannot assign to `*prev` because it is borrowed\n  --> ../../Test_max12/tmp/test-hash-table_hash_table_remove/temp.rs:52:13\n   |\n49 |     while let Some(entry) = prev {\n   |                    ----- `*prev` is borrowed here\n...\n52 |             *prev = entry_to_remove.next;\n   |             ^^^^^\n   |             |\n   |             `*prev` is assigned to here but it was already borrowed\n   |             borrow later used here\n\nerror[E0382]: use of partially moved value: `entry_to_remove`\n  --> ../../Test_max12/tmp/test-hash-table_hash_table_remove/temp.rs:53:47\n   |\n52 |             *prev = entry_to_remove.next;\n   |                     -------------------- value partially moved here\n53 |             hash_table_free_entry(hash_table, entry_to_remove);\n   |                                               ^^^^^^^^^^^^^^^ value used here after partial move\n   |\n   = note: partial move occurs because `entry_to_remove.next` has type `Option<Box<HashTableEntry<K, V>>>`, which does not implement the `Copy` trait\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0499, E0506.\nFor more information about an error, try `rustc --explain E0382`.\n"
    },
    "slist": {
        "slist_remove_data": "\npub struct SListEntry<T> {\n    pub data: T,\n    pub next: Option<Box<SListEntry<T>>>,\n}\n\nimpl<T: Clone> Clone for SListEntry<T> {\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for SListEntry<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.next == other.next\n    }\n}\n\npub struct SListIterator<T> {\n    pub prev_next: Option<Box<SListEntry<T>>>,\n    pub current: Option<Box<SListEntry<T>>>,\n}\n\npub type SListValue<T> = T;\npub type SListEqualFunc<T> = fn(SListValue<T>, SListValue<T>) -> bool;\n\npub fn slist_remove_data<T: PartialEq + Clone>(\n    list: &mut Option<Box<SListEntry<T>>>,\n    callback: SListEqualFunc<T>,\n    data: SListValue<T>,\n) -> usize {\n    let mut entries_removed = 0;\n    let mut rover = list;\n\n    while let Some(entry) = rover {\n        let entry_data = entry.data.clone();\n        if callback(entry_data, data.clone()) {\n            let next = entry.next.take();\n            *rover = next;\n            entries_removed += 1;\n        } else {\n            rover = &mut entry.next;\n        }\n    }\n\n    entries_removed\n}\n\nfn main() {}\n\n //编译报错信息：error[E0506]: cannot assign to `*rover` because it is borrowed\n  --> ../../Test_max12/tmp/test-slist_slist_remove_data/temp.rs:42:13\n   |\n38 |     while let Some(entry) = rover {\n   |                    ----- `*rover` is borrowed here\n...\n42 |             *rover = next;\n   |             ^^^^^^\n   |             |\n   |             `*rover` is assigned to here but it was already borrowed\n   |             borrow later used here\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0506`.\n"
    },
    "rb-tree": {
        "rb_tree_rotate": "\n#[derive(Clone, Copy)]\npub enum RBTreeNodeSide {\n    Left = 0,\n    Right = 1,\n}\n\n#[derive(Clone)]\npub enum RBTreeNodeColor {\n    Red,\n    Black,\n}\n\n#[derive(Clone)]\npub struct RBTreeNode<T: Clone> {\n    pub color: RBTreeNodeColor,\n    pub key: T,\n    pub value: T,\n    pub parent: Option<Box<RBTreeNode<T>>>,\n    pub children: [Option<Box<RBTreeNode<T>>>; 2],\n}\n\npub struct RBTree<T: Clone> {\n    pub root_node: Option<Box<RBTreeNode<T>>>,\n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: i32,\n}\n\npub fn rb_tree_node_replace<T: Clone>(tree: &mut RBTree<T>, node1: &mut RBTreeNode<T>, mut node2: Option<Box<RBTreeNode<T>>>) {\n    let side;\n\n    // Set the node's parent pointer.\n    if let Some(ref mut node2_inner) = node2 {\n        node2_inner.parent = node1.parent.take();\n    }\n\n    // The root node?\n    if node1.parent.is_none() {\n        tree.root_node = node2;\n    } else {\n        side = rb_tree_node_side(node1);\n        if let Some(ref mut parent) = node1.parent {\n            parent.children[side as usize] = node2;\n        }\n    }\n}\n\npub fn rb_tree_node_side<T: Clone>(node: &RBTreeNode<T>) -> RBTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        if let Some(left_child) = &parent.children[RBTreeNodeSide::Left as usize] {\n            if std::ptr::eq(left_child.as_ref(), node) {\n                return RBTreeNodeSide::Left;\n            }\n        }\n    }\n    RBTreeNodeSide::Right\n}\n\npub fn rb_tree_rotate<T: Clone>(tree: &mut RBTree<T>, node: &mut RBTreeNode<T>, direction: RBTreeNodeSide) -> Option<Box<RBTreeNode<T>>> {\n    let mut new_root = node.children[1 - direction as usize].take();\n\n    if let Some(ref mut new_root_inner) = new_root {\n        rb_tree_node_replace(tree, node, Some(Box::new(RBTreeNode {\n            color: new_root_inner.color.clone(),\n            key: new_root_inner.key.clone(),\n            value: new_root_inner.value.clone(),\n            parent: new_root_inner.parent.clone(),\n            children: new_root_inner.children.clone(),\n        })));\n\n        node.children[1 - direction as usize] = new_root_inner.children[direction as usize].take();\n        new_root_inner.children[direction as usize] = Some(Box::new(RBTreeNode {\n            color: node.color.clone(),\n            key: node.key.clone(),\n            value: node.value.clone(),\n            parent: node.parent.clone(),\n            children: node.children.clone(),\n        }));\n\n        node.parent = Some(Box::new(RBTreeNode {\n            color: new_root_inner.color.clone(),\n            key: new_root_inner.key.clone(),\n            value: new_root_inner.value.clone(),\n            parent: new_root_inner.parent.clone(),\n            children: new_root_inner.children.clone(),\n        }));\n\n        if let Some(ref mut child) = node.children[1 - direction as usize] {\n            child.parent = Some(Box::new(RBTreeNode {\n                color: node.color.clone(),\n                key: node.key.clone(),\n                value: node.value.clone(),\n                parent: node.parent.clone(),\n                children: node.children.clone(),\n            }));\n        }\n    }\n\n    new_root\n}\n\nfn main() {}\n\n //编译报错信息：error[E0502]: cannot borrow `node.children` as immutable because it is also borrowed as mutable\n  --> ../../Test_max12/tmp/test-rb-tree_rb_tree_rotate/temp.rs:94:27\n   |\n88 |         if let Some(ref mut child) = node.children[1 - direction as usize] {\n   |                     ------------- mutable borrow occurs here\n89 |             child.parent = Some(Box::new(RBTreeNode {\n   |             ------------ mutable borrow later used here\n...\n94 |                 children: node.children.clone(),\n   |                           ^^^^^^^^^^^^^ immutable borrow occurs here\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
    },
    "list": {
        "list_iter_next": "\npub struct ListEntry<T> {\n    pub data: T,\n    pub prev: Option<Box<ListEntry<T>>>,\n    pub next: Option<Box<ListEntry<T>>>,\n}\n\nimpl<T> Clone for ListEntry<T>\nwhere\n    T: Clone,\n{\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T> PartialEq for ListEntry<T>\nwhere\n    T: PartialEq,\n{\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.prev == other.prev && self.next == other.next\n    }\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Box<ListEntry<T>>>,\n    pub current: Option<Box<ListEntry<T>>>,\n}\n\npub fn list_iter_next<T>(iter: &mut ListIterator<T>) -> Option<T>\nwhere\n    T: Clone,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|e| &**e) != iter.prev_next.as_ref().map(|e| &**e) {\n        // Either we are reading the first entry, we have reached\n        // the end of the list, or the previous entry was removed.\n        // Get the next entry with iter.prev_next.\n        iter.current = iter.prev_next.clone();\n    } else {\n        // Last value returned from list_iter_next was not deleted.\n        // Advance to the next entry.\n        if let Some(current) = &iter.current {\n            iter.prev_next = current.next.clone();\n            iter.current = current.next.clone();\n        }\n    }\n\n    // Have we reached the end of the list?\n    if iter.current.is_none() {\n        None\n    } else {\n        iter.current.as_ref().map(|entry| entry.data.clone())\n    }\n}\n\nfn main() {}\n\n //编译报错信息：error[E0369]: binary operation `!=` cannot be applied to type `Option<&ListEntry<T>>`\n  --> ../../Test_max12/tmp/test-list_list_iter_next/temp.rs:39:70\n   |\n39 | ...|| iter.current.as_ref().map(|e| &**e) != iter.prev_next.as_ref().map(|e| &**e...\n   |       ----------------------------------- ^^ ------------------------------------- Option<&ListEntry<T>>\n   |       |\n   |       Option<&ListEntry<T>>\n   |\n"
    },
    "test-slist": {
        "test_slist_remove_data": "\npub struct SListEntry<T> {\n    pub data: T,\n    pub next: Option<Box<SListEntry<T>>>,\n}\n\nimpl<T: Clone> Clone for SListEntry<T> {\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for SListEntry<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.next == other.next\n    }\n}\n\npub struct SListIterator<T> {\n    pub prev_next: Option<Box<SListEntry<T>>>,\n    pub current: Option<Box<SListEntry<T>>>,\n}\n\npub fn slist_prepend<T: Clone>(list: &mut Option<Box<SListEntry<T>>>, data: T) -> Option<Box<SListEntry<T>>> {\n    let newentry = Box::new(SListEntry {\n        data,\n        next: list.take(),\n    });\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\npub fn slist_free<T>(list: Option<Box<SListEntry<T>>>) {\n    let mut entry = list;\n\n    while let Some(mut current_entry) = entry {\n        entry = current_entry.next.take();\n    }\n}\n\npub fn slist_length<T>(list: Option<Box<SListEntry<T>>>) -> usize {\n    let mut length: usize = 0;\n    let mut entry = list;\n\n    while let Some(node) = entry {\n        length += 1;\n        entry = node.next;\n    }\n\n    length\n}\n\npub type SListEqualFunc<T> = fn(&T, &T) -> bool;\n\npub fn slist_remove_data<T: PartialEq + Clone>(\n    list: &mut Option<Box<SListEntry<T>>>,\n    callback: SListEqualFunc<T>,\n    data: &T,\n) -> usize {\n    let mut entries_removed = 0;\n    let mut rover = list;\n\n    while let Some(ref mut entry) = rover {\n        if callback(&entry.data, data) {\n            let next = entry.next.take();\n            *rover = next;\n            entries_removed += 1;\n        } else {\n            rover = &mut entry.next;\n        }\n    }\n\n    entries_removed\n}\n\npub fn test_slist_remove_data() {\n    let entries = vec![89, 4, 23, 42, 4, 16, 15, 4, 8, 99, 50, 30, 4];\n    let num_entries = entries.len();\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n\n    for entry in entries.iter().rev() {\n        list = slist_prepend(&mut list, entry.clone());\n    }\n\n    let int_equal: SListEqualFunc<i32> = |a, b| a == b;\n\n    let val = 0;\n    assert_eq!(slist_remove_data(&mut list, int_equal, &val), 0);\n    let val = 56;\n    assert_eq!(slist_remove_data(&mut list, int_equal, &val), 0);\n\n    let val = 8;\n    assert_eq!(slist_remove_data(&mut list, int_equal, &val), 1);\n    assert_eq!(slist_length(list.clone()), num_entries - 1);\n\n    let val = 4;\n    assert_eq!(slist_remove_data(&mut list, int_equal, &val), 4);\n    assert_eq!(slist_length(list.clone()), num_entries - 5);\n\n    let val = 89;\n    assert_eq!(slist_remove_data(&mut list, int_equal, &val), 1);\n    assert_eq!(slist_length(list.clone()), num_entries - 6);\n\n    slist_free(list);\n}\n\nfn main() {}\n\n //编译报错信息：error[E0506]: cannot assign to `*rover` because it is borrowed\n  --> ../../Test_max12/tmp/test-slist_test_slist_remove_data/temp.rs:71:13\n   |\n68 |     while let Some(ref mut entry) = rover {\n   |                    ------------- `*rover` is borrowed here\n...\n71 |             *rover = next;\n   |             ^^^^^^\n   |             |\n   |             `*rover` is assigned to here but it was already borrowed\n   |             borrow later used here\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0506`.\n",
        "test_slist_iterate_bad_remove": "\npub struct SListEntry<T> {\n    pub data: T,\n    pub next: Option<Box<SListEntry<T>>>,\n}\n\nimpl<T: Clone> Clone for SListEntry<T> {\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for SListEntry<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.next == other.next\n    }\n}\n\npub struct SListIterator<T> {\n    pub prev_next: Option<Box<SListEntry<T>>>,\n    pub current: Option<Box<SListEntry<T>>>,\n}\n\npub fn slist_prepend<T: Clone>(list: &mut Option<Box<SListEntry<T>>>, data: T) -> Option<Box<SListEntry<T>>> {\n    let newentry = Box::new(SListEntry {\n        data,\n        next: list.take(),\n    });\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\npub fn slist_iter_has_more<T: PartialEq>(iter: &SListIterator<T>) -> bool {\n    let current_ref = iter.current.as_ref().map(|x| &**x);\n    let prev_next_ref = iter.prev_next.as_ref().map(|x| &**x);\n\n    if iter.current.is_none() || current_ref != prev_next_ref {\n        iter.prev_next.is_some()\n    } else {\n        iter.current.as_ref().unwrap().next.is_some()\n    }\n}\n\npub fn slist_free<T>(list: Option<Box<SListEntry<T>>>) {\n    let mut entry = list;\n\n    while let Some(mut current_entry) = entry {\n        entry = current_entry.next.take();\n    }\n}\n\npub fn slist_iter_remove<T: PartialEq>(iter: &mut SListIterator<T>) {\n    let current_ref = iter.current.as_ref().map(|x| &**x);\n    let prev_next_ref = iter.prev_next.as_ref().map(|x| &**x);\n\n    if iter.current.is_none() || current_ref != prev_next_ref {\n        // Either we have not yet read the first item, we have\n        // reached the end of the list, or we have already removed\n        // the current value. Either way, do nothing.\n    } else {\n        // Remove the current entry\n        if let Some(current) = iter.current.take() {\n            if let Some(prev_next) = &mut iter.prev_next {\n                prev_next.next = current.next;\n            }\n        }\n    }\n}\n\npub fn slist_iterate<T>(list: &mut Option<Box<SListEntry<T>>>, iter: &mut SListIterator<T>) {\n    iter.prev_next = list.take();\n    iter.current = None;\n}\n\npub fn slist_iter_next<T>(iter: &mut SListIterator<T>) -> Option<T>\nwhere\n    T: Clone + PartialEq,\n{\n    if iter.current.is_none() || iter.current.as_ref().map(|x| &**x) != iter.prev_next.as_ref().map(|x| &**x) {\n        iter.current = iter.prev_next.clone();\n    } else {\n        if let Some(current) = &iter.current {\n            iter.prev_next = current.next.clone();\n            iter.current = current.next.clone();\n        }\n    }\n\n    if iter.current.is_none() {\n        None\n    } else {\n        iter.current.as_ref().map(|x| x.data.clone())\n    }\n}\n\npub fn test_slist_iterate_bad_remove() {\n    let mut list: Option<Box<SListEntry<i32>>> = None;\n    let mut iter = SListIterator { prev_next: None, current: None };\n    let mut values = [0; 49];\n\n    for i in 0..49 {\n        values[i] = i as i32; // Convert usize to i32\n        list = slist_prepend(&mut list, values[i]);\n    }\n\n    slist_iterate(&mut list, &mut iter);\n\n    while slist_iter_has_more(&iter) {\n        if let Some(val) = slist_iter_next(&mut iter) {\n            if val % 2 == 0 {\n                assert!(slist_remove_data(&mut list, |a, b| a == b, val) != 0);\n                slist_iter_remove(&mut iter);\n            }\n        }\n    }\n\n    slist_free(list);\n}\n\npub fn slist_remove_data<T: PartialEq + Clone>(\n    list: &mut Option<Box<SListEntry<T>>>,\n    callback: impl Fn(&T, &T) -> bool,\n    data: T,\n) -> usize {\n    let mut entries_removed = 0;\n    let mut rover = list;\n\n    while let Some(entry) = rover {\n        if callback(&entry.data, &data) {\n            let next = entry.next.take();\n            *rover = next;\n            entries_removed += 1;\n        } else {\n            rover = &mut entry.next;\n        }\n    }\n\n    entries_removed\n}\n\nfn main() {}\n\n //编译报错信息：error[E0506]: cannot assign to `*rover` because it is borrowed\n   --> ../../Test_max12/tmp/test-slist_test_slist_iterate_bad_remove/temp.rs:135:13\n    |\n132 |     while let Some(entry) = rover {\n    |                    ----- `*rover` is borrowed here\n...\n135 |             *rover = next;\n    |             ^^^^^^\n    |             |\n    |             `*rover` is assigned to here but it was already borrowed\n    |             borrow later used here\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0506`.\n"
    },
    "test-hash-table": {
        "test_hash_table_free_functions": "\npub static mut allocated_values: i32 = 0;\npub static mut allocated_keys: i32 = 0;\n\npub struct HashTablePair<K, V> {\n    pub key: K,\n    pub value: V,\n}\n\nimpl<K: Clone, V: Clone> Clone for HashTablePair<K, V> {\n    fn clone(&self) -> Self {\n        HashTablePair {\n            key: self.key.clone(),\n            value: self.value.clone(),\n        }\n    }\n}\n\npub struct HashTableEntry<K, V> {\n    pub pair: HashTablePair<K, V>,\n    pub next: Option<Box<HashTableEntry<K, V>>>,\n}\n\nimpl<K: Clone, V: Clone> Clone for HashTableEntry<K, V> {\n    fn clone(&self) -> Self {\n        HashTableEntry {\n            pair: self.pair.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct HashTable<K, V> {\n    pub table: Vec<Option<Box<HashTableEntry<K, V>>>>,\n    pub table_size: usize,\n    pub hash_func: fn(&K) -> u32,\n    pub equal_func: fn(&K, &K) -> bool,\n    pub key_free_func: Option<fn(K)>,\n    pub value_free_func: Option<fn(V)>,\n    pub entries: usize,\n    pub prime_index: usize,\n}\n\npub const HASH_TABLE_NUM_PRIMES: usize = 24;\npub const HASH_TABLE_PRIMES: [usize; HASH_TABLE_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct HashTableIterator<K, V> {\n    pub hash_table: Box<HashTable<K, V>>,\n    pub next_entry: Option<Box<HashTableEntry<K, V>>>,\n    pub next_chain: usize,\n}\n\npub fn hash_table_new<K, V>(hash_func: fn(&K) -> u32, equal_func: fn(&K, &K) -> bool) -> Option<HashTable<K, V>> {\n    let mut hash_table = HashTable {\n        table: Vec::new(),\n        table_size: 0,\n        hash_func,\n        equal_func,\n        key_free_func: None,\n        value_free_func: None,\n        entries: 0,\n        prime_index: 0,\n    };\n\n    if !hash_table_allocate_table(&mut hash_table) {\n        return None;\n    }\n\n    Some(hash_table)\n}\n\npub fn hash_table_free<K, V>(mut hash_table: HashTable<K, V>) {\n    for i in 0..hash_table.table_size {\n        let mut rover = hash_table.table[i].take();\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            hash_table_free_entry(&mut hash_table, entry);\n            rover = next;\n        }\n    }\n}\n\npub fn hash_table_free_entry<K, V>(hash_table: &mut HashTable<K, V>, entry: Box<HashTableEntry<K, V>>) {\n    let pair = entry.pair;\n\n    if let Some(key_free_func) = hash_table.key_free_func {\n        key_free_func(pair.key);\n    }\n\n    if let Some(value_free_func) = hash_table.value_free_func {\n        value_free_func(pair.value);\n    }\n}\n\npub fn hash_table_register_free_functions<K, V>(\n    hash_table: &mut HashTable<K, V>,\n    key_free_func: Option<fn(K)>,\n    value_free_func: Option<fn(V)>,\n) {\n    hash_table.key_free_func = key_free_func;\n    hash_table.value_free_func = value_free_func;\n}\n\npub fn new_value(value: i32) -> Box<i32> {\n    let result = Box::new(value);\n    unsafe {\n        allocated_values += 1;\n    }\n    result\n}\n\npub fn new_key(value: i32) -> Box<i32> {\n    let result = Box::new(value);\n    unsafe {\n        allocated_keys += 1;\n    }\n    result\n}\n\npub fn hash_table_enlarge<K, V>(hash_table: &mut HashTable<K, V>) -> bool {\n    let mut old_table = std::mem::take(&mut hash_table.table);\n    let old_table_size = hash_table.table_size;\n    let old_prime_index = hash_table.prime_index;\n\n    hash_table.prime_index += 1;\n\n    if !hash_table_allocate_table(hash_table) {\n        hash_table.table = old_table;\n        hash_table.table_size = old_table_size;\n        hash_table.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let pair = &entry.pair;\n            let index = (hash_table.hash_func(&pair.key) as usize) % hash_table.table_size;\n\n            entry.next = hash_table.table[index].take();\n            hash_table.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn hash_table_insert<K, V>(hash_table: &mut HashTable<K, V>, key: K, value: V) -> bool {\n    if (hash_table.entries * 3) / hash_table.table_size > 0 {\n        if !hash_table_enlarge(hash_table) {\n            return false;\n        }\n    }\n\n    let index = (hash_table.hash_func(&key) as usize) % hash_table.table_size;\n\n    let mut rover = &mut hash_table.table[index];\n\n    while let Some(entry) = rover {\n        if (hash_table.equal_func)(&entry.pair.key, &key) {\n            if let Some(value_free_func) = hash_table.value_free_func {\n                let value = std::mem::replace(&mut entry.pair.value, value);\n                value_free_func(value);\n            }\n            if let Some(key_free_func) = hash_table.key_free_func {\n                let key = std::mem::replace(&mut entry.pair.key, key);\n                key_free_func(key);\n            }\n            return true;\n        }\n        rover = &mut entry.next;\n    }\n\n    let new_entry = Box::new(HashTableEntry {\n        pair: HashTablePair { key, value },\n        next: hash_table.table[index].take(),\n    });\n\n    hash_table.table[index] = Some(new_entry);\n    hash_table.entries += 1;\n\n    true\n}\n\npub fn hash_table_allocate_table<K, V>(hash_table: &mut HashTable<K, V>) -> bool {\n    let new_table_size = if hash_table.prime_index < HASH_TABLE_NUM_PRIMES {\n        HASH_TABLE_PRIMES[hash_table.prime_index]\n    } else {\n        hash_table.entries * 10\n    };\n\n    hash_table.table_size = new_table_size;\n\n    hash_table.table = Vec::with_capacity(hash_table.table_size);\n    for _ in 0..hash_table.table_size {\n        hash_table.table.push(None);\n    }\n\n    true\n}\n\npub fn test_hash_table_free_functions() {\n    let mut hash_table = hash_table_new(int_hash, int_equal).unwrap();\n    hash_table_register_free_functions(&mut hash_table, Some(free_key), Some(free_value));\n\n    unsafe {\n        allocated_values = 0;\n        allocated_keys = 0;\n    }\n\n    for i in 0..NUM_TEST_VALUES {\n        let key = *new_key(i as i32);\n        let value = *new_value(99);\n\n        hash_table_insert(&mut hash_table, key, value);\n    }\n\n    unsafe {\n        assert_eq!(allocated_keys, NUM_TEST_VALUES as i32);\n        assert_eq!(allocated_values, NUM_TEST_VALUES as i32);\n    }\n\n    let i = NUM_TEST_VALUES / 2;\n    hash_table_remove(&mut hash_table, &(i as i32));\n\n    unsafe {\n        assert_eq!(allocated_keys, (NUM_TEST_VALUES - 1) as i32);\n        assert_eq!(allocated_values, (NUM_TEST_VALUES - 1) as i32);\n    }\n\n    let key = *new_key((NUM_TEST_VALUES / 3) as i32);\n    let value = *new_value(999);\n\n    unsafe {\n        assert_eq!(allocated_keys, NUM_TEST_VALUES as i32);\n        assert_eq!(allocated_values, NUM_TEST_VALUES as i32);\n    }\n\n    hash_table_insert(&mut hash_table, key, value);\n\n    unsafe {\n        assert_eq!(allocated_keys, (NUM_TEST_VALUES - 1) as i32);\n        assert_eq!(allocated_values, (NUM_TEST_VALUES - 1) as i32);\n    }\n\n    hash_table_free(hash_table);\n\n    unsafe {\n        assert_eq!(allocated_keys, 0);\n        assert_eq!(allocated_values, 0);\n    }\n}\n\npub fn hash_table_remove<K, V>(hash_table: &mut HashTable<K, V>, key: &K) -> bool {\n    let index = (hash_table.hash_func(key) as usize) % hash_table.table_size;\n\n    let mut rover = &mut hash_table.table[index];\n    let mut result = false;\n\n    while let Some(entry) = rover {\n        if (hash_table.equal_func)(key, &entry.pair.key) {\n            let mut entry_to_remove = rover.take().unwrap();\n            *rover = entry_to_remove.next.take();\n\n            hash_table_free_entry(hash_table, entry_to_remove);\n            hash_table.entries -= 1;\n\n            result = true;\n            break;\n        }\n\n        rover = &mut rover.as_mut().unwrap().next;\n    }\n\n    result\n}\n\npub fn free_key<K>(key: K) {\n    unsafe {\n        allocated_keys -= 1;\n    }\n}\n\npub fn free_value<V>(value: V) {\n    unsafe {\n        allocated_values -= 1;\n    }\n}\n\npub fn int_hash(key: &i32) -> u32 {\n    *key as u32\n}\n\npub fn int_equal(key1: &i32, key2: &i32) -> bool {\n    key1 == key2\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\n\nfn main() {}\n\n //编译报错信息：error[E0599]: no method named `hash_func` found for mutable reference `&mut HashTable<K, V>` in the current scope\n   --> ../../Test_max12/tmp/test-hash-table_test_hash_table_free_functions/temp.rs:146:37\n    |\n146 | ...   let index = (hash_table.hash_func(&pair.key) as usize) % hash_table.tab...\n    |                               ^^^^^^^^^ field, not a method\n    |\n"
    },
    "test-set": {
        "test_set_iterating_remove": "\npub struct Set<T> {\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub entries: usize,\n    pub table_size: usize,\n    pub prime_index: usize,\n    pub hash_func: fn(&T) -> u32,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetEntry<T> {\n    pub value: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\npub const SET_NUM_PRIMES: usize = 24;\npub const SET_PRIMES: [usize; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct SetIterator<'a, T> {\n    pub set: &'a Set<T>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\npub struct SetValue<T> {\n    pub value: T,\n}\n\npub static mut ALLOCATED_VALUES: usize = 0;\n\npub fn set_enlarge<T>(set: &mut Set<T>) -> bool {\n    let mut old_table = std::mem::take(&mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let hash_func = set.hash_func;\n            let index = (hash_func(&entry.value) as usize) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn set_new<T>(hash_func: fn(&T) -> u32, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        table: Vec::new(),\n        entries: 0,\n        table_size: 0,\n        prime_index: 0,\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\npub fn set_iter_next<T: Clone>(iterator: &mut SetIterator<T>) -> Option<T> {\n    let set = &iterator.set;\n\n    if iterator.next_entry.is_none() {\n        return None;\n    }\n\n    let current_entry = iterator.next_entry.as_ref().unwrap();\n    let result = current_entry.value.clone();\n\n    if let Some(next) = &current_entry.next {\n        iterator.next_entry = Some(Box::new(SetEntry {\n            value: next.value.clone(),\n            next: next.next.clone(),\n        }));\n    } else {\n        iterator.next_entry = None;\n\n        let mut chain = iterator.next_chain + 1;\n\n        while chain < set.table_size {\n            if let Some(entry) = &set.table[chain] {\n                iterator.next_entry = Some(Box::new(SetEntry {\n                    value: entry.value.clone(),\n                    next: entry.next.clone(),\n                }));\n                break;\n            }\n\n            chain += 1;\n        }\n\n        iterator.next_chain = chain;\n    }\n\n    Some(result)\n}\n\npub fn set_iter_has_more<T>(iterator: &SetIterator<T>) -> bool {\n    iterator.next_entry.is_some()\n}\n\npub fn set_insert<T>(set: &mut Set<T>, data: T) -> bool {\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let hash_func = set.hash_func;\n    let index = (hash_func(&data) as usize) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    let newentry = Box::new(SetEntry {\n        value: data,\n        next: set.table[index].take(),\n    });\n\n    set.table[index] = Some(newentry);\n\n    set.entries += 1;\n\n    true\n}\n\npub fn generate_set() -> Option<Set<String>> {\n    let mut set = set_new(string_hash, string_equal)?;\n\n    for i in 0..10000 {\n        let value = i.to_string();\n        set_insert(&mut set, value.clone());\n\n        assert_eq!(set_num_entries(&set), i + 1);\n    }\n\n    set_register_free_function(&mut set, Some(|value| {\n        // No need to explicitly free the value as Rust's ownership system handles it\n    }));\n\n    Some(set)\n}\n\npub fn set_allocate_table<T>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = Vec::with_capacity(set.table_size);\n    for _ in 0..set.table_size {\n        set.table.push(None);\n    }\n\n    true\n}\n\npub fn set_iterate<T: Clone>(iterator: &mut SetIterator<T>) {\n    iterator.next_entry = None;\n\n    for chain in 0..iterator.set.table_size {\n        if let Some(entry) = &iterator.set.table[chain] {\n            iterator.next_entry = Some(Box::new(SetEntry {\n                value: entry.value.clone(),\n                next: entry.next.clone(),\n            }));\n            break;\n        }\n    }\n\n    iterator.next_chain = 0;\n}\n\npub fn set_num_entries<T>(set: &Set<T>) -> usize {\n    set.entries\n}\n\npub fn set_free_entry<T>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.value);\n    }\n}\n\npub fn set_free<T>(mut set: Box<Set<T>>) {\n    for i in 0..set.table_size {\n        let mut rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            set_free_entry(&mut set, entry);\n            rover = next;\n        }\n    }\n}\n\npub fn set_register_free_function<T>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\npub fn test_set_iterating_remove() {\n    let mut set = generate_set().expect(\"Failed to generate set\");\n    let mut iterator = SetIterator {\n        set: &set,\n        next_entry: None,\n        next_chain: 0,\n    };\n    let mut count = 0;\n    let mut removed = 0;\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator).expect(\"Failed to get next value\");\n\n        if value.parse::<u32>().unwrap() % 100 == 0 {\n            set_remove(&mut set, value.clone());\n            removed += 1;\n        }\n\n        count += 1;\n    }\n\n    assert_eq!(count, 10000);\n    assert_eq!(removed, 100);\n    assert_eq!(set_num_entries(&set), 10000 - removed);\n\n    set_free(Box::new(set));\n}\n\npub fn set_remove<T: Clone + PartialEq>(set: &mut Set<T>, data: T) -> bool {\n    let hash_func = set.hash_func;\n    let index = (hash_func(&data) as usize) % set.table_size;\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            let mut entry_to_remove = rover.take().unwrap();\n            *rover = entry_to_remove.next.take();\n            set.entries -= 1;\n            set_free_entry(set, entry_to_remove);\n            return true;\n        }\n        rover = &mut entry.next;\n    }\n\n    false\n}\n\npub fn string_hash(s: &String) -> u32 {\n    s.len() as u32\n}\n\npub fn string_equal(s1: &String, s2: &String) -> bool {\n    s1 == s2\n}\n\nfn main() {}\n\n //编译报错信息：error[E0502]: cannot borrow `set` as mutable because it is also borrowed as immutable\n   --> ../../Test_max12/tmp/test-set_test_set_iterating_remove/temp.rs:251:24\n    |\n238 |         set: &set,\n    |              ---- immutable borrow occurs here\n...\n247 |     while set_iter_has_more(&iterator) {\n    |                             --------- immutable borrow later used here\n...\n251 |             set_remove(&mut set, value.clone());\n    |                        ^^^^^^^^ mutable borrow occurs here\n\nerror[E0499]: cannot borrow `*rover` as mutable more than once at a time\n   --> ../../Test_max12/tmp/test-set_test_set_iterating_remove/temp.rs:272:39\n    |\n270 |     while let Some(entry) = rover {\n    |                    ----- first mutable borrow occurs here\n271 |         if (set.equal_func)(&data, &entry.value) {\n272 |             let mut entry_to_remove = rover.take().unwrap();\n    |                                       ^^^^^\n    |                                       |\n    |                                       second mutable borrow occurs here\n    |                                       first borrow later used here\n\nerror[E0506]: cannot assign to `*rover` because it is borrowed\n   --> ../../Test_max12/tmp/test-set_test_set_iterating_remove/temp.rs:273:13\n    |\n270 |     while let Some(entry) = rover {\n    |                    ----- `*rover` is borrowed here\n...\n273 |             *rover = entry_to_remove.next.take();\n    |             ^^^^^^\n    |             |\n    |             `*rover` is assigned to here but it was already borrowed\n    |             borrow later used here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0499, E0502, E0506.\nFor more information about an error, try `rustc --explain E0499`.\n",
        "test_set_insert": "\npub struct Set<T> {\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub entries: usize,\n    pub table_size: usize,\n    pub prime_index: usize,\n    pub hash_func: fn(&T) -> u32,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(Box<SetValue<T>>)>,\n}\n\n#[derive(Clone)]\npub struct SetEntry<T> {\n    pub value: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\npub const SET_NUM_PRIMES: usize = 24;\npub const SET_PRIMES: [usize; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub struct SetIterator<'a, T> {\n    pub set: &'a Set<T>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\npub struct SetValue<T> {\n    pub value: T,\n}\n\npub static mut ALLOCATED_VALUES: usize = 0;\n\npub fn set_enlarge<T>(set: &mut Set<T>) -> bool {\n    let mut old_table = std::mem::take(&mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n\n            let hash_func = set.hash_func;\n            let index = (hash_func(&entry.value) as usize) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn set_free_entry<T>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(Box::new(SetValue { value: entry.value }));\n    }\n}\n\npub fn set_new<T>(hash_func: fn(&T) -> u32, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        table: Vec::new(),\n        entries: 0,\n        table_size: 0,\n        prime_index: 0,\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\npub fn set_insert<T>(set: &mut Set<T>, data: T) -> bool {\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let hash_func = set.hash_func;\n    let index = (hash_func(&data) as usize) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    let newentry = Box::new(SetEntry {\n        value: data,\n        next: set.table[index].take(),\n    });\n\n    set.table[index] = Some(newentry);\n\n    set.entries += 1;\n\n    true\n}\n\npub fn set_allocate_table<T>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = Vec::with_capacity(set.table_size);\n    for _ in 0..set.table_size {\n        set.table.push(None);\n    }\n\n    true\n}\n\npub fn set_num_entries<T>(set: &Set<T>) -> usize {\n    set.entries\n}\n\npub fn set_free<T>(mut set: Box<Set<T>>) {\n    for i in 0..set.table_size {\n        let mut rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            set_free_entry(&mut set, entry);\n            rover = next;\n        }\n    }\n}\n\npub fn test_set_insert() {\n    let numbers1 = vec![1, 2, 3, 4, 5, 6];\n    let numbers2 = vec![5, 6, 7, 8, 9, 10];\n\n    let mut set = set_new(int_hash, int_equal).unwrap();\n\n    for i in 0..6 {\n        set_insert(&mut set, numbers1[i]);\n    }\n    for i in 0..6 {\n        set_insert(&mut set, numbers2[i]);\n    }\n\n    assert_eq!(set_num_entries(&set), 10);\n\n    set_free(Box::new(set));\n}\n\npub fn int_hash(value: &i32) -> u32 {\n    *value as u32\n}\n\npub fn int_equal(value1: &i32, value2: &i32) -> bool {\n    value1 == value2\n}\n\nfn main() {}\n\npub fn set_query<T>(set: &Set<T>, data: T) -> bool \nwhere\n    T: Clone + PartialEq,\n{\n    let index = (set.hash_func)(&data) % set.table_size as u32;\n\n    let mut rover = &set.table[index as usize];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            return true;\n        }\n        rover = &entry.next;\n    }\n\n    false\n}\n\npub fn test_set_new_free() {\n    let mut set = set_new(int_hash, int_equal).unwrap();\n\n    set_register_free_function(&mut set, Some(free_value));\n\n    for i in 0..10000 {\n        let value = Box::new(i);\n        set_insert(&mut set, *value);\n    }\n\n    set_free(Box::new(set));\n}\n\npub fn set_register_free_function<T>(set: &mut Set<T>, free_func: Option<fn(Box<SetValue<T>>)>) {\n    set.free_func = free_func;\n}\n\npub fn test_set_out_of_memory() {\n    let mut set = set_new(int_hash, int_equal).unwrap();\n    let mut values = [0; 66];\n\n    // Test normal failure\n    values[0] = 0;\n    assert!(!set_insert(&mut set, Box::new(values[0])));\n    assert_eq!(set_num_entries(&set), 0);\n\n    // Test failure when increasing table size.\n    // The initial table size is 193 entries. The table increases in\n    // size when 1/3 full, so the 66th entry should cause the insert\n    // to fail.\n    for i in 0..65 {\n        values[i] = i as i32;\n        assert!(set_insert(&mut set, Box::new(values[i])));\n        assert_eq!(set_num_entries(&set), i + 1);\n    }\n\n    assert_eq!(set_num_entries(&set), 65);\n\n    // Test the 66th insert\n    values[65] = 65;\n    assert!(!set_insert(&mut set, Box::new(values[65])));\n    assert_eq!(set_num_entries(&set), 65);\n\n    set_free(Box::new(set));\n}\n\npub fn test_set_union() {\n    let numbers1 = vec![1, 2, 3, 4, 5, 6, 7];\n    let numbers2 = vec![5, 6, 7, 8, 9, 10, 11];\n    let result = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\n    let mut set1 = set_new(int_hash, int_equal).unwrap();\n    for num in &numbers1 {\n        set_insert(&mut set1, *num);\n    }\n\n    let mut set2 = set_new(int_hash, int_equal).unwrap();\n    for num in &numbers2 {\n        set_insert(&mut set2, *num);\n    }\n\n    let result_set = set_union(&set1, &set2).unwrap();\n\n    assert_eq!(set_num_entries(&result_set), 11);\n\n    for num in &result {\n        assert!(set_query(&result_set, *num));\n    }\n\n    set_free(Box::new(result_set));\n\n    set_free(Box::new(set1));\n    set_free(Box::new(set2));\n}\n\npub fn set_union<T: Clone + PartialEq>(set1: &Set<T>, set2: &Set<T>) -> Option<Set<T>> {\n    let mut new_set = set_new(set1.hash_func, set1.equal_func)?;\n\n    let mut iterator = SetIterator {\n        set: set1,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator).unwrap();\n\n        if !set_insert(&mut new_set, value) {\n            set_free(Box::new(new_set));\n            return None;\n        }\n    }\n\n    let mut iterator = SetIterator {\n        set: set2,\n        next_entry: None,\n        next_chain: 0,\n    };\n\n    set_iterate(&mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        let value = set_iter_next(&mut iterator).unwrap();\n\n        if !set_query(&new_set, value.clone()) {\n            if !set_insert(&mut new_set, value) {\n                set_free(Box::new(new_set));\n                return None;\n            }\n        }\n    }\n\n    Some(new_set)\n}\n\npub fn set_iter_next<T: Clone>(iterator: &mut SetIterator<T>) -> Option<T> {\n    let set = &iterator.set;\n\n    if iterator.next_entry.is_none() {\n        return None;\n    }\n\n    let current_entry = iterator.next_entry.as_ref().unwrap();\n    let result = current_entry.value.clone();\n\n    if let Some(next) = &current_entry.next {\n        iterator.next_entry = Some(Box::new(SetEntry {\n            value: next.value.clone(),\n            next: next.next.clone(),\n        }));\n    } else {\n        iterator.next_entry = None;\n\n        let mut chain = iterator.next_chain + 1;\n\n        while chain < set.table_size {\n            if let Some(entry) = &set.table[chain] {\n                iterator.next_entry = Some(Box::new(SetEntry {\n                    value: entry.value.clone(),\n                    next: entry.next.clone(),\n                }));\n                break;\n            }\n\n            chain += 1;\n        }\n\n        iterator.next_chain = chain;\n    }\n\n    Some(result)\n}\n\npub fn set_iterate<T: Clone>(iterator: &mut SetIterator<T>) {\n    iterator.next_entry = None;\n\n    for chain in 0..iterator.set.table_size {\n        if let Some(entry) = &iterator.set.table[chain] {\n            iterator.next_entry = Some(Box::new(SetEntry {\n                value: entry.value.clone(),\n                next: entry.next.clone(),\n            }));\n            break;\n        }\n    }\n\n    iterator.next_chain = 0;\n}\n\npub fn set_iter_has_more<T>(iterator: &SetIterator<T>) -> bool {\n    iterator.next_entry.is_some()\n}\n\npub fn set_remove<T>(set: &mut Set<T>, data: T) -> bool \nwhere\n    T: Clone + PartialEq,\n{\n    let index = (set.hash_func)(&data) % set.table_size as u32;\n\n    let mut rover = &mut set.table[index as usize];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.value) {\n            let mut entry = rover.take().unwrap();\n            *rover = entry.next.take();\n            set.entries -= 1;\n            set_free_entry(set, entry);\n            return true;\n        }\n        rover = &mut rover.as_mut().unwrap().next;\n    }\n\n    false\n}\n\npub fn test_set_free_function() {\n    let mut set = set_new(int_hash, int_equal).unwrap();\n    set_register_free_function(&mut set, Some(free_value));\n\n    unsafe {\n        ALLOCATED_VALUES = 0;\n    }\n\n    for i in 0..1000 {\n        let value = new_value(Box::new(i));\n        set_insert(&mut set, value.value);\n    }\n\n    unsafe {\n        assert_eq!(ALLOCATED_VALUES, 1000);\n    }\n\n    let i = Box::new(500);\n    set_remove(&mut set, *i);\n\n    unsafe {\n        assert_eq!(ALLOCATED_VALUES, 999);\n    }\n\n    set_free(Box::new(set));\n\n    unsafe {\n        assert_eq!(ALLOCATED_VALUES, 0);\n    }\n}\n\npub fn new_value<T: Clone>(value: T) -> Box<SetValue<T>> {\n    let result = Box::new(SetValue { value: value.clone() });\n    unsafe {\n        ALLOCATED_VALUES += 1;\n    }\n    result\n}\n\npub fn free_value<T>(value: Box<SetValue<T>>) {\n    unsafe {\n        ALLOCATED_VALUES -= 1;\n    }\n}\n\n //编译报错信息：error[E0308]: mismatched types\n   --> ../../Test_max12/tmp/test-set_test_set_insert/temp.rs:225:35\n    |\n225 |     assert!(!set_insert(&mut set, Box::new(values[0])));\n    |              ----------           ^^^^^^^^^^^^^^^^^^^ expected `i32`, found `Box<{integer}>`\n    |              |\n    |              arguments to this function are incorrect\n    |\n    = note: expected type `i32`\n             found struct `Box<{integer}>`\nnote: function defined here\n   --> ../../Test_max12/tmp/test-set_test_set_insert/temp.rs:94:8\n    |\n94  | pub fn set_insert<T>(set: &mut Set<T>, data: T) -> bool {\n    |        ^^^^^^^^^^                      -------\n"
    },
    "test-sortedarray": {
        "test_sortedarray_insert": "\npub const TEST_SIZE: usize = 20;\n\npub struct SortedArray<T> {\n    pub data: Vec<T>,\n    pub length: usize,\n    pub _alloced: usize,\n    pub equ_func: fn(&T, &T) -> bool,\n    pub cmp_func: fn(&T, &T) -> std::cmp::Ordering,\n}\n\npub fn sortedarray_length<T>(array: &SortedArray<T>) -> usize {\n    array.length\n}\n\npub fn int_compare<T: PartialOrd>(location1: &T, location2: &T) -> i32 {\n    if location1 < location2 {\n        -1\n    } else if location1 > location2 {\n        1\n    } else {\n        0\n    }\n}\n\npub fn sortedarray_insert<T>(sortedarray: &mut SortedArray<T>, data: T) -> bool {\n    let mut left = 0;\n    let mut right = sortedarray.length;\n    let mut index = 0;\n\n    right = if right > 1 { right } else { 0 };\n\n    while left != right {\n        index = (left + right) / 2;\n\n        let order = (sortedarray.cmp_func)(&data, &sortedarray.data[index]);\n        match order {\n            std::cmp::Ordering::Less => right = index,\n            std::cmp::Ordering::Greater => left = index + 1,\n            std::cmp::Ordering::Equal => break,\n        }\n    }\n\n    if sortedarray.length > 0 && (sortedarray.cmp_func)(&data, &sortedarray.data[index]) == std::cmp::Ordering::Greater {\n        index += 1;\n    }\n\n    if sortedarray.length + 1 > sortedarray._alloced {\n        let newsize = sortedarray._alloced * 2;\n        sortedarray.data.reserve(newsize);\n        sortedarray._alloced = newsize;\n    }\n\n    sortedarray.data.insert(index, data);\n    sortedarray.length += 1;\n\n    true\n}\n\npub fn sortedarray_new<T>(length: usize, equ_func: fn(&T, &T) -> bool, cmp_func: fn(&T, &T) -> std::cmp::Ordering) -> Option<SortedArray<T>> {\n    let mut length = length;\n    if length == 0 {\n        length = 16;\n    }\n\n    let mut data = Vec::<T>::with_capacity(length);\n\n    let sortedarray = SortedArray {\n        data: data,\n        length: 0,\n        _alloced: length,\n        equ_func: equ_func,\n        cmp_func: cmp_func,\n    };\n\n    Some(sortedarray)\n}\n\npub fn generate_sortedarray_equ<T>(equ_func: fn(&T, &T) -> bool) -> Option<SortedArray<T>> \nwhere\n    T: Clone + Ord + From<i32>,\n{\n    const TEST_SIZE: usize = 20;\n    const TEST_ARRAY: [i32; TEST_SIZE] = [10, 12, 12, 1, 2, 3, 6, 7, 2, 23, 13, 23, 23, 34, 31, 9, 0, 0, 0, 0];\n\n    let mut sortedarray = sortedarray_new(0, equ_func, |a: &T, b: &T| a.cmp(b))?;\n\n    for i in 0..TEST_SIZE {\n        let value = T::from(TEST_ARRAY[i]);\n        sortedarray_insert(&mut sortedarray, value);\n    }\n\n    Some(sortedarray)\n}\n\npub fn check_sorted_prop<T: PartialOrd>(sortedarray: &SortedArray<T>) {\n    for i in 1..sortedarray_length(sortedarray) {\n        let prev = sortedarray_get(sortedarray, i - 1).unwrap();\n        let curr = sortedarray_get(sortedarray, i).unwrap();\n        assert!(int_compare(prev, curr) <= 0);\n    }\n}\n\npub fn generate_sortedarray<T>() -> Option<SortedArray<T>>\nwhere\n    T: Clone + Ord + From<i32>,\n{\n    generate_sortedarray_equ(|a: &T, b: &T| a == b)\n}\n\npub fn free_sorted_ints<T>(sortedarray: Option<Box<SortedArray<T>>>) {\n    if let Some(mut sortedarray) = sortedarray {\n        for i in 0..sortedarray_length(&sortedarray) {\n            if let Some(pi) = sortedarray_get(&sortedarray, i) {\n                // In Rust, we don't need to manually free memory as it is managed by the ownership system.\n                // The Vec<T> inside SortedArray will automatically deallocate its memory when it goes out of scope.\n            }\n        }\n        sortedarray_free(Some(sortedarray));\n    }\n}\n\npub fn sortedarray_get<T>(array: &SortedArray<T>, i: usize) -> Option<&T> {\n    if i >= array.length {\n        return None;\n    }\n    Some(&array.data[i])\n}\n\npub fn sortedarray_free<T>(sortedarray: Option<Box<SortedArray<T>>>) {\n    if let Some(mut sortedarray) = sortedarray {\n        sortedarray.data.clear();\n    }\n}\n\npub fn test_sortedarray_insert() {\n    let mut sortedarray = generate_sortedarray::<i32>().unwrap();\n\n    for _ in 0..20 {\n        let i = (rand::random::<f32>() * 100.0) as i32;\n        sortedarray_insert(&mut sortedarray, i);\n    }\n\n    check_sorted_prop(&sortedarray);\n    free_sorted_ints(Some(Box::new(sortedarray)));\n}\n\nfn main() {}\n\n //编译报错信息：error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n   --> ../../Test_max12/tmp/test-sortedarray_test_sortedarray_insert/temp.rs:140:18\n    |\n140 |         let i = (rand::random::<f32>() * 100.0) as i32;\n    |                  ^^^^ use of undeclared crate or module `rand`\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
        "test_sortedarray_new_free": "\n\n\npub const TEST_SIZE: usize = 20;\n\npub struct SortedArray<T> {\n    pub data: Vec<T>,\n    pub length: usize,\n    pub _alloced: usize,\n    pub equ_func: fn(&T, &T) -> bool,\n    pub cmp_func: fn(&T, &T) -> std::cmp::Ordering,\n}\n\npub fn sortedarray_new<T>(length: usize, equ_func: fn(&T, &T) -> bool, cmp_func: fn(&T, &T) -> std::cmp::Ordering) -> Option<SortedArray<T>> {\n    let mut length = length;\n    if length == 0 {\n        length = 16;\n    }\n\n    let mut data = Vec::<T>::with_capacity(length);\n\n    let sortedarray = SortedArray {\n        data: data,\n        length: 0,\n        _alloced: length,\n        equ_func: equ_func,\n        cmp_func: cmp_func,\n    };\n\n    Some(sortedarray)\n}\n\npub fn sortedarray_free<T>(sortedarray: Option<Box<SortedArray<T>>>) {\n    if let Some(mut sortedarray) = sortedarray {\n        sortedarray.data.clear();\n    }\n}\n\nfn int_equal<T: PartialEq>(a: &T, b: &T) -> bool {\n    a == b\n}\n\nfn int_compare<T: Ord>(a: &T, b: &T) -> std::cmp::Ordering {\n    a.cmp(b)\n}\n\npub fn test_sortedarray_new_free() {\n    // Test normal case\n    let mut sortedarray: Option<SortedArray<i32>> = sortedarray_new(0, int_equal, int_compare);\n    assert!(sortedarray.is_some());\n    sortedarray_free(sortedarray.map(Box::new));\n\n    // Test freeing null\n    sortedarray_free::<i32>(None);\n\n    // Test low memory scenario (removed as per requirements)\n}\n\nfn main() {}\n\npub fn check_sorted_prop<T: PartialOrd>(sortedarray: &SortedArray<T>) {\n    for i in 1..sortedarray_length(sortedarray) {\n        let prev = sortedarray_get(sortedarray, i - 1).unwrap();\n        let curr = sortedarray_get(sortedarray, i).unwrap();\n        assert!(int_compare(prev, curr) <= 0);\n    }\n}\n\npub fn sortedarray_get<T>(array: &SortedArray<T>, i: usize) -> Option<&T> {\n    if i >= array.length {\n        return None;\n    }\n    Some(&array.data[i])\n}\n\npub fn sortedarray_length<T>(array: &SortedArray<T>) -> usize {\n    array.length\n}\n\nfn int_compare<T: Ord>(a: &T, b: &T) -> std::cmp::Ordering {\n    a.cmp(b)\n}\n\n\n //编译报错信息："
    }
}