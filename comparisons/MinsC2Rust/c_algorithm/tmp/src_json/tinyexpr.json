{
    "te_compile": "te_expr *te_compile(const char *expression, const te_variable *variables, int var_count, int *error) {\n    state s;\n    s.start = s.next = expression;\n    s.lookup = variables;\n    s.lookup_len = var_count;\n\n    next_token(&s);\n    te_expr *root = list(&s);\n    if (root == NULL) {\n        if (error) *error = -1;\n        return NULL;\n    }\n\n    if (s.type != TOK_END) {\n        te_free(root);\n        if (error) {\n            *error = (s.next - s.start);\n            if (*error == 0) *error = 1;\n        }\n        return 0;\n    } else {\n        optimize(root);\n        if (error) *error = 0;\n        return root;\n    }\n",
    "negate": "static double negate(double a) {return -a;}\n",
    "add": "static double add(double a, double b) {return a + b;}\n",
    "te_free": "void te_free(te_expr *n) {\n    if (!n) return;\n    te_free_parameters(n);\n    free(n);\n}\n",
    "sub": "static double sub(double a, double b) {return a - b;}\n",
    "factor": "static te_expr *factor(state *s) {\n    /* <factor>    =    <power> {\"^\" <power>} */\n    te_expr *ret = power(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_INFIX && (s->function == pow)) {\n        te_fun2 t = s->function;\n        next_token(s);\n        te_expr *p = power(s);\n        CHECK_NULL(p, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, p);\n        CHECK_NULL(ret, te_free(p), te_free(prev));\n\n        ret->function = t;\n    }\n\n    return ret;\n}\n",
    "find_builtin": "static const te_variable *find_builtin(const char *name, int len) {\n    int imin = 0;\n    int imax = sizeof(functions) / sizeof(te_variable) - 2;\n\n    /*Binary search.*/\n    while (imax >= imin) {\n        const int i = (imin + ((imax-imin)/2));\n        int c = strncmp(name, functions[i].name, len);\n        if (!c) c = '\\0' - functions[i].name[len];\n        if (c == 0) {\n            return functions + i;\n        } else if (c > 0) {\n            imin = i + 1;\n        } else {\n            imax = i - 1;\n        }\n    }\n\n    return 0;\n}\n",
    "mul": "static double mul(double a, double b) {return a * b;}\n",
    "new_expr": "static te_expr *new_expr(const int type, const te_expr *parameters[]) {\n    const int arity = ARITY(type);\n    const int psize = sizeof(void*) * arity;\n    const int size = (sizeof(te_expr) - sizeof(void*)) + psize + (IS_CLOSURE(type) ? sizeof(void*) : 0);\n    te_expr *ret = malloc(size);\n    CHECK_NULL(ret);\n\n    memset(ret, 0, size);\n    if (arity && parameters) {\n        memcpy(ret->parameters, parameters, psize);\n    }\n    ret->type = type;\n    ret->bound = 0;\n    return ret;\n}\n",
    "te_interp": "double te_interp(const char *expression, int *error) {\n    te_expr *n = te_compile(expression, 0, 0, error);\n\n    double ret;\n    if (n) {\n        ret = te_eval(n);\n        te_free(n);\n    } else {\n        ret = NAN;\n    }\n    return ret;\n}\n",
    "comma": "static double comma(double a, double b) {(void)a; return b;}\n",
    "find_lookup": "static const te_variable *find_lookup(const state *s, const char *name, int len) {\n    int iters;\n    const te_variable *var;\n    if (!s->lookup) return 0;\n\n    for (var = s->lookup, iters = s->lookup_len; iters; ++var, --iters) {\n        if (strncmp(name, var->name, len) == 0 && var->name[len] == '\\0') {\n            return var;\n        }\n    }\n    return 0;\n}\n",
    "te_print": "void te_print(const te_expr *n) {\n    pn(n, 0);\n}\n",
    "base": "static te_expr *base(state *s) {\n    /* <base>      =    <constant> | <variable> | <function-0> {\"(\" \")\"} | <function-1> <power> | <function-X> \"(\" <expr> {\",\" <expr>} \")\" | \"(\" <list> \")\" */\n    te_expr *ret;\n    int arity;\n\n    switch (TYPE_MASK(s->type)) {\n        case TOK_NUMBER:\n            ret = new_expr(TE_CONSTANT, 0);\n            CHECK_NULL(ret);\n\n            ret->value = s->value;\n            next_token(s);\n            break;\n\n        case TOK_VARIABLE:\n            ret = new_expr(TE_VARIABLE, 0);\n            CHECK_NULL(ret);\n\n            ret->bound = s->bound;\n            next_token(s);\n            break;\n\n        case TE_FUNCTION0:\n        case TE_CLOSURE0:\n            ret = new_expr(s->type, 0);\n            CHECK_NULL(ret);\n\n            ret->function = s->function;\n            if (IS_CLOSURE(s->type)) ret->parameters[0] = s->context;\n            next_token(s);\n            if (s->type == TOK_OPEN) {\n                next_token(s);\n                if (s->type != TOK_CLOSE) {\n                    s->type = TOK_ERROR;\n                } else {\n                    next_token(s);\n                }\n            }\n            break;\n\n        case TE_FUNCTION1:\n        case TE_CLOSURE1:\n            ret = new_expr(s->type, 0);\n            CHECK_NULL(ret);\n\n            ret->function = s->function;\n            if (IS_CLOSURE(s->type)) ret->parameters[1] = s->context;\n            next_token(s);\n            ret->parameters[0] = power(s);\n            CHECK_NULL(ret->parameters[0], te_free(ret));\n            break;\n\n        case TE_FUNCTION2: case TE_FUNCTION3: case TE_FUNCTION4:\n        case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:\n        case TE_CLOSURE2: case TE_CLOSURE3: case TE_CLOSURE4:\n        case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:\n            arity = ARITY(s->type);\n\n            ret = new_expr(s->type, 0);\n            CHECK_NULL(ret);\n\n            ret->function = s->function;\n            if (IS_CLOSURE(s->type)) ret->parameters[arity] = s->context;\n            next_token(s);\n\n            if (s->type != TOK_OPEN) {\n                s->type = TOK_ERROR;\n            } else {\n                int i;\n                for(i = 0; i < arity; i++) {\n                    next_token(s);\n                    ret->parameters[i] = expr(s);\n                    CHECK_NULL(ret->parameters[i], te_free(ret));\n\n                    if(s->type != TOK_SEP) {\n                        break;\n                    }\n                }\n                if(s->type != TOK_CLOSE || i != arity - 1) {\n                    s->type = TOK_ERROR;\n                } else {\n                    next_token(s);\n                }\n            }\n\n            break;\n\n        case TOK_OPEN:\n            next_token(s);\n            ret = list(s);\n            CHECK_NULL(ret);\n\n            if (s->type != TOK_CLOSE) {\n                s->type = TOK_ERROR;\n            } else {\n                next_token(s);\n            }\n            break;\n\n        default:\n            ret = new_expr(0, 0);\n            CHECK_NULL(ret);\n\n            s->type = TOK_ERROR;\n            ret->value = NAN;\n            break;\n    }\n\n    return ret;\n}\n",
    "term": "static te_expr *term(state *s) {\n    /* <term>      =    <factor> {(\"*\" | \"/\" | \"%\") <factor>} */\n    te_expr *ret = factor(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_INFIX && (s->function == mul || s->function == divide || s->function == fmod)) {\n        te_fun2 t = s->function;\n        next_token(s);\n        te_expr *f = factor(s);\n        CHECK_NULL(f, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, f);\n        CHECK_NULL(ret, te_free(f), te_free(prev));\n\n        ret->function = t;\n    }\n\n    return ret;\n}\n",
    "pi": "static double pi(void) {return 3.14159265358979323846;}\n",
    "expr": "static te_expr *expr(state *s) {\n    /* <expr>      =    <term> {(\"+\" | \"-\") <term>} */\n    te_expr *ret = term(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_INFIX && (s->function == add || s->function == sub)) {\n        te_fun2 t = s->function;\n        next_token(s);\n        te_expr *te = term(s);\n        CHECK_NULL(te, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, te);\n        CHECK_NULL(ret, te_free(te), te_free(prev));\n\n        ret->function = t;\n    }\n\n    return ret;\n}\n",
    "ncr": "static double ncr(double n, double r) {\n    if (n < 0.0 || r < 0.0 || n < r) return NAN;\n    if (n > UINT_MAX || r > UINT_MAX) return INFINITY;\n    unsigned long int un = (unsigned int)(n), ur = (unsigned int)(r), i;\n    unsigned long int result = 1;\n    if (ur > un / 2) ur = un - ur;\n    for (i = 1; i <= ur; i++) {\n        if (result > ULONG_MAX / (un - ur + i))\n            return INFINITY;\n        result *= un - ur + i;\n        result /= i;\n    }\n    return result;\n}\n",
    "power": "static te_expr *power(state *s) {\n    /* <power>     =    {(\"-\" | \"+\")} <base> */\n    int sign = 1;\n    while (s->type == TOK_INFIX && (s->function == add || s->function == sub)) {\n        if (s->function == sub) sign = -sign;\n        next_token(s);\n    }\n\n    te_expr *ret;\n\n    if (sign == 1) {\n        ret = base(s);\n    } else {\n        te_expr *b = base(s);\n        CHECK_NULL(b);\n\n        ret = NEW_EXPR(TE_FUNCTION1 | TE_FLAG_PURE, b);\n        CHECK_NULL(ret, te_free(b));\n\n        ret->function = negate;\n    }\n\n    return ret;\n}\n",
    "e": "static double e(void) {return 2.71828182845904523536;}\n",
    "npr": "static double npr(double n, double r) {return ncr(n, r) * fac(r);}\n",
    "optimize": "static void optimize(te_expr *n) {\n    /* Evaluates as much as possible. */\n    if (n->type == TE_CONSTANT) return;\n    if (n->type == TE_VARIABLE) return;\n\n    /* Only optimize out functions flagged as pure. */\n    if (IS_PURE(n->type)) {\n        const int arity = ARITY(n->type);\n        int known = 1;\n        int i;\n        for (i = 0; i < arity; ++i) {\n            optimize(n->parameters[i]);\n            if (((te_expr*)(n->parameters[i]))->type != TE_CONSTANT) {\n                known = 0;\n            }\n        }\n        if (known) {\n            const double value = te_eval(n);\n            te_free_parameters(n);\n            n->type = TE_CONSTANT;\n            n->value = value;\n        }\n",
    "divide": "static double divide(double a, double b) {return a / b;}\n",
    "te_free_parameters": "void te_free_parameters(te_expr *n) {\n    if (!n) return;\n    switch (TYPE_MASK(n->type)) {\n        case TE_FUNCTION7: case TE_CLOSURE7: te_free(n->parameters[6]);     /* Falls through. */\n        case TE_FUNCTION6: case TE_CLOSURE6: te_free(n->parameters[5]);     /* Falls through. */\n        case TE_FUNCTION5: case TE_CLOSURE5: te_free(n->parameters[4]);     /* Falls through. */\n        case TE_FUNCTION4: case TE_CLOSURE4: te_free(n->parameters[3]);     /* Falls through. */\n        case TE_FUNCTION3: case TE_CLOSURE3: te_free(n->parameters[2]);     /* Falls through. */\n        case TE_FUNCTION2: case TE_CLOSURE2: te_free(n->parameters[1]);     /* Falls through. */\n        case TE_FUNCTION1: case TE_CLOSURE1: te_free(n->parameters[0]);\n    }\n",
    "te_eval": "double te_eval(const te_expr *n) {\n    if (!n) return NAN;\n\n    switch(TYPE_MASK(n->type)) {\n        case TE_CONSTANT: return n->value;\n        case TE_VARIABLE: return *n->bound;\n\n        case TE_FUNCTION0: case TE_FUNCTION1: case TE_FUNCTION2: case TE_FUNCTION3:\n        case TE_FUNCTION4: case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:\n            switch(ARITY(n->type)) {\n                case 0: return TE_FUN(void)();\n                case 1: return TE_FUN(double)(M(0));\n                case 2: return TE_FUN(double, double)(M(0), M(1));\n                case 3: return TE_FUN(double, double, double)(M(0), M(1), M(2));\n                case 4: return TE_FUN(double, double, double, double)(M(0), M(1), M(2), M(3));\n                case 5: return TE_FUN(double, double, double, double, double)(M(0), M(1), M(2), M(3), M(4));\n                case 6: return TE_FUN(double, double, double, double, double, double)(M(0), M(1), M(2), M(3), M(4), M(5));\n                case 7: return TE_FUN(double, double, double, double, double, double, double)(M(0), M(1), M(2), M(3), M(4), M(5), M(6));\n                default: return NAN;\n            }\n\n        case TE_CLOSURE0: case TE_CLOSURE1: case TE_CLOSURE2: case TE_CLOSURE3:\n        case TE_CLOSURE4: case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:\n            switch(ARITY(n->type)) {\n                case 0: return TE_FUN(void*)(n->parameters[0]);\n                case 1: return TE_FUN(void*, double)(n->parameters[1], M(0));\n                case 2: return TE_FUN(void*, double, double)(n->parameters[2], M(0), M(1));\n                case 3: return TE_FUN(void*, double, double, double)(n->parameters[3], M(0), M(1), M(2));\n                case 4: return TE_FUN(void*, double, double, double, double)(n->parameters[4], M(0), M(1), M(2), M(3));\n                case 5: return TE_FUN(void*, double, double, double, double, double)(n->parameters[5], M(0), M(1), M(2), M(3), M(4));\n                case 6: return TE_FUN(void*, double, double, double, double, double, double)(n->parameters[6], M(0), M(1), M(2), M(3), M(4), M(5));\n                case 7: return TE_FUN(void*, double, double, double, double, double, double, double)(n->parameters[7], M(0), M(1), M(2), M(3), M(4), M(5), M(6));\n                default: return NAN;\n            }\n\n        default: return NAN;\n    }\n",
    "pn": "static void pn (const te_expr *n, int depth) {\n    int i, arity;\n    printf(\"%*s\", depth, \"\");\n\n    switch(TYPE_MASK(n->type)) {\n    case TE_CONSTANT: printf(\"%f\\n\", n->value); break;\n    case TE_VARIABLE: printf(\"bound %p\\n\", n->bound); break;\n\n    case TE_FUNCTION0: case TE_FUNCTION1: case TE_FUNCTION2: case TE_FUNCTION3:\n    case TE_FUNCTION4: case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:\n    case TE_CLOSURE0: case TE_CLOSURE1: case TE_CLOSURE2: case TE_CLOSURE3:\n    case TE_CLOSURE4: case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:\n         arity = ARITY(n->type);\n         printf(\"f%d\", arity);\n         for(i = 0; i < arity; i++) {\n             printf(\" %p\", n->parameters[i]);\n         }\n         printf(\"\\n\");\n         for(i = 0; i < arity; i++) {\n             pn(n->parameters[i], depth + 1);\n         }\n         break;\n    }\n",
    "list": "static te_expr *list(state *s) {\n    /* <list>      =    <expr> {\",\" <expr>} */\n    te_expr *ret = expr(s);\n    CHECK_NULL(ret);\n\n    while (s->type == TOK_SEP) {\n        next_token(s);\n        te_expr *e = expr(s);\n        CHECK_NULL(e, te_free(ret));\n\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, e);\n        CHECK_NULL(ret, te_free(e), te_free(prev));\n\n        ret->function = comma;\n    }\n\n    return ret;\n}\n",
    "fac": "static double fac(double a) {/* simplest version of fac */\n    if (a < 0.0)\n        return NAN;\n    if (a > UINT_MAX)\n        return INFINITY;\n    unsigned int ua = (unsigned int)(a);\n    unsigned long int result = 1, i;\n    for (i = 1; i <= ua; i++) {\n        if (i > ULONG_MAX / result)\n            return INFINITY;\n        result *= i;\n    }\n    return (double)result;\n}\n",
    "next_token": "void next_token(state *s) {\n    s->type = TOK_NULL;\n\n    do {\n\n        if (!*s->next){\n            s->type = TOK_END;\n            return;\n        }\n\n        /* Try reading a number. */\n        if ((s->next[0] >= '0' && s->next[0] <= '9') || s->next[0] == '.') {\n            s->value = strtod(s->next, (char**)&s->next);\n            s->type = TOK_NUMBER;\n        } else {\n            /* Look for a variable or builtin function call. */\n            if (isalpha(s->next[0])) {\n                const char *start;\n                start = s->next;\n                while (isalpha(s->next[0]) || isdigit(s->next[0]) || (s->next[0] == '_')) s->next++;\n                \n                const te_variable *var = find_lookup(s, start, s->next - start);\n                if (!var) var = find_builtin(start, s->next - start);\n\n                if (!var) {\n                    s->type = TOK_ERROR;\n                } else {\n                    switch(TYPE_MASK(var->type))\n                    {\n                        case TE_VARIABLE:\n                            s->type = TOK_VARIABLE;\n                            s->bound = var->address;\n                            break;\n\n                        case TE_CLOSURE0: case TE_CLOSURE1: case TE_CLOSURE2: case TE_CLOSURE3:         /* Falls through. */\n                        case TE_CLOSURE4: case TE_CLOSURE5: case TE_CLOSURE6: case TE_CLOSURE7:         /* Falls through. */\n                            s->context = var->context;                                                  /* Falls through. */\n\n                        case TE_FUNCTION0: case TE_FUNCTION1: case TE_FUNCTION2: case TE_FUNCTION3:     /* Falls through. */\n                        case TE_FUNCTION4: case TE_FUNCTION5: case TE_FUNCTION6: case TE_FUNCTION7:     /* Falls through. */\n                            s->type = var->type;\n                            s->function = var->address;\n                            break;\n                    }\n                }\n\n            } else {\n                /* Look for an operator or special character. */\n                switch (s->next++[0]) {\n                    case '+': s->type = TOK_INFIX; s->function = add; break;\n                    case '-': s->type = TOK_INFIX; s->function = sub; break;\n                    case '*': s->type = TOK_INFIX; s->function = mul; break;\n                    case '/': s->type = TOK_INFIX; s->function = divide; break;\n                    case '^': s->type = TOK_INFIX; s->function = pow; break;\n                    case '%': s->type = TOK_INFIX; s->function = fmod; break;\n                    case '(': s->type = TOK_OPEN; break;\n                    case ')': s->type = TOK_CLOSE; break;\n                    case ',': s->type = TOK_SEP; break;\n                    case ' ': case '\\t': case '\\n': case '\\r': break;\n                    default: s->type = TOK_ERROR; break;\n                }\n            }\n        }\n    } while (s->type == TOK_NULL);\n}\n",
    "extra": "{'state': '} state;', 'te_expr': '} te_expr;', 'te_variable': '} te_variable;', 'functions': 'static const te_variable functions[] = {\\n    /* must be in alphabetical order */\\n    {\"abs\", fabs,     TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"acos\", acos,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"asin\", asin,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"atan\", atan,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"atan2\", atan2,  TE_FUNCTION2 | TE_FLAG_PURE, 0},\\n    {\"ceil\", ceil,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"cos\", cos,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"cosh\", cosh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"e\", e,          TE_FUNCTION0 | TE_FLAG_PURE, 0},\\n    {\"exp\", exp,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"fac\", fac,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"floor\", floor,  TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"ln\", log,       TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n#ifdef TE_NAT_LOG\\n    {\"log\", log,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n#else\\n    {\"log\", log10,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n#endif\\n    {\"log10\", log10,  TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"ncr\", ncr,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\\n    {\"npr\", npr,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\\n    {\"pi\", pi,        TE_FUNCTION0 | TE_FLAG_PURE, 0},\\n    {\"pow\", pow,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\\n    {\"sin\", sin,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"sinh\", sinh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"sqrt\", sqrt,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"tan\", tan,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {\"tanh\", tanh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\\n    {0, 0, 0, 0}\\n};', 'ARITY': '#define ARITY(TYPE) ( ((TYPE) & (TE_FUNCTION0 | TE_CLOSURE0)) ? ((TYPE) & 0x00000007) : 0 )', 'CHECK_NULL': '#define CHECK_NULL(ptr, ...) if ((ptr) == NULL) { __VA_ARGS__; return NULL; }', 'INFINITY': '#define INFINITY (1.0/0.0)', 'IS_CLOSURE': '#define IS_CLOSURE(TYPE) (((TYPE) & TE_CLOSURE0) != 0)', 'IS_FUNCTION': '#define IS_FUNCTION(TYPE) (((TYPE) & TE_FUNCTION0) != 0)', 'IS_PURE': '#define IS_PURE(TYPE) (((TYPE) & TE_FLAG_PURE) != 0)', 'M': '#define M(e) te_eval(n->parameters[e])', 'NAN': '#define NAN (0.0/0.0)', 'NEW_EXPR': '#define NEW_EXPR(type, ...) new_expr((type), (const te_expr*[]){__VA_ARGS__})', 'TE_FUN': '#define TE_FUN(...) ((double(*)(__VA_ARGS__))n->function)', 'TINYEXPR_H': '#define TINYEXPR_H', 'TYPE_MASK': '#define TYPE_MASK(TYPE) ((TYPE)&0x0000001F)', 'te_fun2': 'typedef double (*te_fun2)(double, double);', '__anonfaa0499e0203': 'enum {TE_CONSTANT = 1};', '__anonfaa0499e0303': 'enum {TE_CONSTANT = 1};', '__anonfaa0499e0403': 'enum {TE_CONSTANT = 1};\\n\\n\\ntypedef struct state {\\n    const char *start;'} extract_info: [// SPDX-License-Identifier: Zlib\n/*\n * TINYEXPR - Tiny recursive descent parser and evaluation engine in C\n *\n * Copyright (c) 2015-2020 Lewis Van Winkle\n *\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgement in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n/* COMPILE TIME OPTIONS */\n\n/* Exponentiation associativity:\nFor a^b^c = (a^b)^c and -a^b = (-a)^b do nothing.\nFor a^b^c = a^(b^c) and -a^b = -(a^b) uncomment the next line.*/\n/* #define TE_POW_FROM_RIGHT */\n\n/* Logarithms\nFor log = base 10 log do nothing\nFor log = natural log uncomment the next line. */\n/* #define TE_NAT_LOG */\n\n// SPDX-License-Identifier: Zlib\n/*\n * TINYEXPR - Tiny recursive descent parser and evaluation engine in C\n *\n * Copyright (c) 2015-2020 Lewis Van Winkle\n *\n * http://CodePlea.com\n *\n * This software is provided 'as-is', without any express or implied\n * warranty. In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgement in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n#ifndef TINYEXPR_H\n#define TINYEXPR_H\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n\ntypedef struct te_expr {\n    int type;\n    union {double value; const double *bound; const void *function;};\n    void *parameters[1];\n} te_expr;\n\n\nenum {\n    TE_VARIABLE = 0,\n\n    TE_FUNCTION0 = 8, TE_FUNCTION1, TE_FUNCTION2, TE_FUNCTION3,\n    TE_FUNCTION4, TE_FUNCTION5, TE_FUNCTION6, TE_FUNCTION7,\n\n    TE_CLOSURE0 = 16, TE_CLOSURE1, TE_CLOSURE2, TE_CLOSURE3,\n    TE_CLOSURE4, TE_CLOSURE5, TE_CLOSURE6, TE_CLOSURE7,\n\n    TE_FLAG_PURE = 32\n};\n\ntypedef struct te_variable {\n    const char *name;\n    const void *address;\n    int type;\n    void *context;\n} te_variable;\n\n\n\n/* Parses the input expression, evaluates it, and frees it. */\n/* Returns NaN on error. */\ndouble te_interp(const char *expression, int *error);\n\n/* Parses the input expression and binds variables. */\n/* Returns NULL on error. */\nte_expr *te_compile(const char *expression, const te_variable *variables, int var_count, int *error);\n\n/* Evaluates the expression. */\ndouble te_eval(const te_expr *n);\n\n/* Prints debugging information on the syntax tree. */\nvoid te_print(const te_expr *n);\n\n/* Frees the expression. */\n/* This is safe to call on NULL pointers. */\nvoid te_free(te_expr *n);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*TINYEXPR_H*/\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <limits.h>\n\n#ifndef NAN\n#define NAN (0.0/0.0)\n#endif\n\n#ifndef INFINITY\n#define INFINITY (1.0/0.0)\n#endif\n\n\ntypedef double (*te_fun2)(double, double);\n\nenum {\n    TOK_NULL = TE_CLOSURE7+1, TOK_ERROR, TOK_END, TOK_SEP,\n    TOK_OPEN, TOK_CLOSE, TOK_NUMBER, TOK_VARIABLE, TOK_INFIX\n};\n\n\nenum {TE_CONSTANT = 1};\n\n\ntypedef struct state {\n    const char *start;\n    const char *next;\n    int type;\n    union {double value; const double *bound; const void *function;};\n    void *context;\n\n    const te_variable *lookup;\n    int lookup_len;\n} state;\n\n\n#define TYPE_MASK(TYPE) ((TYPE)&0x0000001F)\n\n#define IS_PURE(TYPE) (((TYPE) & TE_FLAG_PURE) != 0)\n#define IS_FUNCTION(TYPE) (((TYPE) & TE_FUNCTION0) != 0)\n#define IS_CLOSURE(TYPE) (((TYPE) & TE_CLOSURE0) != 0)\n#define ARITY(TYPE) ( ((TYPE) & (TE_FUNCTION0 | TE_CLOSURE0)) ? ((TYPE) & 0x00000007) : 0 )\n#define NEW_EXPR(type, ...) new_expr((type), (const te_expr*[]){__VA_ARGS__})\n#define CHECK_NULL(ptr, ...) if ((ptr) == NULL) { __VA_ARGS__; return NULL; }\n\n\n\n}\n\n\n\n\n\n#ifdef _MSC_VER\n#pragma function (ceil)\n#pragma function (floor)\n#endif\n\nstatic const te_variable functions[] = {\n    /* must be in alphabetical order */\n    {\"abs\", fabs,     TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"acos\", acos,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"asin\", asin,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"atan\", atan,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"atan2\", atan2,  TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"ceil\", ceil,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"cos\", cos,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"cosh\", cosh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"e\", e,          TE_FUNCTION0 | TE_FLAG_PURE, 0},\n    {\"exp\", exp,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"fac\", fac,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"floor\", floor,  TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"ln\", log,       TE_FUNCTION1 | TE_FLAG_PURE, 0},\n#ifdef TE_NAT_LOG\n    {\"log\", log,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n#else\n    {\"log\", log10,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n#endif\n    {\"log10\", log10,  TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"ncr\", ncr,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"npr\", npr,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"pi\", pi,        TE_FUNCTION0 | TE_FLAG_PURE, 0},\n    {\"pow\", pow,      TE_FUNCTION2 | TE_FLAG_PURE, 0},\n    {\"sin\", sin,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"sinh\", sinh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"sqrt\", sqrt,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"tan\", tan,      TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {\"tanh\", tanh,    TE_FUNCTION1 | TE_FLAG_PURE, 0},\n    {0, 0, 0, 0}\n};\n\n\n\n\n\n\n\n\n\nstatic te_expr *list(state *s);\nstatic te_expr *expr(state *s);\nstatic te_expr *power(state *s);\n\n\n\n\n#ifdef TE_POW_FROM_RIGHT\nstatic te_expr *factor(state *s) {\n    /* <factor>    =    <power> {\"^\" <power>} */\n    te_expr *ret = power(s);\n    CHECK_NULL(ret);\n\n    int neg = 0;\n\n    if (ret->type == (TE_FUNCTION1 | TE_FLAG_PURE) && ret->function == negate) {\n        te_expr *se = ret->parameters[0];\n        free(ret);\n        ret = se;\n        neg = 1;\n    }\n\n    te_expr *insertion = 0;\n\n    while (s->type == TOK_INFIX && (s->function == pow)) {\n        te_fun2 t = s->function;\n        next_token(s);\n\n        if (insertion) {\n            /* Make exponentiation go right-to-left. */\n            te_expr *p = power(s);\n            CHECK_NULL(p, te_free(ret));\n\n            te_expr *insert = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, insertion->parameters[1], p);\n            CHECK_NULL(insert, te_free(p), te_free(ret));\n\n            insert->function = t;\n            insertion->parameters[1] = insert;\n            insertion = insert;\n        } else {\n            te_expr *p = power(s);\n            CHECK_NULL(p, te_free(ret));\n\n            te_expr *prev = ret;\n            ret = NEW_EXPR(TE_FUNCTION2 | TE_FLAG_PURE, ret, p);\n            CHECK_NULL(ret, te_free(p), te_free(prev));\n\n            ret->function = t;\n            insertion = ret;\n        }\n    }\n\n    if (neg) {\n        te_expr *prev = ret;\n        ret = NEW_EXPR(TE_FUNCTION1 | TE_FLAG_PURE, ret);\n        CHECK_NULL(ret, te_free(prev));\n\n        ret->function = negate;\n    }\n\n    return ret;\n}\n#else\n#endif\n\n\n\n\n\n\n\n\n\n#define TE_FUN(...) ((double(*)(__VA_ARGS__))n->function)\n#define M(e) te_eval(n->parameters[e])\n\n\n\n}\n\n#undef TE_FUN\n#undef M\n\n    }\n}\n\n\n}\n\n\n\n}\n\n\n]"
}