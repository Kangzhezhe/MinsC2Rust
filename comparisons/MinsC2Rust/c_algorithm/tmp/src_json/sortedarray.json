{
    "sortedarray_length": "unsigned int sortedarray_length(SortedArray *array)\n{\n\treturn array->length;\n}\n",
    "sortedarray_first_index": "static unsigned int sortedarray_first_index(SortedArray *sortedarray,\n                                   SortedArrayValue data, unsigned int left,\n                                   unsigned int right)\n{\n\tunsigned int index = left;\n\n\twhile (left < right) {\n\t\tindex = (left + right) / 2;\n\n\t\tint order = sortedarray->cmp_func(data, \n\t\t                                  sortedarray->data[index]);\n\t\tif (order > 0) {\n\t\t\tleft = index + 1;\n\t\t} else {\n\t\t\tright = index;\n\t\t}\n\t}\n\n\treturn index;\n}\n",
    "sortedarray_clear": "void sortedarray_clear(SortedArray *sortedarray)\n{\n\t/* set length to 0 */\n\tsortedarray->length = 0;\n}\n",
    "sortedarray_insert": "int sortedarray_insert(SortedArray *sortedarray, SortedArrayValue data)\n{\n\t/* do a binary search like loop to find right position */\n\tunsigned int left  = 0;\n\tunsigned int right = sortedarray->length;\n\tunsigned int index = 0;\n\n\t/* When length is 1 set right to 0 so that the loop is not entered */\t\n\tright = (right > 1) ? right : 0;\n\n\twhile (left != right) {\n\t\tindex = (left + right) / 2;\n\n\t\tint order = sortedarray->cmp_func(data, \n\t\t                                  sortedarray->data[index]);\n\t\tif (order < 0) {\n\t\t\t/* value should be left of index */\n\t\t\tright = index;\n\t\t} else if (order > 0) {\n\t\t\t/* value should be right of index */\n\t\t\tleft = index + 1;\n\t\t} else {\n\t\t\t/* value should be at index */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* look whether the item should be put before or after the index */\n\tif (sortedarray->length > 0 && sortedarray->cmp_func(data, \n\t                       sortedarray->data[index]) > 0) {\n\t\tindex++;\n\t}\n\n\t/* insert element at index */\n\tif (sortedarray->length + 1 > sortedarray->_alloced) {\n\t\t/* enlarge the array */\n\t\tunsigned int newsize;\n\t\tSortedArrayValue *data;\n\n\t\tnewsize = sortedarray->_alloced * 2;\n\t\tdata = realloc(sortedarray->data, sizeof(SortedArrayValue) * newsize);\n\n\t\tif (data == NULL) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tsortedarray->data = data;\n\t\t\tsortedarray->_alloced = newsize;\n\t\t}\n\t}\n\n\t/* move all other elements */\n\tmemmove(&sortedarray->data[index + 1],\n\t        &sortedarray->data[index],\n\t        (sortedarray->length - index) * sizeof(SortedArrayValue));\n\n\t/* insert entry */\n\tsortedarray->data[index] = data;\n\t++(sortedarray->length);\n\n\treturn 1;\n}\n",
    "sortedarray_free": "void sortedarray_free(SortedArray *sortedarray)\n{\n\tif (sortedarray != NULL) {\n\t\tfree(sortedarray->data);\n\t\tfree(sortedarray);\n\t}\n",
    "sortedarray_index_of": "int sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data)\n{\n\tif (sortedarray == NULL) {\n\t\treturn -1;\n\t}\n\t\n\t/* do a binary search */\n\tunsigned int left = 0;\n\tunsigned int right = sortedarray->length;\n\tunsigned int index = 0;\n\n\t/* safe subtract 1 of right without going negative */\n\tright = (right > 1) ? right : 0;\n\n\twhile (left != right) {\n\t\tindex = (left + right) / 2;\n\n\t\tint order = sortedarray->cmp_func(data, \n\t\t                                  sortedarray->data[index]);\n\t\tif (order < 0) {\n\t\t\t/* value should be left */\n\t\t\tright = index;\n\t\t} else if (order > 0) {\n\t\t\t/* value should be right */\n\t\t\tleft = index + 1;\n\t\t} else {\n\t\t\t/* no binary search can be done anymore, \n\t\t\t   search linear now */\n\t\t\tleft = sortedarray_first_index(sortedarray, data, left,\n\t\t\t                               index);\n\t\t\tright = sortedarray_last_index(sortedarray, data, \n\t\t\t                               index, right);\n\n\t\t\tfor (index = left; index <= right; index++) {\n\t\t\t\tif (sortedarray->equ_func(data, \n\t\t\t\t                sortedarray->data[index])) {\n\t\t\t\t\treturn (int) index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* nothing is found */\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn -1;\n}\n",
    "sortedarray_new": "SortedArray *sortedarray_new(unsigned int length,\n                             SortedArrayEqualFunc equ_func,\n                             SortedArrayCompareFunc cmp_func)\n{\n\t/* check input requirements */\n\tif (equ_func == NULL || cmp_func == NULL) {\n\t\treturn NULL;\n\t}\n\n\t/* If length is 0, set it to a default. */\n\tif (length == 0) {\n\t\tlength = 16;\n\t}\n\n\tSortedArrayValue *array = malloc(sizeof(SortedArrayValue) * length);\n\n\t/* on failure, return null */\n\tif (array == NULL) {\n\t\treturn NULL;\n\t}\n\n\tSortedArray *sortedarray = malloc(sizeof(SortedArray));    \n\n\t/* check for failure */\n\tif (sortedarray == NULL) {\n\t\tfree(array);\n\t\treturn NULL;\n\t}\n    \n\t/* init */\n\tsortedarray->data = array;\n\tsortedarray->length = 0;\n\tsortedarray->_alloced = length;\n\tsortedarray->equ_func = equ_func;\n\tsortedarray->cmp_func = cmp_func;\n\treturn sortedarray;\n}\n",
    "sortedarray_get": "SortedArrayValue *sortedarray_get(SortedArray *array, unsigned int i)\n{\n\t//check if array is NULL\n\tif (array == NULL) {\n\t\treturn NULL;\n\t}\n\n\t//otherwise just return the element\n\treturn array->data[i];\t\n}\n",
    "sortedarray_remove_range": "void sortedarray_remove_range(SortedArray *sortedarray, unsigned int index,\n                              unsigned int length)\n{\n\t/* removal does not violate sorted property */\n\n\t/* check if valid range */\n\tif (index > sortedarray->length || index + length > sortedarray->length) {\n\t\treturn;\n\t}\n\n\t/* move entries back */\n\tmemmove(&sortedarray->data[index],\n\t        &sortedarray->data[index + length],\n\t        (sortedarray->length - (index + length)) \n\t              * sizeof(SortedArrayValue));\n\n\tsortedarray->length -= length;\n}\n",
    "sortedarray_last_index": "static unsigned int sortedarray_last_index(SortedArray *sortedarray, \n                                  SortedArrayValue data, unsigned int left, \n                                  unsigned int right)\n{\n\tunsigned int index = right;\n\n\twhile (left < right) {\n\t\tindex = (left + right) / 2;\n\n\t\tint order = sortedarray->cmp_func(data, \n\t\t                                  sortedarray->data[index]);\n\t\tif (order <= 0) {\n\t\t\tleft = index + 1;\n\t\t} else {\n\t\t\tright = index;\n\t\t}\n\t}\n\n\treturn index;\n}\n",
    "sortedarray_remove": "void sortedarray_remove(SortedArray *sortedarray, unsigned int index)\n{\n\t/* same as remove range of length 1 */\n\tsortedarray_remove_range(sortedarray, index, 1);\n}\n",
    "extra": "{'_SortedArray': 'struct _SortedArray {\\n\\t/**\\n\\t * This field contains the actual array. The array always has a length\\n\\t * of value of field length.\\n\\t */\\n\\tSortedArrayValue *data;\\n\\n\\t/**\\n\\t * The length of the sorted array.\\n\\t */\\n\\tunsigned int length;\\n\\n\\t/**\\n\\t * Field for internal usage only indicating how much memory already has\\n\\t * been allocated for *data.\\n\\t */\\n\\tunsigned int _alloced;\\n\\n\\t/**\\n\\t * The callback used to determine if two values equal.\\n\\t */\\n\\tSortedArrayEqualFunc equ_func;\\n\\n\\t/**\\n\\t * The callback use to determine the order of two values.\\n\\t */\\n\\tSortedArrayCompareFunc cmp_func;\\n};', 'ALGORITHM_SORTEDARRAY_H': '#define ALGORITHM_SORTEDARRAY_H', 'ALLOC_TESTING_H': '#define ALLOC_TESTING_H', 'calloc': '#define calloc   alloc_test_calloc', 'free': '#define free     alloc_test_free', 'malloc': '#define malloc   alloc_test_malloc', 'realloc': '#define realloc  alloc_test_realloc', 'strdup': '#define strdup   alloc_test_strdup', 'SortedArray': 'typedef struct _SortedArray SortedArray;', 'SortedArrayCompareFunc': 'typedef int (*SortedArrayCompareFunc)(SortedArrayValue value1,\\n                                      SortedArrayValue value2);', 'SortedArrayEqualFunc': 'typedef int (*SortedArrayEqualFunc)(SortedArrayValue value1,\\n                                    SortedArrayValue value2);', 'SortedArrayValue': 'typedef void *SortedArrayValue;'} extract_info: [/*\n\nCopyright (c) 2016, Stefan Cloudt\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n \n */\n\n/**\n * @file sortedarray.c\n * \n * @brief File containing the implementation of sortedarray.h\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n\nCopyright (c) 2016, Stefan Cloudt\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n/**\n * @file sortedarray.h\n *\n * @brief Automatically sorted and resizing array\n *\n * An SortedArray is an automatically resizing sorted array. Most operations\n * run O(n) worst case running time. Some operations run in O(log n).\n *\n * To retrieve a value use the sortedarray structure by accessing the data\n * field.\n *\n * To create a SortedArray, use @ref sortedarray_new\n * To destroy a SortedArray, use @ref sortedarray_free\n *\n * To add a value to a SortedArray, use @ref sortedarray_prepend, \n * @ref sortedarray_append, or @ref sortedarray_insert.\n *\n * To remove a value from a SortedArray, use @ref sortedarray_remove\n * or @ref sortedarray_remove_range.\n */\n\n#ifndef ALGORITHM_SORTEDARRAY_H\n#define ALGORITHM_SORTEDARRAY_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * A value to store in @ref SortedArray.\n */\ntypedef void *SortedArrayValue;\n\n/**\n * A SortedArray structure. Use @ref sortedarray_new to create one.\n *\n * The SortedArray is an automatically resizing array which stores its \n * elements in sorted order. Userdefined functions determine the sorting order.\n * All operations on a SortedArray maintain the sorted property. Most \n * operations are done in O(n) time, but searching can be done in O(log n)\n * worst case.\n *\n * @see sortedarray_new\n */\ntypedef struct _SortedArray SortedArray;\n\n/**\n * Compare two values in a SortedArray to determine if they are equal.\n *\n * @param value1\tThe first value to compare.\n * @param value2\tThe second value to compare.\n * @return\t\tNon-zero if value1 equals value2, zero if they do not\n *\t\t\tequal.\n *\n */\ntypedef int (*SortedArrayEqualFunc)(SortedArrayValue value1,\n                                    SortedArrayValue value2);\n\n/**\n * Compare two values in a SortedArray to determine their order.\n *\n * @param value1\tThe first value to compare.\n * @param value2\tThe second value to compare.\n * @return\t\tLess than zero if value1 is compared smaller than \n * \t\t\tvalue2, zero if they compare equal, or greater than\n * \t\t\tzero if value1 compares greate than value2.\n */\ntypedef int (*SortedArrayCompareFunc)(SortedArrayValue value1,\n                                      SortedArrayValue value2);\n\n/**\n * @brief Function to retrieve element at index i from array\n *\n * @param array\t\t\tThe pointer to the sortedarray to retrieve the element from.\n * @param i\t\t\t\tThe index of the element to retrieve.\n * @return\t\t\t\tThe i-th element of the array, or NULL if array was NULL.\n */\nSortedArrayValue *sortedarray_get(SortedArray *array, unsigned int i);\n\n/**\n * @brief Function to retrieve the length of the SortedArray array.\n *\n * @param array\t\t\tThe array to retrieve the length from.\n * @return\t\t\t\tThe lenght of the SortedArray.\n */\nunsigned int sortedarray_length(SortedArray *array);\n\n/**\n * Allocate a new SortedArray for use.\n *\n * @param length        Indication to the amount of memory that should be \n *                      allocated. If 0 is given, then a default is used.\n * @param equ_func      The function used to determine if two values in the\n *                      SortedArray equal. This may not be NULL.\n * @param cmp_func      The function used to determine the relative order of\n *                      two values in the SortedArray. This may not be NULL.\n *\n * @return              A new SortedArray or NULL if it was not possible to\n *                      allocate one.\n */\nSortedArray *sortedarray_new(unsigned int length, \n                             SortedArrayEqualFunc equ_func, \n                             SortedArrayCompareFunc cmp_func);\n\n/**\n * Frees a SortedArray from memory.\n *\n * @param sortedarray   The SortedArray to free.\n */\nvoid sortedarray_free(SortedArray *sortedarray);\n\n/**\n * Remove a value from a SortedArray at a specified index while maintaining the\n * sorted property.\n *\n * @param sortedarray   The SortedArray to remove a value from.\n * @param index         The index to remove from the array.\n */\nvoid sortedarray_remove(SortedArray *sortedarray, unsigned int index);\n\n/**\n * Remove a range of entities from a SortedArray while maintaining the sorted \n * property.\n *\n * @param sortedarray   The SortedArray to remove the range of values from.\n * @param index         The starting index of the range to remove.\n * @param length        The length of the range to remove.\n */\nvoid sortedarray_remove_range(SortedArray *sortedarray, unsigned int index,\n                              unsigned int length);\n\n/**\n * Insert a value into a SortedArray while maintaining the sorted property.\n *\n * @param sortedarray   The SortedArray to insert into.\n * @param data          The data to insert.\n *\n * @return              Zero on failure, or a non-zero value if successfull.\n */\nint sortedarray_insert(SortedArray *sortedarray, SortedArrayValue data);\n\n/**\n * Find the index of a value in a SortedArray.\n *\n * @param sortedarray   The SortedArray to find in.\n * @param data          The value to find.\n * @return              The index of the value or -1 if the value is not found.\n */\nint sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data);\n\n/**\n * Remove all values from a SortedArray.\n *\n * @param sortedarray   The SortedArray to clear.\n */\nvoid sortedarray_clear(SortedArray *sortedarray);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // #ifndef ALGORITHM_SORTEDARRAY_H\n\n#ifdef ALLOC_TESTING\n/*\n\nCopyright (c) 2005-2008, Simon Howard\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n/**\n * @file alloc-testing.h\n *\n * @brief Memory allocation testing framework.\n *\n * This file uses the preprocessor to redefine the standard C dynamic memory\n * allocation functions for testing purposes.  This allows checking that\n * code under test correctly frees back all memory allocated, as well as\n * the ability to impose artificial limits on allocation, to test that\n * code correctly handles out-of-memory scenarios.\n */\n\n#ifndef ALLOC_TESTING_H\n#define ALLOC_TESTING_H\n\n/* Don't redefine the functions in the alloc-testing.c, as we need the\n * standard malloc/free functions. */\n\n#ifndef ALLOC_TESTING_C\n#undef malloc\n#define malloc   alloc_test_malloc\n#undef free\n#define free     alloc_test_free\n#undef realloc\n#define realloc  alloc_test_realloc\n#undef calloc\n#define calloc   alloc_test_calloc\n#undef strdup\n#define strdup   alloc_test_strdup\n#endif\n\n/**\n * Allocate a block of memory.\n *\n * @param bytes          Number of bytes to allocate.\n * @return               Pointer to the new block, or NULL if it was not\n *                       possible to allocate the new block.\n */\n\nvoid *alloc_test_malloc(size_t bytes);\n\n/**\n * Free a block of memory.\n *\n * @param ptr            Pointer to the block to free.\n */\n\nvoid alloc_test_free(void *ptr);\n\n/**\n * Reallocate a previously-allocated block to a new size, preserving\n * contents.\n *\n * @param ptr            Pointer to the existing block.\n * @param bytes          Size of the new block, in bytes.\n * @return               Pointer to the new block, or NULL if it was not\n *                       possible to allocate the new block.\n */\n\nvoid *alloc_test_realloc(void *ptr, size_t bytes);\n\n/**\n * Allocate a block of memory for an array of structures, initialising\n * the contents to zero.\n *\n * @param nmemb          Number of structures to allocate for.\n * @param bytes          Size of each structure, in bytes.\n * @return               Pointer to the new memory block for the array,\n *                       or NULL if it was not possible to allocate the\n *                       new block.\n */\n\nvoid *alloc_test_calloc(size_t nmemb, size_t bytes);\n\n/**\n * Allocate a block of memory containing a copy of a string.\n *\n * @param string         The string to copy.\n * @return               Pointer to the new memory block containing the\n *                       copied string, or NULL if it was not possible\n *                       to allocate the new block.\n */\n\nchar *alloc_test_strdup(const char *string);\n\n/**\n * Set an artificial limit on the amount of memory that can be\n * allocated.\n *\n * @param alloc_count    Number of allocations that are possible after\n *                       this call.  For example, if this has a value\n *                       of 3, malloc() can be called successfully\n *                       three times, but all allocation attempts\n *                       after this will fail.  If this has a negative\n *                       value, the allocation limit is disabled.\n */\n\nvoid alloc_test_set_limit(signed int alloc_count);\n\n/**\n * Get a count of the number of bytes currently allocated.\n *\n * @return               The number of bytes currently allocated by\n *                       the allocation system.\n */\n\nsize_t alloc_test_get_allocated(void);\n\n#endif /* #ifndef ALLOC_TESTING_H */\n\n#endif\n\n/**\n * Definition of a @ref SortedArray\n */\nstruct _SortedArray {\n\t/**\n\t * This field contains the actual array. The array always has a length\n\t * of value of field length.\n\t */\n\tSortedArrayValue *data;\n\n\t/**\n\t * The length of the sorted array.\n\t */\n\tunsigned int length;\n\n\t/**\n\t * Field for internal usage only indicating how much memory already has\n\t * been allocated for *data.\n\t */\n\tunsigned int _alloced;\n\n\t/**\n\t * The callback used to determine if two values equal.\n\t */\n\tSortedArrayEqualFunc equ_func;\n\n\t/**\n\t * The callback use to determine the order of two values.\n\t */\n\tSortedArrayCompareFunc cmp_func;\n};\n\n/* Function for finding first index of range which equals data. An equal value\n   must be present. */\n\n/* Function for finding last index of range which equals data. An equal value\n   must be present. */\n\n\n\n\n}\n\n\n\n\n\n]"
}