{
    "generate_sortedarray_equ": "SortedArray *generate_sortedarray_equ(SortedArrayEqualFunc equ_func)\n{\n\t/* generate a sorted array of length TEST_SIZE, filled with random \n\t   numbers. */\n\tSortedArray *sortedarray;\n\tunsigned int i;\n\n\tint array[TEST_SIZE] = TEST_ARRAY;\n\n\tsortedarray = sortedarray_new(0, equ_func, int_compare);\n\n\tfor (i = 0; i < TEST_SIZE; ++i) {\n\t\tint *pi = malloc(sizeof(int));\n\t\t*pi = array[i];\n\t\tsortedarray_insert(sortedarray, pi);\n\t}\n\n\treturn sortedarray;\n}\n",
    "generate_sortedarray": "SortedArray *generate_sortedarray(void)\n{\n\treturn generate_sortedarray_equ(int_equal);\n}\n",
    "ptr_equal": "static int ptr_equal(SortedArrayValue v1, SortedArrayValue v2) {\n\treturn v1 == v2;\n}\n",
    "test_sortedarray_remove": "void test_sortedarray_remove(void)\n{\n\tSortedArray *sortedarray = generate_sortedarray();\n\n\t/* remove index 24 */\n\tint *ip = (int*) sortedarray_get(sortedarray, TEST_REMOVE_EL + 1);\n\tint i = *ip;\n\tfree((int*) sortedarray_get(sortedarray, TEST_REMOVE_EL));\n\tsortedarray_remove(sortedarray, TEST_REMOVE_EL);\n\tassert(*((int*) sortedarray_get(sortedarray, TEST_REMOVE_EL)) == i);\n\n\tcheck_sorted_prop(sortedarray);\n\tfree_sorted_ints(sortedarray);\n}\n",
    "check_sorted_prop": "void check_sorted_prop(SortedArray *sortedarray)\n{\n\tunsigned int i;\n\tfor (i = 1; i < sortedarray_length(sortedarray); i++) {\n\t\tassert(int_compare(\n\t\t                   sortedarray_get(sortedarray, i-1),\n",
    "free_sorted_ints": "void free_sorted_ints(SortedArray *sortedarray)\n{\n\tunsigned int i;\n\tfor (i = 0; i < sortedarray_length(sortedarray); i++) {\n\t\tint *pi = (int*) sortedarray_get(sortedarray, i);\n\t\tfree(pi);\n\t}\n\n\tsortedarray_free(sortedarray);\n}\n",
    "test_sortedarray_index_of_equ_key": "void test_sortedarray_index_of_equ_key(void)\n{\n\t/* replace equal function by function which checks pointers */\n\tSortedArray *sortedarray = generate_sortedarray_equ(ptr_equal);\n\tunsigned int i;\n\n\t/* check if all search value return the same index */\n\tfor (i = 0; i < TEST_SIZE; i++) {\n\t\tint r = sortedarray_index_of(sortedarray, \n\t\t                             sortedarray_get(sortedarray, i));\n\t\tassert(r >= 0);\n\t\tassert(i == (unsigned int) r);\n\t}\n\n\tfree_sorted_ints(sortedarray);\n}\n",
    "main": "int main(int argc, char *argv[])\n{\n\trun_tests(tests);\n  printf(\"num_assert: %lu\\n\", num_assert);\n\treturn 0;\n}\n",
    "test_sortedarray_insert": "void test_sortedarray_insert(void)\n{\n\tSortedArray *sortedarray = generate_sortedarray();\n\tunsigned int i;\n\n\t/* insert a few random numbers, then check if everything is sorted */\n\tfor (i = 0; i < 20; i++) {\n\t\tint i = (int) (((float) rand())/((float) RAND_MAX) * 100);\n\t\tint *pi = malloc(sizeof(int));\n\t\t*pi = i;\n\t\tsortedarray_insert(sortedarray, pi);\n\t}\n\n\tcheck_sorted_prop(sortedarray);\n\tfree_sorted_ints(sortedarray);\n}\n",
    "test_sortedarray_get": "void test_sortedarray_get(void) {\n\tunsigned int i;\n\n\tSortedArray *arr = generate_sortedarray();\n\n\tfor (i = 0; i < sortedarray_length(arr); i++) {\n\t\tassert(sortedarray_get(arr, i) == sortedarray_get(arr, i));\n\t\tassert(*((int*) sortedarray_get(arr, i)) == \n\t\t       *((int*) sortedarray_get(arr, i)));\n\t}\n\n\tfree_sorted_ints(arr);\n}\n",
    "test_sortedarray_remove_range": "void test_sortedarray_remove_range(void)\n{\n\tSortedArray *sortedarray = generate_sortedarray();\n\n\t/* get values in test range */\n\tint new[TEST_REMOVE_RANGE_LENGTH];\n\tunsigned int i;\n\tfor (i = 0; i < TEST_REMOVE_RANGE_LENGTH; i++) {\n\t\tnew[i] = *((int*) sortedarray_get(sortedarray, TEST_REMOVE_RANGE + \n\t\t                                    TEST_REMOVE_RANGE_LENGTH + i));\n\t}\n\t\n\t/* free removed elements */\n\tfor (i = 0; i < TEST_REMOVE_RANGE_LENGTH; i++) {\n\t\tfree((int*) sortedarray_get(sortedarray, TEST_REMOVE_RANGE + i));\n\t}\n\n\t/* remove */\n\tsortedarray_remove_range(sortedarray, TEST_REMOVE_RANGE, \n\t\t\tTEST_REMOVE_RANGE_LENGTH);\n\t\n\t/* assert */\n\tfor (i = 0; i < TEST_REMOVE_RANGE_LENGTH; i++) {\n\t\tassert(*((int*) sortedarray_get(sortedarray, TEST_REMOVE_RANGE + i)) == \n\t\t                                                                new[i]);\n\t}\n\n\tcheck_sorted_prop(sortedarray);\n\tfree_sorted_ints(sortedarray);\n}\n",
    "test_sortedarray_new_free": "void test_sortedarray_new_free(void)\n{\n\tSortedArray *sortedarray;\n\n\t/* test normal */\n\tsortedarray = sortedarray_new(0, int_equal, int_compare);\n\tassert(sortedarray != NULL);\n\tsortedarray_free(sortedarray);\n\n\t/* freeing null */\n\tsortedarray_free(NULL);\n\n\t/* low memory */\n\talloc_test_set_limit(0);\n\tsortedarray = sortedarray_new(0, int_equal, int_compare);\n\tassert(sortedarray == NULL);\n\n\talloc_test_set_limit(-1);\n}\n",
    "test_sortedarray_index_of": "void test_sortedarray_index_of(void) {\n\tSortedArray *sortedarray = generate_sortedarray();\n\n\tunsigned int i;\n\tfor (i = 0; i < TEST_SIZE; i++) {\n\t\tint r = sortedarray_index_of(sortedarray, \n\t\t                sortedarray_get(sortedarray, i));\n\t\tassert(r >= 0);\n\t\tassert(*((int*) sortedarray_get(sortedarray,(unsigned int) r)) == \n\t\t        *((int*) sortedarray_get(sortedarray, i)));\n\t}\n\t\n\tfree_sorted_ints(sortedarray);\n}\n",
    "extra": "{'num_assert': '_Atomic size_t num_assert = 0;', 'tests': 'static UnitTestFunction tests[] = {\\n\\ttest_sortedarray_new_free,\\n\\ttest_sortedarray_insert,\\n\\ttest_sortedarray_remove,\\n\\ttest_sortedarray_remove_range,\\n\\ttest_sortedarray_index_of,\\n\\ttest_sortedarray_index_of_equ_key,\\n\\ttest_sortedarray_get,\\n\\tNULL   \\n};', 'ALGORITHM_COMPARE_INT_H': '#define ALGORITHM_COMPARE_INT_H', 'ALGORITHM_SORTEDARRAY_H': '#define ALGORITHM_SORTEDARRAY_H', 'ALLOC_TESTING_H': '#define ALLOC_TESTING_H', 'TEST_ARRAY': '#define TEST_ARRAY {10, 12, 12, 1, 2, 3, 6, 7, 2, 23, 13, 23, 23, 34, 31, 9,\\\\', 'TEST_FRAMEWORK_H': '#define TEST_FRAMEWORK_H', 'TEST_REMOVE_EL': '#define TEST_REMOVE_EL 15', 'TEST_REMOVE_RANGE': '#define TEST_REMOVE_RANGE 7', 'TEST_REMOVE_RANGE_LENGTH': '#define TEST_REMOVE_RANGE_LENGTH 4', 'TEST_SIZE': '#define TEST_SIZE 20', 'assert': '#define assert(expr)                                                           \\\\', 'calloc': '#define calloc   alloc_test_calloc', 'free': '#define free     alloc_test_free', 'malloc': '#define malloc   alloc_test_malloc', 'realloc': '#define realloc  alloc_test_realloc', 'strdup': '#define strdup   alloc_test_strdup', 'SortedArray': 'typedef struct _SortedArray SortedArray;', 'SortedArrayCompareFunc': 'typedef int (*SortedArrayCompareFunc)(SortedArrayValue value1,\\n                                      SortedArrayValue value2);', 'SortedArrayEqualFunc': 'typedef int (*SortedArrayEqualFunc)(SortedArrayValue value1,\\n                                    SortedArrayValue value2);', 'SortedArrayValue': 'typedef void *SortedArrayValue;', 'UnitTestFunction': 'typedef void (*UnitTestFunction)(void);'} extract_info: [/*\n\nCopyright (c) 2016, Stefan Cloudt\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n)\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <time.h>\n\n/*\n\nCopyright (c) 2005-2008, Simon Howard\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n/**\n * @file alloc-testing.h\n *\n * @brief Memory allocation testing framework.\n *\n * This file uses the preprocessor to redefine the standard C dynamic memory\n * allocation functions for testing purposes.  This allows checking that\n * code under test correctly frees back all memory allocated, as well as\n * the ability to impose artificial limits on allocation, to test that\n * code correctly handles out-of-memory scenarios.\n */\n\n#ifndef ALLOC_TESTING_H\n#define ALLOC_TESTING_H\n\n/* Don't redefine the functions in the alloc-testing.c, as we need the\n * standard malloc/free functions. */\n\n#ifndef ALLOC_TESTING_C\n#undef malloc\n#define malloc   alloc_test_malloc\n#undef free\n#define free     alloc_test_free\n#undef realloc\n#define realloc  alloc_test_realloc\n#undef calloc\n#define calloc   alloc_test_calloc\n#undef strdup\n#define strdup   alloc_test_strdup\n#endif\n\n/**\n * Allocate a block of memory.\n *\n * @param bytes          Number of bytes to allocate.\n * @return               Pointer to the new block, or NULL if it was not\n *                       possible to allocate the new block.\n */\n\nvoid *alloc_test_malloc(size_t bytes);\n\n/**\n * Free a block of memory.\n *\n * @param ptr            Pointer to the block to free.\n */\n\nvoid alloc_test_free(void *ptr);\n\n/**\n * Reallocate a previously-allocated block to a new size, preserving\n * contents.\n *\n * @param ptr            Pointer to the existing block.\n * @param bytes          Size of the new block, in bytes.\n * @return               Pointer to the new block, or NULL if it was not\n *                       possible to allocate the new block.\n */\n\nvoid *alloc_test_realloc(void *ptr, size_t bytes);\n\n/**\n * Allocate a block of memory for an array of structures, initialising\n * the contents to zero.\n *\n * @param nmemb          Number of structures to allocate for.\n * @param bytes          Size of each structure, in bytes.\n * @return               Pointer to the new memory block for the array,\n *                       or NULL if it was not possible to allocate the\n *                       new block.\n */\n\nvoid *alloc_test_calloc(size_t nmemb, size_t bytes);\n\n/**\n * Allocate a block of memory containing a copy of a string.\n *\n * @param string         The string to copy.\n * @return               Pointer to the new memory block containing the\n *                       copied string, or NULL if it was not possible\n *                       to allocate the new block.\n */\n\nchar *alloc_test_strdup(const char *string);\n\n/**\n * Set an artificial limit on the amount of memory that can be\n * allocated.\n *\n * @param alloc_count    Number of allocations that are possible after\n *                       this call.  For example, if this has a value\n *                       of 3, malloc() can be called successfully\n *                       three times, but all allocation attempts\n *                       after this will fail.  If this has a negative\n *                       value, the allocation limit is disabled.\n */\n\nvoid alloc_test_set_limit(signed int alloc_count);\n\n/**\n * Get a count of the number of bytes currently allocated.\n *\n * @return               The number of bytes currently allocated by\n *                       the allocation system.\n */\n\nsize_t alloc_test_get_allocated(void);\n\n#endif /* #ifndef ALLOC_TESTING_H */\n\n/*\n\nCopyright (c) 2005-2008, Simon Howard\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n#ifndef TEST_FRAMEWORK_H\n#define TEST_FRAMEWORK_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * @file framework.h\n *\n * @brief Framework for running unit tests.\n */\n\n/**\n * A unit test.\n */\n\ntypedef void (*UnitTestFunction)(void);\n\n/**\n * Run a list of unit tests.  The provided array contains a list of\n * pointers to test functions to invoke; the last entry is denoted\n * by a NULL pointer.\n *\n * @param tests          List of tests to invoke.\n */\n\nvoid run_tests(UnitTestFunction *tests);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* #ifndef TEST_FRAMEWORK_H */\n\n\n/*\n\nCopyright (c) 2005-2008, Simon Howard\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n/**\n * @file compare-int.h\n *\n * Comparison functions for pointers to integers.\n *\n * To find the difference between two values pointed at, use\n * @ref int_compare.\n *\n * To find if two values pointed at are equal, use @ref int_equal.\n */\n\n#ifndef ALGORITHM_COMPARE_INT_H\n#define ALGORITHM_COMPARE_INT_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * Compare the integer values pointed at by two pointers to determine\n * if they are equal.\n *\n * @param location1       Pointer to the first value to compare.\n * @param location2       Pointer to the second value to compare.\n * @return                Non-zero if the two values are equal, zero if the\n *                        two values are not equal.\n */\n\nint int_equal(void *location1, void *location2);\n\n/**\n * Compare the integer values pointed at by two pointers.\n *\n * @param location1        Pointer to the first value to compare.\n * @param location2        Pointer to the second value to compare.\n * @return                 A negative value if the first value is less than\n *                         the second value, a positive value if the first\n *                         value is greater than the second value, zero if\n *                         they are equal.\n */\n\nint int_compare(void *location1, void *location2);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* #ifndef ALGORITHM_COMPARE_INT_H */\n\n/*\n\nCopyright (c) 2016, Stefan Cloudt\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted, provided\nthat the above copyright notice and this permission notice appear\nin all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\nAUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\nCONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n */\n\n/**\n * @file sortedarray.h\n *\n * @brief Automatically sorted and resizing array\n *\n * An SortedArray is an automatically resizing sorted array. Most operations\n * run O(n) worst case running time. Some operations run in O(log n).\n *\n * To retrieve a value use the sortedarray structure by accessing the data\n * field.\n *\n * To create a SortedArray, use @ref sortedarray_new\n * To destroy a SortedArray, use @ref sortedarray_free\n *\n * To add a value to a SortedArray, use @ref sortedarray_prepend, \n * @ref sortedarray_append, or @ref sortedarray_insert.\n *\n * To remove a value from a SortedArray, use @ref sortedarray_remove\n * or @ref sortedarray_remove_range.\n */\n\n#ifndef ALGORITHM_SORTEDARRAY_H\n#define ALGORITHM_SORTEDARRAY_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * A value to store in @ref SortedArray.\n */\ntypedef void *SortedArrayValue;\n\n/**\n * A SortedArray structure. Use @ref sortedarray_new to create one.\n *\n * The SortedArray is an automatically resizing array which stores its \n * elements in sorted order. Userdefined functions determine the sorting order.\n * All operations on a SortedArray maintain the sorted property. Most \n * operations are done in O(n) time, but searching can be done in O(log n)\n * worst case.\n *\n * @see sortedarray_new\n */\ntypedef struct _SortedArray SortedArray;\n\n/**\n * Compare two values in a SortedArray to determine if they are equal.\n *\n * @param value1\tThe first value to compare.\n * @param value2\tThe second value to compare.\n * @return\t\tNon-zero if value1 equals value2, zero if they do not\n *\t\t\tequal.\n *\n */\ntypedef int (*SortedArrayEqualFunc)(SortedArrayValue value1,\n                                    SortedArrayValue value2);\n\n/**\n * Compare two values in a SortedArray to determine their order.\n *\n * @param value1\tThe first value to compare.\n * @param value2\tThe second value to compare.\n * @return\t\tLess than zero if value1 is compared smaller than \n * \t\t\tvalue2, zero if they compare equal, or greater than\n * \t\t\tzero if value1 compares greate than value2.\n */\ntypedef int (*SortedArrayCompareFunc)(SortedArrayValue value1,\n                                      SortedArrayValue value2);\n\n/**\n * @brief Function to retrieve element at index i from array\n *\n * @param array\t\t\tThe pointer to the sortedarray to retrieve the element from.\n * @param i\t\t\t\tThe index of the element to retrieve.\n * @return\t\t\t\tThe i-th element of the array, or NULL if array was NULL.\n */\nSortedArrayValue *sortedarray_get(SortedArray *array, unsigned int i);\n\n/**\n * @brief Function to retrieve the length of the SortedArray array.\n *\n * @param array\t\t\tThe array to retrieve the length from.\n * @return\t\t\t\tThe lenght of the SortedArray.\n */\nunsigned int sortedarray_length(SortedArray *array);\n\n/**\n * Allocate a new SortedArray for use.\n *\n * @param length        Indication to the amount of memory that should be \n *                      allocated. If 0 is given, then a default is used.\n * @param equ_func      The function used to determine if two values in the\n *                      SortedArray equal. This may not be NULL.\n * @param cmp_func      The function used to determine the relative order of\n *                      two values in the SortedArray. This may not be NULL.\n *\n * @return              A new SortedArray or NULL if it was not possible to\n *                      allocate one.\n */\nSortedArray *sortedarray_new(unsigned int length, \n                             SortedArrayEqualFunc equ_func, \n                             SortedArrayCompareFunc cmp_func);\n\n/**\n * Frees a SortedArray from memory.\n *\n * @param sortedarray   The SortedArray to free.\n */\nvoid sortedarray_free(SortedArray *sortedarray);\n\n/**\n * Remove a value from a SortedArray at a specified index while maintaining the\n * sorted property.\n *\n * @param sortedarray   The SortedArray to remove a value from.\n * @param index         The index to remove from the array.\n */\nvoid sortedarray_remove(SortedArray *sortedarray, unsigned int index);\n\n/**\n * Remove a range of entities from a SortedArray while maintaining the sorted \n * property.\n *\n * @param sortedarray   The SortedArray to remove the range of values from.\n * @param index         The starting index of the range to remove.\n * @param length        The length of the range to remove.\n */\nvoid sortedarray_remove_range(SortedArray *sortedarray, unsigned int index,\n                              unsigned int length);\n\n/**\n * Insert a value into a SortedArray while maintaining the sorted property.\n *\n * @param sortedarray   The SortedArray to insert into.\n * @param data          The data to insert.\n *\n * @return              Zero on failure, or a non-zero value if successfull.\n */\nint sortedarray_insert(SortedArray *sortedarray, SortedArrayValue data);\n\n/**\n * Find the index of a value in a SortedArray.\n *\n * @param sortedarray   The SortedArray to find in.\n * @param data          The value to find.\n * @return              The index of the value or -1 if the value is not found.\n */\nint sortedarray_index_of(SortedArray *sortedarray, SortedArrayValue data);\n\n/**\n * Remove all values from a SortedArray.\n *\n * @param sortedarray   The SortedArray to clear.\n */\nvoid sortedarray_clear(SortedArray *sortedarray);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif // #ifndef ALGORITHM_SORTEDARRAY_H\n\n_Atomic size_t num_assert = 0;\n#undef assert\n#define assert(expr)                                                           \\\n  num_assert += 1;                                                             \\\n  ((void)sizeof((expr) ? 1 : 0), __extension__({                               \\\n     if (expr)                                                                 \\\n       ; /* empty */                                                           \\\n     else                                                                      \\\n       __assert_fail(#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);            \\\n   }))\n\n#define TEST_SIZE 20\n#define TEST_ARRAY {10, 12, 12, 1, 2, 3, 6, 7, 2, 23, 13, 23, 23, 34, 31, 9,\\\n   \t21, -2, -12, -4}\n#define TEST_REMOVE_EL 15\n#define TEST_REMOVE_RANGE 7\n#define TEST_REMOVE_RANGE_LENGTH 4\n\n\t\t\t\t\t\t   sortedarray_get(sortedarray, i)) <= 0);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\nstatic UnitTestFunction tests[] = {\n\ttest_sortedarray_new_free,\n\ttest_sortedarray_insert,\n\ttest_sortedarray_remove,\n\ttest_sortedarray_remove_range,\n\ttest_sortedarray_index_of,\n\ttest_sortedarray_index_of_equ_key,\n\ttest_sortedarray_get,\n\tNULL   \n};\n\n]"
}