{
    "quadtree_search": "quadtree_search(quadtree_t *tree, double x, double y) {\n  return find_(tree->root, x, y);\n}\n",
    "quadtree_bounds_new": "quadtree_bounds_new(void){\n  quadtree_bounds_t *bounds;\n  if((bounds = malloc(sizeof(*bounds))) == NULL)\n    return NULL;\n  bounds->nw     = quadtree_point_new(INFINITY, -INFINITY);\n  bounds->se     = quadtree_point_new(-INFINITY, INFINITY);\n  bounds->width  = 0;\n  bounds->height = 0;\n  return bounds;\n}\n",
    "split_node_": "split_node_(quadtree_t *tree, quadtree_node_t *node){\n  quadtree_node_t *nw;\n  quadtree_node_t *ne;\n  quadtree_node_t *sw;\n  quadtree_node_t *se;\n  quadtree_point_t *old;\n  void *key;\n\n  double x  = node->bounds->nw->x;\n  double y  = node->bounds->nw->y;\n  double hw = node->bounds->width / 2;\n  double hh = node->bounds->height / 2;\n\n                                    //minx,   miny,       maxx,       maxy\n  if(!(nw = quadtree_node_with_bounds(x,      y - hh,     x + hw,     y))) return 0;\n  if(!(ne = quadtree_node_with_bounds(x + hw, y - hh,     x + hw * 2, y))) return 0;\n  if(!(sw = quadtree_node_with_bounds(x,      y - hh * 2, x + hw,     y - hh))) return 0;\n  if(!(se = quadtree_node_with_bounds(x + hw, y - hh * 2, x + hw * 2, y - hh))) return 0;\n\n  node->nw = nw;\n  node->ne = ne;\n  node->sw = sw;\n  node->se = se;\n\n  old = node->point;\n  key   = node->key;\n  node->point = NULL;\n  node->key   = NULL;\n\n  return insert_(tree, node, old, key);\n}\n",
    "quadtree_bounds_free": "quadtree_bounds_free(quadtree_bounds_t *bounds){\n  quadtree_point_free(bounds->nw);\n  quadtree_point_free(bounds->se);\n  free(bounds);\n}\n",
    "quadtree_new": "quadtree_new(double minx, double miny, double maxx, double maxy) {\n  quadtree_t *tree;\n  if(!(tree = malloc(sizeof(*tree))))\n    return NULL;\n  tree->root = quadtree_node_with_bounds(minx, miny, maxx, maxy);\n  if(!(tree->root))\n    return NULL;\n  tree->key_free = NULL;\n  tree->length = 0;\n  return tree;\n}\n",
    "find_": "find_(quadtree_node_t* node, double x, double y) {\n  if(!node){\n    return NULL;\n  }\n  if(quadtree_node_isleaf(node)){\n    if(node->point->x == x && node->point->y == y)\n      return node->point;\n  } else if(quadtree_node_ispointer(node)){\n    quadtree_point_t test;\n    test.x = x;\n    test.y = y;\n    return find_(get_quadrant_(node, &test), x, y);\n  }\n\n  return NULL;\n}\n",
    "quadtree_point_new": "quadtree_point_new(double x, double y) {\n  quadtree_point_t* point;\n  if(!(point = malloc(sizeof(*point))))\n    return NULL;\n  point->x = x;\n  point->y = y;\n  return point;\n}\n",
    "quadtree_node_new": "quadtree_node_new(void) {\n  quadtree_node_t *node;\n  if(!(node = malloc(sizeof(*node))))\n    return NULL;\n  node->ne     = NULL;\n  node->nw     = NULL;\n  node->se     = NULL;\n  node->sw     = NULL;\n  node->point  = NULL;\n  node->bounds = NULL;\n  node->key    = NULL;\n  return node;\n}\n",
    "quadtree_node_isempty": "quadtree_node_isempty(quadtree_node_t *node){\n  return node->nw == NULL\n      && node->ne == NULL\n      && node->sw == NULL\n      && node->se == NULL\n      && !quadtree_node_isleaf(node);\n}\n",
    "quadtree_node_with_bounds": "quadtree_node_with_bounds(double minx, double miny, double maxx, double maxy){\n  quadtree_node_t* node;\n  if(!(node = quadtree_node_new())) return NULL;\n  if(!(node->bounds = quadtree_bounds_new())) return NULL;\n  quadtree_bounds_extend(node->bounds, maxx, maxy);\n  quadtree_bounds_extend(node->bounds, minx, miny);\n  return node;\n}\n",
    "quadtree_node_reset": "quadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*)) {\n  quadtree_point_free(node->point);\n  (*key_free)(node->key);\n}\n",
    "node_contains_": "node_contains_(quadtree_node_t *outer, quadtree_point_t *it) {\n  return outer->bounds != NULL\n      && outer->bounds->nw->x <= it->x\n      && outer->bounds->nw->y >= it->y\n      && outer->bounds->se->x >= it->x\n      && outer->bounds->se->y <= it->y;\n}\n",
    "quadtree_node_isleaf": "quadtree_node_isleaf(quadtree_node_t *node){\n  return node->point != NULL;\n}\n",
    "quadtree_node_free": "quadtree_node_free(quadtree_node_t* node, void (*key_free)(void*)) {\n  if(node->nw != NULL) quadtree_node_free(node->nw, key_free);\n  if(node->ne != NULL) quadtree_node_free(node->ne, key_free);\n  if(node->sw != NULL) quadtree_node_free(node->sw, key_free);\n  if(node->se != NULL) quadtree_node_free(node->se, key_free);\n\n  quadtree_bounds_free(node->bounds);\n  quadtree_node_reset(node, key_free);\n  free(node);\n}\n",
    "quadtree_insert": "quadtree_insert(quadtree_t *tree, double x, double y, void *key) {\n  quadtree_point_t *point;\n  int insert_status;\n\n  if(!(point = quadtree_point_new(x, y))) return 0;\n  if(!node_contains_(tree->root, point)){\n    quadtree_point_free(point);\n    return 0;\n  }\n  \n  if(!(insert_status = insert_(tree, tree->root, point, key))){\n    quadtree_point_free(point);\n    return 0;\n  }\n  if (insert_status == 1) tree->length++;\n  return insert_status;\n}\n",
    "quadtree_free": "quadtree_free(quadtree_t *tree) {\n  if(tree->key_free != NULL) {\n    quadtree_node_free(tree->root, tree->key_free);\n  } else {\n    quadtree_node_free(tree->root, elision_);\n  }\n  free(tree);\n}\n",
    "insert_": "insert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key) {\n  if(quadtree_node_isempty(root)){\n    root->point = point;\n    root->key   = key;\n    return 1; /* normal insertion flag */\n  } else if(quadtree_node_isleaf(root)){\n    if(root->point->x == point->x && root->point->y == point->y){\n      reset_node_(tree, root);\n      root->point = point;\n      root->key   = key;\n      return 2; /* replace insertion flag */\n    } else {\n      if(!split_node_(tree, root)){\n        return 0; /* failed insertion flag */\n      }\n      return insert_(tree, root, point, key);\n    }\n  } else if(quadtree_node_ispointer(root)){\n    quadtree_node_t* quadrant = get_quadrant_(root, point);\n    return quadrant == NULL ? 0 : insert_(tree, quadrant, point, key);\n  }\n  return 0;\n}\n",
    "reset_node_": "reset_node_(quadtree_t *tree, quadtree_node_t *node){\n  if(tree->key_free != NULL) {\n    quadtree_node_reset(node, tree->key_free);\n  } else {\n    quadtree_node_reset(node, elision_);\n  }\n",
    "elision_": "elision_(void* key){}\n",
    "get_quadrant_": "get_quadrant_(quadtree_node_t *root, quadtree_point_t *point) {\n  if(node_contains_(root->nw, point)) return root->nw;\n  if(node_contains_(root->ne, point)) return root->ne;\n  if(node_contains_(root->sw, point)) return root->sw;\n  if(node_contains_(root->se, point)) return root->se;\n  return NULL;\n}\n",
    "quadtree_bounds_extend": "quadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y){\n  bounds->nw->x = fmin(x, bounds->nw->x);\n  bounds->nw->y = fmax(y, bounds->nw->y);\n  bounds->se->x = fmax(x, bounds->se->x);\n  bounds->se->y = fmin(y, bounds->se->y);\n  bounds->width  = fabs(bounds->nw->x - bounds->se->x);\n  bounds->height = fabs(bounds->nw->y - bounds->se->y);\n}\n",
    "quadtree_walk": "quadtree_walk(quadtree_node_t *root, void (*descent)(quadtree_node_t *node),\n                                     void (*ascent)(quadtree_node_t *node)) {\n  (*descent)(root);\n  if(root->nw != NULL) quadtree_walk(root->nw, descent, ascent);\n  if(root->ne != NULL) quadtree_walk(root->ne, descent, ascent);\n  if(root->sw != NULL) quadtree_walk(root->sw, descent, ascent);\n  if(root->se != NULL) quadtree_walk(root->se, descent, ascent);\n  (*ascent)(root);\n}\n",
    "quadtree_point_free": "quadtree_point_free(quadtree_point_t *point){\n  free(point);\n}\n",
    "quadtree_node_ispointer": "quadtree_node_ispointer(quadtree_node_t *node){\n  return node->nw != NULL\n      && node->ne != NULL\n      && node->sw != NULL\n      && node->se != NULL\n      && !quadtree_node_isleaf(node);\n}\n",
    "extra": "{'INFINITY': '  #define INFINITY DBL_MAX', 'QUADTREE_VERSION': '#define QUADTREE_VERSION \"0.0.1\"', '__QUADTREE_H__': '#define __QUADTREE_H__', 'fmax': '  #define fmax(a,b) (((a)>(b))?(a):(b))', 'fmin': '  #define fmin(a,b) (((a)<(b))?(a):(b))', 'quadtree_bounds_t': '} quadtree_bounds_t;', 'quadtree_node_t': '} quadtree_node_t;', 'quadtree_point_t': '} quadtree_point_t;', 'quadtree_t': '} quadtree_t;'} extract_info: [#ifndef __QUADTREE_H__\n#define __QUADTREE_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define QUADTREE_VERSION \"0.0.1\"\n\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct quadtree_point {\n  double x;\n  double y;\n} quadtree_point_t;\n\ntypedef struct quadtree_bounds {\n  quadtree_point_t *nw;\n  quadtree_point_t *se;\n  double width;\n  double height;\n} quadtree_bounds_t;\n\ntypedef struct quadtree_node {\n  struct quadtree_node *ne;\n  struct quadtree_node *nw;\n  struct quadtree_node *se;\n  struct quadtree_node *sw;\n  quadtree_bounds_t *bounds;\n  quadtree_point_t  *point;\n  void *key;\n} quadtree_node_t;\n\ntypedef struct quadtree {\n  quadtree_node_t *root;\n  void (*key_free)(void *key);\n  unsigned int length;\n} quadtree_t;\n\n\nquadtree_point_t*\nquadtree_point_new(double x, double y);\n\nvoid\nquadtree_point_free(quadtree_point_t *point);\n\n\nquadtree_bounds_t*\nquadtree_bounds_new(void);\n\nvoid\nquadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y);\n\nvoid\nquadtree_bounds_free(quadtree_bounds_t *bounds);\n\n\nquadtree_node_t*\nquadtree_node_new(void);\n\nvoid\nquadtree_node_free(quadtree_node_t *node, void (*value_free)(void*));\n\nint\nquadtree_node_ispointer(quadtree_node_t *node);\n\nint\nquadtree_node_isempty(quadtree_node_t *node);\n\nint\nquadtree_node_isleaf(quadtree_node_t *node);\n\nvoid\nquadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*));\n\nquadtree_node_t*\nquadtree_node_with_bounds(double minx, double miny, double maxx, double maxy);\n\nquadtree_t*\nquadtree_new(double minx, double miny, double maxx, double maxy);\n\nvoid\nquadtree_free(quadtree_t *tree);\n\nquadtree_point_t*\nquadtree_search(quadtree_t *tree, double x, double y);\n\nint\nquadtree_insert(quadtree_t *tree, double x, double y, void *key);\n\nvoid\nquadtree_walk(quadtree_node_t *root,\n              void (*descent)(quadtree_node_t *node),\n              void (*ascent)(quadtree_node_t *node));\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n#include <stdio.h>\n\n/* private prototypes */\nstatic int\nsplit_node_(quadtree_t *tree, quadtree_node_t *node);\n\nstatic int\ninsert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key);\n\nstatic int\nnode_contains_(quadtree_node_t *outer, quadtree_point_t *it);\n\nstatic quadtree_node_t *\nget_quadrant_(quadtree_node_t *root, quadtree_point_t *point);\n\n/* private implementations */\nstatic int\n\nstatic void\n\nstatic void\n}\n\nstatic quadtree_node_t *\n\n\nstatic int\n\n\nstatic quadtree_point_t*\n\n/* cribbed from the google closure library. */\nstatic int\n\n\n/* public */\nquadtree_t*\n\nint\n\nquadtree_point_t*\n\nvoid\n\nvoid\n\n\n\n\n#ifndef INFINITY\n  // no infinity defined? high chance we are compiling as c89\n  #include <float.h>\n  #include <math.h>\n  #define INFINITY DBL_MAX\n  #define fmin(a,b) (((a)<(b))?(a):(b))\n  #define fmax(a,b) (((a)>(b))?(a):(b))\n#endif\n\n\n\nvoid\n\nvoid\n\n\nquadtree_bounds_t*\n\n\n\n/* helpers */\n\nint\n\nint\n\nint\n\nvoid\n\n/* api */\nquadtree_node_t*\n\nquadtree_node_t*\n\nvoid\n\n\nquadtree_point_t*\n\nvoid\n]"
}