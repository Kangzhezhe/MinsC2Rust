{
    "test_tree": "test_tree(void){\n  int val = 10;\n\n  quadtree_t *tree = quadtree_new(1, 1, 10, 10);\n  assert(tree->root->bounds->nw->x == 1);\n  assert(tree->root->bounds->nw->y == 10.0);\n  assert(tree->root->bounds->se->x == 10.0);\n  assert(tree->root->bounds->se->y == 1);\n\n\n  assert(quadtree_insert(tree, 0, 0, &val) == 0);\n  assert(quadtree_insert(tree, 110.0, 110.0, &val) == 0);\n\n  assert(quadtree_insert(tree, 8.0, 2.0, &val) != 0);\n  assert(tree->length == 1);\n  assert(tree->root->point->x == 8.0);\n  assert(tree->root->point->y == 2.0);\n\n  assert(quadtree_insert(tree, 0.0, 1.0, &val) == 0); /* failed insertion */\n  assert(quadtree_insert(tree, 2.0, 3.0, &val) == 1); /* normal insertion */\n  assert(quadtree_insert(tree, 2.0, 3.0, &val) == 2); /* replacement insertion */\n  assert(tree->length == 2);\n  assert(tree->root->point == NULL);\n\n  assert(quadtree_insert(tree, 3.0, 1.1, &val) == 1);\n  assert(tree->length == 3);\n  assert(quadtree_search(tree, 3.0, 1.1)->x == 3.0);\n  quadtree_walk(tree->root, ascent, descent);\n  quadtree_free(tree);\n}\n",
    "main": "main(int argc, const char *argv[]){\n  test(tree);\n  test(node);\n  test(bounds);\n  test(points);\n}\n",
    "test_node": "test_node(void){\n  quadtree_node_t *node = quadtree_node_new();\n  assert(!quadtree_node_isleaf(node));\n  assert(quadtree_node_isempty(node));\n  assert(!quadtree_node_ispointer(node));\n  free(node);\n}\n",
    "descent": "void descent(quadtree_node_t *node){}\n",
    "test_bounds": "test_bounds(void){\n  quadtree_bounds_t *bounds = quadtree_bounds_new();\n\n  assert(bounds);\n  assert(bounds->nw->x == INFINITY);\n  assert(bounds->se->x == -INFINITY);\n\n  quadtree_bounds_extend(bounds, 5.0, 5.0);\n  assert(bounds->nw->x == 5.0);\n  assert(bounds->se->x == 5.0);\n\n  quadtree_bounds_extend(bounds, 10.0, 10.0);\n  assert(bounds->nw->y == 10.0);\n  assert(bounds->nw->y == 10.0);\n  assert(bounds->se->y == 5.0);\n  assert(bounds->se->y == 5.0);\n\n  assert(bounds->width == 5.0);\n  assert(bounds->height == 5.0);\n\n  quadtree_bounds_free(bounds);\n}\n",
    "test_points": "test_points(void){\n  quadtree_point_t *point = quadtree_point_new(5, 6);\n  assert(point->x == 5);\n  assert(point->y == 6);\n  quadtree_point_free(point);\n}\n",
    "ascent": "void ascent(quadtree_node_t *node){}\n",
    "extra": "{'QUADTREE_VERSION': '#define QUADTREE_VERSION \"0.0.1\"', '__QUADTREE_H__': '#define __QUADTREE_H__', 'test': '#define test(fn) \\\\', 'quadtree_bounds_t': '} quadtree_bounds_t;', 'quadtree_node_t': '} quadtree_node_t;', 'quadtree_point_t': '} quadtree_point_t;', 'quadtree_t': '} quadtree_t;'} extract_info: [#include <assert.h>\n#include <stdio.h>\n\n#ifndef __QUADTREE_H__\n#define __QUADTREE_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define QUADTREE_VERSION \"0.0.1\"\n\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct quadtree_point {\n  double x;\n  double y;\n} quadtree_point_t;\n\ntypedef struct quadtree_bounds {\n  quadtree_point_t *nw;\n  quadtree_point_t *se;\n  double width;\n  double height;\n} quadtree_bounds_t;\n\ntypedef struct quadtree_node {\n  struct quadtree_node *ne;\n  struct quadtree_node *nw;\n  struct quadtree_node *se;\n  struct quadtree_node *sw;\n  quadtree_bounds_t *bounds;\n  quadtree_point_t  *point;\n  void *key;\n} quadtree_node_t;\n\ntypedef struct quadtree {\n  quadtree_node_t *root;\n  void (*key_free)(void *key);\n  unsigned int length;\n} quadtree_t;\n\n\nquadtree_point_t*\nquadtree_point_new(double x, double y);\n\nvoid\nquadtree_point_free(quadtree_point_t *point);\n\n\nquadtree_bounds_t*\nquadtree_bounds_new(void);\n\nvoid\nquadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y);\n\nvoid\nquadtree_bounds_free(quadtree_bounds_t *bounds);\n\n\nquadtree_node_t*\nquadtree_node_new(void);\n\nvoid\nquadtree_node_free(quadtree_node_t *node, void (*value_free)(void*));\n\nint\nquadtree_node_ispointer(quadtree_node_t *node);\n\nint\nquadtree_node_isempty(quadtree_node_t *node);\n\nint\nquadtree_node_isleaf(quadtree_node_t *node);\n\nvoid\nquadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*));\n\nquadtree_node_t*\nquadtree_node_with_bounds(double minx, double miny, double maxx, double maxy);\n\nquadtree_t*\nquadtree_new(double minx, double miny, double maxx, double maxy);\n\nvoid\nquadtree_free(quadtree_t *tree);\n\nquadtree_point_t*\nquadtree_search(quadtree_t *tree, double x, double y);\n\nint\nquadtree_insert(quadtree_t *tree, double x, double y, void *key);\n\nvoid\nquadtree_walk(quadtree_node_t *root,\n              void (*descent)(quadtree_node_t *node),\n              void (*ascent)(quadtree_node_t *node));\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#define test(fn) \\\n        printf(\"\\x1b[33m\" # fn \"\\x1b[0m \"); \\\n        test_##fn(); \\\n        puts(\"\\x1b[1;32m\u2713\\x1b[0m\");\n\n\n\n\n\nstatic void\n\nstatic void\n\n\nstatic void\n\nstatic void\n\nint\n]"
}