{
    "test-quadtree": {
        "test_tree": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct QuadtreePoint {\n    pub x: f64,\n    pub y: f64,\n}\n\npub struct QuadtreeNode<T> {\n    pub ne: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub nw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub se: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub sw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub bounds: Option<Rc<RefCell<QuadtreeBounds>>>,\n    pub point: Option<Rc<RefCell<QuadtreePoint>>>,\n    pub key: Option<T>,\n}\n\npub struct QuadtreeBounds {\n    pub nw: Rc<RefCell<QuadtreePoint>>,\n    pub se: Rc<RefCell<QuadtreePoint>>,\n    pub width: f64,\n    pub height: f64,\n}\n\npub struct Quadtree<T> {\n    pub key_free: Option<fn(T)>,\n    pub root: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n}\n\npub struct quadtree_node_t {\n    ne: Option<Rc<RefCell<quadtree_node_t>>>,\n    nw: Option<Rc<RefCell<quadtree_node_t>>>,\n    se: Option<Rc<RefCell<quadtree_node_t>>>,\n    sw: Option<Rc<RefCell<quadtree_node_t>>>,\n}\n\n\n\npub fn quadtree_new<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Quadtree<T>> {\n    let root = quadtree_node_with_bounds::<T>(minx, miny, maxx, maxy)?;\n    let tree = Quadtree {\n        key_free: None,\n        root: Some(root),\n    };\n    Some(tree)\n}\n\n\npub fn quadtree_insert<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64, key: T) -> i32 {\n    let point = quadtree_point_new(x, y);\n    if point.is_none() {\n        return 0;\n    }\n    let point_rc = Rc::new(RefCell::new(point.unwrap()));\n    if !node_contains_(tree.borrow().root.as_ref().unwrap().clone(), point_rc.clone()) {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    let insert_status = insert_(tree.clone(), tree.borrow().root.as_ref().unwrap().clone(), Some(point_rc.clone()), Some(key));\n    if insert_status == 0 {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    if insert_status == 1 {\n        let mut tree_mut = tree.borrow_mut();\n        // Assuming length is a field in Quadtree struct\n        // If not, you need to add it\n        // tree_mut.length += 1;\n    }\n    insert_status\n}\n\n\npub fn quadtree_point_free(point: Rc<RefCell<QuadtreePoint>>) {\n    // 释放 QuadtreePoint 的内存\n    // 由于 Rc<RefCell<T>> 是智能指针，无需手动释放内存\n}\n\n\npub fn quadtree_node_new<T>() -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = QuadtreeNode {\n        ne: None,\n        nw: None,\n        se: None,\n        sw: None,\n        bounds: None,\n        point: None,\n        key: None,\n    };\n    Some(Rc::new(RefCell::new(node)))\n}\n\n\npub fn quadtree_node_reset<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(point) = &node_borrow.point {\n        quadtree_point_free(point.clone());\n    }\n    if let Some(key) = node_borrow.key.take() {\n        key_free(key);\n    }\n}\n\n\npub fn quadtree_search<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    let tree_ref = tree.borrow();\n    find_(tree_ref.root.clone(), x, y)\n}\n\n\npub fn quadtree_point_new(x: f64, y: f64) -> Option<QuadtreePoint> {\n    Some(QuadtreePoint { x, y })\n}\n\n\npub fn quadtree_node_with_bounds<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = quadtree_node_new()?;\n    let bounds = quadtree_bounds_new()?;\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.bounds = Some(bounds.clone());\n    }\n    quadtree_bounds_extend(bounds.clone(), maxx, maxy);\n    quadtree_bounds_extend(bounds.clone(), minx, miny);\n    Some(node)\n}\n\n\npub fn reset_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) {\n    let key_free = tree.borrow().key_free.clone();\n    if let Some(key_free) = key_free {\n        quadtree_node_reset(node, key_free);\n    } else {\n        let elision_wrap = |key: T| { elision_(key); };\n        quadtree_node_reset(node, elision_wrap);\n    }\n}\n\n\npub fn node_contains_<T>(outer: Rc<RefCell<QuadtreeNode<T>>>, it: Rc<RefCell<QuadtreePoint>>) -> bool {\n    let outer = outer.borrow();\n    let it = it.borrow();\n    if let Some(bounds) = &outer.bounds {\n        let bounds = bounds.borrow();\n        bounds.nw.borrow().x <= it.x &&\n        bounds.nw.borrow().y >= it.y &&\n        bounds.se.borrow().x >= it.x &&\n        bounds.se.borrow().y <= it.y\n    } else {\n        false\n    }\n}\n\n\npub fn quadtree_bounds_extend(bounds: Rc<RefCell<QuadtreeBounds>>, x: f64, y: f64) {\n    let nw_x;\n    let nw_y;\n    let se_x;\n    let se_y;\n    {\n        let bounds = bounds.borrow();\n        let nw = bounds.nw.borrow();\n        let se = bounds.se.borrow();\n        nw_x = f64::min(x, nw.x);\n        nw_y = f64::max(y, nw.y);\n        se_x = f64::max(x, se.x);\n        se_y = f64::min(y, se.y);\n    }\n    {\n        let mut bounds = bounds.borrow_mut();\n        bounds.width = (nw_x - se_x).abs();\n        bounds.height = (nw_y - se_y).abs();\n    }\n}\n\n\npub fn quadtree_free<T>(tree: Rc<RefCell<Quadtree<T>>>) {\n    let tree_borrow = tree.borrow();\n    if let Some(key_free) = tree_borrow.key_free {\n        if let Some(root) = &tree_borrow.root {\n            quadtree_node_free(Rc::clone(root), key_free);\n        }\n    } else {\n        if let Some(root) = &tree_borrow.root {\n            fn elision_wrap<T>(key: T) {\n                elision_(key);\n            }\n            quadtree_node_free(Rc::clone(root), elision_wrap);\n        }\n    }\n}\n\n\npub fn get_quadrant_<T>(root: Rc<RefCell<QuadtreeNode<T>>>, point: Rc<RefCell<QuadtreePoint>>) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let root = root.borrow();\n    if let Some(nw) = &root.nw {\n        if node_contains_(nw.clone(), point.clone()) {\n            return Some(nw.clone());\n        }\n    }\n    if let Some(ne) = &root.ne {\n        if node_contains_(ne.clone(), point.clone()) {\n            return Some(ne.clone());\n        }\n    }\n    if let Some(sw) = &root.sw {\n        if node_contains_(sw.clone(), point.clone()) {\n            return Some(sw.clone());\n        }\n    }\n    if let Some(se) = &root.se {\n        if node_contains_(se.clone(), point.clone()) {\n            return Some(se.clone());\n        }\n    }\n    None\n}\n\n\npub fn insert_<T>(\n    tree: Rc<RefCell<Quadtree<T>>>,\n    root: Rc<RefCell<QuadtreeNode<T>>>,\n    point: Option<Rc<RefCell<QuadtreePoint>>>,\n    key: Option<T>,\n) -> i32 {\n    if quadtree_node_isempty(&root) {\n        {\n            let mut root_mut = root.borrow_mut();\n            root_mut.point = point;\n            root_mut.key = key;\n        }\n        return 1; // normal insertion flag\n    } else if quadtree_node_isleaf(&root) {\n        let root_point = root.borrow().point.as_ref().unwrap().clone();\n        let point_ref = point.as_ref().unwrap().clone();\n        let root_point_borrow = root_point.borrow();\n        let point_ref_borrow = point_ref.borrow();\n        if root_point_borrow.x == point_ref_borrow.x && root_point_borrow.y == point_ref_borrow.y {\n            reset_node_(tree.clone(), root.clone());\n            {\n                let mut root_mut = root.borrow_mut();\n                root_mut.point = point;\n                root_mut.key = key;\n            }\n            return 2; // replace insertion flag\n        } else {\n            if !split_node_(tree.clone(), root.clone()) {\n                return 0; // failed insertion flag\n            }\n            return insert_(tree, root, point, key);\n        }\n    } else if quadtree_node_ispointer(&root) {\n        let quadrant = get_quadrant_(root.clone(), point.as_ref().unwrap().clone());\n        if quadrant.is_none() {\n            return 0;\n        }\n        return insert_(tree, quadrant.unwrap(), point, key);\n    }\n    0\n}\n\n\npub fn quadtree_bounds_new() -> Option<Rc<RefCell<QuadtreeBounds>>> {\n    let nw = Rc::new(RefCell::new(QuadtreePoint { x: f64::INFINITY, y: -f64::INFINITY }));\n    let se = Rc::new(RefCell::new(QuadtreePoint { x: -f64::INFINITY, y: f64::INFINITY }));\n    let bounds = QuadtreeBounds {\n        nw,\n        se,\n        width: 0.0,\n        height: 0.0,\n    };\n    Some(Rc::new(RefCell::new(bounds)))\n}\n\n\npub fn quadtree_node_free<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(nw) = node_borrow.nw.take() {\n        quadtree_node_free(nw, key_free);\n    }\n    if let Some(ne) = node_borrow.ne.take() {\n        quadtree_node_free(ne, key_free);\n    }\n    if let Some(sw) = node_borrow.sw.take() {\n        quadtree_node_free(sw, key_free);\n    }\n    if let Some(se) = node_borrow.se.take() {\n        quadtree_node_free(se, key_free);\n    }\n    if let Some(bounds) = node_borrow.bounds.take() {\n        quadtree_bounds_free(bounds);\n    }\n    quadtree_node_reset(Rc::clone(&node), key_free);\n}\n\n\npub fn elision_<T>(key: T) -> T {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    key\n}\n\n\npub fn descent(node: Rc<RefCell<quadtree_node_t>>) {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    let mut node = node.borrow_mut();\n    if let Some(ne) = &node.ne {\n        descent(Rc::clone(ne));\n    }\n    if let Some(nw) = &node.nw {\n        descent(Rc::clone(nw));\n    }\n    if let Some(se) = &node.se {\n        descent(Rc::clone(se));\n    }\n    if let Some(sw) = &node.sw {\n        descent(Rc::clone(sw));\n    }\n}\n\n\npub fn quadtree_bounds_free(bounds: Rc<RefCell<QuadtreeBounds>>) {\n    // 释放 QuadtreeBounds 的内存\n    // 由于 Rc<RefCell<T>> 是智能指针，无需手动释放内存\n    let bounds = bounds.borrow();\n    quadtree_point_free(Rc::clone(&bounds.nw));\n    quadtree_point_free(Rc::clone(&bounds.se));\n}\n\n\npub fn quadtree_walk<T>(root: Option<Rc<RefCell<QuadtreeNode<T>>>>, descent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>), ascent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>)) {\n    descent(root.clone());\n    if let Some(node) = &root {\n        let node_ref = node.borrow();\n        if let Some(nw) = &node_ref.nw {\n            quadtree_walk(Some(nw.clone()), descent, ascent);\n        }\n        if let Some(ne) = &node_ref.ne {\n            quadtree_walk(Some(ne.clone()), descent, ascent);\n        }\n        if let Some(sw) = &node_ref.sw {\n            quadtree_walk(Some(sw.clone()), descent, ascent);\n        }\n        if let Some(se) = &node_ref.se {\n            quadtree_walk(Some(se.clone()), descent, ascent);\n        }\n    }\n    ascent(root);\n}\n\n\npub fn find_<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        if quadtree_node_isleaf(&node) {\n            if let Some(point) = &node_ref.point {\n                let point_ref = point.borrow();\n                if point_ref.x == x && point_ref.y == y {\n                    return Some(point.clone());\n                }\n            }\n        } else if quadtree_node_ispointer(&node) {\n            let test = Rc::new(RefCell::new(QuadtreePoint { x, y }));\n            return find_(get_quadrant_(node.clone(), test), x, y);\n        }\n    }\n    None\n}\n\n\npub fn ascent<T>(node: Rc<RefCell<QuadtreeNode<T>>>) {\n// 注意：该函数不允许修改，因为工程中其他文件中的函数也调用了他们，如果修改了，会影响其他文件内函数的功能，只允许调用该函数\n    // Function implementation\n}\n\n\npub fn quadtree_node_ispointer<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_some()\n        && node_ref.ne.is_some()\n        && node_ref.sw.is_some()\n        && node_ref.se.is_some()\n        && !quadtree_node_isleaf(node)\n}\n\n\npub fn quadtree_node_isempty<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_none()\n        && node_ref.ne.is_none()\n        && node_ref.sw.is_none()\n        && node_ref.se.is_none()\n        && !quadtree_node_isleaf(node)\n}\n\n\npub fn quadtree_node_isleaf<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    node.borrow().point.is_some()\n}\n\n\npub fn split_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let x;\n    let y;\n    let hw;\n    let hh;\n    {\n        let node_borrow = node.borrow();\n        let bounds = node_borrow.bounds.as_ref().unwrap().borrow();\n        x = bounds.nw.borrow().x;\n        y = bounds.nw.borrow().y;\n        hw = bounds.width / 2.0;\n        hh = bounds.height / 2.0;\n    }\n\n    let nw = quadtree_node_with_bounds::<T>(x, y - hh, x + hw, y);\n    let ne = quadtree_node_with_bounds::<T>(x + hw, y - hh, x + hw * 2.0, y);\n    let sw = quadtree_node_with_bounds::<T>(x, y - hh * 2.0, x + hw, y - hh);\n    let se = quadtree_node_with_bounds::<T>(x + hw, y - hh * 2.0, x + hw * 2.0, y - hh);\n\n    if nw.is_none() || ne.is_none() || sw.is_none() || se.is_none() {\n        return false;\n    }\n\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.nw = Some(nw.unwrap());\n        node_mut.ne = Some(ne.unwrap());\n        node_mut.sw = Some(sw.unwrap());\n        node_mut.se = Some(se.unwrap());\n    }\n\n    let old_point;\n    let old_key;\n    {\n        let mut node_mut = node.borrow_mut();\n        old_point = node_mut.point.take();\n        old_key = node_mut.key.take();\n    }\n\n    insert_(tree.clone(), node, old_point, old_key) != 0\n}\n\n\npub fn test_tree() {\n    let val = 10;\n\n    let tree = quadtree_new::<i32>(1.0, 1.0, 10.0, 10.0).unwrap();\n    let tree_rc = Rc::new(RefCell::new(tree));\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        let bounds = root.bounds.as_ref().unwrap().borrow();\n        assert_eq!(bounds.nw.borrow().x, 1.0);\n        assert_eq!(bounds.nw.borrow().y, 10.0);\n        assert_eq!(bounds.se.borrow().x, 10.0);\n        assert_eq!(bounds.se.borrow().y, 1.0);\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 0.0, 0.0, val), 0);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 110.0, 110.0, val), 0);\n\n    assert_ne!(quadtree_insert(tree_rc.clone(), 8.0, 2.0, val), 0);\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        let point = root.point.as_ref().unwrap().borrow();\n        assert_eq!(point.x, 8.0);\n        assert_eq!(point.y, 2.0);\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 0.0, 1.0, val), 0);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 2.0, 3.0, val), 1);\n    assert_eq!(quadtree_insert(tree_rc.clone(), 2.0, 3.0, val), 2);\n    {\n        let tree_ref = tree_rc.borrow();\n        let root = tree_ref.root.as_ref().unwrap().borrow();\n        assert!(root.point.is_none());\n    }\n\n    assert_eq!(quadtree_insert(tree_rc.clone(), 3.0, 1.1, val), 1);\n    {\n        let point = quadtree_search(tree_rc.clone(), 3.0, 1.1).unwrap();\n        let point_ref = point.borrow();\n        assert_eq!(point_ref.x, 3.0);\n    }\n\n    fn ascent_wrap<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>) {\n        if let Some(node) = node {\n            ascent(node);\n        }\n    }\n\n    fn descent_wrap<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>) {\n        if let Some(node) = node {\n            let node_t = Rc::new(RefCell::new(quadtree_node_t {\n                ne: None,\n                nw: None,\n                se: None,\n                sw: None,\n            }));\n            descent(node_t);\n        }\n    }\n\n    quadtree_walk(tree_rc.borrow().root.clone(), ascent_wrap, descent_wrap);\n    quadtree_free(tree_rc);\n}\n\nfn main(){}\n\n\n //编译报错信息："
    }
}