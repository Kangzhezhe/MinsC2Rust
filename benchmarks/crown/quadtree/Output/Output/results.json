{
    "quadtree": {
        "quadtree_point_new": "pub fn quadtree_point_new(x: f64, y: f64) -> Option<QuadtreePoint> {\n    Some(QuadtreePoint { x, y })\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct QuadtreePoint {\n    pub x: f64,\n    pub y: f64,\n}\n\npub struct QuadtreeNode<T> {\n    pub ne: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub nw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub se: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub sw: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n    pub bounds: Option<Rc<RefCell<QuadtreeBounds>>>,\n    pub point: Option<Rc<RefCell<QuadtreePoint>>>,\n    pub key: Option<T>,\n}\n\npub struct QuadtreeBounds {\n    pub nw: Rc<RefCell<QuadtreePoint>>,\n    pub se: Rc<RefCell<QuadtreePoint>>,\n    pub width: f64,\n    pub height: f64,\n}\n\npub struct Quadtree<T> {\n    pub key_free: Option<fn(T)>,\n    pub root: Option<Rc<RefCell<QuadtreeNode<T>>>>,\n}\n\npub struct quadtree_node_t {\n    pub ne: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub nw: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub se: Option<Rc<RefCell<quadtree_node_t>>>,\n    pub sw: Option<Rc<RefCell<quadtree_node_t>>>,\n}\n",
        "quadtree_node_new": "pub fn quadtree_node_new<T>() -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = QuadtreeNode {\n        ne: None,\n        nw: None,\n        se: None,\n        sw: None,\n        bounds: None,\n        point: None,\n        key: None,\n    };\n    Some(Rc::new(RefCell::new(node)))\n}\n\n",
        "quadtree_bounds_extend": "pub fn quadtree_bounds_extend(bounds: Rc<RefCell<QuadtreeBounds>>, x: f64, y: f64) {\n    let nw_x;\n    let nw_y;\n    let se_x;\n    let se_y;\n    {\n        let bounds = bounds.borrow();\n        let nw = bounds.nw.borrow();\n        let se = bounds.se.borrow();\n        nw_x = f64::min(x, nw.x);\n        nw_y = f64::max(y, nw.y);\n        se_x = f64::max(x, se.x);\n        se_y = f64::min(y, se.y);\n    }\n    {\n        let mut bounds = bounds.borrow_mut();\n        bounds.width = (nw_x - se_x).abs();\n        bounds.height = (nw_y - se_y).abs();\n    }\n}\n\n",
        "quadtree_bounds_new": "pub fn quadtree_bounds_new() -> Option<Rc<RefCell<QuadtreeBounds>>> {\n    let nw = Rc::new(RefCell::new(QuadtreePoint { x: f64::INFINITY, y: -f64::INFINITY }));\n    let se = Rc::new(RefCell::new(QuadtreePoint { x: -f64::INFINITY, y: f64::INFINITY }));\n    let bounds = QuadtreeBounds {\n        nw,\n        se,\n        width: 0.0,\n        height: 0.0,\n    };\n    Some(Rc::new(RefCell::new(bounds)))\n}\n\n",
        "quadtree_point_free": "pub fn quadtree_point_free(point: Rc<RefCell<QuadtreePoint>>) {\n    // \u91ca\u653e QuadtreePoint \u7684\u5185\u5b58\n    // \u7531\u4e8e Rc<RefCell<T>> \u662f\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u624b\u52a8\u91ca\u653e\u5185\u5b58\n}\n\n",
        "node_contains_": "pub fn node_contains_<T>(outer: Rc<RefCell<QuadtreeNode<T>>>, it: Rc<RefCell<QuadtreePoint>>) -> bool {\n    let outer = outer.borrow();\n    let it = it.borrow();\n    if let Some(bounds) = &outer.bounds {\n        let bounds = bounds.borrow();\n        bounds.nw.borrow().x <= it.x &&\n        bounds.nw.borrow().y >= it.y &&\n        bounds.se.borrow().x >= it.x &&\n        bounds.se.borrow().y <= it.y\n    } else {\n        false\n    }\n}\n\n",
        "quadtree_node_isleaf": "pub fn quadtree_node_isleaf<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    node.borrow().point.is_some()\n}\n\n",
        "quadtree_node_with_bounds": "pub fn quadtree_node_with_bounds<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let node = quadtree_node_new()?;\n    let bounds = quadtree_bounds_new()?;\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.bounds = Some(bounds.clone());\n    }\n    quadtree_bounds_extend(bounds.clone(), maxx, maxy);\n    quadtree_bounds_extend(bounds.clone(), minx, miny);\n    Some(node)\n}\n\n",
        "quadtree_node_reset": "pub fn quadtree_node_reset<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(point) = &node_borrow.point {\n        quadtree_point_free(point.clone());\n    }\n    if let Some(key) = node_borrow.key.take() {\n        key_free(key);\n    }\n}\n\n",
        "elision_": "pub fn elision_<T>(key: T) -> T {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    key\n}\n\n",
        "get_quadrant_": "pub fn get_quadrant_<T>(root: Rc<RefCell<QuadtreeNode<T>>>, point: Rc<RefCell<QuadtreePoint>>) -> Option<Rc<RefCell<QuadtreeNode<T>>>> {\n    let root = root.borrow();\n    if let Some(nw) = &root.nw {\n        if node_contains_(nw.clone(), point.clone()) {\n            return Some(nw.clone());\n        }\n    }\n    if let Some(ne) = &root.ne {\n        if node_contains_(ne.clone(), point.clone()) {\n            return Some(ne.clone());\n        }\n    }\n    if let Some(sw) = &root.sw {\n        if node_contains_(sw.clone(), point.clone()) {\n            return Some(sw.clone());\n        }\n    }\n    if let Some(se) = &root.se {\n        if node_contains_(se.clone(), point.clone()) {\n            return Some(se.clone());\n        }\n    }\n    None\n}\n\n",
        "quadtree_node_ispointer": "pub fn quadtree_node_ispointer<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_some()\n        && node_ref.ne.is_some()\n        && node_ref.sw.is_some()\n        && node_ref.se.is_some()\n        && !quadtree_node_isleaf(node)\n}\n\n",
        "split_node_": "pub fn split_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let x;\n    let y;\n    let hw;\n    let hh;\n    {\n        let node_borrow = node.borrow();\n        let bounds = node_borrow.bounds.as_ref().unwrap().borrow();\n        x = bounds.nw.borrow().x;\n        y = bounds.nw.borrow().y;\n        hw = bounds.width / 2.0;\n        hh = bounds.height / 2.0;\n    }\n\n    let nw = quadtree_node_with_bounds::<T>(x, y - hh, x + hw, y);\n    let ne = quadtree_node_with_bounds::<T>(x + hw, y - hh, x + hw * 2.0, y);\n    let sw = quadtree_node_with_bounds::<T>(x, y - hh * 2.0, x + hw, y - hh);\n    let se = quadtree_node_with_bounds::<T>(x + hw, y - hh * 2.0, x + hw * 2.0, y - hh);\n\n    if nw.is_none() || ne.is_none() || sw.is_none() || se.is_none() {\n        return false;\n    }\n\n    {\n        let mut node_mut = node.borrow_mut();\n        node_mut.nw = Some(nw.unwrap());\n        node_mut.ne = Some(ne.unwrap());\n        node_mut.sw = Some(sw.unwrap());\n        node_mut.se = Some(se.unwrap());\n    }\n\n    let old_point;\n    let old_key;\n    {\n        let mut node_mut = node.borrow_mut();\n        old_point = node_mut.point.take();\n        old_key = node_mut.key.take();\n    }\n\n    insert_(tree.clone(), node, old_point, old_key) != 0\n}\n\n",
        "reset_node_": "pub fn reset_node_<T>(tree: Rc<RefCell<Quadtree<T>>>, node: Rc<RefCell<QuadtreeNode<T>>>) {\n    let key_free = tree.borrow().key_free.clone();\n    if let Some(key_free) = key_free {\n        quadtree_node_reset(node, key_free);\n    } else {\n        let elision_wrap = |key: T| { elision_(key); };\n        quadtree_node_reset(node, elision_wrap);\n    }\n}\n\n",
        "insert_": "pub fn insert_<T>(\n    tree: Rc<RefCell<Quadtree<T>>>,\n    root: Rc<RefCell<QuadtreeNode<T>>>,\n    point: Option<Rc<RefCell<QuadtreePoint>>>,\n    key: Option<T>,\n) -> i32 {\n    if quadtree_node_isempty(&root) {\n        {\n            let mut root_mut = root.borrow_mut();\n            root_mut.point = point;\n            root_mut.key = key;\n        }\n        return 1; // normal insertion flag\n    } else if quadtree_node_isleaf(&root) {\n        let root_point = root.borrow().point.as_ref().unwrap().clone();\n        let point_ref = point.as_ref().unwrap().clone();\n        let root_point_borrow = root_point.borrow();\n        let point_ref_borrow = point_ref.borrow();\n        if root_point_borrow.x == point_ref_borrow.x && root_point_borrow.y == point_ref_borrow.y {\n            reset_node_(tree.clone(), root.clone());\n            {\n                let mut root_mut = root.borrow_mut();\n                root_mut.point = point;\n                root_mut.key = key;\n            }\n            return 2; // replace insertion flag\n        } else {\n            if !split_node_(tree.clone(), root.clone()) {\n                return 0; // failed insertion flag\n            }\n            return insert_(tree, root, point, key);\n        }\n    } else if quadtree_node_ispointer(&root) {\n        let quadrant = get_quadrant_(root.clone(), point.as_ref().unwrap().clone());\n        if quadrant.is_none() {\n            return 0;\n        }\n        return insert_(tree, quadrant.unwrap(), point, key);\n    }\n    0\n}\n\n",
        "quadtree_node_isempty": "pub fn quadtree_node_isempty<T>(node: &Rc<RefCell<QuadtreeNode<T>>>) -> bool {\n    let node_ref = node.borrow();\n    node_ref.nw.is_none()\n        && node_ref.ne.is_none()\n        && node_ref.sw.is_none()\n        && node_ref.se.is_none()\n        && !quadtree_node_isleaf(node)\n}\n\n",
        "quadtree_bounds_free": "pub fn quadtree_bounds_free(bounds: Rc<RefCell<QuadtreeBounds>>) {\n    // \u91ca\u653e QuadtreeBounds \u7684\u5185\u5b58\n    // \u7531\u4e8e Rc<RefCell<T>> \u662f\u667a\u80fd\u6307\u9488\uff0c\u65e0\u9700\u624b\u52a8\u91ca\u653e\u5185\u5b58\n    let bounds = bounds.borrow();\n    quadtree_point_free(Rc::clone(&bounds.nw));\n    quadtree_point_free(Rc::clone(&bounds.se));\n}\n\n",
        "find_": "pub fn find_<T>(node: Option<Rc<RefCell<QuadtreeNode<T>>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    if let Some(node) = node {\n        let node_ref = node.borrow();\n        if quadtree_node_isleaf(&node) {\n            if let Some(point) = &node_ref.point {\n                let point_ref = point.borrow();\n                if point_ref.x == x && point_ref.y == y {\n                    return Some(point.clone());\n                }\n            }\n        } else if quadtree_node_ispointer(&node) {\n            let test = Rc::new(RefCell::new(QuadtreePoint { x, y }));\n            return find_(get_quadrant_(node.clone(), test), x, y);\n        }\n    }\n    None\n}\n\n",
        "quadtree_node_free": "pub fn quadtree_node_free<T>(node: Rc<RefCell<QuadtreeNode<T>>>, key_free: fn(T)) {\n    let mut node_borrow = node.borrow_mut();\n    if let Some(nw) = node_borrow.nw.take() {\n        quadtree_node_free(nw, key_free);\n    }\n    if let Some(ne) = node_borrow.ne.take() {\n        quadtree_node_free(ne, key_free);\n    }\n    if let Some(sw) = node_borrow.sw.take() {\n        quadtree_node_free(sw, key_free);\n    }\n    if let Some(se) = node_borrow.se.take() {\n        quadtree_node_free(se, key_free);\n    }\n    if let Some(bounds) = node_borrow.bounds.take() {\n        quadtree_bounds_free(bounds);\n    }\n    quadtree_node_reset(Rc::clone(&node), key_free);\n}\n\n",
        "quadtree_search": "pub fn quadtree_search<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64) -> Option<Rc<RefCell<QuadtreePoint>>> {\n    let tree_ref = tree.borrow();\n    find_(tree_ref.root.clone(), x, y)\n}\n\n",
        "quadtree_insert": "pub fn quadtree_insert<T>(tree: Rc<RefCell<Quadtree<T>>>, x: f64, y: f64, key: T) -> i32 {\n    let point = quadtree_point_new(x, y);\n    if point.is_none() {\n        return 0;\n    }\n    let point_rc = Rc::new(RefCell::new(point.unwrap()));\n    if !node_contains_(tree.borrow().root.as_ref().unwrap().clone(), point_rc.clone()) {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    let insert_status = insert_(tree.clone(), tree.borrow().root.as_ref().unwrap().clone(), Some(point_rc.clone()), Some(key));\n    if insert_status == 0 {\n        quadtree_point_free(point_rc);\n        return 0;\n    }\n    if insert_status == 1 {\n        let mut tree_mut = tree.borrow_mut();\n        // Assuming length is a field in Quadtree struct\n        // If not, you need to add it\n        // tree_mut.length += 1;\n    }\n    insert_status\n}\n\n",
        "quadtree_free": "pub fn quadtree_free<T>(tree: Rc<RefCell<Quadtree<T>>>) {\n    let tree_borrow = tree.borrow();\n    if let Some(key_free) = tree_borrow.key_free {\n        if let Some(root) = &tree_borrow.root {\n            quadtree_node_free(Rc::clone(root), key_free);\n        }\n    } else {\n        if let Some(root) = &tree_borrow.root {\n            fn elision_wrap<T>(key: T) {\n                elision_(key);\n            }\n            quadtree_node_free(Rc::clone(root), elision_wrap);\n        }\n    }\n}\n\n",
        "quadtree_new": "pub fn quadtree_new<T>(minx: f64, miny: f64, maxx: f64, maxy: f64) -> Option<Quadtree<T>> {\n    let root = quadtree_node_with_bounds::<T>(minx, miny, maxx, maxy)?;\n    let tree = Quadtree {\n        key_free: None,\n        root: Some(root),\n    };\n    Some(tree)\n}\n\n",
        "quadtree_walk": "pub fn quadtree_walk<T>(root: Option<Rc<RefCell<QuadtreeNode<T>>>>, descent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>), ascent: fn(Option<Rc<RefCell<QuadtreeNode<T>>>>)) {\n    descent(root.clone());\n    if let Some(node) = &root {\n        let node_ref = node.borrow();\n        if let Some(nw) = &node_ref.nw {\n            quadtree_walk(Some(nw.clone()), descent, ascent);\n        }\n        if let Some(ne) = &node_ref.ne {\n            quadtree_walk(Some(ne.clone()), descent, ascent);\n        }\n        if let Some(sw) = &node_ref.sw {\n            quadtree_walk(Some(sw.clone()), descent, ascent);\n        }\n        if let Some(se) = &node_ref.se {\n            quadtree_walk(Some(se.clone()), descent, ascent);\n        }\n    }\n    ascent(root);\n}\n\n"
    },
    "test-quadtree": {
        "main": "fn main(){}\n\n",
        "ascent": "pub fn ascent<T>(node: Rc<RefCell<QuadtreeNode<T>>>) {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    // Function implementation\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse test_project::quadtree::{QuadtreeNode, quadtree_node_t, quadtree_node_isleaf, find_, quadtree_walk, quadtree_node_new, quadtree_bounds_extend, quadtree_new, quadtree_node_isempty, quadtree_node_ispointer, quadtree_node_free, insert_, quadtree_search, quadtree_free, elision_, quadtree_bounds_free, quadtree_point_new, quadtree_bounds_new, get_quadrant_, reset_node_, split_node_, node_contains_, quadtree_insert, quadtree_node_with_bounds, quadtree_point_free, quadtree_node_reset};",
        "descent": "pub fn descent(node: Rc<RefCell<quadtree_node_t>>) {\n// \u6ce8\u610f\uff1a\u8be5\u51fd\u6570\u4e0d\u5141\u8bb8\u4fee\u6539\uff0c\u56e0\u4e3a\u5de5\u7a0b\u4e2d\u5176\u4ed6\u6587\u4ef6\u4e2d\u7684\u51fd\u6570\u4e5f\u8c03\u7528\u4e86\u4ed6\u4eec\uff0c\u5982\u679c\u4fee\u6539\u4e86\uff0c\u4f1a\u5f71\u54cd\u5176\u4ed6\u6587\u4ef6\u5185\u51fd\u6570\u7684\u529f\u80fd\uff0c\u53ea\u5141\u8bb8\u8c03\u7528\u8be5\u51fd\u6570\n    let mut node = node.borrow_mut();\n    if let Some(ne) = &node.ne {\n        descent(Rc::clone(ne));\n    }\n    if let Some(nw) = &node.nw {\n        descent(Rc::clone(nw));\n    }\n    if let Some(se) = &node.se {\n        descent(Rc::clone(se));\n    }\n    if let Some(sw) = &node.sw {\n        descent(Rc::clone(sw));\n    }\n}\n\n",
        "test_bounds": "pub fn test_bounds() {\n    let bounds = quadtree_bounds_new().unwrap();\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.x, f64::INFINITY);\n        assert_eq!(se.x, -f64::INFINITY);\n    }\n\n    quadtree_bounds_extend(Rc::clone(&bounds), 5.0, 5.0);\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.x, 5.0);\n        assert_eq!(se.x, 5.0);\n    }\n\n    quadtree_bounds_extend(Rc::clone(&bounds), 10.0, 10.0);\n    {\n        let bounds_ref = bounds.borrow();\n        let nw = bounds_ref.nw.borrow();\n        let se = bounds_ref.se.borrow();\n        assert_eq!(nw.y, 10.0);\n        assert_eq!(se.y, 5.0);\n        assert_eq!(bounds_ref.width, 5.0);\n        assert_eq!(bounds_ref.height, 5.0);\n    }\n\n    quadtree_bounds_free(bounds);\n}\n\n",
        "test_points": "pub fn test_points() {\n    let point = quadtree_point_new(5.0, 6.0);\n    assert!(point.as_ref().unwrap().x == 5.0);\n    assert!(point.as_ref().unwrap().y == 6.0);\n    quadtree_point_free(Rc::new(RefCell::new(point.unwrap())));\n}\n\n",
        "test_node": "pub fn test_node() {\n    let node = quadtree_node_new::<i32>();\n    let node_ref = node.as_ref().unwrap();\n    assert!(!quadtree_node_isleaf(node_ref));\n    assert!(quadtree_node_isempty(node_ref));\n    assert!(!quadtree_node_ispointer(node_ref));\n}\n\n"
    }
}