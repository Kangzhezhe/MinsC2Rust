{
    "binn_list_read_next": "void * APIENTRY binn_list_read_next(binn_iter *iter, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_list_next(iter, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "binn_get_ptr_type": "BINN_PRIVATE int binn_get_ptr_type(const void *ptr) {\n\n  if (ptr == NULL) return 0;\n\n  switch (*(unsigned int *)ptr) {\n  case BINN_MAGIC:\n    return BINN_STRUCT;\n  default:\n    return BINN_BUFFER;\n  }\n",
    "binn_object_int32": "int APIENTRY binn_object_int32(const void *obj, const char *key) {\n  int value;\n\n  binn_object_get(obj, key, BINN_INT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_map_float": "float APIENTRY binn_map_float(const void *map, int id) {\n  float value;\n\n  binn_map_get(map, id, BINN_FLOAT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_list_get_value": "BOOL APIENTRY binn_list_get_value(const void *ptr, int pos, binn *value) {\n  int  i, type, count, size=0, header_size;\n  unsigned char *p, *plimit, *base;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || value == NULL) return FALSE;\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != BINN_LIST) return FALSE;\n  if (count == 0) return FALSE;\n  if (pos <= 0 || pos > count) return FALSE;\n  pos--;  // convert from base 1 to base 0\n\n  p = (unsigned char *) ptr;\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  for (i = 0; i < pos; i++) {\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) return FALSE;\n  }\n\n  return GetValue(p, plimit, value);\n\n",
    "binn_map_uint8": "unsigned char APIENTRY binn_map_uint8(const void *map, int id) {\n  unsigned char value;\n\n  binn_map_get(map, id, BINN_UINT8, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_read_pair": "void * APIENTRY binn_object_read_pair(const void *ptr, int pos, char *pkey, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_object_get_pair(ptr, pos, pkey, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "binn_map_null": "BOOL APIENTRY binn_map_null(const void *map, int id) {\n\n  return binn_map_get(map, id, BINN_NULL, NULL, NULL);\n\n",
    "copy_be64": "BINN_PRIVATE void copy_be64(u64 *pdest, u64 *psource) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  int i;\n  for (i=0; i < 8; i++) {\n    dest[i] = source[7-i];\n  }\n",
    "binn_object_int16": "short APIENTRY binn_object_int16(const void *obj, const char *key) {\n  short value;\n\n  binn_object_get(obj, key, BINN_INT16, &value, NULL);\n\n  return value;\n}\n",
    "binn_list_add": "BOOL APIENTRY binn_list_add(binn *list, int type, void *pvalue, int size) {\n\n  if (GetWriteConvertedData(&type, &pvalue, &size) == FALSE) return FALSE;\n\n  return binn_list_add_raw(list, type, pvalue, size);\n\n",
    "binn_ptr": "void * APIENTRY binn_ptr(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    if (item->writable && item->dirty) {\n      binn_save_header(item);\n    }\n    return item->ptr;\n  case BINN_BUFFER:\n    return (void*)ptr;\n  default:\n    return NULL;\n  }\n",
    "binn_set_alloc_functions": "void APIENTRY binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*)) {\n\n  malloc_fn = new_malloc;\n  realloc_fn = new_realloc;\n  free_fn = new_free;\n\n",
    "CalcAllocation": "BINN_PRIVATE int CalcAllocation(int needed_size, int alloc_size) {\n  int calc_size;\n\n  calc_size = alloc_size;\n  while (calc_size < needed_size) {\n    calc_size <<= 1;  // same as *= 2\n    //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n  }\n  return calc_size;\n\n",
    "binn_map_uint16": "unsigned short APIENTRY binn_map_uint16(const void *map, int id) {\n  unsigned short value;\n\n  binn_map_get(map, id, BINN_UINT16, &value, NULL);\n\n  return value;\n}\n",
    "binn_list_int64": "int64 APIENTRY binn_list_int64(const void *list, int pos) {\n  int64 value;\n\n  binn_list_get(list, pos, BINN_INT64, &value, NULL);\n\n  return value;\n}\n",
    "atoi64": "int64 atoi64(char *str) {\n  int64 retval;\n  int is_negative=0;\n\n  if (*str == '-') {\n    is_negative = 1;\n    str++;\n  }\n  retval = 0;\n  for (; *str; str++) {\n    retval = 10 * retval + (*str - '0');\n  }\n  if (is_negative) retval *= -1;\n  return retval;\n}\n",
    "binn_add_value": "BOOL APIENTRY binn_add_value(binn *item, int binn_type, int id, char *name, int type, void *pvalue, int size) {\n\n  switch (binn_type) {\n    case BINN_LIST:\n      return binn_list_add(item, type, pvalue, size);\n    case BINN_MAP:\n      return binn_map_set(item, id, type, pvalue, size);\n    case BINN_OBJECT:\n      return binn_object_set(item, name, type, pvalue, size);\n    default:\n      return FALSE;\n  }\n",
    "binn_map_set_raw": "BINN_PRIVATE BOOL binn_map_set_raw(binn *item, int id, int type, void *pvalue, int size) {\n  unsigned char *base, *p, sign;\n  int id_size;\n\n  if (item == NULL || item->type != BINN_MAP || item->writable == FALSE) return FALSE;\n\n  // is the ID already in it?\n  p = SearchForID(item->pbuf, MAX_BINN_HEADER, item->used_size, item->count, id);\n  if (p) return FALSE;\n\n  // start adding it\n\n  if (CheckAllocation(item, 5) == FALSE) return FALSE;  // max 5 bytes used for the id.\n\n  p = base = ((unsigned char *) item->pbuf) + item->used_size;\n\n  sign = (id < 0);\n  if (sign) id = -id;\n\n  if (id <= 0x3F) {\n    *p++ = (sign << 6) | id;\n  } else if (id <= 0xFFF) {\n    *p++ = 0x80 | (sign << 4) | ((id & 0xF00) >> 8);\n    *p++ = id & 0xFF;\n  } else if (id <= 0xFFFFF) {\n    *p++ = 0xA0 | (sign << 4) | ((id & 0xF0000) >> 16);\n    *p++ = (id & 0xFF00) >> 8;\n    *p++ = id & 0xFF;\n  } else if (id <= 0xFFFFFFF) {\n    *p++ = 0xC0 | (sign << 4) | ((id & 0xF000000) >> 24);\n    *p++ = (id & 0xFF0000) >> 16;\n    *p++ = (id & 0xFF00) >> 8;\n    *p++ = id & 0xFF;\n  } else {\n    *p++ = 0xE0;\n    if (sign) id = -id;\n    copy_be32((u32*)p, (u32*)&id);\n    p += 4;\n  }\n\n  id_size = (p - base);\n  item->used_size += id_size;\n\n  if (AddValue(item, type, pvalue, size) == FALSE) {\n    item->used_size -= id_size;\n    return FALSE;\n  }\n\n  item->count++;\n\n  return TRUE;\n\n",
    "binn_buf_count": "BINN_PRIVATE int binn_buf_count(const void *pbuf) {\n  int  nitems;\n\n  if (!IsValidBinnHeader(pbuf, NULL, &nitems, NULL, NULL)) return 0;\n\n  return nitems;\n\n",
    "binn_alloc_item": "BINN_PRIVATE binn * binn_alloc_item() {\n  binn *item;\n  item = (binn *) binn_malloc(sizeof(binn));\n  if (item) {\n    memset(item, 0, sizeof(binn));\n    item->header = BINN_MAGIC;\n    item->allocated = TRUE;\n    //item->writable = FALSE;  -- already zeroed\n  }\n  return item;\n}\n",
    "compress_int": "BINN_PRIVATE void * compress_int(int *pstorage_type, int *ptype, void *psource) {\n  int storage_type, storage_type2, type, type2=0;\n  int64  vint = 0;\n  uint64 vuint;\n  char *pvalue;\n#if BYTE_ORDER == BIG_ENDIAN\n  int size1, size2;\n#endif\n\n  storage_type = *pstorage_type;\n  if (storage_type == BINN_STORAGE_BYTE) return psource;\n\n  type = *ptype;\n\n  switch (type) {\n  case BINN_INT64:\n    vint = *(int64*)psource;\n    goto loc_signed;\n  case BINN_INT32:\n    vint = *(int*)psource;\n    goto loc_signed;\n  case BINN_INT16:\n    vint = *(short*)psource;\n    goto loc_signed;\n  case BINN_UINT64:\n    vuint = *(uint64*)psource;\n    goto loc_positive;\n  case BINN_UINT32:\n    vuint = *(unsigned int*)psource;\n    goto loc_positive;\n  case BINN_UINT16:\n    vuint = *(unsigned short*)psource;\n    goto loc_positive;\n  }\n\nloc_signed:\n\n  if (vint >= 0) {\n    vuint = vint;\n    goto loc_positive;\n  }\n\n//loc_negative:\n\n  if (vint >= INT8_MIN) {\n    type2 = BINN_INT8;\n  } else\n  if (vint >= INT16_MIN) {\n    type2 = BINN_INT16;\n  } else\n  if (vint >= INT32_MIN) {\n    type2 = BINN_INT32;\n  }\n  goto loc_exit;\n\nloc_positive:\n\n  if (vuint <= UINT8_MAX) {\n    type2 = BINN_UINT8;\n  } else\n  if (vuint <= UINT16_MAX) {\n    type2 = BINN_UINT16;\n  } else\n  if (vuint <= UINT32_MAX) {\n    type2 = BINN_UINT32;\n  }\n\nloc_exit:\n\n  pvalue = (char *) psource;\n\n  if (type2 && type2 != type) {\n    *ptype = type2;\n    storage_type2 = binn_get_write_storage(type2);\n    *pstorage_type = storage_type2;\n#if BYTE_ORDER == BIG_ENDIAN\n    size1 = get_storage_size(storage_type);\n    size2 = get_storage_size(storage_type2);\n    pvalue += (size1 - size2);\n#endif\n  }\n\n  return pvalue;\n\n",
    "binn_is_valid_ex": "BOOL APIENTRY binn_is_valid_ex(const void *ptr, int *ptype, int *pcount, int *psize) {\n  int size;\n\n  if (psize && *psize > 0) {\n    size = *psize;\n  } else {\n    size = 0;\n  }\n\n  if (binn_is_valid_ex2(ptr, ptype, pcount, &size) == FALSE) return FALSE;\n\n  if (psize) {\n    if (*psize > 0) {\n      if (size != *psize) return FALSE;\n    } else if (*psize==0) {\n      *psize = size;\n    }\n  }\n\n  return TRUE;\n}\n",
    "binn_map_blob": "void * APIENTRY binn_map_blob(const void *map, int id, int *psize) {\n  void *value;\n\n  binn_map_get(map, id, BINN_BLOB, &value, psize);\n\n  return value;\n}\n",
    "binn_list_uint32": "unsigned int APIENTRY binn_list_uint32(const void *list, int pos) {\n  unsigned int value;\n\n  binn_list_get(list, pos, BINN_UINT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_set_raw": "BINN_PRIVATE BOOL binn_object_set_raw(binn *item, const char *key, int type, void *pvalue, int size) {\n  unsigned char *p, len;\n  int int32;\n\n  if (item == NULL || item->type != BINN_OBJECT || item->writable == FALSE) return FALSE;\n\n  if (key == NULL) return FALSE;\n  int32 = strlen(key);\n  if (int32 > 255) return FALSE;\n\n  // is the key already in it?\n  p = SearchForKey(item->pbuf, MAX_BINN_HEADER, item->used_size, item->count, key);\n  if (p) return FALSE;\n\n  // start adding it\n\n  if (CheckAllocation(item, 1 + int32) == FALSE) return FALSE;  // bytes used for the key size and the key itself.\n\n  p = ((unsigned char *) item->pbuf) + item->used_size;\n  len = int32;\n  *p = len;\n  p++;\n  memcpy(p, key, int32);\n  int32++;  // now contains the strlen + 1 byte for the len\n  item->used_size += int32;\n\n  if (AddValue(item, type, pvalue, size) == FALSE) {\n    item->used_size -= int32;\n    return FALSE;\n  }\n\n  item->count++;\n\n  return TRUE;\n\n",
    "binn_create_map": "BOOL APIENTRY binn_create_map(binn *map) {\n\n  return binn_create(map, BINN_MAP, 0, NULL);\n\n",
    "binn_list_blob": "void * APIENTRY binn_list_blob(const void *list, int pos, int *psize) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_BLOB, &value, psize);\n\n  return value;\n}\n",
    "binn_read_next_pair": "BINN_PRIVATE BOOL binn_read_next_pair(int expected_type, binn_iter *iter, int *pid, char *pkey, binn *value) {\n  int  int32, id;\n  unsigned char *p, *key;\n  unsigned short len;\n\n  if (iter == NULL || iter->pnext == NULL || iter->pnext > iter->plimit || iter->current > iter->count || iter->type != expected_type) return FALSE;\n\n  iter->current++;\n  if (iter->current > iter->count) return FALSE;\n\n  p = iter->pnext;\n\n  switch (expected_type) {\n    case BINN_MAP:\n      int32 = read_map_id(&p, iter->plimit);\n      if (p > iter->plimit) return FALSE;\n      id = int32;\n      if (pid) *pid = id;\n      break;\n    case BINN_OBJECT:\n      len = *((unsigned char *)p); p++;\n      key = p;\n      p += len;\n      if (p > iter->plimit) return FALSE;\n      if (pkey) {\n        memcpy(pkey, key, len);\n        pkey[len] = 0;\n      }\n      break;\n  }\n\n  iter->pnext = AdvanceDataPos(p, iter->plimit);\n  if (iter->pnext != 0 && iter->pnext < p) return FALSE;\n\n  return GetValue(p, iter->plimit, value);\n\n",
    "binn_list_uint16": "unsigned short APIENTRY binn_list_uint16(const void *list, int pos) {\n  unsigned short value;\n\n  binn_list_get(list, pos, BINN_UINT16, &value, NULL);\n\n  return value;\n}\n",
    "binn_list_uint64": "uint64 APIENTRY binn_list_uint64(const void *list, int pos) {\n  uint64 value;\n\n  binn_list_get(list, pos, BINN_UINT64, &value, NULL);\n\n  return value;\n}\n",
    "is_integer": "BINN_PRIVATE BOOL is_integer(char *p) {\n  BOOL retval;\n\n  if (p == NULL) return FALSE;\n  if (*p == '-') p++;\n  if (*p == 0) return FALSE;\n\n  retval = TRUE;\n\n  for (; *p; p++) {\n    if ( (*p < '0' || *p > '9') ) {\n      retval = FALSE;\n    }\n  }\n\n  return retval;\n}\n",
    "binn_list_next": "BOOL APIENTRY binn_list_next(binn_iter *iter, binn *value) {\n  unsigned char *pnow;\n\n  if (iter == NULL || iter->pnext == NULL || iter->pnext > iter->plimit || iter->current > iter->count || iter->type != BINN_LIST) return FALSE;\n\n  iter->current++;\n  if (iter->current > iter->count) return FALSE;\n\n  pnow = iter->pnext;\n  iter->pnext = AdvanceDataPos(pnow, iter->plimit);\n  if (iter->pnext != 0 && iter->pnext < pnow) return FALSE;\n\n  return GetValue(pnow, iter->plimit, value);\n\n",
    "binn_list_int32": "int APIENTRY binn_list_int32(const void *list, int pos) {\n  int value;\n\n  binn_list_get(list, pos, BINN_INT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_type": "int APIENTRY binn_type(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    return item->type;\n  case BINN_BUFFER:\n    return binn_buf_type(ptr);\n  default:\n    return -1;\n  }\n",
    "binn_list_next_value": "binn * APIENTRY binn_list_next_value(binn_iter *iter) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_list_next(iter, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "int_type": "BINN_PRIVATE int int_type(int type)  {\n\n  switch (type) {\n  case BINN_INT8:\n  case BINN_INT16:\n  case BINN_INT32:\n  case BINN_INT64:\n    return BINN_SIGNED_INT;\n\n  case BINN_UINT8:\n  case BINN_UINT16:\n  case BINN_UINT32:\n  case BINN_UINT64:\n    return BINN_UNSIGNED_INT;\n\n  default:\n    return 0;\n  }\n",
    "binn_get_double": "BOOL APIENTRY binn_get_double(binn *value, double *pfloat) {\n  int64 vint;\n\n  if (value == NULL || pfloat == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    if (copy_int_value(value->ptr, &vint, value->type, BINN_INT64) == FALSE) return FALSE;\n    *pfloat = (double) vint;\n    return TRUE;\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    *pfloat = value->vfloat;\n    break;\n  case BINN_DOUBLE:\n    *pfloat = value->vdouble;\n    break;\n  case BINN_STRING:\n    if (is_integer((char*)value->ptr))\n      *pfloat = (double) atoi64((char*)value->ptr);\n    else if (is_float((char*)value->ptr))\n      *pfloat = atof((char*)value->ptr);\n    else\n      return FALSE;\n    break;\n  case BINN_BOOL:\n    *pfloat = value->vbool;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}\n",
    "binn_object_next_value": "binn * APIENTRY binn_object_next_value(binn_iter *iter, char *pkey) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_object_next(iter, pkey, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "binn_count": "int APIENTRY binn_count(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    return item->count;\n  case BINN_BUFFER:\n    return binn_buf_count(ptr);\n  default:\n    return -1;\n  }\n",
    "binn_list_object": "void * APIENTRY binn_list_object(const void *list, int pos) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_OBJECT, &value, NULL);\n\n  return value;\n}\n",
    "AddValue": "BINN_PRIVATE BOOL AddValue(binn *item, int type, void *pvalue, int size) {\n  int int32, ArgSize, storage_type, extra_type;\n  unsigned char *p;\n\n  binn_get_type_info(type, &storage_type, &extra_type);\n\n  if (pvalue == NULL) {\n    switch (storage_type) {\n      case BINN_STORAGE_NOBYTES:\n        break;\n      case BINN_STORAGE_BLOB:\n      case BINN_STORAGE_STRING:\n        if (size == 0) break; // the 2 above are allowed to have 0 length\n      default:\n        return FALSE;\n    }\n  }\n\n  if (type_family(type) == BINN_FAMILY_INT && item->disable_int_compression == FALSE)\n    pvalue = compress_int(&storage_type, &type, pvalue);\n\n  switch (storage_type) {\n    case BINN_STORAGE_NOBYTES:\n      size = 0;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_BYTE:\n      size = 1;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_WORD:\n      size = 2;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_DWORD:\n      size = 4;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_QWORD:\n      size = 8;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_BLOB:\n      if (size < 0) return FALSE;\n      //if (size == 0) ...\n      ArgSize = size + 4; // at least this size\n      break;\n    case BINN_STORAGE_STRING:\n      if (size < 0) return FALSE;\n      if (size == 0) size = strlen2( (char *) pvalue);\n      ArgSize = size + 5; // at least this size\n      break;\n    case BINN_STORAGE_CONTAINER:\n      if (size <= 0) return FALSE;\n      ArgSize = size;\n      break;\n    default:\n      return FALSE;\n  }\n\n  ArgSize += 2;  // at least 2 bytes used for data_type.\n  if (CheckAllocation(item, ArgSize) == FALSE) return FALSE;\n\n  // Gets the pointer to the next place in buffer\n  p = ((unsigned char *) item->pbuf) + item->used_size;\n\n  // If the data is not a container, store the data type\n  if (storage_type != BINN_STORAGE_CONTAINER) {\n    if (type > 255) {\n      u16 type16 = type;\n      copy_be16((u16*)p, (u16*)&type16);\n      p += 2;\n      item->used_size += 2;\n    } else {\n      *p = type;\n      p++;\n      item->used_size++;\n    }\n  }\n\n  switch (storage_type) {\n    case BINN_STORAGE_NOBYTES:\n      // Nothing to do.\n      break;\n    case BINN_STORAGE_BYTE:\n      *((char *) p) = *((char *) pvalue);\n      item->used_size += 1;\n      break;\n    case BINN_STORAGE_WORD:\n      copy_be16((u16*)p, (u16*)pvalue);\n      item->used_size += 2;\n      break;\n    case BINN_STORAGE_DWORD:\n      copy_be32((u32*)p, (u32*)pvalue);\n      item->used_size += 4;\n      break;\n    case BINN_STORAGE_QWORD:\n      copy_be64((u64*)p, (u64*)pvalue);\n      item->used_size += 8;\n      break;\n    case BINN_STORAGE_BLOB:\n    case BINN_STORAGE_STRING:\n      if (size > 127) {\n        int32 = size | 0x80000000;\n        copy_be32((u32*)p, (u32*)&int32);\n        p += 4;\n        item->used_size += 4;\n      } else {\n        *((unsigned char *) p) = size;\n        p++;\n        item->used_size++;\n      }\n      memcpy(p, pvalue, size);\n      if (storage_type == BINN_STORAGE_STRING) {\n        p += size;\n        *((char *) p) = (char) 0;\n        size++;  // null terminator\n      }\n      item->used_size += size;\n      break;\n    case BINN_STORAGE_CONTAINER:\n      memcpy(p, pvalue, size);\n      item->used_size += size;\n      break;\n  }\n\n  item->dirty = TRUE;\n\n  return TRUE;\n}\n",
    "binn_object_set_new": "BOOL APIENTRY binn_object_set_new(binn *obj, const char *key, binn *value) {\n  BOOL retval;\n\n  retval = binn_object_set_value(obj, key, value);\n  if (value) free_fn(value);\n  return retval;\n\n",
    "binn_release": "void * APIENTRY binn_release(binn *item) {\n  void *data;\n\n  if (item == NULL) return NULL;\n\n  data = binn_ptr(item);\n\n  if (data > item->pbuf) {\n    memmove(item->pbuf, data, item->size);\n    data = item->pbuf;\n  }\n\n  if (item->allocated) {\n    free_fn(item);\n  } else {\n    memset(item, 0, sizeof(binn));\n    item->header = BINN_MAGIC;\n  }\n\n  return data;\n\n",
    "binn_list_list": "void * APIENTRY binn_list_list(const void *list, int pos) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_LIST, &value, NULL);\n\n  return value;\n}\n",
    "binn_list_int8": "signed char APIENTRY binn_list_int8(const void *list, int pos) {\n  signed char value;\n\n  binn_list_get(list, pos, BINN_INT8, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_map": "void * APIENTRY binn_object_map(const void *obj, const char *key) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_MAP, &value, NULL);\n\n  return value;\n}\n",
    "binn_list_add_raw": "BINN_PRIVATE BOOL binn_list_add_raw(binn *item, int type, void *pvalue, int size) {\n\n  if (item == NULL || item->type != BINN_LIST || item->writable == FALSE) return FALSE;\n\n  //if (CheckAllocation(item, 4) == FALSE) return FALSE;  // 4 bytes used for data_store and data_format.\n\n  if (AddValue(item, type, pvalue, size) == FALSE) return FALSE;\n\n  item->count++;\n\n  return TRUE;\n\n",
    "binn_iter_init": "BOOL APIENTRY binn_iter_init(binn_iter *iter, const void *ptr, int expected_type) {\n  int  type, count, size=0, header_size;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || iter == NULL) return FALSE;\n  memset(iter, 0, sizeof(binn_iter));\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != expected_type) return FALSE;\n  //if (count == 0) return FALSE;  -- should not be used\n\n  iter->plimit = (unsigned char *)ptr + size - 1;\n  iter->pnext = (unsigned char *)ptr + header_size;\n  iter->count = count;\n  iter->current = 0;\n  iter->type = type;\n\n  return TRUE;\n}\n",
    "is_float": "BINN_PRIVATE BOOL is_float(char *p) {\n  BOOL retval, number_found=FALSE;\n\n  if (p == NULL) return FALSE;\n  if (*p == '-') p++;\n  if (*p == 0) return FALSE;\n\n  retval = TRUE;\n\n  for (; *p; p++) {\n    if (*p == '.' || *p == ',') {\n      if (!number_found) retval = FALSE;\n    } else if ( *p >= '0' && *p <= '9' ) {\n      number_found = TRUE;\n    } else {\n      return FALSE;\n    }\n  }\n\n  return retval;\n}\n",
    "binn_is_container": "BOOL APIENTRY binn_is_container(binn *item) {\n\n  if (item == NULL) return FALSE;\n\n  switch (item->type) {\n  case BINN_LIST:\n  case BINN_MAP:\n  case BINN_OBJECT:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n",
    "binn_get_read_storage": "int APIENTRY binn_get_read_storage(int type) {\n  int storage_type;\n\n  switch (type) {\n#ifdef BINN_EXTENDED\n    case BINN_SINGLE_STR:\n      return BINN_STORAGE_DWORD;\n    case BINN_DOUBLE_STR:\n      return BINN_STORAGE_QWORD;\n#endif\n    case BINN_BOOL:\n    case BINN_TRUE:\n    case BINN_FALSE:\n      return BINN_STORAGE_DWORD;\n    default:\n      binn_get_type_info(type, &storage_type, NULL);\n      return storage_type;\n  }\n",
    "binn_is_valid_ex2": "BINN_PRIVATE BOOL binn_is_valid_ex2(const void *ptr, int *ptype, int *pcount, int *psize) {\n  int  i, type, count, size, header_size;\n  unsigned char *p, *plimit, *base, len;\n\n  if (ptr == NULL) return FALSE;\n\n  // is there an informed size?\n  if (psize && *psize > 0) {\n    size = *psize;\n  } else {\n    size = 0;\n  }\n\n  if (!IsValidBinnHeader(ptr, &type, &count, &size, &header_size)) return FALSE;\n\n  // is there an informed size?\n  if (psize && *psize > 0) {\n    // is it bigger than the buffer?\n    if (size > *psize) return FALSE;\n  }\n  // is there an informed count?\n  if (pcount && *pcount > 0) {\n    // is it the same as the one in the buffer?\n    if (count != *pcount) return FALSE;\n  }\n  // is there an informed type?\n  if (ptype && *ptype != 0) {\n    // is it the same as the one in the buffer?\n    if (type != *ptype) return FALSE;\n  }\n\n  p = (unsigned char *)ptr;\n  base = p;\n  plimit = p + size - 1;\n\n  p += header_size;\n\n  // process each (key and) value\n  for (i = 0; i < count; i++) {\n    switch (type) {\n      case BINN_OBJECT:\n        if (p > plimit) goto Invalid;\n        // get the key (string) size\n        len = *p;\n        p++;\n        //if (len == 0) goto Invalid;\n        // advance over the key\n        p += len;\n        break;\n      case BINN_MAP:\n        // advance over the key\n        read_map_id(&p, plimit);\n        break;\n      case BINN_LIST:\n        // no key\n        break;\n      default:\n        goto Invalid;\n    }\n    // check the value\n    if (p > plimit) goto Invalid;\n    if ((*p & BINN_STORAGE_MASK) == BINN_STORAGE_CONTAINER) {\n      // recursively check the internal container\n      int size2 = plimit - p + 1;  // maximum container size\n      if (binn_is_valid_ex2(p, NULL, NULL, &size2) == FALSE) goto Invalid;\n      p += size2;\n    } else {\n      // advance over the value\n      p = AdvanceDataPos(p, plimit);\n      if (p == 0 || p < base) goto Invalid;\n    }\n  }\n\n  if (ptype  && *ptype==0) *ptype = type;\n  if (pcount && *pcount==0) *pcount = count;\n  if (psize) *psize = size;\n  return TRUE;\n\nInvalid:\n  return FALSE;\n\n",
    "binn_get_int64": "BOOL APIENTRY binn_get_int64(binn *value, int64 *pint) {\n\n  if (value == NULL || pint == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    return copy_int_value(value->ptr, pint, value->type, BINN_INT64);\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    if (value->vfloat < (float)INT64_MIN || value->vfloat > (float)INT64_MAX) return FALSE;\n    *pint = roundval(value->vfloat);\n    break;\n  case BINN_DOUBLE:\n    if (value->vdouble < (double)INT64_MIN || value->vdouble > (double)INT64_MAX) return FALSE;\n    *pint = roundval(value->vdouble);\n    break;\n  case BINN_STRING:\n    if (is_integer((char*)value->ptr))\n      *pint = atoi64((char*)value->ptr);\n    else if (is_float((char*)value->ptr))\n      *pint = roundval(atof((char*)value->ptr));\n    else\n      return FALSE;\n    break;\n  case BINN_BOOL:\n    *pint = value->vbool;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}\n",
    "GetWriteConvertedData": "BINN_PRIVATE BOOL GetWriteConvertedData(int *ptype, void **ppvalue, int *psize) {\n  int  type;\n  float  f1;\n  double d1;\n  char pstr[128];\n\n  UNUSED(pstr);\n  UNUSED(d1);\n  UNUSED(f1);\n\n  type = *ptype;\n\n  if (*ppvalue == NULL) {\n    switch (type) {\n      case BINN_NULL:\n      case BINN_TRUE:\n      case BINN_FALSE:\n        break;\n      case BINN_STRING:\n      case BINN_BLOB:\n        if (*psize == 0) break;\n      default:\n        return FALSE;\n    }\n  }\n\n  switch (type) {\n#ifdef BINN_EXTENDED\n    case BINN_SINGLE:\n      f1 = **(float**)ppvalue;\n      d1 = f1;  // convert from float (32bits) to double (64bits)\n      type = BINN_SINGLE_STR;\n      goto conv_double;\n    case BINN_DOUBLE:\n      d1 = **(double**)ppvalue;\n      type = BINN_DOUBLE_STR;\nconv_double:\n      // the '%.17e' is more precise than the '%g'\n      snprintf(pstr, 127, \"%.17e\", d1);\n      *ppvalue = pstr;\n      *ptype = type;\n      break;\n#endif\n    case BINN_DECIMAL:\n    case BINN_CURRENCYSTR:\n      /*\n      if (binn_malloc_extptr(128) == NULL) return FALSE;\n      snprintf(sptr, 127, \"%E\", **ppvalue);\n      *ppvalue = sptr;\n      */\n      return TRUE;  //! temporary\n      break;\n\n    case BINN_DATE:\n    case BINN_DATETIME:\n    case BINN_TIME:\n      return TRUE;  //! temporary\n      break;\n\n    case BINN_BOOL:\n      if (**((BOOL**)ppvalue) == FALSE) {\n        type = BINN_FALSE;\n      } else {\n        type = BINN_TRUE;\n      }\n      *ptype = type;\n      break;\n\n  }\n\n  return TRUE;\n\n",
    "binn_is_struct": "BOOL APIENTRY binn_is_struct(const void *ptr) {\n\n  if (ptr == NULL) return FALSE;\n\n  if ((*(unsigned int *)ptr) == BINN_MAGIC) {\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n",
    "binn_object_value": "binn * APIENTRY binn_object_value(const void *ptr, const char *key) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_object_get_value(ptr, key, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "binn_list_uint8": "unsigned char APIENTRY binn_list_uint8(const void *list, int pos) {\n  unsigned char value;\n\n  binn_list_get(list, pos, BINN_UINT8, &value, NULL);\n\n  return value;\n}\n",
    "binn_new": "binn * APIENTRY binn_new(int type, int size, void *pointer) {\n  binn *item;\n\n  item = (binn*) binn_malloc(sizeof(binn));\n\n  if (binn_create(item, type, size, pointer) == FALSE) {\n    free_fn(item);\n    return NULL;\n  }\n\n  item->allocated = TRUE;\n  return item;\n\n",
    "IsValidBinnHeader": "BINN_PRIVATE BOOL IsValidBinnHeader(const void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize) {\n  unsigned char byte, *p, *plimit=0;\n  int int32, type, size, count;\n\n  if (pbuf == NULL) return FALSE;\n\n  p = (unsigned char *) pbuf;\n\n  if (psize && *psize > 0) {\n    if (*psize < MIN_BINN_SIZE) return FALSE;\n    plimit = p + *psize - 1;\n  }\n\n  // get the type\n  byte = *p; p++;\n  if ((byte & BINN_STORAGE_MASK) != BINN_STORAGE_CONTAINER) return FALSE;\n  if (byte & BINN_STORAGE_HAS_MORE) return FALSE;\n  type = byte;\n\n  switch (type) {\n    case BINN_LIST:\n    case BINN_MAP:\n    case BINN_OBJECT:\n      break;\n    default:\n      return FALSE;\n  }\n\n  // get the size\n  if (plimit && p > plimit) return FALSE;\n  int32 = *((unsigned char*)p);\n  if (int32 & 0x80) {\n    if (plimit && p + sizeof(int) - 1 > plimit) return FALSE;\n    copy_be32((u32*)&int32, (u32*)p);\n    int32 &= 0x7FFFFFFF;\n    p+=4;\n  } else {\n    p++;\n  }\n  size = int32;\n\n  // get the count\n  if (plimit && p > plimit) return FALSE;\n  int32 = *((unsigned char*)p);\n  if (int32 & 0x80) {\n    if (plimit && p + sizeof(int) - 1 > plimit) return FALSE;\n    copy_be32((u32*)&int32, (u32*)p);\n    int32 &= 0x7FFFFFFF;\n    p+=4;\n  } else {\n    p++;\n  }\n  count = int32;\n\n  if (size < MIN_BINN_SIZE || count < 0) return FALSE;\n\n  // return the values\n  if (ptype)  *ptype  = type;\n  if (pcount) *pcount = count;\n  if (psize)  *psize  = size;\n  if (pheadersize) *pheadersize = (int) (p - (unsigned char*)pbuf);\n  return TRUE;\n}\n",
    "binn_create_type": "int APIENTRY binn_create_type(int storage_type, int data_type_index) {\n  if (data_type_index < 0) return -1;\n  if (storage_type < BINN_STORAGE_MIN || storage_type > BINN_STORAGE_MAX) return -1;\n  if (data_type_index < 16)\n    return storage_type | data_type_index;\n  else if (data_type_index < 4096) {\n    storage_type |= BINN_STORAGE_HAS_MORE;\n    storage_type <<= 8;\n    data_type_index >>= 4;\n    return storage_type | data_type_index;\n  } else\n    return -1;\n}\n",
    "binn_list_bool": "BOOL APIENTRY binn_list_bool(const void *list, int pos) {\n  BOOL value;\n\n  binn_list_get(list, pos, BINN_BOOL, &value, NULL);\n\n  return value;\n}\n",
    "binn_create": "BOOL APIENTRY binn_create(binn *item, int type, int size, void *pointer) {\n  BOOL retval=FALSE;\n\n  switch (type) {\n    case BINN_LIST:\n    case BINN_MAP:\n    case BINN_OBJECT:\n      break;\n    default:\n      goto loc_exit;\n  }\n\n  if (item == NULL || size < 0) goto loc_exit;\n  if (size < MIN_BINN_SIZE) {\n    if (pointer) goto loc_exit;\n    else size = 0;\n  }\n\n  memset(item, 0, sizeof(binn));\n\n  if (pointer) {\n    item->pre_allocated = TRUE;\n  } else {\n    item->pre_allocated = FALSE;\n    if (size == 0) size = CHUNK_SIZE;\n    pointer = binn_malloc(size);\n    if (pointer == 0) return INVALID_BINN;\n  }\n\n  item->pbuf = pointer;\n  item->alloc_size = size;\n\n  item->header = BINN_MAGIC;\n  //item->allocated = FALSE;   -- already zeroed\n  item->writable = TRUE;\n  item->used_size = MAX_BINN_HEADER;  // save space for the header\n  item->type = type;\n  //item->count = 0;           -- already zeroed\n  item->dirty = TRUE;          // the header is not written to the buffer\n\n  retval = TRUE;\n\nloc_exit:\n  return retval;\n\n",
    "strlen2": "BINN_PRIVATE size_t strlen2(char *str) {\n\n  if (str == NULL) return 0;\n  return strlen(str);\n\n",
    "binn_object": "binn * APIENTRY binn_object() {\n  return binn_new(BINN_OBJECT, 0, 0);\n}\n",
    "type_family": "BINN_PRIVATE int type_family(int type)  {\n\n  switch (type) {\n    case BINN_LIST:\n    case BINN_MAP:\n    case BINN_OBJECT:\n      return BINN_FAMILY_BINN;\n\n    case BINN_INT8:\n    case BINN_INT16:\n    case BINN_INT32:\n    case BINN_INT64:\n    case BINN_UINT8:\n    case BINN_UINT16:\n    case BINN_UINT32:\n    case BINN_UINT64:\n      return BINN_FAMILY_INT;\n\n    case BINN_FLOAT32:\n    case BINN_FLOAT64:\n    //case BINN_SINGLE:\n    case BINN_SINGLE_STR:\n    //case BINN_DOUBLE:\n    case BINN_DOUBLE_STR:\n      return BINN_FAMILY_FLOAT;\n\n    case BINN_STRING:\n    case BINN_HTML:\n    case BINN_CSS:\n    case BINN_XML:\n    case BINN_JSON:\n    case BINN_JAVASCRIPT:\n      return BINN_FAMILY_STRING;\n\n    case BINN_BLOB:\n    case BINN_JPEG:\n    case BINN_GIF:\n    case BINN_PNG:\n    case BINN_BMP:\n      return BINN_FAMILY_BLOB;\n\n    case BINN_DECIMAL:\n    case BINN_CURRENCY:\n    case BINN_DATE:\n    case BINN_TIME:\n    case BINN_DATETIME:\n      return BINN_FAMILY_STRING;\n\n    case BINN_BOOL:\n      return BINN_FAMILY_BOOL;\n\n    case BINN_NULL:\n      return BINN_FAMILY_NULL;\n\n    default:\n      // if it wasn't found\n      return BINN_FAMILY_NONE;\n  }\n",
    "binn_buf_size": "BINN_PRIVATE int binn_buf_size(const void *pbuf) {\n  int  size=0;\n\n  if (!IsValidBinnHeader(pbuf, NULL, NULL, &size, NULL)) return 0;\n\n  return size;\n\n",
    "binn_object_str": "char * APIENTRY binn_object_str(const void *obj, const char *key) {\n  char *value;\n\n  binn_object_get(obj, key, BINN_STRING, &value, NULL);\n\n  return value;\n}\n",
    "binn_get_int32": "BOOL APIENTRY binn_get_int32(binn *value, int *pint) {\n\n  if (value == NULL || pint == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    return copy_int_value(value->ptr, pint, value->type, BINN_INT32);\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    if (value->vfloat < (float)INT32_MIN || value->vfloat > (float)INT32_MAX) return FALSE;\n    *pint = roundval(value->vfloat);\n    break;\n  case BINN_DOUBLE:\n    if (value->vdouble < (double)INT32_MIN || value->vdouble > (double)INT32_MAX) return FALSE;\n    *pint = roundval(value->vdouble);\n    break;\n  case BINN_STRING:\n    if (is_integer((char*)value->ptr))\n      *pint = atoi((char*)value->ptr);\n    else if (is_float((char*)value->ptr))\n      *pint = roundval(atof((char*)value->ptr));\n    else\n      return FALSE;\n    break;\n  case BINN_BOOL:\n    *pint = value->vbool;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}\n",
    "binn_map_next": "BOOL APIENTRY binn_map_next(binn_iter *iter, int *pid, binn *value) {\n\n  return binn_read_next_pair(BINN_MAP, iter, pid, NULL, value);\n\n",
    "binn_map_map": "void * APIENTRY binn_map_map(const void *map, int id) {\n  void *value;\n\n  binn_map_get(map, id, BINN_MAP, &value, NULL);\n\n  return value;\n}\n",
    "binn_map_str": "char * APIENTRY binn_map_str(const void *map, int id) {\n  char *value;\n\n  binn_map_get(map, id, BINN_STRING, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_null": "BOOL APIENTRY binn_object_null(const void *obj, const char *key) {\n\n  return binn_object_get(obj, key, BINN_NULL, NULL, NULL);\n\n",
    "binn_object_object": "void * APIENTRY binn_object_object(const void *obj, const char *key) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_OBJECT, &value, NULL);\n\n  return value;\n}\n",
    "binn_map_set": "BOOL APIENTRY binn_map_set(binn *map, int id, int type, void *pvalue, int size) {\n\n  if (GetWriteConvertedData(&type, &pvalue, &size) == FALSE) return FALSE;\n\n  return binn_map_set_raw(map, id, type, pvalue, size);\n\n",
    "zero_value": "BINN_PRIVATE void zero_value(const void *pvalue, int type) {\n  //int size=0;\n\n  switch (binn_get_read_storage(type)) {\n  case BINN_STORAGE_NOBYTES:\n    break;\n  case BINN_STORAGE_BYTE:\n    *((char *) pvalue) = 0;\n    //size=1;\n    break;\n  case BINN_STORAGE_WORD:\n    *((short *) pvalue) = 0;\n    //size=2;\n    break;\n  case BINN_STORAGE_DWORD:\n    *((int *) pvalue) = 0;\n    //size=4;\n    break;\n  case BINN_STORAGE_QWORD:\n    *((uint64 *) pvalue) = 0;\n    //size=8;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n  case BINN_STORAGE_CONTAINER:\n    *(char **)pvalue = NULL;\n    break;\n  }\n",
    "binn_object_uint64": "uint64 APIENTRY binn_object_uint64(const void *obj, const char *key) {\n  uint64 value;\n\n  binn_object_get(obj, key, BINN_UINT64, &value, NULL);\n\n  return value;\n}\n",
    "binn_set_string": "BOOL APIENTRY binn_set_string(binn *item, char *str, binn_mem_free pfree) {\n\n  if (item == NULL || str == NULL) return FALSE;\n\n  if (pfree == BINN_TRANSIENT) {\n    item->ptr = binn_memdup(str, strlen(str) + 1);\n    if (item->ptr == NULL) return FALSE;\n    item->freefn = free_fn;\n  } else {\n    item->ptr = str;\n    item->freefn = pfree;\n  }\n\n  item->type = BINN_STRING;\n  return TRUE;\n\n",
    "binn_is_valid": "BOOL APIENTRY binn_is_valid(const void *ptr, int *ptype, int *pcount, int *psize) {\n\n  if (ptype)  *ptype  = 0;\n  if (pcount) *pcount = 0;\n  if (psize)  *psize  = 0;\n\n  return binn_is_valid_ex(ptr, ptype, pcount, psize);\n\n",
    "binn_open_ex": "binn * APIENTRY binn_open_ex(const void *data, int size) {\n  binn *item;\n\n  item = (binn*) binn_malloc(sizeof(binn));\n\n  if (binn_load_ex(data, size, item) == FALSE) {\n    free_fn(item);\n    return NULL;\n  }\n\n  item->allocated = TRUE;\n  return item;\n\n",
    "binn_object_get": "BOOL APIENTRY binn_object_get(const void *ptr, const char *key, int type, void *pvalue, int *psize) {\n  binn value;\n  int storage_type;\n\n  storage_type = binn_get_read_storage(type);\n  if (storage_type != BINN_STORAGE_NOBYTES && pvalue == NULL) return FALSE;\n\n  zero_value(pvalue, type);\n\n  if (binn_object_get_value(ptr, key, &value) == FALSE) return FALSE;\n\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == FALSE) return FALSE;\n\n  if (psize) *psize = value.size;\n\n  return TRUE;\n\n",
    "binn_map_get_value": "BOOL APIENTRY binn_map_get_value(const void *ptr, int id, binn *value) {\n  int type, count, size=0, header_size;\n  unsigned char *p, *plimit;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || value == NULL) return FALSE;\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != BINN_MAP) return FALSE;\n  if (count == 0) return FALSE;\n\n  p = (unsigned char *) ptr;\n  plimit = p + size - 1;\n\n  p = SearchForID(p, header_size, size, count, id);\n  if (p == FALSE) return FALSE;\n\n  return GetValue(p, plimit, value);\n\n",
    "binn_map_value": "binn * APIENTRY binn_map_value(const void *ptr, int id) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_map_get_value(ptr, id, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "copy_be32": "BINN_PRIVATE void copy_be32(u32 *pdest, u32 *psource) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  dest[0] = source[3];\n  dest[1] = source[2];\n  dest[2] = source[1];\n  dest[3] = source[0];\n#else // if BYTE_ORDER == BIG_ENDIAN\n",
    "binn_map_bool": "BOOL APIENTRY binn_map_bool(const void *map, int id) {\n  BOOL value;\n\n  binn_map_get(map, id, BINN_BOOL, &value, NULL);\n\n  return value;\n}\n",
    "binn_read_pair": "BINN_PRIVATE BOOL binn_read_pair(int expected_type, const void *ptr, int pos, int *pid, char *pkey, binn *value) {\n  int  type, count, size=0, header_size;\n  int  i, int32, id = 0, counter=0;\n  unsigned char *p, *plimit, *base, *key = NULL, len = 0;\n\n  ptr = binn_ptr(ptr);\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != expected_type || count == 0 || pos < 1 || pos > count) return FALSE;\n\n  p = (unsigned char *) ptr;\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  for (i = 0; i < count; i++) {\n    switch (type) {\n      case BINN_MAP:\n        int32 = read_map_id(&p, plimit);\n        if (p > plimit) return FALSE;\n        id = int32;\n        break;\n      case BINN_OBJECT:\n        len = *((unsigned char *)p); p++;\n        if (p > plimit) return FALSE;\n        key = p;\n        p += len;\n        if (p > plimit) return FALSE;\n        break;\n    }\n    counter++;\n    if (counter == pos) goto found;\n    //\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) return FALSE;\n  }\n\n  return FALSE;\n\nfound:\n\n  switch (type) {\n    case BINN_MAP:\n      if (pid) *pid = id;\n      break;\n    case BINN_OBJECT:\n      if (pkey) {\n        memcpy(pkey, key, len);\n        pkey[len] = 0;\n      }\n      break;\n  }\n\n  return GetValue(p, plimit, value);\n\n",
    "binn_map_pair": "binn * APIENTRY binn_map_pair(const void *map, int pos, int *pid) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_read_pair(BINN_MAP, map, pos, pid, NULL, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "binn_object_read_next": "void * APIENTRY binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_object_next(iter, pkey, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "binn_value": "binn * APIENTRY binn_value(int type, void *pvalue, int size, binn_mem_free freefn) {\n  int storage_type;\n  binn *item = binn_alloc_item();\n  if (item) {\n    item->type = type;\n    binn_get_type_info(type, &storage_type, NULL);\n    switch (storage_type) {\n    case BINN_STORAGE_NOBYTES:\n      break;\n    case BINN_STORAGE_STRING:\n      if (size == 0) size = strlen((char*)pvalue) + 1;\n    case BINN_STORAGE_BLOB:\n    case BINN_STORAGE_CONTAINER:\n      if (freefn == BINN_TRANSIENT) {\n        item->ptr = binn_memdup(pvalue, size);\n        if (item->ptr == NULL) {\n          free_fn(item);\n          return NULL;\n        }\n        item->freefn = free_fn;\n        if (storage_type == BINN_STORAGE_STRING) size--;\n      } else {\n        item->ptr = pvalue;\n        item->freefn = freefn;\n      }\n      item->size = size;\n      break;\n    default:\n      item->ptr = &item->vint32;\n      copy_raw_value(pvalue, item->ptr, storage_type);\n    }\n  }\n  return item;\n}\n",
    "copy_raw_value": "BINN_PRIVATE BOOL copy_raw_value(const void *psource, void *pdest, int data_store) {\n\n  switch (data_store) {\n  case BINN_STORAGE_NOBYTES:\n    break;\n  case BINN_STORAGE_BYTE:\n    *((char *) pdest) = *(char *)psource;\n    break;\n  case BINN_STORAGE_WORD:\n    *((short *) pdest) = *(short *)psource;\n    break;\n  case BINN_STORAGE_DWORD:\n    *((int *) pdest) = *(int *)psource;\n    break;\n  case BINN_STORAGE_QWORD:\n    *((uint64 *) pdest) = *(uint64 *)psource;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n  case BINN_STORAGE_CONTAINER:\n    *((char **) pdest) = (char *)psource;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n\n",
    "binn_load": "BOOL APIENTRY binn_load(const void *data, binn *value) {\n\n  if (data == NULL || value == NULL) return FALSE;\n  memset(value, 0, sizeof(binn));\n  value->header = BINN_MAGIC;\n  //value->allocated = FALSE;  --  already zeroed\n  //value->writable = FALSE;\n\n  if (binn_is_valid(data, &value->type, &value->count, &value->size) == FALSE) return FALSE;\n  value->ptr = (void*) data;\n  return TRUE;\n\n",
    "binn_map_next_value": "binn * APIENTRY binn_map_next_value(binn_iter *iter, int *pid) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_map_next(iter, pid, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "binn_object_uint8": "unsigned char APIENTRY binn_object_uint8(const void *obj, const char *key) {\n  unsigned char value;\n\n  binn_object_get(obj, key, BINN_UINT8, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_get_pair": "BOOL APIENTRY binn_object_get_pair(const void *ptr, int pos, char *pkey, binn *value) {\n\n  return binn_read_pair(BINN_OBJECT, ptr, pos, NULL, pkey, value);\n\n",
    "binn_object_next": "BOOL APIENTRY binn_object_next(binn_iter *iter, char *pkey, binn *value) {\n\n  return binn_read_next_pair(BINN_OBJECT, iter, NULL, pkey, value);\n\n",
    "copy_be16": "BINN_PRIVATE void copy_be16(u16 *pdest, u16 *psource) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  dest[0] = source[1];\n  dest[1] = source[0];\n#else // if BYTE_ORDER == BIG_ENDIAN\n",
    "binn_map_read": "void * APIENTRY binn_map_read(const void *map, int id, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_map_get_value(map, id, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "binn_object_blob": "void * APIENTRY binn_object_blob(const void *obj, const char *key, int *psize) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_BLOB, &value, psize);\n\n  return value;\n}\n",
    "binn_map_list": "void * APIENTRY binn_map_list(const void *map, int id) {\n  void *value;\n\n  binn_map_get(map, id, BINN_LIST, &value, NULL);\n\n  return value;\n}\n",
    "binn_map_uint32": "unsigned int APIENTRY binn_map_uint32(const void *map, int id) {\n  unsigned int value;\n\n  binn_map_get(map, id, BINN_UINT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_uint16": "unsigned short APIENTRY binn_object_uint16(const void *obj, const char *key) {\n  unsigned short value;\n\n  binn_object_get(obj, key, BINN_UINT16, &value, NULL);\n\n  return value;\n}\n",
    "store_value": "BINN_PRIVATE void * store_value(binn *value) {\n\n  memcpy(&local_value, value, sizeof(binn));\n\n  switch (binn_get_read_storage(value->type)) {\n  case BINN_STORAGE_NOBYTES:\n    // return a valid pointer\n  case BINN_STORAGE_WORD:\n  case BINN_STORAGE_DWORD:\n  case BINN_STORAGE_QWORD:\n    return &local_value.vint32;  // returns the pointer to the converted value, from big-endian to little-endian\n  }\n\n  return value->ptr;   // returns from the on stack value to be thread-safe (for list, map, object, string and blob)\n\n",
    "binn_map_int64": "int64 APIENTRY binn_map_int64(const void *map, int id) {\n  int64 value;\n\n  binn_map_get(map, id, BINN_INT64, &value, NULL);\n\n  return value;\n}\n",
    "binn_version": "char * APIENTRY binn_version() {\n  return BINN_VERSION;\n}\n",
    "binn_list_double": "double APIENTRY binn_list_double(const void *list, int pos) {\n  double value;\n\n  binn_list_get(list, pos, BINN_FLOAT64, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_int64": "int64 APIENTRY binn_object_int64(const void *obj, const char *key) {\n  int64 value;\n\n  binn_object_get(obj, key, BINN_INT64, &value, NULL);\n\n  return value;\n}\n",
    "binn_get_type_info": "BOOL APIENTRY binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type) {\n  int storage_type, extra_type;\n  BOOL retval=TRUE;\n\nagain:\n\n  if (long_type < 0) {\n    goto loc_invalid;\n  } else if (long_type <= 0xff) {\n    storage_type = long_type & BINN_STORAGE_MASK;\n    extra_type = long_type & BINN_TYPE_MASK;\n  } else if (long_type <= 0xffff) {\n    storage_type = long_type & BINN_STORAGE_MASK16;\n    storage_type >>= 8;\n    extra_type = long_type & BINN_TYPE_MASK16;\n    extra_type >>= 4;\n  } else if (long_type & BINN_STORAGE_VIRTUAL) {\n    //storage_type = BINN_STORAGE_VIRTUAL;\n    //extra_type = xxx;\n    long_type &= 0xffff;\n    goto again;\n  } else {\nloc_invalid:\n    storage_type = -1;\n    extra_type = -1;\n    retval = FALSE;\n  }\n\n  if (pstorage_type) *pstorage_type = storage_type;\n  if (pextra_type) *pextra_type = extra_type;\n\n  return retval;\n\n",
    "GetValue": "BINN_PRIVATE BOOL GetValue(unsigned char *p, unsigned char *plimit, binn *value) {\n  unsigned char byte;\n  int   data_type, storage_type;  //, extra_type;\n  int   DataSize;\n  void *p2;\n\n  if (value == NULL) return FALSE;\n  memset(value, 0, sizeof(binn));\n  value->header = BINN_MAGIC;\n  //value->allocated = FALSE;  --  already zeroed\n  //value->writable = FALSE;\n\n  // saves for use with BINN_STORAGE_CONTAINER\n  p2 = p;\n\n  // read the data type\n  if (p > plimit) return FALSE;\n  byte = *p; p++;\n  storage_type = byte & BINN_STORAGE_MASK;\n  if (byte & BINN_STORAGE_HAS_MORE) {\n    data_type = byte << 8;\n    if (p > plimit) return FALSE;\n    byte = *p; p++;\n    data_type |= byte;\n    //extra_type = data_type & BINN_TYPE_MASK16;\n  } else {\n    data_type = byte;\n    //extra_type = byte & BINN_TYPE_MASK;\n  }\n\n  //value->storage_type = storage_type;\n  value->type = data_type;\n\n  switch (storage_type) {\n  case BINN_STORAGE_NOBYTES:\n    break;\n  case BINN_STORAGE_BYTE:\n    if (p > plimit) return FALSE;\n    value->vuint8 = *((unsigned char *) p);\n    value->ptr = p;   //value->ptr = &value->vuint8;\n    break;\n  case BINN_STORAGE_WORD:\n    if (p + 1 > plimit) return FALSE;\n    copy_be16((u16*)&value->vint16, (u16*)p);\n    value->ptr = &value->vint16;\n    break;\n  case BINN_STORAGE_DWORD:\n    if (p + 3 > plimit) return FALSE;\n    copy_be32((u32*)&value->vint32, (u32*)p);\n    value->ptr = &value->vint32;\n    break;\n  case BINN_STORAGE_QWORD:\n    if (p + 7 > plimit) return FALSE;\n    copy_be64((u64*)&value->vint64, (u64*)p);\n    value->ptr = &value->vint64;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n    if (p > plimit) return FALSE;\n    DataSize = *((unsigned char*)p);\n    if (DataSize & 0x80) {\n      if (p + 3 > plimit) return FALSE;\n      copy_be32((u32*)&DataSize, (u32*)p);\n      DataSize &= 0x7FFFFFFF;\n      p+=4;\n    } else {\n      p++;\n    }\n    if (p + DataSize - 1 > plimit) return FALSE;\n    value->size = DataSize;\n    value->ptr = p;\n    break;\n  case BINN_STORAGE_CONTAINER:\n    value->ptr = p2;  // <-- it returns the pointer to the container, not the data\n    if (IsValidBinnHeader(p2, NULL, &value->count, &value->size, NULL) == FALSE) return FALSE;\n    break;\n  default:\n    return FALSE;\n  }\n\n  // convert the returned value, if needed\n\n  switch (value->type) {\n    case BINN_TRUE:\n      value->type = BINN_BOOL;\n      value->vbool = TRUE;\n      value->ptr = &value->vbool;\n      break;\n    case BINN_FALSE:\n      value->type = BINN_BOOL;\n      value->vbool = FALSE;\n      value->ptr = &value->vbool;\n      break;\n#ifdef BINN_EXTENDED\n    case BINN_SINGLE_STR:\n      value->type = BINN_SINGLE;\n      value->vfloat = (float) atof((const char*)value->ptr);  // converts from string to double, and then to float\n      value->ptr = &value->vfloat;\n      break;\n    case BINN_DOUBLE_STR:\n      value->type = BINN_DOUBLE;\n      value->vdouble = atof((const char*)value->ptr);  // converts from string to double\n      value->ptr = &value->vdouble;\n      break;\n#endif\n    /*\n    case BINN_DECIMAL:\n    case BINN_CURRENCYSTR:\n    case BINN_DATE:\n    case BINN_DATETIME:\n    case BINN_TIME:\n    */\n  }\n\n  return TRUE;\n\n",
    "binn_buf_type": "BINN_PRIVATE int binn_buf_type(const void *pbuf) {\n  int  type;\n\n  if (!IsValidBinnHeader(pbuf, &type, NULL, NULL, NULL)) return INVALID_BINN;\n\n  return type;\n\n",
    "binn_map_double": "double APIENTRY binn_map_double(const void *map, int id) {\n  double value;\n\n  binn_map_get(map, id, BINN_FLOAT64, &value, NULL);\n\n  return value;\n}\n",
    "binn_map_object": "void * APIENTRY binn_map_object(const void *map, int id) {\n  void *value;\n\n  binn_map_get(map, id, BINN_OBJECT, &value, NULL);\n\n  return value;\n}\n",
    "binn_copy": "binn * APIENTRY binn_copy(const void *old) {\n  int type, count, size, header_size;\n  unsigned char *old_ptr = binn_ptr(old);\n  binn *item;\n\n  size = 0;\n  if (!IsValidBinnHeader(old_ptr, &type, &count, &size, &header_size)) return NULL;\n\n  item = binn_new(type, size - header_size + MAX_BINN_HEADER, NULL);\n  if( item ){\n    unsigned char *dest;\n    dest = ((unsigned char *) item->pbuf) + MAX_BINN_HEADER;\n    memcpy(dest, old_ptr + header_size, size - header_size);\n    item->used_size = MAX_BINN_HEADER + size - header_size;\n    item->count = count;\n  }\n  return item;\n\n",
    "binn_list_int16": "short APIENTRY binn_list_int16(const void *list, int pos) {\n  short value;\n\n  binn_list_get(list, pos, BINN_INT16, &value, NULL);\n\n  return value;\n}\n",
    "binn_size": "int APIENTRY binn_size(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    if (item->writable && item->dirty) {\n      binn_save_header(item);\n    }\n    return item->size;\n  case BINN_BUFFER:\n    return binn_buf_size(ptr);\n  default:\n    return 0;\n  }\n",
    "SearchForKey": "BINN_PRIVATE unsigned char * SearchForKey(unsigned char *p, int header_size, int size, int numitems, const char *key) {\n  unsigned char len, *plimit, *base;\n  int  i, keylen;\n\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  keylen = strlen(key);\n\n  // search for the key in all the arguments.\n  for (i = 0; i < numitems; i++) {\n    if (p > plimit) break;\n    len = *((unsigned char *)p);\n    p++;\n    if (p + len > plimit) break;\n    // Compare if the strings are equal.\n    if (len > 0) {\n      if (strnicmp((char*)p, key, len) == 0) {   // note that there is no null terminator here\n        if (keylen == len) {\n          p += len;\n          return p;\n        }\n      }\n      p += len;\n    } else if (len == keylen) {   // in the case of empty string: \"\"\n      return p;\n    }\n    // xxx\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) break;\n  }\n\n  return NULL;\n\n",
    "binn_map_read_next": "void * APIENTRY binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_map_next(iter, pid, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "copy_int_value": "BINN_PRIVATE BOOL copy_int_value(const void *psource, void *pdest, int source_type, int dest_type) {\n  uint64 vuint64 = 0; int64 vint64 = 0;\n\n  switch (source_type) {\n  case BINN_INT8:\n    vint64 = *(signed char *)psource;\n    break;\n  case BINN_INT16:\n    vint64 = *(short *)psource;\n    break;\n  case BINN_INT32:\n    vint64 = *(int *)psource;\n    break;\n  case BINN_INT64:\n    vint64 = *(int64 *)psource;\n    break;\n\n  case BINN_UINT8:\n    vuint64 = *(unsigned char *)psource;\n    break;\n  case BINN_UINT16:\n    vuint64 = *(unsigned short *)psource;\n    break;\n  case BINN_UINT32:\n    vuint64 = *(unsigned int *)psource;\n    break;\n  case BINN_UINT64:\n    vuint64 = *(uint64 *)psource;\n    break;\n\n  default:\n    return FALSE;\n  }\n\n\n  // copy from int64 to uint64, if possible\n\n  if (int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT) {\n    if (vuint64 > INT64_MAX) return FALSE;\n    vint64 = vuint64;\n  } else if (int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT) {\n    if (vint64 < 0) return FALSE;\n    vuint64 = vint64;\n  }\n\n\n  switch (dest_type) {\n  case BINN_INT8:\n    if (vint64 < INT8_MIN || vint64 > INT8_MAX) return FALSE;\n    *(signed char *)pdest = (signed char) vint64;\n    break;\n  case BINN_INT16:\n    if (vint64 < INT16_MIN || vint64 > INT16_MAX) return FALSE;\n    *(short *)pdest = (short) vint64;\n    break;\n  case BINN_INT32:\n    if (vint64 < INT32_MIN || vint64 > INT32_MAX) return FALSE;\n    *(int *)pdest = (int) vint64;\n    break;\n  case BINN_INT64:\n    *(int64 *)pdest = vint64;\n    break;\n\n  case BINN_UINT8:\n    if (vuint64 > UINT8_MAX) return FALSE;\n    *(unsigned char *)pdest = (unsigned char) vuint64;\n    break;\n  case BINN_UINT16:\n    if (vuint64 > UINT16_MAX) return FALSE;\n    *(unsigned short *)pdest = (unsigned short) vuint64;\n    break;\n  case BINN_UINT32:\n    if (vuint64 > UINT32_MAX) return FALSE;\n    *(unsigned int *)pdest = (unsigned int) vuint64;\n    break;\n  case BINN_UINT64:\n    *(uint64 *)pdest = vuint64;\n    break;\n\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n\n",
    "binn_map_set_new": "BOOL APIENTRY binn_map_set_new(binn *map, int id, binn *value) {\n  BOOL retval;\n\n  retval = binn_map_set_value(map, id, value);\n  if (value) free_fn(value);\n  return retval;\n\n",
    "binn_object_bool": "BOOL APIENTRY binn_object_bool(const void *obj, const char *key) {\n  BOOL value;\n\n  binn_object_get(obj, key, BINN_BOOL, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_list": "void * APIENTRY binn_object_list(const void *obj, const char *key) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_LIST, &value, NULL);\n\n  return value;\n}\n",
    "binn_get_bool": "BOOL APIENTRY binn_get_bool(binn *value, BOOL *pbool) {\n  int64 vint;\n\n  if (value == NULL || pbool == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    if (copy_int_value(value->ptr, &vint, value->type, BINN_INT64) == FALSE) return FALSE;\n    *pbool = (vint != 0) ? TRUE : FALSE;\n    return TRUE;\n  }\n\n  switch (value->type) {\n  case BINN_BOOL:\n    *pbool = value->vbool;\n    break;\n  case BINN_FLOAT:\n    *pbool = (value->vfloat != 0) ? TRUE : FALSE;\n    break;\n  case BINN_DOUBLE:\n    *pbool = (value->vdouble != 0) ? TRUE : FALSE;\n    break;\n  case BINN_STRING:\n    return is_bool_str((char*)value->ptr, pbool);\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}\n",
    "binn_malloc": "BINN_PRIVATE void * binn_malloc(int size) {\n  check_alloc_functions();\n  return malloc_fn(size);\n}\n",
    "binn_map_int16": "short APIENTRY binn_map_int16(const void *map, int id) {\n  short value;\n\n  binn_map_get(map, id, BINN_INT16, &value, NULL);\n\n  return value;\n}\n",
    "binn_load_ex": "BOOL APIENTRY binn_load_ex(const void *data, int size, binn *value) {\n\n  if (data == NULL || value == NULL || size <= 0) return FALSE;\n  memset(value, 0, sizeof(binn));\n  value->header = BINN_MAGIC;\n  //value->allocated = FALSE;  --  already zeroed\n  //value->writable = FALSE;\n\n  if (binn_is_valid_ex(data, &value->type, &value->count, &size) == FALSE) return FALSE;\n  value->ptr = (void*) data;\n  value->size = size;\n  return TRUE;\n\n",
    "binn_object_set": "BOOL APIENTRY binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size) {\n\n  if (GetWriteConvertedData(&type, &pvalue, &size) == FALSE) return FALSE;\n\n  return binn_object_set_raw(obj, key, type, pvalue, size);\n\n",
    "binn_map_int8": "signed char APIENTRY binn_map_int8(const void *map, int id) {\n  signed char value;\n\n  binn_map_get(map, id, BINN_INT8, &value, NULL);\n\n  return value;\n}\n",
    "binn_map_int32": "int APIENTRY binn_map_int32(const void *map, int id) {\n  int value;\n\n  binn_map_get(map, id, BINN_INT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_double": "double APIENTRY binn_object_double(const void *obj, const char *key) {\n  double value;\n\n  binn_object_get(obj, key, BINN_FLOAT64, &value, NULL);\n\n  return value;\n}\n",
    "binn_get_str": "char * APIENTRY binn_get_str(binn *value) {\n  int64 vint;\n  char buf[128];\n\n  if (value == NULL) return NULL;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    if (copy_int_value(value->ptr, &vint, value->type, BINN_INT64) == FALSE) return NULL;\n    snprintf(buf, sizeof buf, \"%\" INT64_FORMAT, vint);\n    goto loc_convert_value;\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    value->vdouble = value->vfloat;\n  case BINN_DOUBLE:\n    snprintf(buf, sizeof buf, \"%g\", value->vdouble);\n    goto loc_convert_value;\n  case BINN_STRING:\n    return (char*) value->ptr;\n  case BINN_BOOL:\n    if (value->vbool)\n      strcpy(buf, \"true\");\n    else\n      strcpy(buf, \"false\");\n    goto loc_convert_value;\n  }\n\n  return NULL;\n\nloc_convert_value:\n\n  //value->vint64 = 0;\n  value->ptr = strdup(buf);\n  if (value->ptr == NULL) return NULL;\n  value->freefn = free;\n  value->type = BINN_STRING;\n  return (char*) value->ptr;\n\n",
    "CheckAllocation": "BINN_PRIVATE BOOL CheckAllocation(binn *item, int add_size) {\n  int  alloc_size;\n  void *ptr;\n\n  if (item->used_size + add_size > item->alloc_size) {\n    if (item->pre_allocated) return FALSE;\n    alloc_size = CalcAllocation(item->used_size + add_size, item->alloc_size);\n    ptr = realloc_fn(item->pbuf, alloc_size);\n    if (ptr == NULL) return FALSE;\n    item->pbuf = ptr;\n    item->alloc_size = alloc_size;\n  }\n\n  return TRUE;\n\n",
    "binn_create_list": "BOOL APIENTRY binn_create_list(binn *list) {\n\n  return binn_create(list, BINN_LIST, 0, NULL);\n\n",
    "binn_save_header": "BINN_PRIVATE BOOL binn_save_header(binn *item) {\n  unsigned char byte, *p;\n  int int32, size;\n\n  if (item == NULL) return FALSE;\n\n#ifndef BINN_DISABLE_SMALL_HEADER\n\n  p = ((unsigned char *) item->pbuf) + MAX_BINN_HEADER;\n  size = item->used_size - MAX_BINN_HEADER + 3;  // at least 3 bytes for the header\n\n  // write the count\n  if (item->count > 127) {\n    p -= 4;\n    size += 3;\n    int32 = item->count | 0x80000000;\n    copy_be32((u32*)p, (u32*)&int32);\n  } else {\n    p--;\n    *p = (unsigned char) item->count;\n  }\n\n  // write the size\n  if (size > 127) {\n    p -= 4;\n    size += 3;\n    int32 = size | 0x80000000;\n    copy_be32((u32*)p, (u32*)&int32);\n  } else {\n    p--;\n    *p = (unsigned char) size;\n  }\n\n  // write the type.\n  p--;\n  *p = (unsigned char) item->type;\n\n  // set the values\n  item->ptr = p;\n  item->size = size;\n\n  UNUSED(byte);\n\n#else\n\n  p = (unsigned char *) item->pbuf;\n\n  // write the type.\n  byte = item->type;\n  *p = byte; p++;\n  // write the size\n  int32 = item->used_size | 0x80000000;\n  copy_be32((u32*)p, (u32*)&int32);\n  p+=4;\n  // write the count\n  int32 = item->count | 0x80000000;\n  copy_be32((u32*)p, (u32*)&int32);\n\n  item->ptr = item->pbuf;\n  item->size = item->used_size;\n\n#endif\n\n  item->dirty = FALSE;\n\n  return TRUE;\n\n",
    "binn_list": "binn * APIENTRY binn_list() {\n  return binn_new(BINN_LIST, 0, 0);\n}\n",
    "binn_list_value": "binn * APIENTRY binn_list_value(const void *ptr, int pos) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_list_get_value(ptr, pos, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "binn_list_map": "void * APIENTRY binn_list_map(const void *list, int pos) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_MAP, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_float": "float APIENTRY binn_object_float(const void *obj, const char *key) {\n  float value;\n\n  binn_object_get(obj, key, BINN_FLOAT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_object_pair": "binn * APIENTRY binn_object_pair(const void *obj, int pos, char *pkey) {\n  binn *value;\n\n  value = (binn *) binn_malloc(sizeof(binn));\n\n  if (binn_read_pair(BINN_OBJECT, obj, pos, NULL, pkey, value) == FALSE) {\n    free_fn(value);\n    return NULL;\n  }\n\n  value->allocated = TRUE;\n  return value;\n\n",
    "binn_map_read_pair": "void * APIENTRY binn_map_read_pair(const void *ptr, int pos, int *pid, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_map_get_pair(ptr, pos, pid, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "binn_object_read": "void * APIENTRY binn_object_read(const void *obj, const char *key, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_object_get_value(obj, key, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "binn_object_int8": "signed char APIENTRY binn_object_int8(const void *obj, const char *key) {\n  signed char value;\n\n  binn_object_get(obj, key, BINN_INT8, &value, NULL);\n\n  return value;\n}\n",
    "binn_memdup": "BINN_PRIVATE void * binn_memdup(const void *src, int size) {\n  void *dest;\n\n  if (src == NULL || size <= 0) return NULL;\n  dest = binn_malloc(size);\n  if (dest == NULL) return NULL;\n  memcpy(dest, src, size);\n  return dest;\n\n",
    "binn_list_str": "char * APIENTRY binn_list_str(const void *list, int pos) {\n  char *value;\n\n  binn_list_get(list, pos, BINN_STRING, &value, NULL);\n\n  return value;\n}\n",
    "binn_map": "binn * APIENTRY binn_map() {\n  return binn_new(BINN_MAP, 0, 0);\n}\n",
    "copy_float_value": "BINN_PRIVATE BOOL copy_float_value(const void *psource, void *pdest, int source_type, int dest_type) {\n\n  switch (source_type) {\n  case BINN_FLOAT32:\n    *(double *)pdest = *(float *)psource;\n    break;\n  case BINN_FLOAT64:\n    *(float *)pdest = (float) *(double *)psource;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n\n",
    "is_bool_str": "BINN_PRIVATE BOOL is_bool_str(char *str, BOOL *pbool) {\n  int64  vint;\n  double vdouble;\n\n  if (str == NULL || pbool == NULL) return FALSE;\n\n  if (stricmp(str, \"true\") == 0) goto loc_true;\n  if (stricmp(str, \"yes\") == 0) goto loc_true;\n  if (stricmp(str, \"on\") == 0) goto loc_true;\n  //if (stricmp(str, \"1\") == 0) goto loc_true;\n\n  if (stricmp(str, \"false\") == 0) goto loc_false;\n  if (stricmp(str, \"no\") == 0) goto loc_false;\n  if (stricmp(str, \"off\") == 0) goto loc_false;\n  //if (stricmp(str, \"0\") == 0) goto loc_false;\n\n  if (is_integer(str)) {\n    vint = atoi64(str);\n    *pbool = (vint != 0) ? TRUE : FALSE;\n    return TRUE;\n  } else if (is_float(str)) {\n    vdouble = atof(str);\n    *pbool = (vdouble != 0) ? TRUE : FALSE;\n    return TRUE;\n  }\n\n  return FALSE;\n\nloc_true:\n  *pbool = TRUE;\n  return TRUE;\n\nloc_false:\n  *pbool = FALSE;\n  return TRUE;\n\n",
    "binn_free": "void APIENTRY binn_free(binn *item) {\n\n  if (item == NULL) return;\n\n  if (item->writable && item->pre_allocated == FALSE) {\n    free_fn(item->pbuf);\n  }\n\n  if (item->freefn) item->freefn(item->ptr);\n\n  if (item->allocated) {\n    free_fn(item);\n  } else {\n    memset(item, 0, sizeof(binn));\n    item->header = BINN_MAGIC;\n  }\n",
    "read_map_id": "BINN_PRIVATE int read_map_id(unsigned char **pp, unsigned char *plimit) {\n  unsigned char *p, c, sign, type;\n  int id, extra_bytes;\n\n  p = *pp;\n  if (p > plimit) return 0;\n\n  c = *p++;\n\n  if (c & 0x80) {\n    extra_bytes = ((c & 0x60) >> 5) + 1;\n    if (p + extra_bytes > plimit ) {\n      *pp = p + extra_bytes;\n      return 0;\n    }\n  }\n\n  type = c & 0xE0;\n  sign = c & 0x10;\n\n  if ((c & 0x80) == 0) {\n    sign = c & 0x40;\n    id = c & 0x3F;\n  } else if (type == 0x80) {\n    id = c & 0x0F;\n    id = (id << 8) | *p++;\n  } else if (type == 0xA0) {\n    id = c & 0x0F;\n    id = (id << 8) | *p++;\n    id = (id << 8) | *p++;\n  } else if (type == 0xC0) {\n    id = c & 0x0F;\n    id = (id << 8) | *p++;\n    id = (id << 8) | *p++;\n    id = (id << 8) | *p++;\n  } else if (type == 0xE0) {\n    copy_be32((u32*)&id, (u32*)p);\n    p += 4;\n  } else {\n    *pp = plimit + 2;\n    return 0;\n  }\n\n  if (sign) id = -id;\n\n  *pp = p;\n\n  return id;\n}\n",
    "binn_create_object": "BOOL APIENTRY binn_create_object(binn *object) {\n\n  return binn_create(object, BINN_OBJECT, 0, NULL);\n\n",
    "binn_map_get_pair": "BOOL APIENTRY binn_map_get_pair(const void *ptr, int pos, int *pid, binn *value) {\n\n  return binn_read_pair(BINN_MAP, ptr, pos, pid, NULL, value);\n\n",
    "copy_value": "BINN_PRIVATE BOOL copy_value(void *psource, void *pdest, int source_type, int dest_type, int data_store) {\n\n  if (type_family(source_type) != type_family(dest_type)) return FALSE;\n\n  if (type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type) {\n    return copy_int_value(psource, pdest, source_type, dest_type);\n  } else if (type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type) {\n    return copy_float_value(psource, pdest, source_type, dest_type);\n  } else {\n    return copy_raw_value(psource, pdest, data_store);\n  }\n",
    "binn_map_uint64": "uint64 APIENTRY binn_map_uint64(const void *map, int id) {\n  uint64 value;\n\n  binn_map_get(map, id, BINN_UINT64, &value, NULL);\n\n  return value;\n}\n",
    "binn_list_float": "float APIENTRY binn_list_float(const void *list, int pos) {\n  float value;\n\n  binn_list_get(list, pos, BINN_FLOAT32, &value, NULL);\n\n  return value;\n}\n",
    "binn_map_get": "BOOL APIENTRY binn_map_get(const void *ptr, int id, int type, void *pvalue, int *psize) {\n  binn value;\n  int storage_type;\n\n  storage_type = binn_get_read_storage(type);\n  if (storage_type != BINN_STORAGE_NOBYTES && pvalue == NULL) return FALSE;\n\n  zero_value(pvalue, type);\n\n  if (binn_map_get_value(ptr, id, &value) == FALSE) return FALSE;\n\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == FALSE) return FALSE;\n\n  if (psize) *psize = value.size;\n\n  return TRUE;\n\n",
    "AdvanceDataPos": "BINN_PRIVATE unsigned char * AdvanceDataPos(unsigned char *p, unsigned char *plimit) {\n  unsigned char byte;\n  int  storage_type, DataSize;\n\n  if (p > plimit) return 0;\n\n  byte = *p; p++;\n  storage_type = byte & BINN_STORAGE_MASK;\n  if (byte & BINN_STORAGE_HAS_MORE) p++;\n\n  switch (storage_type) {\n  case BINN_STORAGE_NOBYTES:\n    //p += 0;\n    break;\n  case BINN_STORAGE_BYTE:\n    p ++;\n    break;\n  case BINN_STORAGE_WORD:\n    p += 2;\n    break;\n  case BINN_STORAGE_DWORD:\n    p += 4;\n    break;\n  case BINN_STORAGE_QWORD:\n    p += 8;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n    if (p > plimit) return 0;\n    DataSize = *((unsigned char*)p);\n    if (DataSize & 0x80) {\n      if (p + sizeof(int) - 1 > plimit) return 0;\n      copy_be32((u32*)&DataSize, (u32*)p);\n      DataSize &= 0x7FFFFFFF;\n      p+=4;\n    } else {\n      p++;\n    }\n    p += DataSize;\n    if (storage_type == BINN_STORAGE_STRING) {\n      p++;  // null terminator.\n    }\n    break;\n  case BINN_STORAGE_CONTAINER:\n    if (p > plimit) return 0;\n    DataSize = *((unsigned char*)p);\n    if (DataSize & 0x80) {\n      if (p + sizeof(int) - 1 > plimit) return 0;\n      copy_be32((u32*)&DataSize, (u32*)p);\n      DataSize &= 0x7FFFFFFF;\n    }\n    DataSize--;  // remove the type byte already added before\n    p += DataSize;\n    break;\n  default:\n    return 0;\n  }\n\n  return p;\n\n",
    "binn_list_add_new": "BOOL APIENTRY binn_list_add_new(binn *list, binn *value) {\n  BOOL retval;\n\n  retval = binn_list_add_value(list, value);\n  if (value) free_fn(value);\n  return retval;\n\n",
    "binn_get_write_storage": "int APIENTRY binn_get_write_storage(int type) {\n  int storage_type;\n\n  switch (type) {\n    case BINN_SINGLE_STR:\n    case BINN_DOUBLE_STR:\n      return BINN_STORAGE_STRING;\n\n    case BINN_BOOL:\n      return BINN_STORAGE_NOBYTES;\n\n    default:\n      binn_get_type_info(type, &storage_type, NULL);\n      return storage_type;\n  }\n",
    "binn_list_get": "BOOL APIENTRY binn_list_get(const void *ptr, int pos, int type, void *pvalue, int *psize) {\n  binn value;\n  int storage_type;\n\n  storage_type = binn_get_read_storage(type);\n  if (storage_type != BINN_STORAGE_NOBYTES && pvalue == NULL) return FALSE;\n\n  zero_value(pvalue, type);\n\n  if (binn_list_get_value(ptr, pos, &value) == FALSE) return FALSE;\n\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == FALSE) return FALSE;\n\n  if (psize) *psize = value.size;\n\n  return TRUE;\n\n",
    "binn_list_null": "BOOL APIENTRY binn_list_null(const void *list, int pos) {\n\n  return binn_list_get(list, pos, BINN_NULL, NULL, NULL);\n\n",
    "binn_open": "binn * APIENTRY binn_open(const void *data) {\n  binn *item;\n\n  item = (binn*) binn_malloc(sizeof(binn));\n\n  if (binn_load(data, item) == FALSE) {\n    free_fn(item);\n    return NULL;\n  }\n\n  item->allocated = TRUE;\n  return item;\n\n",
    "binn_set_blob": "BOOL APIENTRY binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree) {\n\n  if (item == NULL || ptr == NULL) return FALSE;\n\n  if (pfree == BINN_TRANSIENT) {\n    item->ptr = binn_memdup(ptr, size);\n    if (item->ptr == NULL) return FALSE;\n    item->freefn = free_fn;\n  } else {\n    item->ptr = ptr;\n    item->freefn = pfree;\n  }\n\n  item->type = BINN_BLOB;\n  item->size = size;\n  return TRUE;\n\n",
    "binn_list_read": "void * APIENTRY binn_list_read(const void *list, int pos, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_list_get_value(list, pos, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n",
    "binn_object_get_value": "BOOL APIENTRY binn_object_get_value(const void *ptr, const char *key, binn *value) {\n  int type, count, size=0, header_size;\n  unsigned char *p, *plimit;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || key == NULL || value == NULL) return FALSE;\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != BINN_OBJECT) return FALSE;\n  if (count == 0) return FALSE;\n\n  p = (unsigned char *) ptr;\n  plimit = p + size - 1;\n\n  p = SearchForKey(p, header_size, size, count, key);\n  if (p == FALSE) return FALSE;\n\n  return GetValue(p, plimit, value);\n\n",
    "binn_object_uint32": "unsigned int APIENTRY binn_object_uint32(const void *obj, const char *key) {\n  unsigned int value;\n\n  binn_object_get(obj, key, BINN_UINT32, &value, NULL);\n\n  return value;\n}\n",
    "check_alloc_functions": "BINN_PRIVATE void check_alloc_functions() {\n\n  if (malloc_fn == 0) malloc_fn = &malloc;\n  if (realloc_fn == 0) realloc_fn = &realloc;\n  if (free_fn == 0) free_fn = &free;\n\n",
    "SearchForID": "BINN_PRIVATE unsigned char * SearchForID(unsigned char *p, int header_size, int size, int numitems, int id) {\n  unsigned char *plimit, *base;\n  int  i, int32;\n\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  // search for the ID in all the arguments.\n  for (i = 0; i < numitems; i++) {\n    int32 = read_map_id(&p, plimit);\n    if (p > plimit) break;\n    // Compare if the IDs are equal.\n    if (int32 == id) return p;\n    // xxx\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) break;\n  }\n\n  return NULL;\n\n",
    "binn_list_get_uint64": "ALWAYS_INLINE BOOL binn_list_get_uint64(const void *list, int pos, uint64 *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT64, pvalue, NULL);\n}\n",
    "binn_map_set_int32": "ALWAYS_INLINE BOOL binn_map_set_int32(binn *map, int id, int value) {\n  return binn_map_set(map, id, BINN_INT32, &value, 0);\n}\n",
    "binn_map_get_str": "ALWAYS_INLINE BOOL binn_map_get_str(const void *map, int id, char **pvalue) {\n  return binn_map_get(map, id, BINN_STRING, pvalue, NULL);\n}\n",
    "binn_map_set_double": "ALWAYS_INLINE BOOL binn_map_set_double(binn *map, int id, double value) {\n  return binn_map_set(map, id, BINN_FLOAT64, &value, 0);\n}\n",
    "binn_list_get_int16": "ALWAYS_INLINE BOOL binn_list_get_int16(const void *list, int pos, short *pvalue) {\n  return binn_list_get(list, pos, BINN_INT16, pvalue, NULL);\n}\n",
    "binn_object_get_int8": "ALWAYS_INLINE BOOL binn_object_get_int8(const void *obj, const char *key, signed char *pvalue) {\n  return binn_object_get(obj, key, BINN_INT8, pvalue, NULL);\n}\n",
    "binn_null": "ALWAYS_INLINE binn * binn_null() {\n  return binn_value(BINN_NULL, NULL, 0, NULL);\n}\n",
    "binn_list_add_str": "ALWAYS_INLINE BOOL binn_list_add_str(binn *list, char *str) {\n  return binn_list_add(list, BINN_STRING, str, 0);\n}\n",
    "binn_list_get_int32": "ALWAYS_INLINE BOOL binn_list_get_int32(const void *list, int pos, int *pvalue) {\n  return binn_list_get(list, pos, BINN_INT32, pvalue, NULL);\n}\n",
    "binn_map_set_null": "ALWAYS_INLINE BOOL binn_map_set_null(binn *map, int id) {\n  return binn_map_set(map, id, BINN_NULL, NULL, 0);\n}\n",
    "binn_map_set_map": "ALWAYS_INLINE BOOL binn_map_set_map(binn *map, int id, void *map2) {\n  return binn_map_set(map, id, BINN_MAP, binn_ptr(map2), binn_size(map2));\n}\n",
    "binn_list_add_uint16": "ALWAYS_INLINE BOOL binn_list_add_uint16(binn *list, unsigned short value) {\n  return binn_list_add(list, BINN_UINT16, &value, 0);\n}\n",
    "binn_map_set_uint64": "ALWAYS_INLINE BOOL binn_map_set_uint64(binn *map, int id, uint64 value) {\n  return binn_map_set(map, id, BINN_UINT64, &value, 0);\n}\n",
    "binn_list_add_map": "ALWAYS_INLINE BOOL binn_list_add_map(binn *list, void *map) {\n  return binn_list_add(list, BINN_MAP, binn_ptr(map), binn_size(map));\n}\n",
    "binn_map_get_double": "ALWAYS_INLINE BOOL binn_map_get_double(const void *map, int id, double *pvalue) {\n  return binn_map_get(map, id, BINN_FLOAT64, pvalue, NULL);\n}\n",
    "binn_object_set_int8": "ALWAYS_INLINE BOOL binn_object_set_int8(binn *obj, const char *key, signed char value) {\n  return binn_object_set(obj, key, BINN_INT8, &value, 0);\n}\n",
    "binn_map_set_int64": "ALWAYS_INLINE BOOL binn_map_set_int64(binn *map, int id, int64 value) {\n  return binn_map_set(map, id, BINN_INT64, &value, 0);\n}\n",
    "binn_list_add_double": "ALWAYS_INLINE BOOL binn_list_add_double(binn *list, double value) {\n  return binn_list_add(list, BINN_FLOAT64, &value, 0);\n}\n",
    "binn_object_set_int16": "ALWAYS_INLINE BOOL binn_object_set_int16(binn *obj, const char *key, short value) {\n  return binn_object_set(obj, key, BINN_INT16, &value, 0);\n}\n",
    "binn_object_set_uint8": "ALWAYS_INLINE BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value) {\n  return binn_object_set(obj, key, BINN_UINT8, &value, 0);\n}\n",
    "binn_list_get_str": "ALWAYS_INLINE BOOL binn_list_get_str(const void *list, int pos, char **pvalue) {\n  return binn_list_get(list, pos, BINN_STRING, pvalue, NULL);\n}\n",
    "binn_object_set_double": "ALWAYS_INLINE BOOL binn_object_set_double(binn *obj, const char *key, double value) {\n  return binn_object_set(obj, key, BINN_FLOAT64, &value, 0);\n}\n",
    "binn_list_get_float": "ALWAYS_INLINE BOOL binn_list_get_float(const void *list, int pos, float *pvalue) {\n  return binn_list_get(list, pos, BINN_FLOAT32, pvalue, NULL);\n}\n",
    "binn_map_set_uint16": "ALWAYS_INLINE BOOL binn_map_set_uint16(binn *map, int id, unsigned short value) {\n  return binn_map_set(map, id, BINN_UINT16, &value, 0);\n}\n",
    "binn_list_get_object": "ALWAYS_INLINE BOOL binn_list_get_object(const void *list, int pos, void **pvalue) {\n  return binn_list_get(list, pos, BINN_OBJECT, pvalue, NULL);\n}\n",
    "binn_map_get_int16": "ALWAYS_INLINE BOOL binn_map_get_int16(const void *map, int id, short *pvalue) {\n  return binn_map_get(map, id, BINN_INT16, pvalue, NULL);\n}\n",
    "binn_map_get_uint32": "ALWAYS_INLINE BOOL binn_map_get_uint32(const void *map, int id, unsigned int *pvalue) {\n  return binn_map_get(map, id, BINN_UINT32, pvalue, NULL);\n}\n",
    "binn_object_set_uint16": "ALWAYS_INLINE BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value) {\n  return binn_object_set(obj, key, BINN_UINT16, &value, 0);\n}\n",
    "binn_object_get_int16": "ALWAYS_INLINE BOOL binn_object_get_int16(const void *obj, const char *key, short *pvalue) {\n  return binn_object_get(obj, key, BINN_INT16, pvalue, NULL);\n}\n",
    "binn_list_get_int64": "ALWAYS_INLINE BOOL binn_list_get_int64(const void *list, int pos, int64 *pvalue) {\n  return binn_list_get(list, pos, BINN_INT64, pvalue, NULL);\n}\n",
    "binn_object_set_uint32": "ALWAYS_INLINE BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value) {\n  return binn_object_set(obj, key, BINN_UINT32, &value, 0);\n}\n",
    "binn_map_get_int8": "ALWAYS_INLINE BOOL binn_map_get_int8(const void *map, int id, signed char *pvalue) {\n  return binn_map_get(map, id, BINN_INT8, pvalue, NULL);\n}\n",
    "binn_list_get_blob": "ALWAYS_INLINE BOOL binn_list_get_blob(const void *list, int pos, void **pvalue, int *psize) {\n  return binn_list_get(list, pos, BINN_BLOB, pvalue, psize);\n}\n",
    "binn_map_get_list": "ALWAYS_INLINE BOOL binn_map_get_list(const void *map, int id, void **pvalue) {\n  return binn_map_get(map, id, BINN_LIST, pvalue, NULL);\n}\n",
    "binn_object_set_map": "ALWAYS_INLINE BOOL binn_object_set_map(binn *obj, const char *key, void *map) {\n  return binn_object_set(obj, key, BINN_MAP, binn_ptr(map), binn_size(map));\n}\n",
    "binn_list_add_int32": "ALWAYS_INLINE BOOL binn_list_add_int32(binn *list, int value) {\n  return binn_list_add(list, BINN_INT32, &value, 0);\n}\n",
    "binn_object_get_str": "ALWAYS_INLINE BOOL binn_object_get_str(const void *obj, const char *key, char **pvalue) {\n  return binn_object_get(obj, key, BINN_STRING, pvalue, NULL);\n}\n",
    "binn_map_set_int16": "ALWAYS_INLINE BOOL binn_map_set_int16(binn *map, int id, short value) {\n  return binn_map_set(map, id, BINN_INT16, &value, 0);\n}\n",
    "binn_uint16": "ALWAYS_INLINE binn * binn_uint16(unsigned short value) {\n  return binn_value(BINN_UINT16, &value, 0, NULL);\n}\n",
    "binn_object_set_float": "ALWAYS_INLINE BOOL binn_object_set_float(binn *obj, const char *key, float value) {\n  return binn_object_set(obj, key, BINN_FLOAT32, &value, 0);\n}\n",
    "binn_int64": "ALWAYS_INLINE binn * binn_int64(int64 value) {\n  return binn_value(BINN_INT64, &value, 0, NULL);\n}\n",
    "binn_blob": "ALWAYS_INLINE binn * binn_blob(void *ptr, int size, binn_mem_free freefn) {\n  return binn_value(BINN_BLOB, ptr, size, freefn);\n}\n",
    "binn_map_set_int8": "ALWAYS_INLINE BOOL binn_map_set_int8(binn *map, int id, signed char value) {\n  return binn_map_set(map, id, BINN_INT8, &value, 0);\n}\n",
    "binn_map_set_blob": "ALWAYS_INLINE BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size) {\n  return binn_map_set(map, id, BINN_BLOB, ptr, size);\n}\n",
    "binn_map_set_str": "ALWAYS_INLINE BOOL binn_map_set_str(binn *map, int id, char *str) {\n  return binn_map_set(map, id, BINN_STRING, str, 0);\n}\n",
    "binn_list_get_int8": "ALWAYS_INLINE BOOL binn_list_get_int8(const void *list, int pos, signed char *pvalue) {\n  return binn_list_get(list, pos, BINN_INT8, pvalue, NULL);\n}\n",
    "binn_object_set_object": "ALWAYS_INLINE BOOL binn_object_set_object(binn *obj, const char *key, void *obj2) {\n  return binn_object_set(obj, key, BINN_OBJECT, binn_ptr(obj2), binn_size(obj2));\n}\n",
    "binn_int32": "ALWAYS_INLINE binn * binn_int32(int value) {\n  return binn_value(BINN_INT32, &value, 0, NULL);\n}\n",
    "binn_map_get_float": "ALWAYS_INLINE BOOL binn_map_get_float(const void *map, int id, float *pvalue) {\n  return binn_map_get(map, id, BINN_FLOAT32, pvalue, NULL);\n}\n",
    "binn_object_get_int32": "ALWAYS_INLINE BOOL binn_object_get_int32(const void *obj, const char *key, int *pvalue) {\n  return binn_object_get(obj, key, BINN_INT32, pvalue, NULL);\n}\n",
    "binn_list_get_uint16": "ALWAYS_INLINE BOOL binn_list_get_uint16(const void *list, int pos, unsigned short *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT16, pvalue, NULL);\n}\n",
    "binn_list_add_uint64": "ALWAYS_INLINE BOOL binn_list_add_uint64(binn *list, uint64 value) {\n  return binn_list_add(list, BINN_UINT64, &value, 0);\n}\n",
    "binn_list_get_list": "ALWAYS_INLINE BOOL binn_list_get_list(const void *list, int pos, void **pvalue) {\n  return binn_list_get(list, pos, BINN_LIST, pvalue, NULL);\n}\n",
    "binn_list_add_uint8": "ALWAYS_INLINE BOOL binn_list_add_uint8(binn *list, unsigned char value) {\n  return binn_list_add(list, BINN_UINT8, &value, 0);\n}\n",
    "binn_map_get_int64": "ALWAYS_INLINE BOOL binn_map_get_int64(const void *map, int id, int64 *pvalue) {\n  return binn_map_get(map, id, BINN_INT64, pvalue, NULL);\n}\n",
    "binn_object_set_list": "ALWAYS_INLINE BOOL binn_object_set_list(binn *obj, const char *key, void *list) {\n  return binn_object_set(obj, key, BINN_LIST, binn_ptr(list), binn_size(list));\n}\n",
    "binn_map_get_object": "ALWAYS_INLINE BOOL binn_map_get_object(const void *map, int id, void **pvalue) {\n  return binn_map_get(map, id, BINN_OBJECT, pvalue, NULL);\n}\n",
    "binn_object_set_uint64": "ALWAYS_INLINE BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value) {\n  return binn_object_set(obj, key, BINN_UINT64, &value, 0);\n}\n",
    "binn_int16": "ALWAYS_INLINE binn * binn_int16(short value) {\n  return binn_value(BINN_INT16, &value, 0, NULL);\n}\n",
    "binn_list_add_blob": "ALWAYS_INLINE BOOL binn_list_add_blob(binn *list, void *ptr, int size) {\n  return binn_list_add(list, BINN_BLOB, ptr, size);\n}\n",
    "binn_object_get_blob": "ALWAYS_INLINE BOOL binn_object_get_blob(const void *obj, const char *key, void **pvalue, int *psize) {\n  return binn_object_get(obj, key, BINN_BLOB, pvalue, psize);\n}\n",
    "binn_list_add_null": "ALWAYS_INLINE BOOL binn_list_add_null(binn *list) {\n  return binn_list_add(list, BINN_NULL, NULL, 0);\n}\n",
    "binn_list_add_int64": "ALWAYS_INLINE BOOL binn_list_add_int64(binn *list, int64 value) {\n  return binn_list_add(list, BINN_INT64, &value, 0);\n}\n",
    "binn_map_set_uint8": "ALWAYS_INLINE BOOL binn_map_set_uint8(binn *map, int id, unsigned char value) {\n  return binn_map_set(map, id, BINN_UINT8, &value, 0);\n}\n",
    "binn_object_set_int64": "ALWAYS_INLINE BOOL binn_object_set_int64(binn *obj, const char *key, int64 value) {\n  return binn_object_set(obj, key, BINN_INT64, &value, 0);\n}\n",
    "binn_map_set_value": "ALWAYS_INLINE BOOL binn_map_set_value(binn *map, int id, binn *value) {\n  return binn_map_set(map, id, value->type, binn_ptr(value), binn_size(value));\n}\n",
    "binn_list_get_bool": "ALWAYS_INLINE BOOL binn_list_get_bool(const void *list, int pos, BOOL *pvalue) {\n  return binn_list_get(list, pos, BINN_BOOL, pvalue, NULL);\n}\n",
    "binn_bool": "ALWAYS_INLINE binn * binn_bool(BOOL value) {\n  return binn_value(BINN_BOOL, &value, 0, NULL);\n}\n",
    "binn_map_set_float": "ALWAYS_INLINE BOOL binn_map_set_float(binn *map, int id, float value) {\n  return binn_map_set(map, id, BINN_FLOAT32, &value, 0);\n}\n",
    "binn_map_set_list": "ALWAYS_INLINE BOOL binn_map_set_list(binn *map, int id, void *list) {\n  return binn_map_set(map, id, BINN_LIST, binn_ptr(list), binn_size(list));\n}\n",
    "binn_string": "ALWAYS_INLINE binn * binn_string(char *str, binn_mem_free freefn) {\n  return binn_value(BINN_STRING, str, 0, freefn);\n}\n",
    "binn_list_add_value": "ALWAYS_INLINE BOOL binn_list_add_value(binn *list, binn *value) {\n  return binn_list_add(list, value->type, binn_ptr(value), binn_size(value));\n}\n",
    "binn_object_get_double": "ALWAYS_INLINE BOOL binn_object_get_double(const void *obj, const char *key, double *pvalue) {\n  return binn_object_get(obj, key, BINN_FLOAT64, pvalue, NULL);\n}\n",
    "binn_list_add_bool": "ALWAYS_INLINE BOOL binn_list_add_bool(binn *list, BOOL value) {\n  return binn_list_add(list, BINN_BOOL, &value, 0);\n}\n",
    "binn_map_get_uint64": "ALWAYS_INLINE BOOL binn_map_get_uint64(const void *map, int id, uint64 *pvalue) {\n  return binn_map_get(map, id, BINN_UINT64, pvalue, NULL);\n}\n",
    "binn_list_add_int8": "ALWAYS_INLINE BOOL binn_list_add_int8(binn *list, signed char value) {\n  return binn_list_add(list, BINN_INT8, &value, 0);\n}\n",
    "binn_object_get_uint32": "ALWAYS_INLINE BOOL binn_object_get_uint32(const void *obj, const char *key, unsigned int *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT32, pvalue, NULL);\n}\n",
    "binn_map_get_map": "ALWAYS_INLINE BOOL binn_map_get_map(const void *map, int id, void **pvalue) {\n  return binn_map_get(map, id, BINN_MAP, pvalue, NULL);\n}\n",
    "binn_list_add_uint32": "ALWAYS_INLINE BOOL binn_list_add_uint32(binn *list, unsigned int value) {\n  return binn_list_add(list, BINN_UINT32, &value, 0);\n}\n",
    "binn_map_set_uint32": "ALWAYS_INLINE BOOL binn_map_set_uint32(binn *map, int id, unsigned int value) {\n  return binn_map_set(map, id, BINN_UINT32, &value, 0);\n}\n",
    "binn_object_set_bool": "ALWAYS_INLINE BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value) {\n  return binn_object_set(obj, key, BINN_BOOL, &value, 0);\n}\n",
    "binn_list_add_object": "ALWAYS_INLINE BOOL binn_list_add_object(binn *list, void *obj) {\n  return binn_list_add(list, BINN_OBJECT, binn_ptr(obj), binn_size(obj));\n}\n",
    "binn_object_get_uint8": "ALWAYS_INLINE BOOL binn_object_get_uint8(const void *obj, const char *key, unsigned char *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT8, pvalue, NULL);\n}\n",
    "binn_map_get_int32": "ALWAYS_INLINE BOOL binn_map_get_int32(const void *map, int id, int *pvalue) {\n  return binn_map_get(map, id, BINN_INT32, pvalue, NULL);\n}\n",
    "binn_object_set_blob": "ALWAYS_INLINE BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size) {\n  return binn_object_set(obj, key, BINN_BLOB, ptr, size);\n}\n",
    "binn_object_get_uint64": "ALWAYS_INLINE BOOL binn_object_get_uint64(const void *obj, const char *key, uint64 *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT64, pvalue, NULL);\n}\n",
    "binn_map_set_object": "ALWAYS_INLINE BOOL binn_map_set_object(binn *map, int id, void *obj) {\n  return binn_map_set(map, id, BINN_OBJECT, binn_ptr(obj), binn_size(obj));\n}\n",
    "binn_list_get_map": "ALWAYS_INLINE BOOL binn_list_get_map(const void *list, int pos, void **pvalue) {\n  return binn_list_get(list, pos, BINN_MAP, pvalue, NULL);\n}\n",
    "binn_map_get_blob": "ALWAYS_INLINE BOOL binn_map_get_blob(const void *map, int id, void **pvalue, int *psize) {\n  return binn_map_get(map, id, BINN_BLOB, pvalue, psize);\n}\n",
    "binn_object_get_map": "ALWAYS_INLINE BOOL binn_object_get_map(const void *obj, const char *key, void **pvalue) {\n  return binn_object_get(obj, key, BINN_MAP, pvalue, NULL);\n}\n",
    "binn_map_get_uint16": "ALWAYS_INLINE BOOL binn_map_get_uint16(const void *map, int id, unsigned short *pvalue) {\n  return binn_map_get(map, id, BINN_UINT16, pvalue, NULL);\n}\n",
    "binn_object_set_null": "ALWAYS_INLINE BOOL binn_object_set_null(binn *obj, const char *key) {\n  return binn_object_set(obj, key, BINN_NULL, NULL, 0);\n}\n",
    "binn_object_get_list": "ALWAYS_INLINE BOOL binn_object_get_list(const void *obj, const char *key, void **pvalue) {\n  return binn_object_get(obj, key, BINN_LIST, pvalue, NULL);\n}\n",
    "binn_map_get_bool": "ALWAYS_INLINE BOOL binn_map_get_bool(const void *map, int id, BOOL *pvalue) {\n  return binn_map_get(map, id, BINN_BOOL, pvalue, NULL);\n}\n",
    "binn_uint64": "ALWAYS_INLINE binn * binn_uint64(uint64 value) {\n  return binn_value(BINN_UINT64, &value, 0, NULL);\n}\n",
    "binn_uint8": "ALWAYS_INLINE binn * binn_uint8(unsigned char value) {\n  return binn_value(BINN_UINT8, &value, 0, NULL);\n}\n",
    "binn_list_add_float": "ALWAYS_INLINE BOOL binn_list_add_float(binn *list, float value) {\n  return binn_list_add(list, BINN_FLOAT32, &value, 0);\n}\n",
    "binn_map_set_bool": "ALWAYS_INLINE BOOL binn_map_set_bool(binn *map, int id, BOOL value) {\n  return binn_map_set(map, id, BINN_BOOL, &value, 0);\n}\n",
    "binn_object_set_int32": "ALWAYS_INLINE BOOL binn_object_set_int32(binn *obj, const char *key, int value) {\n  return binn_object_set(obj, key, BINN_INT32, &value, 0);\n}\n",
    "binn_uint32": "ALWAYS_INLINE binn * binn_uint32(unsigned int value) {\n  return binn_value(BINN_UINT32, &value, 0, NULL);\n}\n",
    "binn_list_get_double": "ALWAYS_INLINE BOOL binn_list_get_double(const void *list, int pos, double *pvalue) {\n  return binn_list_get(list, pos, BINN_FLOAT64, pvalue, NULL);\n}\n",
    "binn_list_get_uint32": "ALWAYS_INLINE BOOL binn_list_get_uint32(const void *list, int pos, unsigned int *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT32, pvalue, NULL);\n}\n",
    "binn_object_get_bool": "ALWAYS_INLINE BOOL binn_object_get_bool(const void *obj, const char *key, BOOL *pvalue) {\n  return binn_object_get(obj, key, BINN_BOOL, pvalue, NULL);\n}\n",
    "binn_list_get_uint8": "ALWAYS_INLINE BOOL binn_list_get_uint8(const void *list, int pos, unsigned char *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT8, pvalue, NULL);\n}\n",
    "binn_map_get_uint8": "ALWAYS_INLINE BOOL binn_map_get_uint8(const void *map, int id, unsigned char *pvalue) {\n  return binn_map_get(map, id, BINN_UINT8, pvalue, NULL);\n}\n",
    "binn_object_get_uint16": "ALWAYS_INLINE BOOL binn_object_get_uint16(const void *obj, const char *key, unsigned short *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT16, pvalue, NULL);\n}\n",
    "binn_float": "ALWAYS_INLINE binn * binn_float(float value) {\n  return binn_value(BINN_FLOAT, &value, 0, NULL);\n}\n",
    "binn_list_add_list": "ALWAYS_INLINE BOOL binn_list_add_list(binn *list, void *list2) {\n  return binn_list_add(list, BINN_LIST, binn_ptr(list2), binn_size(list2));\n}\n",
    "binn_object_set_value": "ALWAYS_INLINE BOOL binn_object_set_value(binn *obj, const char *key, binn *value) {\n  return binn_object_set(obj, key, value->type, binn_ptr(value), binn_size(value));\n}\n",
    "binn_object_get_int64": "ALWAYS_INLINE BOOL binn_object_get_int64(const void *obj, const char *key, int64 *pvalue) {\n  return binn_object_get(obj, key, BINN_INT64, pvalue, NULL);\n}\n",
    "binn_object_set_str": "ALWAYS_INLINE BOOL binn_object_set_str(binn *obj, const char *key, char *str) {\n  return binn_object_set(obj, key, BINN_STRING, str, 0);\n}\n",
    "binn_list_add_int16": "ALWAYS_INLINE BOOL binn_list_add_int16(binn *list, short value) {\n  return binn_list_add(list, BINN_INT16, &value, 0);\n}\n",
    "binn_object_get_float": "ALWAYS_INLINE BOOL binn_object_get_float(const void *obj, const char *key, float *pvalue) {\n  return binn_object_get(obj, key, BINN_FLOAT32, pvalue, NULL);\n}\n",
    "binn_object_get_object": "ALWAYS_INLINE BOOL binn_object_get_object(const void *obj, const char *key, void **pvalue) {\n  return binn_object_get(obj, key, BINN_OBJECT, pvalue, NULL);\n}\n",
    "binn_double": "ALWAYS_INLINE binn * binn_double(double value) {\n  return binn_value(BINN_DOUBLE, &value, 0, NULL);\n}\n",
    "binn_int8": "ALWAYS_INLINE binn * binn_int8(signed char value) {\n  return binn_value(BINN_INT8, &value, 0, NULL);\n}\n",
    "extra": "{'binn_iter_struct': 'typedef struct binn_iter_struct {\\n    unsigned char *pnext;\\n    unsigned char *plimit;\\n    int   type;\\n    int   count;\\n    int   current;\\n};', 'binn_struct': 'struct binn_struct {\\n  int    header;     // this struct header holds the magic number (BINN_MAGIC) that identifies this memory block as a binn structure\\n  BOOL   allocated;  // the struct can be allocated using malloc_fn() or can be on the stack\\n  BOOL   writable;   // did it was create for writing? it can use the pbuf if not unified with ptr\\n  BOOL   dirty;      // the container header is not written to the buffer\\n  //\\n  void  *pbuf;       // use *ptr below?\\n  BOOL   pre_allocated;\\n  int    alloc_size;\\n  int    used_size;\\n  //\\n  int    type;\\n  void  *ptr;\\n  int    size;\\n  int    count;\\n  //\\n  binn_mem_free freefn;  // used only when type == BINN_STRING or BINN_BLOB\\n  //\\n  union {\\n    signed char    vint8;\\n    signed short   vint16;\\n    signed int     vint32;\\n    int64          vint64;\\n    unsigned char  vuint8;\\n    unsigned short vuint16;\\n    unsigned int   vuint32;\\n    uint64         vuint64;\\n    //\\n    signed char    vchar;\\n    unsigned char  vuchar;\\n    signed short   vshort;\\n    unsigned short vushort;\\n    signed int     vint;\\n    unsigned int   vuint;\\n    //\\n    float          vfloat;\\n    double         vdouble;\\n    //\\n    BOOL           vbool;\\n  };\\n  //\\n  BOOL   disable_int_compression;\\n};', 'free_fn': 'void  (*free_fn)(void *ptr) = 0;', 'local_value': 'binn local_value;', 'malloc_fn': 'void* (*malloc_fn)(size_t len) = 0;', 'realloc_fn': 'void* (*realloc_fn)(void *ptr, size_t len) = 0;', 'ALWAYS_INLINE': '  #define ALWAYS_INLINE  __forceinline', 'APIENTRY': '  #define APIENTRY __stdcall', 'BIG_ENDIAN': '#define BIG_ENDIAN      0x1000', 'BINN_BLOB': '#define BINN_BLOB      0xC0  // (BLOB) Raw Blob', 'BINN_BMP': '#define BINN_BMP       0xD004', 'BINN_BOOL': '#define BINN_BOOL      0x80061  // (DWORD) The value may be 0 or 1', 'BINN_BUFFER': '#define BINN_BUFFER        2', 'BINN_CSS': '#define BINN_CSS       0xB005', 'BINN_CURRENCY': '#define BINN_CURRENCY  0x83  // (QWORD)', 'BINN_CURRENCYSTR': '#define BINN_CURRENCYSTR  0xA5  // (STRING) With currency unit/symbol - check for some iso standard format', 'BINN_DATE': '#define BINN_DATE      0xA2  // (STRING) iso8601 format -- YYYY-MM-DD', 'BINN_DATETIME': '#define BINN_DATETIME  0xA1  // (STRING) iso8601 format -- YYYY-MM-DD HH:MM:SS', 'BINN_DECIMAL': '#define BINN_DECIMAL   0xA4  // (STRING) High precision number - used for generic decimal values and for those ones that cannot be represented in the float64 format.', 'BINN_DOUBLE': '#define BINN_DOUBLE    BINN_FLOAT64', 'BINN_DOUBLE_STR': '#define BINN_DOUBLE_STR   0xA7  // (STRING) May be restored to float64', 'BINN_FALSE': '#define BINN_FALSE     0x02', 'BINN_FAMILY_BINN': '#define BINN_FAMILY_BINN   0xf7', 'BINN_FAMILY_BLOB': '#define BINN_FAMILY_BLOB   0xf5', 'BINN_FAMILY_BOOL': '#define BINN_FAMILY_BOOL   0xf6', 'BINN_FAMILY_FLOAT': '#define BINN_FAMILY_FLOAT  0xf3', 'BINN_FAMILY_INT': '#define BINN_FAMILY_INT    0xf2', 'BINN_FAMILY_NONE': '#define BINN_FAMILY_NONE   0x00', 'BINN_FAMILY_NULL': '#define BINN_FAMILY_NULL   0xf1', 'BINN_FAMILY_STRING': '#define BINN_FAMILY_STRING 0xf4', 'BINN_FLOAT': '#define BINN_FLOAT     BINN_FLOAT32', 'BINN_FLOAT32': '#define BINN_FLOAT32   0x62  // (DWORD) ', 'BINN_FLOAT64': '#define BINN_FLOAT64   0x82  // (QWORD) ', 'BINN_GIF': '#define BINN_GIF       0xD002', 'BINN_H': '#define BINN_H', 'BINN_HTML': '#define BINN_HTML      0xB001', 'BINN_INT16': '#define BINN_INT16     0x41  // (WORD) (signed integer)', 'BINN_INT32': '#define BINN_INT32     0x61  // (DWORD) (signed integer)', 'BINN_INT64': '#define BINN_INT64     0x81  // (QWORD) (signed integer)', 'BINN_INT8': '#define BINN_INT8      0x21  // (BYTE) (signed byte, from -128 to +127. The 0x80 is the sign bit, so the range in hex is from 0x80 [-128] to 0x7F [127], being 0x00 = 0 and 0xFF = -1)', 'BINN_JAVASCRIPT': '#define BINN_JAVASCRIPT 0xB004', 'BINN_JPEG': '#define BINN_JPEG      0xD001', 'BINN_JSON': '#define BINN_JSON      0xB003', 'BINN_LIST': '#define BINN_LIST      0xE0', 'BINN_MAGIC': '#define BINN_MAGIC            0x1F22B11F', 'BINN_MAP': '#define BINN_MAP       0xE1', 'BINN_MAX_VALUE_MASK': '#define BINN_MAX_VALUE_MASK    0xFFFFF', 'BINN_NULL': '#define BINN_NULL      0x00', 'BINN_OBJECT': '#define BINN_OBJECT    0xE2', 'BINN_ONLY_ALIGNED_ACCESS': '#define BINN_ONLY_ALIGNED_ACCESS', 'BINN_PNG': '#define BINN_PNG       0xD003', 'BINN_PRIVATE': '#define BINN_PRIVATE ', 'BINN_SCHAR': '#define BINN_SCHAR     BINN_INT8', 'BINN_SIGNED_INT': '#define BINN_SIGNED_INT     11', 'BINN_SINGLE': '#define BINN_SINGLE    BINN_FLOAT32', 'BINN_SINGLE_STR': '#define BINN_SINGLE_STR   0xA6  // (STRING) Can be restored to float32', 'BINN_STATIC': '#define BINN_STATIC      ((binn_mem_free)0)', 'BINN_STORAGE_BLOB': '#define BINN_STORAGE_BLOB      0xC0', 'BINN_STORAGE_BYTE': '#define BINN_STORAGE_BYTE      0x20  //  8 bits', 'BINN_STORAGE_CONTAINER': '#define BINN_STORAGE_CONTAINER 0xE0', 'BINN_STORAGE_DWORD': '#define BINN_STORAGE_DWORD     0x60  // 32 bits -- the endianess (byte order) is automatically corrected', 'BINN_STORAGE_HAS_MORE': '#define BINN_STORAGE_HAS_MORE  0x10', 'BINN_STORAGE_MASK': '#define BINN_STORAGE_MASK      0xE0', 'BINN_STORAGE_MASK16': '#define BINN_STORAGE_MASK16    0xE000', 'BINN_STORAGE_MAX': '#define BINN_STORAGE_MAX       BINN_STORAGE_CONTAINER', 'BINN_STORAGE_MIN': '#define BINN_STORAGE_MIN       BINN_STORAGE_NOBYTES', 'BINN_STORAGE_NOBYTES': '#define BINN_STORAGE_NOBYTES   0x00', 'BINN_STORAGE_QWORD': '#define BINN_STORAGE_QWORD     0x80  // 64 bits -- the endianess (byte order) is automatically corrected', 'BINN_STORAGE_STRING': '#define BINN_STORAGE_STRING    0xA0  // Are stored with null termination', 'BINN_STORAGE_VIRTUAL': '#define BINN_STORAGE_VIRTUAL   0x80000', 'BINN_STORAGE_WORD': '#define BINN_STORAGE_WORD      0x40  // 16 bits -- the endianess (byte order) is automatically corrected', 'BINN_STRING': '#define BINN_STRING    0xA0  // (STRING) Raw String', 'BINN_STRUCT': '#define BINN_STRUCT        1', 'BINN_TIME': '#define BINN_TIME      0xA3  // (STRING) iso8601 format -- HH:MM:SS', 'BINN_TRANSIENT': '#define BINN_TRANSIENT   ((binn_mem_free)-1)', 'BINN_TRUE': '#define BINN_TRUE      0x01', 'BINN_TYPE_MASK': '#define BINN_TYPE_MASK         0x0F', 'BINN_TYPE_MASK16': '#define BINN_TYPE_MASK16       0x0FFF', 'BINN_UCHAR': '#define BINN_UCHAR     BINN_UINT8', 'BINN_UINT16': '#define BINN_UINT16    0x40  // (WORD) (unsigned integer) Is the default format for the WORD type', 'BINN_UINT32': '#define BINN_UINT32    0x60  // (DWORD) (unsigned integer) Is the default format for the DWORD type', 'BINN_UINT64': '#define BINN_UINT64    0x80  // (QWORD) (unsigned integer) Is the default format for the QWORD type', 'BINN_UINT8': '#define BINN_UINT8     0x20  // (BYTE) (unsigned byte) Is the default format for the BYTE type', 'BINN_UNSIGNED_INT': '#define BINN_UNSIGNED_INT   22', 'BINN_VERSION': '#define BINN_VERSION \"3.0.0\"  /* using semantic versioning */', 'BINN_XML': '#define BINN_XML       0xB002', 'BYTE_ORDER': '#define BYTE_ORDER      LITTLE_ENDIAN', 'CHUNK_SIZE': '#define CHUNK_SIZE            256  // 1024', 'FALSE': '#define FALSE 0', 'INLINE': '  #define INLINE         __inline', 'INT64_FORMAT': '#define INT64_FORMAT  \"I64i\"', 'INT64_HEX_FORMAT': '#define INT64_HEX_FORMAT  \"I64x\"', 'INVALID_BINN': '#define INVALID_BINN         0', 'LITTLE_ENDIAN': '#define LITTLE_ENDIAN   0x0001', 'MAX_BINN_HEADER': '#define MAX_BINN_HEADER       9  // [1:type][4:size][4:count]', 'MIN_BINN_SIZE': '#define MIN_BINN_SIZE         3  // [1:type][1:size][1:count]', 'NULL': '#define NULL    0', 'TRUE': '#define TRUE  1', 'UINT64_FORMAT': '#define UINT64_FORMAT \"I64u\"', 'UNUSED': '#define UNUSED(x) (void)(x)', 'atoi64': '#define atoi64 _atoi64', 'binn_is_writable': '#define binn_is_writable(item) (item)->writable;', 'binn_list_foreach': '#define binn_list_foreach(list, value)            \\\\', 'binn_list_foreach2': '#define binn_list_foreach2(list, value)            \\\\', 'binn_map_foreach': '#define binn_map_foreach(map, id, value)          \\\\', 'binn_map_foreach2': '#define binn_map_foreach2(map, id, value)          \\\\', 'binn_object_foreach': '#define binn_object_foreach(object, key, value)   \\\\', 'binn_object_foreach2': '#define binn_object_foreach2(object, key, value)   \\\\', 'binn_set_bool': '#define binn_set_bool(item,value)   do { (item)->type = BINN_BOOL; (item)->vbool = value; (item)->ptr = &((item)->vbool); } while (0)', 'binn_set_double': '#define binn_set_double(item,value) do { (item)->type = BINN_DOUBLE; (item)->vdouble = value; (item)->ptr = &((item)->vdouble); } while (0)', 'binn_set_float': '#define binn_set_float(item,value)  do { (item)->type = BINN_FLOAT;  (item)->vfloat  = value; (item)->ptr = &((item)->vfloat); } while (0)', 'binn_set_int': '#define binn_set_int(item,value)    do { (item)->type = BINN_INT32; (item)->vint32 = value; (item)->ptr = &((item)->vint32); } while (0)', 'binn_set_int64': '#define binn_set_int64(item,value)  do { (item)->type = BINN_INT64; (item)->vint64 = value; (item)->ptr = &((item)->vint64); } while (0)', 'binn_set_null': '#define binn_set_null(item)         do { (item)->type = BINN_NULL; } while (0)', 'binn_set_uint': '#define binn_set_uint(item,value)   do { (item)->type = BINN_UINT32; (item)->vuint32 = value; (item)->ptr = &((item)->vuint32); } while (0)', 'binn_set_uint64': '#define binn_set_uint64(item,value) do { (item)->type = BINN_UINT64; (item)->vuint64 = value; (item)->ptr = &((item)->vuint64); } while (0)', 'roundval': '#define roundval(dbl) dbl >= 0.0 ? (int)(dbl + 0.5) : ((dbl - (double)(int)dbl) <= -0.5 ? (int)dbl : (int)(dbl - 0.5))', 'stricmp': '#define stricmp strcasecmp', 'strnicmp': '#define strnicmp strncasecmp', 'BOOL': 'typedef int BOOL;', 'binn': 'typedef struct binn_struct binn;', 'binn_iter': '} binn_iter;', 'binn_mem_free': 'typedef void (*binn_mem_free)(void*);', 'int64': '  typedef long long int int64;', 'u16': 'typedef unsigned short int     u16;', 'u32': 'typedef unsigned int           u32;', 'u64': 'typedef unsigned long long int u64;', 'uint64': '  typedef unsigned long long int uint64;'} extract_info: [#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <memory.h>\n\n// TO ENABLE INLINE FUNCTIONS:\n//   ON MSVC: enable the 'Inline Function Expansion' (/Ob2) compiler option, and maybe the\n//            'Whole Program Optimitazion' (/GL), that requires the\n//            'Link Time Code Generation' (/LTCG) linker option to be enabled too\n\n#ifndef BINN_H\n#define BINN_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stddef.h>\n\n#define BINN_VERSION \"3.0.0\"  /* using semantic versioning */\n\n#ifndef NULL\n#ifdef __cplusplus\n#define NULL    0\n#else\n#define NULL    ((void *)0)\n#endif\n#endif\n\n#ifndef TRUE\n#define TRUE  1\n#endif\n\n#ifndef FALSE\n#define FALSE 0\n#endif\n\n#ifndef BOOL\ntypedef int BOOL;\n#endif\n\n#ifndef APIENTRY\n #ifdef _WIN32\n  #define APIENTRY __stdcall\n #else\n  //#define APIENTRY __attribute__((stdcall))\n  #define APIENTRY \n #endif\n#endif\n\n#define BINN_PRIVATE \n\n#ifdef _MSC_VER\n  #define INLINE         __inline\n  #define ALWAYS_INLINE  __forceinline\n#else\n  // you can change to 'extern inline' if using the gcc option -flto\n  #define INLINE         static inline\n  #define ALWAYS_INLINE  static inline\n#endif\n\n#ifndef int64\n#if defined(_MSC_VER) || defined(__BORLANDC__)\n  typedef __int64 int64;\n  typedef unsigned __int64 uint64;\n#else\n  typedef long long int int64;\n  typedef unsigned long long int uint64;\n#endif\n#endif\n\n#ifdef _WIN32\n#define INT64_FORMAT  \"I64i\"\n#define UINT64_FORMAT \"I64u\"\n#define INT64_HEX_FORMAT  \"I64x\"\n#else\n#define INT64_FORMAT  \"lli\"\n#define UINT64_FORMAT \"llu\"\n#define INT64_HEX_FORMAT  \"llx\"\n#endif\n\n\n// BINN CONSTANTS  ----------------------------------------\n\n#define INVALID_BINN         0\n\n// Storage Data Types  ------------------------------------\n\n#define BINN_STORAGE_NOBYTES   0x00\n#define BINN_STORAGE_BYTE      0x20  //  8 bits\n#define BINN_STORAGE_WORD      0x40  // 16 bits -- the endianess (byte order) is automatically corrected\n#define BINN_STORAGE_DWORD     0x60  // 32 bits -- the endianess (byte order) is automatically corrected\n#define BINN_STORAGE_QWORD     0x80  // 64 bits -- the endianess (byte order) is automatically corrected\n#define BINN_STORAGE_STRING    0xA0  // Are stored with null termination\n#define BINN_STORAGE_BLOB      0xC0\n#define BINN_STORAGE_CONTAINER 0xE0\n#define BINN_STORAGE_VIRTUAL   0x80000\n\n#define BINN_STORAGE_MIN       BINN_STORAGE_NOBYTES\n#define BINN_STORAGE_MAX       BINN_STORAGE_CONTAINER\n\n#define BINN_STORAGE_MASK      0xE0\n#define BINN_STORAGE_MASK16    0xE000\n#define BINN_STORAGE_HAS_MORE  0x10\n#define BINN_TYPE_MASK         0x0F\n#define BINN_TYPE_MASK16       0x0FFF\n\n#define BINN_MAX_VALUE_MASK    0xFFFFF\n\n\n// Data Formats  ------------------------------------------\n\n#define BINN_LIST      0xE0\n#define BINN_MAP       0xE1\n#define BINN_OBJECT    0xE2\n\n#define BINN_NULL      0x00\n#define BINN_TRUE      0x01\n#define BINN_FALSE     0x02\n\n#define BINN_UINT8     0x20  // (BYTE) (unsigned byte) Is the default format for the BYTE type\n#define BINN_INT8      0x21  // (BYTE) (signed byte, from -128 to +127. The 0x80 is the sign bit, so the range in hex is from 0x80 [-128] to 0x7F [127], being 0x00 = 0 and 0xFF = -1)\n#define BINN_UINT16    0x40  // (WORD) (unsigned integer) Is the default format for the WORD type\n#define BINN_INT16     0x41  // (WORD) (signed integer)\n#define BINN_UINT32    0x60  // (DWORD) (unsigned integer) Is the default format for the DWORD type\n#define BINN_INT32     0x61  // (DWORD) (signed integer)\n#define BINN_UINT64    0x80  // (QWORD) (unsigned integer) Is the default format for the QWORD type\n#define BINN_INT64     0x81  // (QWORD) (signed integer)\n\n#define BINN_SCHAR     BINN_INT8\n#define BINN_UCHAR     BINN_UINT8\n\n#define BINN_STRING    0xA0  // (STRING) Raw String\n#define BINN_DATETIME  0xA1  // (STRING) iso8601 format -- YYYY-MM-DD HH:MM:SS\n#define BINN_DATE      0xA2  // (STRING) iso8601 format -- YYYY-MM-DD\n#define BINN_TIME      0xA3  // (STRING) iso8601 format -- HH:MM:SS\n#define BINN_DECIMAL   0xA4  // (STRING) High precision number - used for generic decimal values and for those ones that cannot be represented in the float64 format.\n#define BINN_CURRENCYSTR  0xA5  // (STRING) With currency unit/symbol - check for some iso standard format\n#define BINN_SINGLE_STR   0xA6  // (STRING) Can be restored to float32\n#define BINN_DOUBLE_STR   0xA7  // (STRING) May be restored to float64\n\n#define BINN_FLOAT32   0x62  // (DWORD) \n#define BINN_FLOAT64   0x82  // (QWORD) \n#define BINN_FLOAT     BINN_FLOAT32\n#define BINN_SINGLE    BINN_FLOAT32\n#define BINN_DOUBLE    BINN_FLOAT64\n\n#define BINN_CURRENCY  0x83  // (QWORD)\n\n#define BINN_BLOB      0xC0  // (BLOB) Raw Blob\n\n\n// virtual types:\n\n#define BINN_BOOL      0x80061  // (DWORD) The value may be 0 or 1\n\n#ifdef BINN_EXTENDED\n//#define BINN_SINGLE    0x800A1  // (STRING) Can be restored to float32\n//#define BINN_DOUBLE    0x800A2  // (STRING) May be restored to float64\n#endif\n\n//#define BINN_BINN      0x800E1  // (CONTAINER)\n//#define BINN_BINN_BUFFER  0x800C1  // (BLOB) user binn. it's not open by the parser\n\n\n// extended content types:\n\n// strings:\n\n#define BINN_HTML      0xB001\n#define BINN_XML       0xB002\n#define BINN_JSON      0xB003\n#define BINN_JAVASCRIPT 0xB004\n#define BINN_CSS       0xB005\n\n// blobs:\n\n#define BINN_JPEG      0xD001\n#define BINN_GIF       0xD002\n#define BINN_PNG       0xD003\n#define BINN_BMP       0xD004\n\n\n// type families\n#define BINN_FAMILY_NONE   0x00\n#define BINN_FAMILY_NULL   0xf1\n#define BINN_FAMILY_INT    0xf2\n#define BINN_FAMILY_FLOAT  0xf3\n#define BINN_FAMILY_STRING 0xf4\n#define BINN_FAMILY_BLOB   0xf5\n#define BINN_FAMILY_BOOL   0xf6\n#define BINN_FAMILY_BINN   0xf7\n\n// integer types related to signal\n#define BINN_SIGNED_INT     11\n#define BINN_UNSIGNED_INT   22\n\n\ntypedef void (*binn_mem_free)(void*);\n#define BINN_STATIC      ((binn_mem_free)0)\n#define BINN_TRANSIENT   ((binn_mem_free)-1)\n\n\n// --- BINN STRUCTURE --------------------------------------------------------------\n\n\nstruct binn_struct {\n  int    header;     // this struct header holds the magic number (BINN_MAGIC) that identifies this memory block as a binn structure\n  BOOL   allocated;  // the struct can be allocated using malloc_fn() or can be on the stack\n  BOOL   writable;   // did it was create for writing? it can use the pbuf if not unified with ptr\n  BOOL   dirty;      // the container header is not written to the buffer\n  //\n  void  *pbuf;       // use *ptr below?\n  BOOL   pre_allocated;\n  int    alloc_size;\n  int    used_size;\n  //\n  int    type;\n  void  *ptr;\n  int    size;\n  int    count;\n  //\n  binn_mem_free freefn;  // used only when type == BINN_STRING or BINN_BLOB\n  //\n  union {\n    signed char    vint8;\n    signed short   vint16;\n    signed int     vint32;\n    int64          vint64;\n    unsigned char  vuint8;\n    unsigned short vuint16;\n    unsigned int   vuint32;\n    uint64         vuint64;\n    //\n    signed char    vchar;\n    unsigned char  vuchar;\n    signed short   vshort;\n    unsigned short vushort;\n    signed int     vint;\n    unsigned int   vuint;\n    //\n    float          vfloat;\n    double         vdouble;\n    //\n    BOOL           vbool;\n  };\n  //\n  BOOL   disable_int_compression;\n};\n\ntypedef struct binn_struct binn;\n\n\n\n// --- GENERAL FUNCTIONS  ----------------------------------------------------------\n\nchar * APIENTRY binn_version();\n\nvoid   APIENTRY binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*));\n\nint    APIENTRY binn_create_type(int storage_type, int data_type_index);\nBOOL   APIENTRY binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type);\n\nint    APIENTRY binn_get_write_storage(int type);\nint    APIENTRY binn_get_read_storage(int type);\n\nBOOL   APIENTRY binn_is_container(binn *item);\n\n\n// --- WRITE FUNCTIONS  ------------------------------------------------------------\n\n// create a new binn allocating memory for the structure\nbinn * APIENTRY binn_new(int type, int size, void *buffer);\nbinn * APIENTRY binn_list();\nbinn * APIENTRY binn_map();\nbinn * APIENTRY binn_object();\n\n// create a new binn storing the structure on the stack\nBOOL APIENTRY binn_create(binn *item, int type, int size, void *buffer);\nBOOL APIENTRY binn_create_list(binn *list);\nBOOL APIENTRY binn_create_map(binn *map);\nBOOL APIENTRY binn_create_object(binn *object);\n\n// create a new binn as a copy from another\nbinn * APIENTRY binn_copy(const void *old);\n\n\nBOOL APIENTRY binn_list_add_new(binn *list, binn *value);\nBOOL APIENTRY binn_map_set_new(binn *map, int id, binn *value);\nBOOL APIENTRY binn_object_set_new(binn *obj, const char *key, binn *value);\n\n\n// extended interface\n\nBOOL   APIENTRY binn_list_add(binn *list, int type, void *pvalue, int size);\nBOOL   APIENTRY binn_map_set(binn *map, int id, int type, void *pvalue, int size);\nBOOL   APIENTRY binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size);\n\n\n// release memory\n\nvoid   APIENTRY binn_free(binn *item);\nvoid * APIENTRY binn_release(binn *item); // free the binn structure but keeps the binn buffer allocated, returning a pointer to it. use the free function to release the buffer later\n\n\n// --- CREATING VALUES ---------------------------------------------------\n\nbinn * APIENTRY binn_value(int type, void *pvalue, int size, binn_mem_free freefn);\n\n\n\n// --- READ FUNCTIONS  -------------------------------------------------------------\n\n// these functions accept pointer to the binn structure and pointer to the binn buffer\nvoid * APIENTRY binn_ptr(const void *ptr);\nint    APIENTRY binn_size(const void *ptr);\nint    APIENTRY binn_type(const void *ptr);\nint    APIENTRY binn_count(const void *ptr);\n\nBOOL   APIENTRY binn_is_valid(const void *ptr, int *ptype, int *pcount, int *psize);\n/* the function returns the values (type, count and size) and they don't need to be\n   initialized. these values are read from the buffer. example:\n\n   int type, count, size;\n   result = binn_is_valid(ptr, &type, &count, &size);\n*/\nBOOL   APIENTRY binn_is_valid_ex(const void *ptr, int *ptype, int *pcount, int *psize);\n/* if some value is informed (type, count or size) then the function will check if \n   the value returned from the serialized data matches the informed value. otherwise\n   the values must be initialized to zero. example:\n\n   int type=0, count=0, size = known_size;\n   result = binn_is_valid_ex(ptr, &type, &count, &size);\n*/\n\nBOOL   APIENTRY binn_is_struct(const void *ptr);\n\n\n// Loading a binn buffer into a binn value - this is optional\n\nbinn * APIENTRY binn_open(const void *data);              // allocated - unsecure\nbinn * APIENTRY binn_open_ex(const void *data, int size); // allocated - secure\nBOOL   APIENTRY binn_load(const void *data, binn *item);  // on stack - unsecure\nBOOL   APIENTRY binn_load_ex(const void *data, int size, binn *value); // secure\n\n\n// easiest interface to use, but don't check if the value is there\n\nsigned char    APIENTRY binn_list_int8(const void *list, int pos);\nshort          APIENTRY binn_list_int16(const void *list, int pos);\nint            APIENTRY binn_list_int32(const void *list, int pos);\nint64          APIENTRY binn_list_int64(const void *list, int pos);\nunsigned char  APIENTRY binn_list_uint8(const void *list, int pos);\nunsigned short APIENTRY binn_list_uint16(const void *list, int pos);\nunsigned int   APIENTRY binn_list_uint32(const void *list, int pos);\nuint64         APIENTRY binn_list_uint64(const void *list, int pos);\nfloat          APIENTRY binn_list_float(const void *list, int pos);\ndouble         APIENTRY binn_list_double(const void *list, int pos);\nBOOL           APIENTRY binn_list_bool(const void *list, int pos);\nBOOL           APIENTRY binn_list_null(const void *list, int pos);\nchar *         APIENTRY binn_list_str(const void *list, int pos);\nvoid *         APIENTRY binn_list_blob(const void *list, int pos, int *psize);\nvoid *         APIENTRY binn_list_list(const void *list, int pos);\nvoid *         APIENTRY binn_list_map(const void *list, int pos);\nvoid *         APIENTRY binn_list_object(const void *list, int pos);\n\nsigned char    APIENTRY binn_map_int8(const void *map, int id);\nshort          APIENTRY binn_map_int16(const void *map, int id);\nint            APIENTRY binn_map_int32(const void *map, int id);\nint64          APIENTRY binn_map_int64(const void *map, int id);\nunsigned char  APIENTRY binn_map_uint8(const void *map, int id);\nunsigned short APIENTRY binn_map_uint16(const void *map, int id);\nunsigned int   APIENTRY binn_map_uint32(const void *map, int id);\nuint64         APIENTRY binn_map_uint64(const void *map, int id);\nfloat          APIENTRY binn_map_float(const void *map, int id);\ndouble         APIENTRY binn_map_double(const void *map, int id);\nBOOL           APIENTRY binn_map_bool(const void *map, int id);\nBOOL           APIENTRY binn_map_null(const void *map, int id);\nchar *         APIENTRY binn_map_str(const void *map, int id);\nvoid *         APIENTRY binn_map_blob(const void *map, int id, int *psize);\nvoid *         APIENTRY binn_map_list(const void *map, int id);\nvoid *         APIENTRY binn_map_map(const void *map, int id);\nvoid *         APIENTRY binn_map_object(const void *map, int id);\n\nsigned char    APIENTRY binn_object_int8(const void *obj, const char *key);\nshort          APIENTRY binn_object_int16(const void *obj, const char *key);\nint            APIENTRY binn_object_int32(const void *obj, const char *key);\nint64          APIENTRY binn_object_int64(const void *obj, const char *key);\nunsigned char  APIENTRY binn_object_uint8(const void *obj, const char *key);\nunsigned short APIENTRY binn_object_uint16(const void *obj, const char *key);\nunsigned int   APIENTRY binn_object_uint32(const void *obj, const char *key);\nuint64         APIENTRY binn_object_uint64(const void *obj, const char *key);\nfloat          APIENTRY binn_object_float(const void *obj, const char *key);\ndouble         APIENTRY binn_object_double(const void *obj, const char *key);\nBOOL           APIENTRY binn_object_bool(const void *obj, const char *key);\nBOOL           APIENTRY binn_object_null(const void *obj, const char *key);\nchar *         APIENTRY binn_object_str(const void *obj, const char *key);\nvoid *         APIENTRY binn_object_blob(const void *obj, const char *key, int *psize);\nvoid *         APIENTRY binn_object_list(const void *obj, const char *key);\nvoid *         APIENTRY binn_object_map(const void *obj, const char *key);\nvoid *         APIENTRY binn_object_object(const void *obj, const char *key);\n\n\n// return a pointer to an allocated binn structure - must be released with the free() function or equivalent set in binn_set_alloc_functions()\nbinn * APIENTRY binn_list_value(const void *list, int pos);\nbinn * APIENTRY binn_map_value(const void *map, int id);\nbinn * APIENTRY binn_object_value(const void *obj, const char *key);\n\n// read the value to a binn structure on the stack\nBOOL APIENTRY binn_list_get_value(const void *list, int pos, binn *value);\nBOOL APIENTRY binn_map_get_value(const void *map, int id, binn *value);\nBOOL APIENTRY binn_object_get_value(const void *obj, const char *key, binn *value);\n\n// single interface - these functions check the data type\nBOOL APIENTRY binn_list_get(const void *list, int pos, int type, void *pvalue, int *psize);\nBOOL APIENTRY binn_map_get(const void *map, int id, int type, void *pvalue, int *psize);\nBOOL APIENTRY binn_object_get(const void *obj, const char *key, int type, void *pvalue, int *psize);\n\n// these 3 functions return a pointer to the value and the data type\n// they are thread-safe on big-endian devices\n// on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings\n// the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications\nvoid * APIENTRY binn_list_read(const void *list, int pos, int *ptype, int *psize);\nvoid * APIENTRY binn_map_read(const void *map, int id, int *ptype, int *psize);\nvoid * APIENTRY binn_object_read(const void *obj, const char *key, int *ptype, int *psize);\n\n\n// READ PAIR FUNCTIONS\n\n// these functions use base 1 in the 'pos' argument\n\n// on stack\nBOOL APIENTRY binn_map_get_pair(const void *map, int pos, int *pid, binn *value);\nBOOL APIENTRY binn_object_get_pair(const void *obj, int pos, char *pkey, binn *value);  // the key must be declared as: char key[256];\n\n// allocated\nbinn * APIENTRY binn_map_pair(const void *map, int pos, int *pid);\nbinn * APIENTRY binn_object_pair(const void *obj, int pos, char *pkey);  // the key must be declared as: char key[256];\n\n// these 2 functions return a pointer to the value and the data type\n// they are thread-safe on big-endian devices\n// on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings\n// the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications\nvoid * APIENTRY binn_map_read_pair(const void *ptr, int pos, int *pid, int *ptype, int *psize);\nvoid * APIENTRY binn_object_read_pair(const void *ptr, int pos, char *pkey, int *ptype, int *psize);\n\n\n// SEQUENTIAL READ FUNCTIONS\n\ntypedef struct binn_iter_struct {\n    unsigned char *pnext;\n    unsigned char *plimit;\n    int   type;\n    int   count;\n    int   current;\n} binn_iter;\n\nBOOL   APIENTRY binn_iter_init(binn_iter *iter, const void *pbuf, int type);\n\n// allocated\nbinn * APIENTRY binn_list_next_value(binn_iter *iter);\nbinn * APIENTRY binn_map_next_value(binn_iter *iter, int *pid);\nbinn * APIENTRY binn_object_next_value(binn_iter *iter, char *pkey);  // the key must be declared as: char key[256];\n\n// on stack\nBOOL   APIENTRY binn_list_next(binn_iter *iter, binn *value);\nBOOL   APIENTRY binn_map_next(binn_iter *iter, int *pid, binn *value);\nBOOL   APIENTRY binn_object_next(binn_iter *iter, char *pkey, binn *value);  // the key must be declared as: char key[256];\n\n// these 3 functions return a pointer to the value and the data type\n// they are thread-safe on big-endian devices\n// on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings\n// the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications\nvoid * APIENTRY binn_list_read_next(binn_iter *iter, int *ptype, int *psize);\nvoid * APIENTRY binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize);\nvoid * APIENTRY binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize);  // the key must be declared as: char key[256];\n\n\n// --- MACROS ------------------------------------------------------------\n\n\n#define binn_is_writable(item) (item)->writable;\n\n\n// set values on stack allocated binn structures\n\n#define binn_set_null(item)         do { (item)->type = BINN_NULL; } while (0)\n\n#define binn_set_bool(item,value)   do { (item)->type = BINN_BOOL; (item)->vbool = value; (item)->ptr = &((item)->vbool); } while (0)\n\n#define binn_set_int(item,value)    do { (item)->type = BINN_INT32; (item)->vint32 = value; (item)->ptr = &((item)->vint32); } while (0)\n#define binn_set_int64(item,value)  do { (item)->type = BINN_INT64; (item)->vint64 = value; (item)->ptr = &((item)->vint64); } while (0)\n\n#define binn_set_uint(item,value)   do { (item)->type = BINN_UINT32; (item)->vuint32 = value; (item)->ptr = &((item)->vuint32); } while (0)\n#define binn_set_uint64(item,value) do { (item)->type = BINN_UINT64; (item)->vuint64 = value; (item)->ptr = &((item)->vuint64); } while (0)\n\n#define binn_set_float(item,value)  do { (item)->type = BINN_FLOAT;  (item)->vfloat  = value; (item)->ptr = &((item)->vfloat); } while (0)\n#define binn_set_double(item,value) do { (item)->type = BINN_DOUBLE; (item)->vdouble = value; (item)->ptr = &((item)->vdouble); } while (0)\n\n//#define binn_set_string(item,str,pfree)    do { (item)->type = BINN_STRING; (item)->ptr = str; (item)->freefn = pfree; } while (0)\n//#define binn_set_blob(item,ptr,size,pfree) do { (item)->type = BINN_BLOB;   (item)->ptr = ptr; (item)->freefn = pfree; (item)->size = size; } while (0)\nBOOL APIENTRY binn_set_string(binn *item, char *str, binn_mem_free pfree);\nBOOL APIENTRY binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree);\n\n\n//#define binn_double(value) {       (item)->type = BINN_DOUBLE; (item)->vdouble = value; (item)->ptr = &((item)->vdouble) }\n\n\n\n// FOREACH MACROS\n// --------------\n//\n// We must use these declarations inside the functions that will use the macros:\n//\n//  binn_iter iter;\n//  binn value;\n//  char key[256];  // only for objects\n//  int  id;        // only for maps\n\n#define binn_object_foreach(object, key, value)   \\\n    binn_iter_init(&iter, object, BINN_OBJECT);   \\\n    while (binn_object_next(&iter, key, &value))\n\n#define binn_map_foreach(map, id, value)          \\\n    binn_iter_init(&iter, map, BINN_MAP);         \\\n    while (binn_map_next(&iter, &id, &value))\n\n#define binn_list_foreach(list, value)            \\\n    binn_iter_init(&iter, list, BINN_LIST);       \\\n    while (binn_list_next(&iter, &value))\n\n// If you need nested foreach loops, use the macros below for the nested loop\n// Also we need to add an additional declaration on the function to hold the iterator\n// We can add in the same line as the first iterator:\n//\n//  binn_iter iter, iter2;\n\n#define binn_object_foreach2(object, key, value)   \\\n    binn_iter_init(&iter2, object, BINN_OBJECT);   \\\n    while (binn_object_next(&iter2, key, &value))\n\n#define binn_map_foreach2(map, id, value)          \\\n    binn_iter_init(&iter2, map, BINN_MAP);         \\\n    while (binn_map_next(&iter2, &id, &value))\n\n#define binn_list_foreach2(list, value)            \\\n    binn_iter_init(&iter2, list, BINN_LIST);       \\\n    while (binn_list_next(&iter2, &value))\n\n\n/*************************************************************************************/\n/*** SET FUNCTIONS *******************************************************************/\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n/*** GET FUNCTIONS *******************************************************************/\n/*************************************************************************************/\n\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n// usage:\n//   if (binn_object_get_int32(obj, \"key\", &value) == FALSE) xxx;\n\n\n/***************************************************************************/\n\nBOOL   APIENTRY binn_get_int32(binn *value, int *pint);\nBOOL   APIENTRY binn_get_int64(binn *value, int64 *pint);\nBOOL   APIENTRY binn_get_double(binn *value, double *pfloat);\nBOOL   APIENTRY binn_get_bool(binn *value, BOOL *pbool);\nchar * APIENTRY binn_get_str(binn *value);\n\n// boolean string values:\n// 1, true, yes, on\n// 0, false, no, off\n\n// boolean number values:\n// !=0 [true]\n// ==0 [false]\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif //BINN_H\n\n#define UNUSED(x) (void)(x)\n#define roundval(dbl) dbl >= 0.0 ? (int)(dbl + 0.5) : ((dbl - (double)(int)dbl) <= -0.5 ? (int)dbl : (int)(dbl - 0.5))\n\n// magic number:  0x1F 0xb1 0x22 0x1F  =>  0x1FB1221F or 0x1F22B11F\n// because the BINN_STORAGE_NOBYTES (binary 000) may not have so many sub-types (BINN_STORAGE_HAS_MORE = 0x10)\n#define BINN_MAGIC            0x1F22B11F\n\n#define MAX_BINN_HEADER       9  // [1:type][4:size][4:count]\n#define MIN_BINN_SIZE         3  // [1:type][1:size][1:count]\n#define CHUNK_SIZE            256  // 1024\n\n#define BINN_STRUCT        1\n#define BINN_BUFFER        2\n\nvoid* (*malloc_fn)(size_t len) = 0;\nvoid* (*realloc_fn)(void *ptr, size_t len) = 0;\nvoid  (*free_fn)(void *ptr) = 0;\n\n/***************************************************************************/\n\n#if defined(__alpha__) || defined(__hppa__) || defined(__mips__) || defined(__powerpc__) || defined(__sparc__)\n#define BINN_ONLY_ALIGNED_ACCESS\n#elif ( defined(__arm__) || defined(__aarch64__) ) && !defined(__ARM_FEATURE_UNALIGNED)\n#define BINN_ONLY_ALIGNED_ACCESS\n#endif\n\n#if defined(_WIN32)\n#define BIG_ENDIAN      0x1000\n#define LITTLE_ENDIAN   0x0001\n#define BYTE_ORDER      LITTLE_ENDIAN\n#elif defined(__APPLE__)\n/* macros already defined */\n#elif defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)\n#include <sys/endian.h>\n#elif defined(_AIX)\n#include <sys/machine.h>\n#else\n#include <endian.h>\n#endif\n\n#ifndef BYTE_ORDER\n#error \"BYTE_ORDER not defined\"\n#endif\n#ifndef BIG_ENDIAN\n#error \"BIG_ENDIAN not defined\"\n#endif\n#ifndef LITTLE_ENDIAN\n#error \"LITTLE_ENDIAN not defined\"\n#endif\n#if BIG_ENDIAN == LITTLE_ENDIAN\n#error \"BIG_ENDIAN == LITTLE_ENDIAN\"\n#endif\n#if BYTE_ORDER!=BIG_ENDIAN && BYTE_ORDER!=LITTLE_ENDIAN\n#error \"BYTE_ORDER not supported\"\n#endif\n\ntypedef unsigned short int     u16;\ntypedef unsigned int           u32;\ntypedef unsigned long long int u64;\n\n#ifdef BINN_ONLY_ALIGNED_ACCESS\n  if ((uintptr_t)psource % 2 == 0){  // address aligned to 16 bit\n    *pdest = *psource;\n  } else {\n    unsigned char *source = (unsigned char *) psource;\n    unsigned char *dest = (unsigned char *) pdest;\n    dest[0] = source[0];  // indexes are the same\n    dest[1] = source[1];\n  }\n#else\n  *pdest = *psource;\n#endif\n#endif\n}\n\n#ifdef BINN_ONLY_ALIGNED_ACCESS\n  if ((uintptr_t)psource % 4 == 0){  // address aligned to 32 bit\n    *pdest = *psource;\n  } else {\n    unsigned char *source = (unsigned char *) psource;\n    unsigned char *dest = (unsigned char *) pdest;\n    dest[0] = source[0];  // indexes are the same\n    dest[1] = source[1];\n    dest[2] = source[2];\n    dest[3] = source[3];\n  }\n#else\n  *pdest = *psource;\n#endif\n#endif\n}\n\n#else // if BYTE_ORDER == BIG_ENDIAN\n#ifdef BINN_ONLY_ALIGNED_ACCESS\n  if ((uintptr_t)psource % 8 == 0){  // address aligned to 64 bit\n    *pdest = *psource;\n  } else {\n    unsigned char *source = (unsigned char *) psource;\n    unsigned char *dest = (unsigned char *) pdest;\n    int i;\n    for (i=0; i < 8; i++) {\n      dest[i] = source[i];  // indexes are the same\n    }\n  }\n#else\n  *pdest = *psource;\n#endif\n#endif\n}\n\n/***************************************************************************/\n\n#ifndef _MSC_VER\n#define stricmp strcasecmp\n#define strnicmp strncasecmp\n#endif\n\nBINN_PRIVATE BOOL IsValidBinnHeader(const void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize);\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n// deprecated: unsecure. the size can be corrupted accidentally or intentionally\n}\n\n}\n\n/*************************************************************************************/\n\n}\n\n}\n\n/***************************************************************************/\n\n\n}\n\n/***************************************************************************/\n\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n#if BYTE_ORDER == BIG_ENDIAN\n\nBINN_PRIVATE int get_storage_size(int storage_type) {\n\n  switch (storage_type) {\n  case BINN_STORAGE_NOBYTES:\n    return 0;\n  case BINN_STORAGE_BYTE:\n    return 1;\n  case BINN_STORAGE_WORD:\n    return 2;\n  case BINN_STORAGE_DWORD:\n    return 4;\n  case BINN_STORAGE_QWORD:\n    return 8;\n  default:\n    return 0;\n  }\n\n}\n\n#endif\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n/*\n\nThe id can be stored with 1 to 5 bytes\n\nS = signal bit\nX = bit part of id\n\n  0SXX XXXX\n  100S XXXX + 1 byte\n  101S XXXX + 2 bytes\n  110S XXXX + 3 bytes\n  1110 0000 + 4 bytes\n\n*/\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\nBINN_PRIVATE BOOL AddValue(binn *item, int type, void *pvalue, int size);\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\nBINN_PRIVATE int type_family(int type);\n\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n\n}\n\n/***************************************************************************/\n// free the binn structure but keeps the binn buffer allocated, returning a pointer to it. use the free function to release the buffer later\n}\n\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n\n}\n\n/***************************************************************************/\n\n\n}\n\n/***************************************************************************/\n\n\n}\n\n/***************************************************************************/\n\n\n}\n\n/***************************************************************************/\n\n// the container can be smaller than the informed size\n}\n\n// the container must have the informed size, if informed\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n/*** INTERNAL FUNCTIONS ****************************************************/\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n#if BYTE_ORDER == LITTLE_ENDIAN\n\n// on little-endian devices we store the value so we can return a pointer to integers.\n// it's valid only for single-threaded apps. multi-threaded apps must use the _get_ functions instead.\n\nbinn local_value;\n\n}\n\n#endif\n\n/***************************************************************************/\n/*** READ FUNCTIONS ********************************************************/\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n/*** READ PAIR BY POSITION *************************************************/\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/***************************************************************************/\n/*** SEQUENTIAL READ FUNCTIONS *********************************************/\n/***************************************************************************/\n\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/*************************************************************************************/\n/****** EXTENDED INTERFACE ***********************************************************/\n/****** none of the functions above call the functions below *************************/\n/*************************************************************************************/\n\n\n}\n\n/*************************************************************************************/\n\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n\n}\n\n/*************************************************************************************/\n\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n\n  //if (size>0) memset(pvalue, 0, size);\n\n}\n\n/*************************************************************************************/\n\n\n}\n\n/*************************************************************************************/\n/*** WRITE FUNCTIONS *****************************************************************/\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n// this function is used by the wrappers\n\n}\n\n/*************************************************************************************/\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n/*** READ FUNCTIONS ******************************************************************/\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/***************************************************************************/\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/***************************************************************************/\n\n  return value.ptr;\n#endif\n\n}\n\n/***************************************************************************/\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n}\n\n/***************************************************************************/\n\n//   if (binn_object_get(obj, \"multiplier\", BINN_INT32, &multiplier, NULL) == FALSE) xxx;\n\n}\n\n/***************************************************************************/\n/***************************************************************************/\n\n// these functions below may not be implemented as inline functions, because\n// they use a lot of space, even for the variable. so they will be exported.\n\n// but what about using as static?\n//    is there any problem with wrappers? can these wrappers implement these functions using the header?\n//    if as static, will they be present even on modules that don't use the functions?\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n/***************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n/***************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n/*************************************************************************************/\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n/*** READ CONVERTED VALUE ************************************************************/\n/*************************************************************************************/\n\n#ifdef _MSC_VER\n#define atoi64 _atoi64\n#else\n#endif\n\n/*****************************************************************************/\n\n\n/*****************************************************************************/\n\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n\n/*************************************************************************************/\n\n}\n\n/*************************************************************************************/\n/*** GENERAL FUNCTIONS ***************************************************************/\n/*************************************************************************************/\n\n\n}\n\n/*************************************************************************************/\n]"
}