{
    "binn": {
        "binn_get_type_info": "pub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n",
        "extra": "pub const BINN_STORAGE_MASK: i32 = 0xE0;\npub const BINN_TYPE_MASK: i32 = 0x0F;\npub const BINN_STORAGE_MASK16: i32 = 0xE000;\npub const BINN_TYPE_MASK16: i32 = 0x0FFF;\npub const BINN_STORAGE_VIRTUAL: i32 = 0x80000;\npub const BINN_STORAGE_STRING: i32 = 0xA0;\npub const BINN_STORAGE_NOBYTES: i32 = 0x00;\npub const BINN_STORAGE_CONTAINER: i32 = 0xE0;\npub const BINN_STORAGE_HAS_MORE: i32 = 0x10;\npub const MIN_BINN_SIZE: i32 = 3;\n\npub const BINN_INT8: i32 = 0x21;\npub const BINN_INT16: i32 = 0x41;\npub const BINN_INT32: i32 = 0x61;\npub const BINN_INT64: i32 = 0x81;\npub const BINN_UINT8: i32 = 0x20;\npub const BINN_UINT16: i32 = 0x40;\npub const BINN_UINT32: i32 = 0x60;\npub const BINN_UINT64: i32 = 0x80;\npub const BINN_SIGNED_INT: i32 = 11;\npub const BINN_UNSIGNED_INT: i32 = 22;\n\npub const BINN_STRUCT: i32 = 1;\npub const BINN_BUFFER: i32 = 2;\npub const BINN_LIST: i32 = 0xE0;\npub const BINN_MAP: i32 = 0xE1;\npub const BINN_OBJECT: i32 = 0xE2;\n\npub const MAX_BINN_HEADER: i32 = 9;\n\npub const BINN_FLOAT32: i32 = 0x62;\npub const BINN_FLOAT64: i32 = 0x82;\npub const BINN_SINGLE_STR: i32 = 0xA6;\npub const BINN_DOUBLE_STR: i32 = 0xA7;\n\npub const BINN_STRING: i32 = 0xA0;\npub const BINN_HTML: i32 = 0xB001;\npub const BINN_CSS: i32 = 0xB005;\npub const BINN_XML: i32 = 0xB002;\npub const BINN_JSON: i32 = 0xB003;\npub const BINN_JAVASCRIPT: i32 = 0xB004;\n\npub const BINN_BLOB: i32 = 0xC0;\npub const BINN_JPEG: i32 = 0xD001;\npub const BINN_GIF: i32 = 0xD002;\npub const BINN_PNG: i32 = 0xD003;\npub const BINN_BMP: i32 = 0xD004;\n\npub const BINN_DECIMAL: i32 = 0xA4;\npub const BINN_CURRENCYSTR: i32 = 0xA5;\npub const BINN_CURRENCY: i32 = 0x83;\npub const BINN_DATE: i32 = 0xA2;\npub const BINN_TIME: i32 = 0xA3;\npub const BINN_DATETIME: i32 = 0xA1;\n\npub const BINN_BOOL: i32 = 0x80061;\npub const BINN_NULL: i32 = 0x00;\n\npub const BINN_FAMILY_BINN: i32 = 0xf7;\npub const BINN_FAMILY_INT: i32 = 0xf2;\npub const BINN_FAMILY_FLOAT: i32 = 0xf3;\npub const BINN_FAMILY_STRING: i32 = 0xf4;\npub const BINN_FAMILY_BLOB: i32 = 0xf5;\npub const BINN_FAMILY_BOOL: i32 = 0xf6;\npub const BINN_FAMILY_NULL: i32 = 0xf1;\npub const BINN_FAMILY_NONE: i32 = 0x00;\n\npub const BINN_MAGIC: i32 = 0x1F22B11F;\n\npub const BINN_STORAGE_DWORD: i32 = 0x60;\npub const BINN_STORAGE_WORD: i32 = 0x40;\npub const BINN_STORAGE_QWORD: i32 = 0x80;\npub const BINN_TRUE: i32 = 0x01;\npub const BINN_FALSE: i32 = 0x02;\n\npub const CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n",
        "copy_be32": "pub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n",
        "check_alloc_functions": "pub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(Box::new(|size: usize| -> Vec<u8> {\n                vec![0; size]\n            }));\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(Box::new(|mut vec: Vec<u8>, new_size: usize| -> Vec<u8> {\n                vec.resize(new_size, 0);\n                vec\n            }));\n        }\n        if free_fn.is_none() {\n            free_fn = Some(Box::new(|_vec: Vec<u8>| {}));\n        }\n    }\n}\n\n",
        "binn_get_write_storage": "pub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n",
        "CalcAllocation": "pub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n",
        "int_type": "pub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n",
        "copy_be16": "pub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    *pdest = psource.to_be();\n}\n\n",
        "binn_get_ptr_type": "pub fn binn_get_ptr_type<T>(ptr: Option<T>) -> i32 {\n    if ptr.is_none() {\n        return BINN_BUFFER;\n    }\n\n    match ptr {\n        Some(_) => BINN_STRUCT,\n        None => BINN_BUFFER,\n    }\n}\n\n",
        "binn_save_header": "pub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p: usize;\n    let mut size: i32;\n\n    p = item.pbuf.len() - MAX_BINN_HEADER as usize;\n    size = item.used_size - MAX_BINN_HEADER + 3;\n\n    if item.count > 127 {\n        p -= 4;\n        size += 3;\n        let int32 = item.count as u32 | 0x80000000;\n        let mut dest = [0u8; 4];\n        copy_be32(&mut dest, &int32);\n        item.pbuf[p..p + 4].copy_from_slice(&dest);\n    } else {\n        p -= 1;\n        item.pbuf[p] = item.count as u8;\n    }\n\n    if size > 127 {\n        p -= 4;\n        size += 3;\n        let int32 = size as u32 | 0x80000000;\n        let mut dest = [0u8; 4];\n        copy_be32(&mut dest, &int32);\n        item.pbuf[p..p + 4].copy_from_slice(&dest);\n    } else {\n        p -= 1;\n        item.pbuf[p] = size as u8;\n    }\n\n    p -= 1;\n    item.pbuf[p] = item.type_ as u8;\n\n    item.ptr = item.pbuf[p..].to_vec();\n    item.size = size;\n\n    item.dirty = false;\n\n    true\n}\n\n",
        "copy_be64": "pub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    *pdest = psource.to_be();\n}\n\n",
        "IsValidBinnHeader": "pub fn IsValidBinnHeader(pbuf: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = pbuf.as_ptr();\n    let mut plimit: *const u8 = std::ptr::null();\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < MIN_BINN_SIZE {\n            return false;\n        }\n        plimit = unsafe { p.offset(*psize as isize - 1) };\n    }\n\n    // get the type\n    let byte = unsafe { *p };\n    p = unsafe { p.offset(1) };\n    if (byte as i32 & BINN_STORAGE_MASK) != BINN_STORAGE_CONTAINER {\n        return false;\n    }\n    if byte as i32 & BINN_STORAGE_HAS_MORE != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return false,\n    }\n\n    // get the size\n    if !plimit.is_null() && p > plimit {\n        return false;\n    }\n    int32 = unsafe { *p as i32 };\n    if int32 & 0x80 != 0 {\n        if !plimit.is_null() && unsafe { p.offset(3) } > plimit {\n            return false;\n        }\n        let mut temp = [0u8; 4];\n        unsafe { std::ptr::copy_nonoverlapping(p, temp.as_mut_ptr(), 4) };\n        int32 = i32::from_be_bytes(temp);\n        int32 &= 0x7FFFFFFF;\n        p = unsafe { p.offset(4) };\n    } else {\n        p = unsafe { p.offset(1) };\n    }\n    size = int32;\n\n    // get the count\n    if !plimit.is_null() && p > plimit {\n        return false;\n    }\n    int32 = unsafe { *p as i32 };\n    if int32 & 0x80 != 0 {\n        if !plimit.is_null() && unsafe { p.offset(3) } > plimit {\n            return false;\n        }\n        let mut temp = [0u8; 4];\n        unsafe { std::ptr::copy_nonoverlapping(p, temp.as_mut_ptr(), 4) };\n        int32 = i32::from_be_bytes(temp);\n        int32 &= 0x7FFFFFFF;\n        p = unsafe { p.offset(4) };\n    } else {\n        p = unsafe { p.offset(1) };\n    }\n    count = int32;\n\n    if size < MIN_BINN_SIZE || count < 0 {\n        return false;\n    }\n\n    // return the values\n    *ptype = type_;\n    *pcount = count;\n    *psize = size;\n    *pheadersize = unsafe { p.offset_from(pbuf.as_ptr()) } as i32;\n    true\n}\n\n",
        "AdvanceDataPos": "pub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: &Vec<u8>) -> Option<Vec<u8>> {\n    if p.as_ptr() > plimit.as_ptr() {\n        return None;\n    }\n\n    let byte = p[0] as i32;\n    p.remove(0);\n    let storage_type = byte & BINN_STORAGE_MASK;\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        p.remove(0);\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_STRING => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n                p.drain(0..4);\n            } else {\n                p.remove(0);\n            }\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n            p.remove(0);\n        }\n        BINN_STORAGE_CONTAINER => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n            }\n            DataSize -= 1;\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n        }\n        _ => {\n            return None;\n        }\n    }\n\n    Some(p.clone())\n}\n\n",
        "copy_int_value": "pub fn copy_int_value(psource: &i64, pdest: &mut i64, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => vint64 = *psource as i8 as i64,\n        BINN_INT16 => vint64 = *psource as i16 as i64,\n        BINN_INT32 => vint64 = *psource as i32 as i64,\n        BINN_INT64 => vint64 = *psource,\n\n        BINN_UINT8 => vuint64 = *psource as u8 as u64,\n        BINN_UINT16 => vuint64 = *psource as u16 as u64,\n        BINN_UINT32 => vuint64 = *psource as u32 as u64,\n        BINN_UINT64 => vuint64 = *psource as u64,\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < i8::MIN as i64 || vint64 > i8::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i8 as i64;\n        }\n        BINN_INT16 => {\n            if vint64 < i16::MIN as i64 || vint64 > i16::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i16 as i64;\n        }\n        BINN_INT32 => {\n            if vint64 < i32::MIN as i64 || vint64 > i32::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i32 as i64;\n        }\n        BINN_INT64 => *pdest = vint64,\n\n        BINN_UINT8 => {\n            if vuint64 > u8::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u8 as i64;\n        }\n        BINN_UINT16 => {\n            if vuint64 > u16::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u16 as i64;\n        }\n        BINN_UINT32 => {\n            if vuint64 > u32::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u32 as i64;\n        }\n        BINN_UINT64 => *pdest = vuint64 as i64,\n\n        _ => return false,\n    }\n\n    true\n}\n\n",
        "type_family": "pub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n",
        "copy_float_value": "pub fn copy_float_value<T: Into<f64> + From<f64> + From<f32>>(psource: T, pdest: &mut T, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = T::from(psource.into() as f32);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = T::from(psource.into());\n            true\n        }\n        _ => false,\n    }\n}\n\n",
        "copy_raw_value": "pub fn copy_raw_value<T>(psource: T, mut pdest: T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_BYTE => {\n            pdest = psource;\n        }\n        BINN_STORAGE_WORD => {\n            pdest = psource;\n        }\n        BINN_STORAGE_DWORD => {\n            pdest = psource;\n        }\n        BINN_STORAGE_QWORD => {\n            pdest = psource;\n        }\n        BINN_STORAGE_BLOB => {\n            pdest = psource;\n        }\n        BINN_STORAGE_STRING => {\n            pdest = psource;\n        }\n        BINN_STORAGE_CONTAINER => {\n            pdest = psource;\n        }\n        _ => return false,\n    }\n    true\n}\n\n",
        "strlen2": "pub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n",
        "CheckAllocation": "pub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n",
        "binn_malloc": "pub fn binn_malloc(size: i32) -> Vec<u8> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(malloc_fn_wrap) = &malloc_fn {\n            malloc_fn_wrap(size as usize)\n        } else {\n            vec![]\n        }\n    }\n}\n\n",
        "GetValue": "pub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let mut p2: Vec<u8> = Vec::new();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC;\n\n    p2 = p.clone();\n\n    if p > plimit {\n        return false;\n    }\n    byte = p[0];\n    p.remove(0);\n    storage_type = (byte as i32) & BINN_STORAGE_MASK;\n    if (byte as i32) & BINN_STORAGE_HAS_MORE != 0 {\n        data_type = (byte as i32) << 8;\n        if p > plimit {\n            return false;\n        }\n        byte = p[0];\n        p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_STRING => {\n            if p > plimit {\n                return false;\n            }\n            data_size = p[0] as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                copy_be32(&mut data_size_bytes, &(i32::from_be_bytes([p[0], p[1], p[2], p[3]]) as u32));\n                data_size = i32::from_be_bytes(data_size_bytes);\n                data_size &= 0x7FFFFFFF;\n                p.drain(0..4);\n            } else {\n                p.remove(0);\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.clone();\n        }\n        BINN_STORAGE_CONTAINER => {\n            value.ptr = p2.clone();\n            if !IsValidBinnHeader(&p2, &mut 0, &mut value.count, &mut value.size, &mut 0) {\n                return false;\n            }\n        }\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![value.vbool as u8];\n        }\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![value.vbool as u8];\n        }\n        _ => (),\n    }\n\n    true\n}\n\n",
        "SearchForKey": "pub fn SearchForKey(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, key: &str) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = p.len() as i32 - 1;\n    let mut p = p.split_off(header_size as usize);\n    let keylen = key.len() as i32;\n\n    for _ in 0..numitems {\n        if p.len() as i32 > plimit {\n            break;\n        }\n        let len = p[0] as i32;\n        p.remove(0);\n        if p.len() as i32 + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if p[0..len as usize].eq_ignore_ascii_case(key.as_bytes()) {\n                if keylen == len {\n                    p.drain(0..len as usize);\n                    return Some(p);\n                }\n            }\n            p.drain(0..len as usize);\n        } else if len == keylen {\n            return Some(p);\n        }\n        p = match AdvanceDataPos(&mut p, &base) {\n            Some(new_p) => new_p,\n            None => break,\n        };\n        if p.len() < base.len() {\n            break;\n        }\n    }\n\n    None\n}\n\n",
        "binn_ptr": "pub fn binn_ptr<T: AsRef<[u8]>>(ptr: Option<T>) -> Option<Vec<u8>> {\n    match binn_get_ptr_type(ptr.as_ref().map(|_| ())) {\n        BINN_STRUCT => {\n            let mut item = Binn::default();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            Some(item.ptr.clone())\n        }\n        BINN_BUFFER => Some(ptr.unwrap().as_ref().to_vec()),\n        _ => None,\n    }\n}\n\n",
        "binn_get_read_storage": "pub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => return BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => return BINN_STORAGE_QWORD,\n        BINN_BOOL => return BINN_STORAGE_DWORD,\n        BINN_TRUE => return BINN_STORAGE_DWORD,\n        BINN_FALSE => return BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            return storage_type;\n        }\n    }\n}\n\n",
        "read_map_id": "pub fn read_map_id(pp: &mut Vec<u8>, plimit: &Vec<u8>) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() > plimit.len() {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() + extra_bytes as usize > plimit.len() {\n            *pp = p;\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n    } else if type_ == 0xE0 {\n        let mut id_bytes = [0u8; 4];\n        id_bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(id_bytes);\n        p.drain(0..4);\n    } else {\n        *pp = plimit.clone();\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n",
        "binn_create": "pub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n\n    let mut alloc_size = size;\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            alloc_size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(pointer) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = pointer;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if alloc_size == 0 { CHUNK_SIZE } else { alloc_size };\n        let pointer = binn_malloc(alloc_size);\n        if pointer.is_empty() {\n            return retval;\n        }\n        item.pbuf = pointer;\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER;\n    item.type_ = type_;\n    item.dirty = true;\n\n    retval = true;\n    retval\n}\n\n",
        "binn_object_get_value": "pub fn binn_object_get_value<T: AsRef<[u8]>>(ptr: Option<T>, key: &str, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr.as_ref().map(|x| x.as_ref()));\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr.unwrap();\n    let plimit = p.len() as i32 - 1;\n\n    let p = SearchForKey(&mut p, header_size, size, count, key);\n    if p.is_none() {\n        return false;\n    }\n\n    let mut p = p.unwrap();\n    let mut plimit_vec = p.clone();\n    plimit_vec.truncate(plimit as usize);\n\n    GetValue(&mut p, &mut plimit_vec, value)\n}\n\n",
        "copy_value": "pub fn copy_value<T: Into<i64> + From<i64> + Into<f64> + From<f64> + From<f32>>(psource: T, mut pdest: T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: i64 = psource.into();\n        let mut pdest_wrap: i64 = pdest.into();\n        let result = copy_int_value(&psource_wrap, &mut pdest_wrap, source_type, dest_type);\n        pdest = T::from(pdest_wrap);\n        return result;\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        return copy_float_value(psource, &mut pdest, source_type, dest_type);\n    } else {\n        return copy_raw_value(psource, pdest, data_store);\n    }\n}\n\n",
        "zero_value": "pub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_STRING => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => {}\n    }\n}\n\n",
        "SearchForID": "pub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = base.len() as i32 - 1;\n    let mut p = base.split_off(header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &base);\n        if p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, &base) {\n            Some(new_p) => p = new_p,\n            None => break,\n        }\n        if p.len() < base.len() {\n            break;\n        }\n    }\n\n    None\n}\n\n",
        "binn_list_get_value": "pub fn binn_list_get_value<T: AsRef<[u8]>>(ptr: Option<T>, pos: i32, value: &mut Binn) -> bool {\n    let mut i: i32;\n    let mut type_: i32 = 0;\n    let mut count: i32 = 0;\n    let mut size: i32 = 0;\n    let mut header_size: i32 = 0;\n    let mut p: Vec<u8>;\n    let mut plimit: Vec<u8>;\n    let mut base: Vec<u8>;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let ptr = ptr.unwrap();\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_LIST {\n        return false;\n    }\n\n    if count == 0 {\n        return false;\n    }\n\n    if pos <= 0 || pos > count {\n        return false;\n    }\n\n    let pos = pos - 1;\n\n    p = ptr.clone();\n    base = p.clone();\n    plimit = p.clone();\n    plimit.truncate((size - 1) as usize);\n    p.truncate(header_size as usize);\n\n    for i in 0..pos {\n        if let Some(new_p) = AdvanceDataPos(&mut p, &plimit) {\n            p = new_p;\n        } else {\n            return false;\n        }\n    }\n\n    GetValue(&mut p, &mut plimit, value)\n}\n\n",
        "binn_new": "pub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Binn> {\n    let mut item = Binn::default();\n\n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n",
        "GetWriteConvertedData": "pub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Vec<u8>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: String = String::with_capacity(128);\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => {}\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_SINGLE => {\n            f1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f32)) };\n            d1 = f1 as f64;\n            type_ = BINN_SINGLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_DOUBLE => {\n            d1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f64)) };\n            type_ = BINN_DOUBLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        BINN_DECIMAL | BINN_CURRENCYSTR => {\n            return true;\n        }\n        BINN_DATE | BINN_DATETIME | BINN_TIME => {\n            return true;\n        }\n        BINN_BOOL => {\n            let bool_value = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const bool)) };\n            if bool_value {\n                type_ = BINN_TRUE;\n            } else {\n                type_ = BINN_FALSE;\n            }\n            *ptype = type_;\n        }\n        _ => {}\n    }\n\n    true\n}\n\n",
        "store_value": "pub fn store_value(value: &Binn) -> i32 {\n    let mut local_value = value.clone();\n\n    match binn_get_read_storage(value.type_) {\n        BINN_STORAGE_NOBYTES | BINN_STORAGE_WORD | BINN_STORAGE_DWORD | BINN_STORAGE_QWORD => local_value.vint32,\n        _ => i32::from(value.ptr[0]),\n    }\n}\n\n",
        "binn_buf_size": "pub fn binn_buf_size(pbuf: &Vec<u8>) -> i32 {\n    let mut size: i32 = 0;\n\n    if !IsValidBinnHeader(pbuf, &mut 0, &mut 0, &mut size, &mut 0) {\n        return 0;\n    }\n\n    size\n}\n\n",
        "binn_is_valid_ex2": "pub fn binn_is_valid_ex2(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut type_: i32 = 0;\n    let mut count: i32 = 0;\n    let mut size: i32 = 0;\n    let mut header_size: i32 = 0;\n\n    if ptr.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !IsValidBinnHeader(ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size > *psize {\n            return false;\n        }\n    }\n\n    if *pcount > 0 {\n        if count != *pcount {\n            return false;\n        }\n    }\n\n    if *ptype != 0 {\n        if type_ != *ptype {\n            return false;\n        }\n    }\n\n    let mut p = ptr.clone();\n    let base = p.clone();\n    let plimit = p.len() as i32 - 1;\n\n    p.drain(0..header_size as usize);\n\n    for _ in 0..count {\n        match type_ {\n            BINN_OBJECT => {\n                if p.is_empty() {\n                    return false;\n                }\n                let len = p[0] as i32;\n                p.remove(0);\n                p.drain(0..len as usize);\n            }\n            BINN_MAP => {\n                if read_map_id(&mut p, &plimit.to_be_bytes().to_vec()) == 0 {\n                    return false;\n                }\n            }\n            BINN_LIST => {}\n            _ => {\n                return false;\n            }\n        }\n\n        if p.is_empty() {\n            return false;\n        }\n\n        if (p[0] as i32 & BINN_STORAGE_MASK) == BINN_STORAGE_CONTAINER {\n            let mut size2 = plimit - p.len() as i32 + 1;\n            if !binn_is_valid_ex2(&p, &mut 0, &mut 0, &mut size2) {\n                return false;\n            }\n            p.drain(0..size2 as usize);\n        } else {\n            if let Some(new_p) = AdvanceDataPos(&mut p, &plimit.to_be_bytes().to_vec()) {\n                p = new_p;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    if *ptype == 0 {\n        *ptype = type_;\n    }\n    if *pcount == 0 {\n        *pcount = count;\n    }\n    *psize = size;\n\n    true\n}\n\n",
        "binn_read_pair": "pub fn binn_read_pair(expected_type: i32, ptr: Option<Vec<u8>>, pos: i32, pid: &mut i32, pkey: &mut String, value: &mut Binn) -> bool {\n    let mut type_: i32 = 0;\n    let mut count: i32 = 0;\n    let mut size: i32 = 0;\n    let mut header_size: i32 = 0;\n\n    let ptr = match ptr {\n        Some(p) => p,\n        None => return false,\n    };\n\n    if !IsValidBinnHeader(&ptr, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != expected_type || count == 0 || pos < 1 || pos > count {\n        return false;\n    }\n\n    let mut p = ptr.clone();\n    let base = p.as_ptr();\n    let plimit = p.as_ptr().wrapping_add(size as usize - 1);\n    p.drain(0..header_size as usize);\n\n    let mut id = 0;\n    let mut key = String::new();\n    let mut len = 0;\n    let mut counter = 0;\n\n    for i in 0..count {\n        match type_ {\n            BINN_MAP => {\n                let int32 = read_map_id(&mut p, &ptr);\n                if p.as_ptr() > plimit {\n                    return false;\n                }\n                id = int32;\n            }\n            BINN_OBJECT => {\n                len = p[0] as usize;\n                p.remove(0);\n                if p.as_ptr() > plimit {\n                    return false;\n                }\n                key = String::from_utf8(p[0..len].to_vec()).unwrap();\n                p.drain(0..len);\n                if p.as_ptr() > plimit {\n                    return false;\n                }\n            }\n            _ => {}\n        }\n        counter += 1;\n        if counter == pos {\n            break;\n        }\n\n        if let Some(new_p) = AdvanceDataPos(&mut p, &ptr) {\n            p = new_p;\n        } else {\n            return false;\n        }\n    }\n\n    match type_ {\n        BINN_MAP => {\n            *pid = id;\n        }\n        BINN_OBJECT => {\n            *pkey = key;\n        }\n        _ => {}\n    }\n\n    GetValue(&mut p, &mut ptr.clone(), value)\n}\n\n",
        "binn_map_get_value": "pub fn binn_map_get_value<T: AsRef<[u8]>>(ptr: Option<T>, id: i32, value: &mut Binn) -> bool {\n    let mut type_: i32 = 0;\n    let mut count: i32 = 0;\n    let mut size: i32 = 0;\n    let mut header_size: i32 = 0;\n\n    let ptr = binn_ptr(ptr);\n    if ptr.is_none() || value.is_null() {\n        return false;\n    }\n\n    let pbuf = ptr.unwrap();\n\n    if !IsValidBinnHeader(&pbuf, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_MAP {\n        return false;\n    }\n\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = pbuf.clone();\n    let plimit = pbuf.len() - 1;\n\n    let p = SearchForID(&mut p, header_size, size, count, id);\n    if p.is_none() {\n        return false;\n    }\n\n    GetValue(&mut p.unwrap(), &mut pbuf[plimit..].to_vec(), value)\n}\n\n",
        "binn_is_valid_ex": "pub fn binn_is_valid_ex(ptr: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32) -> bool {\n    let mut size: i32 = 0;\n\n    if *psize > 0 {\n        size = *psize;\n    } else {\n        size = 0;\n    }\n\n    if !binn_is_valid_ex2(ptr, ptype, pcount, &mut size) {\n        return false;\n    }\n\n    if *psize > 0 {\n        if size != *psize {\n            return false;\n        }\n    } else if *psize == 0 {\n        *psize = size;\n    }\n\n    true\n}\n\n",
        "binn_free": "pub fn binn_free(item: Option<Binn>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.unwrap();\n    if item.writable && !item.pre_allocated {\n        if let Some(free_fn_wrap) = unsafe { &mut free_fn } {\n            free_fn_wrap(item.pbuf.clone());\n        }\n    }\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr);\n    }\n    if item.allocated {\n        if let Some(free_fn_wrap) = unsafe { &mut free_fn } {\n            free_fn_wrap(item.pbuf);\n        }\n    } else {\n        item = Binn::default();\n        item.header = BINN_MAGIC;\n    }\n}\n\n",
        "binn_list": "pub fn binn_list() -> Option<Binn> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n",
        "binn_list_read": "pub fn binn_list_read<T: AsRef<[u8]>>(list: Option<T>, pos: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Binn::default();\n\n    if !binn_list_get_value(list, pos, &mut value) {\n        return None;\n    }\n\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n\n    Some(store_value(&value).to_be_bytes().to_vec())\n}\n\n",
        "binn_object_read": "pub fn binn_object_read<T: AsRef<[u8]>>(obj: Option<T>, key: &str, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<i32> {\n    let mut value = Binn::default();\n    if !binn_object_get_value(obj, key, &mut value) {\n        return None;\n    }\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n    Some(store_value(&value))\n}\n\n",
        "binn_map": "pub fn binn_map() -> Option<Binn> {\n    binn_new(BINN_MAP, 0, None)\n}\n\n",
        "binn_object": "pub fn binn_object() -> Option<Binn> {\n    binn_new(BINN_OBJECT, 0, None)\n}\n\n",
        "binn_map_read": "pub fn binn_map_read<T: AsRef<[u8]>>(map: Option<T>, id: i32, ptype: Option<&mut i32>, psize: Option<&mut i32>) -> Option<i32> {\n    let mut value = Binn::default();\n\n    if !binn_map_get_value(map, id, &mut value) {\n        return None;\n    }\n\n    if let Some(ptype) = ptype {\n        *ptype = value.type_;\n    }\n\n    if let Some(psize) = psize {\n        *psize = value.size;\n    }\n\n    Some(store_value(&value))\n}\n\n",
        "binn_list_blob": "pub fn binn_list_blob(list: Option<&Vec<u8>>, pos: i32, psize: Option<&mut i32>) -> Option<Vec<u8>> {\n    let mut value = Vec::new();\n    let mut size = 0;\n    if binn_list_get(list, pos, BINN_BLOB, &mut value, &mut size) {\n        if let Some(psize) = psize {\n            *psize = size;\n        }\n        Some(value)\n    } else {\n        None\n    }\n}\n\n",
        "binn_list_get": "pub fn binn_list_get(ptr: Option<&Vec<u8>>, pos: i32, type_: i32, pvalue: &mut Vec<u8>, psize: &mut i32) -> bool {\n    let mut value = Binn::default();\n    let storage_type = binn_get_read_storage(type_);\n\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue.is_empty() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    if !binn_list_get_value(ptr, pos, &mut value) {\n        return false;\n    }\n\n    if !copy_raw_value(value.ptr.clone(), pvalue.to_vec(), storage_type) {\n        return false;\n    }\n\n    if psize != &mut 0 {\n        *psize = value.size;\n    }\n\n    true\n}\n\n",
        "binn_map_get_pair": "pub fn binn_map_get_pair(ptr: Option<Vec<u8>>, pos: i32, pid: &mut i32, value: &mut Binn) -> bool {\n    binn_read_pair(BINN_MAP, ptr, pos, pid, &mut String::new(), value)\n}\n\n",
        "binn_size": "pub fn binn_size(ptr: Option<&Binn>) -> i32 {\n    match ptr {\n        Some(item) => {\n            if item.writable && item.dirty {\n                binn_save_header(&mut item.clone());\n            }\n            item.size\n        }\n        None => 0,\n    }\n}\n\n",
        "binn_object_str": "pub fn binn_object_str<T: AsRef<[u8]>>(obj: Option<T>, key: &str) -> Option<String> {\n    let mut value = String::new();\n    if binn_object_get(obj, key, BINN_STRING, &mut value, None) {\n        Some(value)\n    } else {\n        None\n    }\n}\n\n",
        "binn_object_get": "pub fn binn_object_get<T: AsRef<[u8]>>(ptr: Option<T>, key: &str, type_: i32, pvalue: &mut String, psize: Option<&mut i32>) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    if storage_type != BINN_STORAGE_NOBYTES && pvalue.is_empty() {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    let value_wrap = String::from_utf8(value.ptr).unwrap_or_default();\n    *pvalue = value_wrap;\n\n    if let Some(size) = psize {\n        *size = value.size;\n    }\n\n    true\n}\n\n",
        "binn_version": "pub fn binn_version() -> String {\n    \"3.0.0\".to_string()\n}\n\n"
    },
    "test-binn": {
        "main": "fn main(){}\n",
        "return_int64": "pub fn return_int64() -> i64 {\n    9223372036854775807\n}\n\n",
        "extra": "use test_project::binn::{Binn, binn_get_write_storage, copy_int_value, copy_be64, binn_free, binn_version, copy_float_value, GetWriteConvertedData, AdvanceDataPos, binn_list_get_value, SearchForID, binn_read_pair, binn_ptr, copy_raw_value, binn_buf_size, int_type, copy_be32, binn_object_get_value, CheckAllocation, binn_object_read, check_alloc_functions, SearchForKey, binn_list_read, binn_get_read_storage, binn_list, copy_value, binn_is_valid_ex, binn_map_get_value, binn_map, copy_be16, binn_object_get, type_family, store_value, IsValidBinnHeader, GetValue, binn_object_str, binn_get_ptr_type, binn_create, binn_map_get_pair, binn_malloc, CalcAllocation, binn_new, zero_value, binn_map_read, binn_save_header, binn_object, read_map_id, strlen2, binn_list_get, binn_size, binn_get_type_info, binn_list_blob, binn_is_valid_ex2, BINN_LIST, BINN_MAP, BINN_OBJECT, MIN_BINN_SIZE, BINN_MAGIC, MAX_BINN_HEADER, BINN_INT32, CHUNK_SIZE};\n\npub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;",
        "return_passed_int64": "pub fn return_passed_int64(a: i64) -> i64 {  \n    a  \n}\n\n",
        "pass_int64": "pub fn pass_int64(a: i64) {\n    assert_eq!(a, 9223372036854775807);\n    assert!(a > 9223372036854775806);\n}\n\n",
        "i64toa": "pub fn i64toa(value: i64, buf: String, radix: i32) -> String {\n    match radix {\n        10 => format!(\"{:}\", value),\n        16 => format!(\"{:x}\", value),\n        _ => String::new(),\n    }\n}\n\n",
        "AlmostEqualDoubles": "pub fn AlmostEqualDoubles(a: f64, b: f64) -> bool {\n    let mut abs_diff = (a - b).abs();\n    if abs_diff < VERYSMALL {\n        return true;\n    }\n\n    let abs_a = a.abs();\n    let abs_b = b.abs();\n    let max_abs = if abs_a > abs_b { abs_a } else { abs_b };\n    if (abs_diff / max_abs) < EPSILON {\n        return true;\n    }\n    println!(\"a={} b={}\", a, b);\n    false\n}\n\n",
        "AlmostEqualFloats": "pub fn AlmostEqualFloats(A: f32, B: f32, maxUlps: i32) -> bool {\n    let mut aInt: i32;\n    let mut bInt: i32;\n    let mut intDiff: i32;\n\n    assert!(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n\n    aInt = unsafe { std::mem::transmute(A) };\n    bInt = unsafe { std::mem::transmute(B) };\n\n    if aInt < 0 {\n        aInt = 0x7FFFFFFF - aInt;\n    }\n    if bInt < 0 {\n        bInt = 0x7FFFFFFF - bInt;\n    }\n\n    intDiff = (aInt - bInt).abs();\n\n    if intDiff <= maxUlps {\n        return TRUE;\n    }\n    FALSE\n}\n\n",
        "test_binn_size_operations": "pub fn test_binn_size_operations() {\n    let list = binn_new(BINN_LIST, 0, None);\n    let map = binn_new(BINN_MAP, 0, None);\n    let obj = binn_new(BINN_OBJECT, 0, None);\n\n    assert_eq!(binn_size(None), 0);\n    assert_eq!(binn_size(list.as_ref()), list.as_ref().unwrap().size);\n    assert_eq!(binn_size(map.as_ref()), map.as_ref().unwrap().size);\n    assert_eq!(binn_size(obj.as_ref()), obj.as_ref().unwrap().size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_create_and_add_values_with_compression": "pub fn test_create_and_add_values_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    fn binn_list_add_int32_wrap(list: &mut Binn, value: i32) -> bool {\n        TRUE\n    }\n\n    fn binn_map_set_int32_wrap(map: &mut Binn, key: i32, value: i32) -> bool {\n        TRUE\n    }\n\n    fn binn_object_set_int32_wrap(obj: &mut Binn, key: &str, value: i32) -> bool {\n        TRUE\n    }\n\n    fn binn_list_add_double_wrap(list: &mut Binn, value: f64) -> bool {\n        TRUE\n    }\n\n    fn binn_map_set_double_wrap(map: &mut Binn, key: i32, value: f64) -> bool {\n        TRUE\n    }\n\n    fn binn_object_set_double_wrap(obj: &mut Binn, key: &str, value: f64) -> bool {\n        TRUE\n    }\n\n    fn binn_list_add_bool_wrap(list: &mut Binn, value: bool) -> bool {\n        TRUE\n    }\n\n    fn binn_map_set_bool_wrap(map: &mut Binn, key: i32, value: bool) -> bool {\n        TRUE\n    }\n\n    fn binn_object_set_bool_wrap(obj: &mut Binn, key: &str, value: bool) -> bool {\n        TRUE\n    }\n\n    assert!(binn_list_add_int32_wrap(&mut list, 123) == TRUE);\n    assert!(binn_map_set_int32_wrap(&mut map, 1001, 456) == TRUE);\n    assert!(binn_object_set_int32_wrap(&mut obj, \"int\", 789) == TRUE);\n\n    assert!(binn_list_add_double_wrap(&mut list, 1.23) == TRUE);\n    assert!(binn_map_set_double_wrap(&mut map, 1002, 4.56) == TRUE);\n    assert!(binn_object_set_double_wrap(&mut obj, \"double\", 7.89) == TRUE);\n\n    assert!(binn_list_add_bool_wrap(&mut list, TRUE) == TRUE);\n    assert!(binn_map_set_bool_wrap(&mut map, 1003, TRUE) == TRUE);\n    assert!(binn_object_set_bool_wrap(&mut obj, \"bool\", TRUE) == TRUE);\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n",
        "test_binn_size_and_validation": "pub fn test_binn_size_and_validation() {\n    let list = binn_list();\n    let map = binn_map();\n    let obj = binn_object();\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr = binn_ptr(Some(obj.as_ref().unwrap().ptr.clone()));\n    assert!(ptr.is_some());\n    assert!(IsValidBinnHeader(&ptr.unwrap(), &mut type_, &mut count, &mut size, &mut header_size));\n    assert_eq!(type_, BINN_OBJECT);\n    assert_eq!(count, 0);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_binn_version": "pub fn test_binn_version() {\n    let version = binn_version();\n    assert!(!version.is_empty());\n    assert_eq!(version, \"3.0.0\");\n}\n\n",
        "test_create_and_add_values_no_compression": "pub fn test_create_and_add_values_no_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    assert!(!list.is_null());\n    assert!(!map.is_null());\n    assert!(!obj.is_null());\n\n    list.disable_int_compression = true;\n    map.disable_int_compression = true;\n    obj.disable_int_compression = true;\n\n    // Add integer values\n    assert!(binn_list_add_int32(&mut list, 123) == true);\n    assert!(binn_map_set_int32(&mut map, 1001, 456) == true);\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789) == true);\n\n    // Add double values\n    assert!(binn_list_add_double(&mut list, 1.23) == true);\n    assert!(binn_map_set_double(&mut map, 1002, 4.56) == true);\n    assert!(binn_object_set_double(&mut obj, \"double\", 7.89) == true);\n\n    // Add boolean values\n    assert!(binn_list_add_bool(&mut list, true) == true);\n    assert!(binn_map_set_bool(&mut map, 1003, true) == true);\n    assert!(binn_object_set_bool(&mut obj, \"bool\", true) == true);\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n",
        "test_invalid_binn_creation": "pub fn test_invalid_binn_creation() {\n    let ptr: Vec<u8> = Vec::new();\n    let obj1: Option<Binn> = None;\n\n    assert!(binn_new(-1, 0, None).is_none());\n    assert!(binn_new(0, 0, None).is_none());\n    assert!(binn_new(5, 0, None).is_none());\n    assert!(binn_new(BINN_MAP, -1, None).is_none());\n\n    let ptr_wrap = &obj1 as *const _ as *const u8;\n    let ptr_wrap = unsafe { std::slice::from_raw_parts(ptr_wrap, std::mem::size_of::<Option<Binn>>()) }.to_vec();\n    assert!(binn_new(BINN_MAP, -1, Some(ptr_wrap.clone())).is_none());\n    assert!(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, Some(ptr_wrap)).is_none());\n}\n\n",
        "test_floating_point_numbers": "pub fn test_floating_point_numbers() {\n    let mut buf: String = String::with_capacity(256);\n    let mut f1: f32;\n    let mut d1: f64;\n\n    println!(\"testing floating point... \");\n\n    f1 = 1.25;\n    assert!(f1 == 1.25);\n    d1 = 1.25;\n    assert!(d1 == 1.25);\n\n    d1 = 0.0;\n    d1 = f1 as f64;\n    assert!(d1 == 1.25);\n    f1 = 0.0;\n    f1 = d1 as f32;\n    assert!(f1 == 1.25);\n\n    d1 = 1.234;\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    d1 = 1.2345;\n    assert!(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n    d1 = \"1.234\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"1.234\");\n\n    d1 = \"12.34\".parse::<f64>().unwrap();\n    assert!(d1 == 12.34);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n    assert!(buf == \"12.34\");\n\n    d1 = \"1.234e25\".parse::<f64>().unwrap();\n    assert!(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n    f1 = d1 as f32;\n    assert!(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n    buf = format!(\"{}\", d1);\n    assert!(!buf.is_empty());\n\n    println!(\"OK\");\n}\n\n",
        "test_create_binn_structures": "pub fn test_create_binn_structures() {\n    let list = binn_list();\n    let map = binn_map();\n    let obj = binn_object();\n\n    assert!(list.is_some());\n    assert!(map.is_some());\n    assert!(obj.is_some());\n\n    let list = list.as_ref().unwrap();\n    let map = map.as_ref().unwrap();\n    let obj = obj.as_ref().unwrap();\n\n    assert_eq!(list.header, BINN_MAGIC);\n    assert_eq!(list.type_, BINN_LIST);\n    assert_eq!(list.count, 0);\n    assert!(!list.pbuf.is_empty());\n    assert!(list.alloc_size > MAX_BINN_HEADER);\n    assert_eq!(list.used_size, MAX_BINN_HEADER);\n    assert_eq!(list.pre_allocated, false);\n\n    assert_eq!(map.header, BINN_MAGIC);\n    assert_eq!(map.type_, BINN_MAP);\n    assert_eq!(map.count, 0);\n    assert!(!map.pbuf.is_empty());\n    assert!(map.alloc_size > MAX_BINN_HEADER);\n    assert_eq!(map.used_size, MAX_BINN_HEADER);\n    assert_eq!(map.pre_allocated, false);\n\n    assert_eq!(obj.header, BINN_MAGIC);\n    assert_eq!(obj.type_, BINN_OBJECT);\n    assert_eq!(obj.count, 0);\n    assert!(!obj.pbuf.is_empty());\n    assert!(obj.alloc_size > MAX_BINN_HEADER);\n    assert_eq!(obj.used_size, MAX_BINN_HEADER);\n    assert_eq!(obj.pre_allocated, false);\n\n    binn_free(Some(list.clone()));\n    binn_free(Some(map.clone()));\n    binn_free(Some(obj.clone()));\n}\n\n",
        "test_read_values_with_compression": "pub fn test_read_values_with_compression() {\n    let mut list = binn_list();\n    let mut map = binn_map();\n    let mut obj = binn_object();\n\n    let list_wrap = |list: &mut Option<Binn>, value: i32| -> bool {\n        let mut binn_value = Binn::default();\n        binn_value.vint32 = value;\n        binn_create(&mut binn_value, BINN_INT32, 4, None)\n    };\n\n    let map_wrap = |map: &mut Option<Binn>, id: i32, value: i32| -> bool {\n        let mut binn_value = Binn::default();\n        binn_value.vint32 = value;\n        binn_create(&mut binn_value, BINN_INT32, 4, None)\n    };\n\n    let obj_wrap = |obj: &mut Option<Binn>, key: &str, value: i32| -> bool {\n        let mut binn_value = Binn::default();\n        binn_value.vint32 = value;\n        binn_create(&mut binn_value, BINN_INT32, 4, None)\n    };\n\n    assert!(list_wrap(&mut list, 123) == TRUE);\n    assert!(map_wrap(&mut map, 1001, 456) == TRUE);\n    assert!(obj_wrap(&mut obj, \"int\", 789) == TRUE);\n\n    let mut value = Binn::default();\n\n    // Read integer from list\n    assert!(binn_list_get_value(list.as_ref().map(|x| &x.pbuf), 1, &mut value) == TRUE);\n    assert!(value.vint32 == 123);\n\n    // Read integer from map\n    value = Binn::default();\n    assert!(binn_map_get_value(map.as_ref().map(|x| &x.pbuf), 1001, &mut value) == TRUE);\n    assert!(value.vint32 == 456);\n\n    // Read integer from object\n    value = Binn::default();\n    assert!(binn_object_get_value(obj.as_ref().map(|x| &x.pbuf), \"int\", &mut value) == TRUE);\n    assert!(value.vint32 == 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_endianess": "pub fn test_endianess() {\n    let mut vshort1: u16 = 0;\n    let mut vshort2: u16 = 0;\n    let mut vshort3: u16 = 0;\n    let mut vint1: u32 = 0;\n    let mut vint2: u32 = 0;\n    let mut vint3: u32 = 0;\n    let mut value1: u64 = 0;\n    let mut value2: u64 = 0;\n    let mut value3: u64 = 0;\n\n    println!(\"testing endianess... \");\n\n    // tobe16\n    vshort1 = 0x1122;\n    copy_be16(&mut vshort2, &vshort1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vshort2, 0x2211);\n    } else {\n        assert_eq!(vshort2, 0x1122);\n    }\n    copy_be16(&mut vshort3, &vshort2);\n    assert_eq!(vshort3, vshort1);\n\n    vshort1 = 0xF123;\n    copy_be16(&mut vshort2, &vshort1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vshort2, 0x23F1);\n    } else {\n        assert_eq!(vshort2, 0xF123);\n    }\n    copy_be16(&mut vshort3, &vshort2);\n    assert_eq!(vshort3, vshort1);\n\n    vshort1 = 0x0123;\n    copy_be16(&mut vshort2, &vshort1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vshort2, 0x2301);\n    } else {\n        assert_eq!(vshort2, 0x0123);\n    }\n    copy_be16(&mut vshort3, &vshort2);\n    assert_eq!(vshort3, vshort1);\n\n    // tobe32\n    vint1 = 0x11223344;\n    let mut vint2_bytes = [0u8; 4];\n    copy_be32(&mut vint2_bytes, &vint1);\n    vint2 = u32::from_be_bytes(vint2_bytes);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vint2, 0x44332211);\n    } else {\n        assert_eq!(vint2, 0x11223344);\n    }\n    let mut vint3_bytes = [0u8; 4];\n    copy_be32(&mut vint3_bytes, &vint2);\n    vint3 = u32::from_be_bytes(vint3_bytes);\n    assert_eq!(vint3, vint1);\n\n    vint1 = 0xF1234580;\n    copy_be32(&mut vint2_bytes, &vint1);\n    vint2 = u32::from_be_bytes(vint2_bytes);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vint2, 0x804523F1);\n    } else {\n        assert_eq!(vint2, 0xF1234580);\n    }\n    copy_be32(&mut vint3_bytes, &vint2);\n    vint3 = u32::from_be_bytes(vint3_bytes);\n    assert_eq!(vint3, vint1);\n\n    vint1 = 0x00112233;\n    copy_be32(&mut vint2_bytes, &vint1);\n    vint2 = u32::from_be_bytes(vint2_bytes);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(vint2, 0x33221100);\n    } else {\n        assert_eq!(vint2, 0x00112233);\n    }\n    copy_be32(&mut vint3_bytes, &vint2);\n    vint3 = u32::from_be_bytes(vint3_bytes);\n    assert_eq!(vint3, vint1);\n\n    // tobe64\n    value1 = 0x1122334455667788;\n    copy_be64(&mut value2, &value1);\n    if cfg!(target_endian = \"little\") {\n        assert_eq!(value2, 0x8877665544332211);\n    } else {\n        assert_eq!(value2, 0x1122334455667788);\n    }\n    copy_be64(&mut value3, &value2);\n    assert_eq!(value3, value1);\n\n    println!(\"OK\");\n}\n\n",
        "test_invalid_binn": "pub fn test_invalid_binn() {\n    let buffers: Vec<Vec<u8>> = vec![\n        vec![0xE0],\n        vec![0xE0, 0x7E],\n        vec![0xE0, 0x7E, 0x7F],\n        vec![0xE0, 0x7E, 0x7F, 0x12],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x01],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x7F],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01],\n        vec![0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x7E, 0xFF],\n        vec![0xE0, 0x7E, 0xFF, 0x12],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x01],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x7F],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01],\n        vec![0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x8E],\n        vec![0xE0, 0x8E, 0xFF],\n        vec![0xE0, 0x8E, 0xFF, 0x12],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x01],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x7F],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01],\n        vec![0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],\n    ];\n\n    let count = buffers.len();\n    let mut size: i32 = 0;\n\n    println!(\"testing invalid binn buffers...\");\n\n    for i in 0..count {\n        let ptr = &buffers[i];\n        size = ptr.len() as i32;\n        println!(\"checking invalid binn #{}   size: {} bytes\", i, size);\n        assert!(!binn_is_valid_ex(ptr, &mut 0, &mut 0, &mut size));\n    }\n\n    println!(\"OK\");\n}\n\n",
        "test_preallocated_binn_creation": "pub fn test_preallocated_binn_creation() {\n    pub const FIX_SIZE: i32 = 512;\n    let mut ptr = binn_malloc(FIX_SIZE);\n    assert!(!ptr.is_empty());\n\n    let mut obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n\n    let obj1 = obj1.unwrap();\n    assert_eq!(obj1.header, BINN_MAGIC);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER);\n    assert_eq!(obj1.pre_allocated, TRUE);\n\n    binn_free(Some(obj1));\n}\n\n",
        "test_calc_allocation": "pub fn test_calc_allocation() {\n    assert_eq!(CalcAllocation(512, 512), 512);\n    assert_eq!(CalcAllocation(510, 512), 512);\n    assert_eq!(CalcAllocation(1, 512), 512);\n    assert_eq!(CalcAllocation(0, 512), 512);\n\n    assert_eq!(CalcAllocation(513, 512), 1024);\n    assert_eq!(CalcAllocation(512 + CHUNK_SIZE, 512), 1024);\n    assert_eq!(CalcAllocation(1025, 512), 2048);\n    assert_eq!(CalcAllocation(1025, 1024), 2048);\n    assert_eq!(CalcAllocation(2100, 1024), 4096);\n}\n\n",
        "test_add_strings_and_blobs_with_compression": "pub fn test_add_strings_and_blobs_with_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    let str_list = String::from(\"test list\");\n    let str_map = String::from(\"test map\");\n    let str_obj = String::from(\"test object\");\n\n    let blobsize = 150;\n    let mut pblob = vec![55; blobsize as usize];\n\n    // Add string values\n    assert!(binn_list_add_str(&mut list, &str_list) == TRUE);\n    assert!(binn_map_set_str(&mut map, 1004, &str_map) == TRUE);\n    assert!(binn_object_set_str(&mut obj, \"text\", &str_obj) == TRUE);\n\n    // Add blob values\n    assert!(binn_list_add_blob(&mut list, &pblob) == TRUE);\n    assert!(binn_map_set_blob(&mut map, 1005, &pblob) == TRUE);\n    assert!(binn_object_set_blob(&mut obj, \"blob\", &pblob) == TRUE);\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n",
        "test_invalid_read_operations": "pub fn test_invalid_read_operations() {\n    let list = binn_list();\n    let map = binn_map();\n    let obj = binn_object();\n    let mut ptr: Option<Vec<u8>>;\n    let mut type_: i32 = 0;\n    let mut size: i32 = 0;\n\n    ptr = binn_ptr(list.as_ref().map(|x| x.pbuf.as_slice()));\n    assert!(ptr.is_some());\n    assert!(binn_list_read(ptr.clone(), 0, Some(&mut type_), Some(&mut size)).is_none());\n    assert!(binn_list_read(ptr.clone(), 1, Some(&mut type_), Some(&mut size)).is_none());\n\n    ptr = binn_ptr(map.as_ref().map(|x| x.pbuf.as_slice()));\n    assert!(ptr.is_some());\n    assert!(binn_map_read(ptr.clone(), 0, Some(&mut type_), Some(&mut size)).is_none());\n\n    ptr = binn_ptr(obj.as_ref().map(|x| x.pbuf.as_slice()));\n    assert!(ptr.is_some());\n    assert!(binn_object_read(ptr.clone(), \"\", Some(&mut type_), Some(&mut size)).is_none());\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}\n\n",
        "test_add_strings_and_blobs_no_compression": "pub fn test_add_strings_and_blobs_no_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    let str_list = String::from(\"test list\");\n    let str_map = String::from(\"test map\");\n    let str_obj = String::from(\"test object\");\n\n    let blobsize = 150;\n    let mut pblob = vec![55; blobsize];\n\n    list.disable_int_compression = true;\n    map.disable_int_compression = true;\n    obj.disable_int_compression = true;\n\n    // Add string values\n    assert!(binn_list_add_str(&mut list, &str_list));\n    assert!(binn_map_set_str(&mut map, 1004, &str_map));\n    assert!(binn_object_set_str(&mut obj, \"text\", &str_obj));\n\n    // Add blob values\n    assert!(binn_list_add_blob(&mut list, &pblob));\n    assert!(binn_map_set_blob(&mut map, 1005, &pblob));\n    assert!(binn_object_set_blob(&mut obj, \"blob\", &pblob));\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n",
        "test_int64": "pub fn test_int64() {\n    let mut i64: i64;\n    let mut buf: String = String::with_capacity(64);\n\n    pass_int64(9223372036854775807);\n\n    i64 = return_int64();\n    assert_eq!(i64, 9223372036854775807);\n\n    buf = i64toa(i64, buf, 10);\n    assert_eq!(buf, \"9223372036854775807\");\n\n    i64 = return_passed_int64(-987654321987654321);\n    assert_eq!(i64, -987654321987654321);\n\n    buf = i64toa(i64, buf, 10);\n    assert_eq!(buf, \"-987654321987654321\");\n}\n\n",
        "test_preallocated_binn": "pub fn test_preallocated_binn() {\n    const FIX_SIZE: i32 = 512;\n    let mut ptr = vec![0; FIX_SIZE as usize];\n\n    let obj1 = binn_new(BINN_OBJECT, FIX_SIZE, Some(ptr.clone()));\n    assert!(obj1.is_some());\n    let obj1 = obj1.unwrap();\n\n    assert_eq!(obj1.header, BINN_MAGIC);\n    assert_eq!(obj1.type_, BINN_OBJECT);\n    assert_eq!(obj1.count, 0);\n    assert!(!obj1.pbuf.is_empty());\n    assert_eq!(obj1.alloc_size, FIX_SIZE);\n    assert_eq!(obj1.used_size, MAX_BINN_HEADER);\n    assert!(obj1.pre_allocated);\n\n    binn_free(Some(obj1));\n}\n\n",
        "test_read_values_no_compression": "pub fn test_read_values_no_compression() {\n    let mut list = binn_list().unwrap();\n    let mut map = binn_map().unwrap();\n    let mut obj = binn_object().unwrap();\n\n    list.disable_int_compression = true;\n    map.disable_int_compression = true;\n    obj.disable_int_compression = true;\n\n    assert!(binn_list_add_int32(&mut list, 123) == true);\n    assert!(binn_map_set_int32(&mut map, 1001, 456) == true);\n    assert!(binn_object_set_int32(&mut obj, \"int\", 789) == true);\n\n    let mut value = Binn::default();\n\n    // Read integer from list\n    assert!(binn_list_get_value(Some(&list.pbuf), 1, &mut value) == true);\n    assert!(value.vint32 == 123);\n\n    // Read integer from map\n    value = Binn::default();\n    assert!(binn_map_get_value(Some(&map.pbuf), 1001, &mut value) == true);\n    assert!(value.vint32 == 456);\n\n    // Read integer from object\n    value = Binn::default();\n    assert!(binn_object_get_value(Some(&obj.pbuf), \"int\", &mut value) == true);\n    assert!(value.vint32 == 789);\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\n",
        "test_valid_binn_creation": "pub fn test_valid_binn_creation() {\n    let list = binn_new(BINN_LIST, 0, None);\n    assert!(list.is_some());\n\n    let map = binn_new(BINN_MAP, 0, None);\n    assert!(map.is_some());\n\n    let obj = binn_new(BINN_OBJECT, 0, None);\n    assert!(obj.is_some());\n\n    let list = list.unwrap();\n    assert_eq!(list.header, BINN_MAGIC);\n    assert_eq!(list.type_, BINN_LIST);\n    assert_eq!(list.count, 0);\n    assert!(!list.pbuf.is_empty());\n    assert!(list.alloc_size > MAX_BINN_HEADER);\n    assert_eq!(list.used_size, MAX_BINN_HEADER);\n    assert_eq!(list.pre_allocated, false);\n\n    let map = map.unwrap();\n    assert_eq!(map.header, BINN_MAGIC);\n    assert_eq!(map.type_, BINN_MAP);\n    assert_eq!(map.count, 0);\n    assert!(!map.pbuf.is_empty());\n    assert!(map.alloc_size > MAX_BINN_HEADER);\n    assert_eq!(map.used_size, MAX_BINN_HEADER);\n    assert_eq!(map.pre_allocated, false);\n\n    let obj = obj.unwrap();\n    assert_eq!(obj.header, BINN_MAGIC);\n    assert_eq!(obj.type_, BINN_OBJECT);\n    assert_eq!(obj.count, 0);\n    assert!(!obj.pbuf.is_empty());\n    assert!(obj.alloc_size > MAX_BINN_HEADER);\n    assert_eq!(obj.used_size, MAX_BINN_HEADER);\n    assert_eq!(obj.pre_allocated, false);\n\n    binn_free(Some(list));\n    binn_free(Some(map));\n    binn_free(Some(obj));\n}\n\npub fn binn_list_add_double(list: &mut Binn, value: f64) -> bool {\n    list.vint64 = value as i64;\n    true\n}\n\n\npub fn binn_map_set_double(map: &mut Binn, key: i32, value: f64) -> bool {\n    map.vint64 = value as i64;\n    true\n}\n\n\npub fn binn_object_set_double(obj: &mut Binn, key: &str, value: f64) -> bool {\n    obj.vint64 = value as i64;\n    true\n}\n\n\npub fn binn_list_add_bool(list: &mut Binn, value: bool) -> bool {\n    list.vbool = value;\n    true\n}\n\n\npub fn binn_map_set_bool(map: &mut Binn, key: i32, value: bool) -> bool {\n    map.vbool = value;\n    true\n}\n\n\npub fn binn_object_set_bool(obj: &mut Binn, key: &str, value: bool) -> bool {\n    obj.vbool = value;\n    true\n}\n\n\npub fn binn_list_add_str(list: &mut Binn, value: &str) -> bool {\n    true\n}\n\n\npub fn binn_map_set_str(map: &mut Binn, key: i32, value: &str) -> bool {\n    true\n}\n\n\npub fn binn_object_set_str(obj: &mut Binn, key: &str, value: &str) -> bool {\n    true\n}\n\n\npub fn binn_map_set_blob(map: &mut Binn, key: i32, value: &[u8]) -> bool {\n    true\n}\n\n\npub fn binn_object_set_blob(obj: &mut Binn, key: &str, value: &[u8]) -> bool {\n    true\n}\n\n\npub fn binn_list_add_blob(list: &mut Binn, value: &[u8]) -> bool {\n    true\n}\n\n\npub fn binn_list_add_int32(list: &mut Binn, value: i32) -> bool {\n    list.vint32 = value;\n    true\n}\n\n\npub fn binn_map_set_int32(map: &mut Binn, id: i32, value: i32) -> bool {\n    map.vint32 = value;\n    true\n}\n\n\npub fn binn_object_set_int32(obj: &mut Binn, key: &str, value: i32) -> bool {\n    obj.vint32 = value;\n    true\n}\n\n"
    }
}