{
    "binn": {
        "compress_int": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: &mut Vec<u8>) -> Vec<u8> {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_NOBYTES {\n        return psource.clone();\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n    let mut pvalue = psource.clone();\n\n    match type_ {\n        BINN_INT64 => {\n            vint = i64::from_le_bytes(psource[..8].try_into().unwrap());\n        }\n        BINN_INT32 => {\n            vint = i32::from_le_bytes(psource[..4].try_into().unwrap()) as i64;\n        }\n        BINN_INT16 => {\n            vint = i16::from_le_bytes(psource[..2].try_into().unwrap()) as i64;\n        }\n        BINN_UINT64 => {\n            vuint = u64::from_le_bytes(psource[..8].try_into().unwrap());\n        }\n        BINN_UINT32 => {\n            vuint = u32::from_le_bytes(psource[..4].try_into().unwrap()) as u64;\n        }\n        BINN_UINT16 => {\n            vuint = u16::from_le_bytes(psource[..2].try_into().unwrap()) as u64;\n        }\n        _ => {}\n    }\n\n    if vint >= 0 {\n        vuint = vint as u64;\n    }\n\n    if vint >= i8::MIN as i64 {\n        type2 = BINN_INT8;\n    } else if vint >= i16::MIN as i64 {\n        type2 = BINN_INT16;\n    } else if vint >= i32::MIN as i64 {\n        type2 = BINN_INT32;\n    }\n\n    if vuint <= u8::MAX as u64 {\n        type2 = BINN_UINT8;\n    } else if vuint <= u16::MAX as u64 {\n        type2 = BINN_UINT16;\n    } else if vuint <= u32::MAX as u64 {\n        type2 = BINN_UINT32;\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    pvalue\n}\n\n //编译报错信息：error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_signed`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:233:18\n    |\n233 |             goto loc_signed!();\n    |                  ^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_signed`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:237:18\n    |\n237 |             goto loc_signed!();\n    |                  ^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_signed`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:241:18\n    |\n241 |             goto loc_signed!();\n    |                  ^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_positive`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:245:18\n    |\n245 |             goto loc_positive!();\n    |                  ^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_positive`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:249:18\n    |\n249 |             goto loc_positive!();\n    |                  ^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_positive`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:253:18\n    |\n253 |             goto loc_positive!();\n    |                  ^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_positive`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:262:14\n    |\n262 |         goto loc_positive!();\n    |              ^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_exit`\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:272:10\n    |\n272 |     goto loc_exit!();\n    |          ^^^^^^^^ expected one of 8 possible tokens\n\nerror: cannot find macro `loc_signed` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:258:5\n    |\n258 |     loc_signed!();\n    |     ^^^^^^^^^^\n\nerror[E0425]: cannot find value `BINN_STORAGE_BYTE` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:220:24\n    |\n7   | const BINN_STORAGE_NOBYTES: i32 = 0x00;\n    | --------------------------------------- similarly named constant `BINN_STORAGE_NOBYTES` defined here\n...\n220 |     if storage_type == BINN_STORAGE_BYTE {\n    |                        ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_NOBYTES`\n\nerror[E0599]: no method named `try_into` found for slice `[u8]` in the current scope\n   --> ../../exp/binn/Output/tmp/test-binn_compress_int/temp.rs:232:52\n    |\n232 |             vint = i64::from_le_bytes(psource[..8].try_into().unwrap());\n    |                                                    ^^^^^^^^\n    |\n",
        "AddValue": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_BYTE: i32 = 0x20;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    let source = psource.to_be_bytes();\n    for i in 0..8 {\n        pdest[i] = source[7 - i];\n    }\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    if cfg!(target_endian = \"little\") {\n        let source = psource.to_be_bytes();\n        *pdest = u16::from_be_bytes([source[1], source[0]]);\n    } else {\n        *pdest = *psource;\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<&[u8]>, size: i32) -> bool {\n    let mut storage_type: i32 = 0;\n    let mut extra_type: i32 = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => {}\n            BINN_STORAGE_STRING => {\n                if size == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    let pvalue = if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        compress_int(&mut storage_type, &mut type_, pvalue.unwrap())\n    } else {\n        pvalue.unwrap()\n    };\n\n    let mut ArgSize: i32 = match storage_type {\n        BINN_STORAGE_NOBYTES => 0,\n        BINN_STORAGE_BYTE => 1,\n        BINN_STORAGE_WORD => 2,\n        BINN_STORAGE_DWORD => 4,\n        BINN_STORAGE_QWORD => 8,\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let size = if size == 0 {\n                strlen2(Some(String::from_utf8(pvalue.to_vec()).unwrap())) as i32\n            } else {\n                size\n            };\n            size + 5\n        }\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            size\n        }\n        _ => return false,\n    };\n\n    ArgSize += 2;\n    if !CheckAllocation(item, ArgSize) {\n        return false;\n    }\n\n    let p = &mut item.pbuf[item.used_size as usize..];\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut dest = [0u8; 2];\n            dest.copy_from_slice(&type16.to_be_bytes());\n            p[0..2].copy_from_slice(&dest);\n            item.used_size += 2;\n        } else {\n            p[0] = type_ as u8;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_BYTE => {\n            p[0] = pvalue[0];\n            item.used_size += 1;\n        }\n        BINN_STORAGE_WORD => {\n            let mut dest = [0u8; 2];\n            dest.copy_from_slice(&u16::from_ne_bytes([pvalue[0], pvalue[1]]).to_be_bytes());\n            p[0..2].copy_from_slice(&dest);\n            item.used_size += 2;\n        }\n        BINN_STORAGE_DWORD => {\n            let mut dest = [0u8; 4];\n            dest.copy_from_slice(&i32::from_ne_bytes([pvalue[0], pvalue[1], pvalue[2], pvalue[3]]).to_be_bytes());\n            p[0..4].copy_from_slice(&dest);\n            item.used_size += 4;\n        }\n        BINN_STORAGE_QWORD => {\n            let mut dest = [0u8; 8];\n            dest.copy_from_slice(&u64::from_ne_bytes([pvalue[0], pvalue[1], pvalue[2], pvalue[3], pvalue[4], pvalue[5], pvalue[6], pvalue[7]]).to_be_bytes());\n            p[0..8].copy_from_slice(&dest);\n            item.used_size += 8;\n        }\n        BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = size | 0x80000000;\n                let mut dest = [0u8; 4];\n                dest.copy_from_slice(&int32.to_be_bytes());\n                p[0..4].copy_from_slice(&dest);\n                item.used_size += 4;\n            } else {\n                p[0] = size as u8;\n                item.used_size += 1;\n            }\n            p[..size as usize].copy_from_slice(&pvalue[..size as usize]);\n            p[size as usize] = 0;\n            item.used_size += 1;\n            item.used_size += size;\n        }\n        BINN_STORAGE_CONTAINER => {\n            p[..size as usize].copy_from_slice(&pvalue[..size as usize]);\n            item.used_size += size;\n        }\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a [u8]) -> &'a [u8] {\n    let storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n\n    let vint = match type_ {\n        BINN_INT64 => i64::from_be_bytes([psource[0], psource[1], psource[2], psource[3], psource[4], psource[5], psource[6], psource[7]]),\n        BINN_INT32 => i32::from_be_bytes([psource[0], psource[1], psource[2], psource[3]]) as i64,\n        BINN_INT16 => i16::from_be_bytes([psource[0], psource[1]]) as i64,\n        BINN_UINT64 => u64::from_be_bytes([psource[0], psource[1], psource[2], psource[3], psource[4], psource[5], psource[6], psource[7]]) as i64,\n        BINN_UINT32 => u32::from_be_bytes([psource[0], psource[1], psource[2], psource[3]]) as i64,\n        BINN_UINT16 => u16::from_be_bytes([psource[0], psource[1]]) as i64,\n        _ => return psource,\n    };\n\n    if vint >= 0 {\n        let vuint = vint as u64;\n        if vuint <= u8::MAX as u64 {\n            type2 = BINN_UINT8;\n        } else if vuint <= u16::MAX as u64 {\n            type2 = BINN_UINT16;\n        } else if vuint <= u32::MAX as u64 {\n            type2 = BINN_UINT32;\n        }\n    } else {\n        if vint >= i8::MIN as i64 {\n            type2 = BINN_INT8;\n        } else if vint >= i16::MIN as i64 {\n            type2 = BINN_INT16;\n        } else if vint >= i32::MIN as i64 {\n            type2 = BINN_INT32;\n        }\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    psource\n}\n\nfn main(){}\n\n\n //编译报错信息：error[E0004]: non-exhaustive patterns: `i32::MIN..=-1_i32`, `1_i32..=31_i32`, `33_i32..=63_i32` and 5 more not covered\n   --> ../../exp/binn/Output/tmp/test-binn_AddValue/temp.rs:341:11\n    |\n341 |     match storage_type {\n    |           ^^^^^^^^^^^^ patterns `i32::MIN..=-1_i32`, `1_i32..=31_i32`, `33_i32..=63_i32` and 5 more not covered\n    |\n    = note: the matched value is of type `i32`\n",
        "binn_list_add_raw": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn copy_be64(pdest: &mut [u8; 8], psource: &u64) {\n    let source = psource.to_be_bytes();\n    pdest.copy_from_slice(&source);\n}\n\n\npub fn copy_be16(pdest: &mut [u8; 2], psource: &u16) {\n    let source = psource.to_be_bytes();\n    pdest.copy_from_slice(&source);\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source = psource.to_be_bytes();\n    pdest.copy_from_slice(&source);\n}\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    if !AddValue(item, type_, pvalue, size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn get_storage_size(storage_type: i32) -> i32 {\n    match storage_type {\n        BINN_STORAGE_NOBYTES => 0,\n        BINN_STORAGE_WORD => 2,\n        BINN_STORAGE_DWORD => 4,\n        BINN_STORAGE_QWORD => 8,\n        _ => 0,\n    }\n}\n\n\npub fn AddValue(item: &mut Binn, mut type_: i32, pvalue: Option<&Vec<u8>>, size: i32) -> bool {\n    let mut int32: i32 = 0;\n    let mut ArgSize: i32 = 0;\n    let mut storage_type: i32 = 0;\n    let mut extra_type: i32 = 0;\n\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => {}\n            BINN_STORAGE_BLOB => {\n                if size == 0 {}\n            }\n            BINN_STORAGE_STRING => {\n                if size == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let compressed_value = compress_int(&mut storage_type, &mut type_, pvalue);\n        if let Some(compressed) = compressed_value {\n            let pvalue_wrap = Some(&compressed);\n            match storage_type {\n                BINN_STORAGE_NOBYTES => {\n                    ArgSize = 0;\n                }\n                BINN_STORAGE_WORD => {\n                    ArgSize = 2;\n                }\n                BINN_STORAGE_DWORD => {\n                    ArgSize = 4;\n                }\n                BINN_STORAGE_QWORD => {\n                    ArgSize = 8;\n                }\n                BINN_STORAGE_BLOB => {\n                    if size < 0 {\n                        return false;\n                    }\n                    ArgSize = size + 4;\n                }\n                BINN_STORAGE_STRING => {\n                    if size < 0 {\n                        return false;\n                    }\n                    let size = if size == 0 {\n                        pvalue_wrap.as_ref().map_or(0, |v| v.len() as i32)\n                    } else {\n                        size\n                    };\n                    ArgSize = size + 5;\n                }\n                BINN_STORAGE_CONTAINER => {\n                    if size <= 0 {\n                        return false;\n                    }\n                    ArgSize = size;\n                }\n                _ => return false,\n            }\n\n            ArgSize += 2;\n            if !CheckAllocation(item, ArgSize) {\n                return false;\n            }\n\n            let mut p = item.pbuf[item.used_size as usize..].to_vec();\n\n            if storage_type != BINN_STORAGE_CONTAINER {\n                if type_ > 255 {\n                    let type16 = type_ as u16;\n                    let mut dest = [0u8; 2];\n                    copy_be16(&mut dest, &type16);\n                    p[0..2].copy_from_slice(&dest);\n                    item.used_size += 2;\n                } else {\n                    p[0] = type_ as u8;\n                    item.used_size += 1;\n                }\n            }\n\n            match storage_type {\n                BINN_STORAGE_NOBYTES => {}\n                BINN_STORAGE_WORD => {\n                    let value = pvalue_wrap.as_ref().map_or(0, |v| (v[0] as u16) << 8 | v[1] as u16);\n                    let mut dest = [0u8; 2];\n                    copy_be16(&mut dest, &value);\n                    p[0..2].copy_from_slice(&dest);\n                    item.used_size += 2;\n                }\n                BINN_STORAGE_DWORD => {\n                    let value = pvalue_wrap.as_ref().map_or(0, |v| {\n                        (v[0] as u32) << 24 | (v[1] as u32) << 16 | (v[2] as u32) << 8 | v[3] as u32\n                    });\n                    let mut dest = [0u8; 4];\n                    copy_be32(&mut dest, &(value as i32));\n                    p[0..4].copy_from_slice(&dest);\n                    item.used_size += 4;\n                }\n                BINN_STORAGE_QWORD => {\n                    let value = pvalue_wrap.as_ref().map_or(0, |v| {\n                        (v[0] as u64) << 56\n                            | (v[1] as u64) << 48\n                            | (v[2] as u64) << 40\n                            | (v[3] as u64) << 32\n                            | (v[4] as u64) << 24\n                            | (v[5] as u64) << 16\n                            | (v[6] as u64) << 8\n                            | v[7] as u64\n                    });\n                    let mut dest = [0u8; 8];\n                    copy_be64(&mut dest, &value);\n                    p[0..8].copy_from_slice(&dest);\n                    item.used_size += 8;\n                }\n                BINN_STORAGE_BLOB => {\n                    if size > 127 {\n                        int32 = size | 0x80000000;\n                        let mut dest = [0u8; 4];\n                        copy_be32(&mut dest, &int32);\n                        p[0..4].copy_from_slice(&dest);\n                        item.used_size += 4;\n                    } else {\n                        p[0] = size as u8;\n                        item.used_size += 1;\n                    }\n                    if let Some(value) = pvalue_wrap {\n                        p[..value.len()].copy_from_slice(value);\n                    }\n                    item.used_size += size;\n                }\n                BINN_STORAGE_STRING => {\n                    if size > 127 {\n                        int32 = size | 0x80000000;\n                        let mut dest = [0u8; 4];\n                        copy_be32(&mut dest, &int32);\n                        p[0..4].copy_from_slice(&dest);\n                        item.used_size += 4;\n                    } else {\n                        p[0] = size as u8;\n                        item.used_size += 1;\n                    }\n                    if let Some(value) = pvalue_wrap {\n                        p[..value.len()].copy_from_slice(value);\n                    }\n                    p[size as usize] = 0;\n                    item.used_size += size + 1;\n                }\n                BINN_STORAGE_CONTAINER => {\n                    if let Some(value) = pvalue_wrap {\n                        p[..value.len()].copy_from_slice(value);\n                    }\n                    item.used_size += size;\n                }\n            }\n\n            item.dirty = true;\n            return true;\n        }\n    }\n\n    false\n}\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: Option<&Vec<u8>>) -> Option<Vec<u8>> {\n    let storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_WORD {\n        return psource.cloned();\n    }\n\n    let type_ = *ptype;\n\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            vint = psource.as_ref().map_or(0, |v| {\n                (v[0] as i64) << 56\n                    | (v[1] as i64) << 48\n                    | (v[2] as i64) << 40\n                    | (v[3] as i64) << 32\n                    | (v[4] as i64) << 24\n                    | (v[5] as i64) << 16\n                    | (v[6] as i64) << 8\n                    | v[7] as i64\n            });\n        }\n        BINN_INT32 => {\n            vint = psource.as_ref().map_or(0, |v| {\n                (v[0] as i32) << 24 | (v[1] as i32) << 16 | (v[2] as i32) << 8 | v[3] as i32\n            }) as i64;\n        }\n        BINN_INT16 => {\n            vint = psource.as_ref().map_or(0, |v| ((v[0] as i16) << 8 | v[1] as i16) as i64);\n        }\n        BINN_UINT64 => {\n            vuint = psource.as_ref().map_or(0, |v| {\n                (v[0] as u64) << 56\n                    | (v[1] as u64) << 48\n                    | (v[2] as u64) << 40\n                    | (v[3] as u64) << 32\n                    | (v[4] as u64) << 24\n                    | (v[5] as u64) << 16\n                    | (v[6] as u64) << 8\n                    | v[7] as u64\n            });\n        }\n        BINN_UINT32 => {\n            vuint = psource.as_ref().map_or(0, |v| {\n                (v[0] as u32) << 24 | (v[1] as u32) << 16 | (v[2] as u32) << 8 | v[3] as u32\n            }) as u64;\n        }\n        BINN_UINT16 => {\n            vuint = psource.as_ref().map_or(0, |v| ((v[0] as u16) << 8 | v[1] as u16) as u64);\n        }\n        _ => return None,\n    }\n\n    let mut type2: i32 = 0;\n\n    if vint >= 0 {\n        vuint = vint as u64;\n    } else {\n        if vint >= i8::MIN as i64 {\n            type2 = BINN_INT8;\n        } else if vint >= i16::MIN as i64 {\n            type2 = BINN_INT16;\n        } else if vint >= i32::MIN as i64 {\n            type2 = BINN_INT32;\n        }\n    }\n\n    if vuint <= u8::MAX as u64 {\n        type2 = BINN_UINT8;\n    } else if vuint <= u16::MAX as u64 {\n        type2 = BINN_UINT16;\n    } else if vuint <= u32::MAX as u64 {\n        type2 = BINN_UINT32;\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n\n        let size1 = get_storage_size(storage_type);\n        let size2 = get_storage_size(storage_type2);\n        let offset = size1 - size2;\n\n        let mut result = Vec::new();\n        if let Some(source) = psource {\n            result.extend_from_slice(&source[offset as usize..]);\n        }\n        Some(result)\n    } else {\n        psource.cloned()\n    }\n}\n\n\nfn main(){}\n\n\n //编译报错信息：error: literal out of range for `i32`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_list_add_raw/temp.rs:412:40\n    |\n412 |                         int32 = size | 0x80000000;\n    |                                        ^^^^^^^^^^\n    |\n    = note: the literal `0x80000000` (decimal `2147483648`) does not fit into the type `i32` and will become `-2147483648i32`\n    = help: consider using the type `u32` instead\n    = note: `#[deny(overflowing_literals)]` on by default\n",
        "binn_map_set_raw": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: &Vec<u8>) -> Vec<u8> {\n    let mut storage_type: i32;\n    let mut storage_type2: i32;\n    let mut type_: i32;\n    let mut type2: i32 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64;\n    let mut pvalue: Vec<u8>;\n\n    storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource.clone();\n    }\n\n    type_ = *ptype;\n\n    match type_ {\n        BINN_INT64 => {\n            vint = i64::from_be_bytes(psource[..8].try_into().unwrap());\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= u8::MAX as u64 {\n                    type2 = BINN_UINT8;\n                } else if vuint <= u16::MAX as u64 {\n                    type2 = BINN_UINT16;\n                } else if vuint <= u32::MAX as u64 {\n                    type2 = BINN_UINT32;\n                }\n            } else if vint >= i8::MIN as i64 {\n                type2 = BINN_INT8;\n            } else if vint >= i16::MIN as i64 {\n                type2 = BINN_INT16;\n            } else if vint >= i32::MIN as i64 {\n                type2 = BINN_INT32;\n            }\n        }\n        BINN_INT32 => {\n            vint = i32::from_be_bytes(psource[..4].try_into().unwrap()) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= u8::MAX as u64 {\n                    type2 = BINN_UINT8;\n                } else if vuint <= u16::MAX as u64 {\n                    type2 = BINN_UINT16;\n                } else if vuint <= u32::MAX as u64 {\n                    type2 = BINN_UINT32;\n                }\n            } else if vint >= i8::MIN as i64 {\n                type2 = BINN_INT8;\n            } else if vint >= i16::MIN as i64 {\n                type2 = BINN_INT16;\n            } else if vint >= i32::MIN as i64 {\n                type2 = BINN_INT32;\n            }\n        }\n        BINN_INT16 => {\n            vint = i16::from_be_bytes(psource[..2].try_into().unwrap()) as i64;\n            if vint >= 0 {\n                vuint = vint as u64;\n                if vuint <= u8::MAX as u64 {\n                    type2 = BINN_UINT8;\n                } else if vuint <= u16::MAX as u64 {\n                    type2 = BINN_UINT16;\n                } else if vuint <= u32::MAX as u64 {\n                    type2 = BINN_UINT32;\n                }\n            } else if vint >= i8::MIN as i64 {\n                type2 = BINN_INT8;\n            } else if vint >= i16::MIN as i64 {\n                type2 = BINN_INT16;\n            } else if vint >= i32::MIN as i64 {\n                type2 = BINN_INT32;\n            }\n        }\n        BINN_UINT64 => {\n            vuint = u64::from_be_bytes(psource[..8].try_into().unwrap());\n            if vuint <= u8::MAX as u64 {\n                type2 = BINN_UINT8;\n            } else if vuint <= u16::MAX as u64 {\n                type2 = BINN_UINT16;\n            } else if vuint <= u32::MAX as u64 {\n                type2 = BINN_UINT32;\n            }\n        }\n        BINN_UINT32 => {\n            vuint = u32::from_be_bytes(psource[..4].try_into().unwrap()) as u64;\n            if vuint <= u8::MAX as u64 {\n                type2 = BINN_UINT8;\n            } else if vuint <= u16::MAX as u64 {\n                type2 = BINN_UINT16;\n            } else if vuint <= u32::MAX as u64 {\n                type2 = BINN_UINT32;\n            }\n        }\n        BINN_UINT16 => {\n            vuint = u16::from_be_bytes(psource[..2].try_into().unwrap()) as u64;\n            if vuint <= u8::MAX as u64 {\n                type2 = BINN_UINT8;\n            } else if vuint <= u16::MAX as u64 {\n                type2 = BINN_UINT16;\n            } else if vuint <= u32::MAX as u64 {\n                type2 = BINN_UINT32;\n            }\n        }\n        _ => (),\n    }\n\n    pvalue = psource.clone();\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n    }\n\n    pvalue\n}\n\n //编译报错信息：error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_signed`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set_raw/temp.rs:656:18\n    |\n656 |             goto loc_signed;\n    |                  ^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_signed`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set_raw/temp.rs:660:18\n    |\n660 |             goto loc_signed;\n    |                  ^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_signed`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set_raw/temp.rs:664:18\n    |\n664 |             goto loc_signed;\n    |                  ^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_positive`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set_raw/temp.rs:668:18\n    |\n668 |             goto loc_positive;\n    |                  ^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_positive`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set_raw/temp.rs:672:18\n    |\n672 |             goto loc_positive;\n    |                  ^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `loc_positive`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set_raw/temp.rs:676:18\n    |\n676 |             goto loc_positive;\n    |                  ^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: statements are terminated with a semicolon\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set_raw/temp.rs:681:11\n    |\n681 | loc_signed:\n    |           ^\n    |\n    = note: if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n",
        "binn_object_set_raw": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    let source = psource.to_be_bytes();\n    let dest = &mut pdest.to_be_bytes();\n    for i in 0..8 {\n        dest[i] = source[7 - i];\n    }\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    if cfg!(target_endian = \"little\") {\n        let source = psource.to_be_bytes();\n        *pdest = u16::from_be_bytes([source[1], source[0]]);\n    } else {\n        *pdest = *psource;\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, key: &str) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = p.len() as i32 - 1;\n    let mut p = p.split_off(header_size as usize);\n    let keylen = key.len() as i32;\n\n    for _ in 0..numitems {\n        if p.len() as i32 > plimit {\n            break;\n        }\n        let len = p[0] as i32;\n        p.remove(0);\n        if p.len() as i32 + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if p[0..len as usize].eq_ignore_ascii_case(key.as_bytes()) {\n                if keylen == len {\n                    p.drain(0..len as usize);\n                    return Some(p);\n                }\n            }\n            p.drain(0..len as usize);\n        } else if len == keylen {\n            return Some(p);\n        }\n        p = match AdvanceDataPos(&mut p, &base) {\n            Some(new_p) => new_p,\n            None => break,\n        };\n        if p.len() < base.len() {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: &Vec<u8>) -> Option<Vec<u8>> {\n    if p.as_ptr() > plimit.as_ptr() {\n        return None;\n    }\n\n    let byte = p[0] as i32;\n    p.remove(0);\n    let storage_type = byte & BINN_STORAGE_MASK;\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        p.remove(0);\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_STRING => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n                p.drain(0..4);\n            } else {\n                p.remove(0);\n            }\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n            p.remove(0);\n        }\n        BINN_STORAGE_CONTAINER => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n            }\n            DataSize -= 1;\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n        }\n        _ => {\n            return None;\n        }\n    }\n\n    Some(p.clone())\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: &[u8], size: i32) -> bool {\n    if item.is_null() || item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n\n    if key.is_empty() {\n        return false;\n    }\n    let key_len = key.len();\n    if key_len > 255 {\n        return false;\n    }\n\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size, item.count, key).is_some() {\n        return false;\n    }\n\n    if !CheckAllocation(item, 1 + key_len as i32) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    item.pbuf[p] = key_len as u8;\n    p += 1;\n    item.pbuf[p..p + key_len].copy_from_slice(key.as_bytes());\n    item.used_size += 1 + key_len as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= 1 + key_len as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: &[u8], size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    if !binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type)) {\n        return false;\n    }\n\n    if pvalue.is_empty() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => {}\n            BINN_STORAGE_STRING => {\n                if size == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    let mut compressed_value = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        compressed_value = compress_int(&mut storage_type, &mut type_, pvalue);\n    }\n\n    let mut arg_size = match storage_type {\n        BINN_STORAGE_NOBYTES => 0,\n        BINN_STORAGE_WORD => 2,\n        BINN_STORAGE_DWORD => 4,\n        BINN_STORAGE_QWORD => 8,\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            size + 4\n        }\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let len = if size == 0 { pvalue.len() } else { size as usize };\n            len as i32 + 5\n        }\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            size\n        }\n        _ => return false,\n    };\n\n    arg_size += 2;\n    if !CheckAllocation(item, arg_size) {\n        return false;\n    }\n\n    let mut p = item.used_size as usize;\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut type16_bytes = [0u8; 2];\n            type16_bytes.copy_from_slice(&type16.to_be_bytes());\n            item.pbuf[p..p + 2].copy_from_slice(&type16_bytes);\n            p += 2;\n            item.used_size += 2;\n        } else {\n            item.pbuf[p] = type_ as u8;\n            p += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_WORD => {\n            let value = u16::from_ne_bytes([pvalue[0], pvalue[1]]);\n            item.pbuf[p..p + 2].copy_from_slice(&value.to_be_bytes());\n            item.used_size += 2;\n        }\n        BINN_STORAGE_DWORD => {\n            let value = i32::from_ne_bytes([pvalue[0], pvalue[1], pvalue[2], pvalue[3]]);\n            item.pbuf[p..p + 4].copy_from_slice(&value.to_be_bytes());\n            item.used_size += 4;\n        }\n        BINN_STORAGE_QWORD => {\n            let value = u64::from_ne_bytes([\n                pvalue[0], pvalue[1], pvalue[2], pvalue[3], pvalue[4], pvalue[5], pvalue[6], pvalue[7],\n            ]);\n            item.pbuf[p..p + 8].copy_from_slice(&value.to_be_bytes());\n            item.used_size += 8;\n        }\n        BINN_STORAGE_BLOB => {\n            let len = if size > 127 {\n                let int32 = size | 0x80000000;\n                item.pbuf[p..p + 4].copy_from_slice(&int32.to_be_bytes());\n                p += 4;\n                item.used_size += 4;\n                size\n            } else {\n                item.pbuf[p] = size as u8;\n                p += 1;\n                item.used_size += 1;\n                size\n            };\n            item.pbuf[p..p + len as usize].copy_from_slice(&pvalue[..len as usize]);\n            item.used_size += len;\n        }\n        BINN_STORAGE_STRING => {\n            let len = if size > 127 {\n                let int32 = size | 0x80000000;\n                item.pbuf[p..p + 4].copy_from_slice(&int32.to_be_bytes());\n                p += 4;\n                item.used_size += 4;\n                size\n            } else {\n                item.pbuf[p] = size as u8;\n                p += 1;\n                item.used_size += 1;\n                size\n            };\n            item.pbuf[p..p + len as usize].copy_from_slice(&pvalue[..len as usize]);\n            item.pbuf[p + len as usize] = 0;\n            item.used_size += len + 1;\n        }\n        BINN_STORAGE_CONTAINER => {\n            item.pbuf[p..p + size as usize].copy_from_slice(pvalue);\n            item.used_size += size;\n        }\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn compress_int<'a>(pstorage_type: &mut i32, ptype: &mut i32, psource: &'a [u8]) -> &'a [u8] {\n    use std::convert::TryInto;\n\n    let storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_WORD {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint = 0i64;\n    let mut vuint = 0u64;\n\n    match type_ {\n        BINN_INT64 => vint = i64::from_ne_bytes(psource.try_into().unwrap()),\n        BINN_INT32 => vint = i32::from_ne_bytes(psource[..4].try_into().unwrap()) as i64,\n        BINN_INT16 => vint = i16::from_ne_bytes(psource[..2].try_into().unwrap()) as i64,\n        BINN_UINT64 => vuint = u64::from_ne_bytes(psource.try_into().unwrap()),\n        BINN_UINT32 => vuint = u32::from_ne_bytes(psource[..4].try_into().unwrap()) as u64,\n        BINN_UINT16 => vuint = u16::from_ne_bytes(psource[..2].try_into().unwrap()) as u64,\n        _ => return psource,\n    }\n\n    if vint >= 0 {\n        vuint = vint as u64;\n    } else {\n        if vint >= i8::MIN as i64 {\n            type2 = BINN_INT8;\n        } else if vint >= i16::MIN as i64 {\n            type2 = BINN_INT16;\n        } else if vint >= i32::MIN as i64 {\n            type2 = BINN_INT32;\n        }\n    }\n\n    if vuint <= u8::MAX as u64 {\n        type2 = BINN_UINT8;\n    } else if vuint <= u16::MAX as u64 {\n        type2 = BINN_UINT16;\n    } else if vuint <= u32::MAX as u64 {\n        type2 = BINN_UINT32;\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        *pstorage_type = binn_get_write_storage(type2);\n    }\n\n    psource\n}\n\nfn main(){}\n\n\n //编译报错信息：error[E0596]: cannot borrow `type_` as mutable, as it is not declared as mutable\n   --> ../../exp/binn/Output/tmp/test-binn_binn_object_set_raw/temp.rs:433:60\n    |\n433 |         compressed_value = compress_int(&mut storage_type, &mut type_, pvalue);\n    |                                                            ^^^^^^^^^^ cannot borrow as mutable\n    |\n",
        "binn_list_get": "const BINN_INT8: i32 = 1;\nconst BINN_INT16: i32 = 2;\nconst BINN_INT32: i32 = 3;\nconst BINN_INT64: i32 = 4;\nconst BINN_UINT8: i32 = 5;\nconst BINN_UINT16: i32 = 6;\nconst BINN_UINT32: i32 = 7;\nconst BINN_UINT64: i32 = 8;\nconst BINN_SIGNED_INT: i32 = 1;\nconst BINN_UNSIGNED_INT: i32 = 2;\nconst BINN_LIST: i32 = 9;\nconst BINN_MAP: i32 = 10;\nconst BINN_OBJECT: i32 = 11;\nconst BINN_FAMILY_BINN: i32 = 1;\nconst BINN_FAMILY_INT: i32 = 2;\nconst BINN_FAMILY_FLOAT: i32 = 3;\nconst BINN_FAMILY_STRING: i32 = 4;\nconst BINN_FAMILY_BLOB: i32 = 5;\nconst BINN_FAMILY_BOOL: i32 = 6;\nconst BINN_FAMILY_NULL: i32 = 7;\nconst BINN_FAMILY_NONE: i32 = 0;\nconst BINN_FLOAT32: i32 = 12;\nconst BINN_FLOAT64: i32 = 13;\nconst BINN_SINGLE_STR: i32 = 14;\nconst BINN_DOUBLE_STR: i32 = 15;\nconst BINN_STRING: i32 = 16;\nconst BINN_HTML: i32 = 17;\nconst BINN_CSS: i32 = 18;\nconst BINN_XML: i32 = 19;\nconst BINN_JSON: i32 = 20;\nconst BINN_JAVASCRIPT: i32 = 21;\nconst BINN_BLOB: i32 = 22;\nconst BINN_JPEG: i32 = 23;\nconst BINN_GIF: i32 = 24;\nconst BINN_PNG: i32 = 25;\nconst BINN_BMP: i32 = 26;\nconst BINN_DECIMAL: i32 = 27;\nconst BINN_CURRENCY: i32 = 28;\nconst BINN_DATE: i32 = 29;\nconst BINN_TIME: i32 = 30;\nconst BINN_DATETIME: i32 = 31;\nconst BINN_BOOL: i32 = 32;\nconst BINN_NULL: i32 = 33;\nconst BINN_STORAGE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst BINN_STORAGE_CONTAINER: i32 = 0x20;\nconst BINN_STORAGE_MASK16: i32 = 0x0F00;\nconst BINN_TYPE_MASK16: i32 = 0xF000;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x10000;\nconst BINN_STORAGE_NOBYTES: i32 = 0;\nconst BINN_STORAGE_BYTE: i32 = 1;\nconst BINN_STORAGE_WORD: i32 = 2;\nconst BINN_STORAGE_DWORD: i32 = 3;\nconst BINN_STORAGE_QWORD: i32 = 4;\nconst BINN_STORAGE_BLOB: i32 = 5;\nconst BINN_STORAGE_STRING: i32 = 6;\nconst BINN_STORAGE_CONTAINER: i32 = 7;\nconst MAX_BINN_HEADER: i32 = 9;\nconst MIN_BINN_SIZE: i32 = 1;\n\nstruct Binn {\n    pbuf: Vec<u8>,\n    used_size: i32,\n    count: i32,\n    type_: i32,\n    ptr: Vec<u8>,\n    size: i32,\n    dirty: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            pbuf: Vec::new(),\n            used_size: 0,\n            count: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            dirty: false,\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn copy_int_value(psource: &i64, pdest: &mut i64, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => vint64 = *psource as i8 as i64,\n        BINN_INT16 => vint64 = *psource as i16 as i64,\n        BINN_INT32 => vint64 = *psource as i32 as i64,\n        BINN_INT64 => vint64 = *psource,\n\n        BINN_UINT8 => vuint64 = *psource as u8 as u64,\n        BINN_UINT16 => vuint64 = *psource as u16 as u64,\n        BINN_UINT32 => vuint64 = *psource as u32 as u64,\n        BINN_UINT64 => vuint64 = *psource as u64,\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < i8::MIN as i64 || vint64 > i8::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i8 as i64;\n        }\n        BINN_INT16 => {\n            if vint64 < i16::MIN as i64 || vint64 > i16::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i16 as i64;\n        }\n        BINN_INT32 => {\n            if vint64 < i32::MIN as i64 || vint64 > i32::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i32 as i64;\n        }\n        BINN_INT64 => *pdest = vint64,\n\n        BINN_UINT8 => {\n            if vuint64 > u8::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u8 as i64;\n        }\n        BINN_UINT16 => {\n            if vuint64 > u16::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u16 as i64;\n        }\n        BINN_UINT32 => {\n            if vuint64 > u32::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u32 as i64;\n        }\n        BINN_UINT64 => *pdest = vuint64 as i64,\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p: usize;\n    let mut size: i32;\n\n    p = item.pbuf.len() - MAX_BINN_HEADER as usize;\n    size = item.used_size - MAX_BINN_HEADER + 3;\n\n    if item.count > 127 {\n        p -= 4;\n        size += 3;\n        let int32 = item.count as u32 | 0x80000000;\n        let mut dest = [0u8; 4];\n        copy_be32(&mut dest, &(int32 as i32));\n        item.pbuf[p..p + 4].copy_from_slice(&dest);\n    } else {\n        p -= 1;\n        item.pbuf[p] = item.count as u8;\n    }\n\n    if size > 127 {\n        p -= 4;\n        size += 3;\n        let int32 = size as u32 | 0x80000000;\n        let mut dest = [0u8; 4];\n        copy_be32(&mut dest, &(int32 as i32));\n        item.pbuf[p..p + 4].copy_from_slice(&dest);\n    } else {\n        p -= 1;\n        item.pbuf[p] = size as u8;\n    }\n\n    p -= 1;\n    item.pbuf[p] = item.type_ as u8;\n\n    item.ptr = item.pbuf[p..].to_vec();\n    item.size = size;\n\n    item.dirty = false;\n\n    true\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_STRING => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => {}\n    }\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n //编译报错信息：error: expected one of `!` or `::`, found keyword `pub`\n --> ../../exp/binn/Output/tmp/test-binn_binn_list_get/temp.rs:3:1\n  |\n1 | 上下文长度超过限制\n  |                   - expected one of `!` or `::`\n2 |\n3 | pub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n  | ^^^ unexpected token\n\nerror: aborting due to 1 previous error\n\n",
        "binn_object_get": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn copy_int_value(psource: &i64, pdest: &mut i64, source_type: i32, dest_type: i32) -> bool {\n    let mut vuint64: u64 = 0;\n    let mut vint64: i64 = 0;\n\n    match source_type {\n        BINN_INT8 => vint64 = *psource as i8 as i64,\n        BINN_INT16 => vint64 = *psource as i16 as i64,\n        BINN_INT32 => vint64 = *psource as i32 as i64,\n        BINN_INT64 => vint64 = *psource,\n\n        BINN_UINT8 => vuint64 = *psource as u8 as u64,\n        BINN_UINT16 => vuint64 = *psource as u16 as u64,\n        BINN_UINT32 => vuint64 = *psource as u32 as u64,\n        BINN_UINT64 => vuint64 = *psource as u64,\n\n        _ => return false,\n    }\n\n    if int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT {\n        if vuint64 > i64::MAX as u64 {\n            return false;\n        }\n        vint64 = vuint64 as i64;\n    } else if int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT {\n        if vint64 < 0 {\n            return false;\n        }\n        vuint64 = vint64 as u64;\n    }\n\n    match dest_type {\n        BINN_INT8 => {\n            if vint64 < i8::MIN as i64 || vint64 > i8::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i8 as i64;\n        }\n        BINN_INT16 => {\n            if vint64 < i16::MIN as i64 || vint64 > i16::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i16 as i64;\n        }\n        BINN_INT32 => {\n            if vint64 < i32::MIN as i64 || vint64 > i32::MAX as i64 {\n                return false;\n            }\n            *pdest = vint64 as i32 as i64;\n        }\n        BINN_INT64 => *pdest = vint64,\n\n        BINN_UINT8 => {\n            if vuint64 > u8::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u8 as i64;\n        }\n        BINN_UINT16 => {\n            if vuint64 > u16::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u16 as i64;\n        }\n        BINN_UINT32 => {\n            if vuint64 > u32::MAX as u64 {\n                return false;\n            }\n            *pdest = vuint64 as u32 as i64;\n        }\n        BINN_UINT64 => *pdest = vuint64 as i64,\n\n        _ => return false,\n    }\n\n    true\n}\n\n\npub fn int_type(type_: i32) -> i32 {\n    match type_ {\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 => BINN_SIGNED_INT,\n        BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_UNSIGNED_INT,\n        _ => 0,\n    }\n}\n\n\npub fn binn_save_header(item: &mut Binn) -> bool {\n    if item.pbuf.is_empty() {\n        return false;\n    }\n\n    let mut p: usize;\n    let mut size: i32;\n\n    p = item.pbuf.len() - MAX_BINN_HEADER as usize;\n    size = item.used_size - MAX_BINN_HEADER + 3;\n\n    if item.count > 127 {\n        p -= 4;\n        size += 3;\n        let int32 = item.count as u32 | 0x80000000;\n        let mut dest = [0u8; 4];\n        copy_be32(&mut dest, &(int32 as i32));\n        item.pbuf[p..p + 4].copy_from_slice(&dest);\n    } else {\n        p -= 1;\n        item.pbuf[p] = item.count as u8;\n    }\n\n    if size > 127 {\n        p -= 4;\n        size += 3;\n        let int32 = size as u32 | 0x80000000;\n        let mut dest = [0u8; 4];\n        copy_be32(&mut dest, &(int32 as i32));\n        item.pbuf[p..p + 4].copy_from_slice(&dest);\n    } else {\n        p -= 1;\n        item.pbuf[p] = size as u8;\n    }\n\n    p -= 1;\n    item.pbuf[p] = item.type_ as u8;\n\n    item.ptr = item.pbuf[p..].to_vec();\n    item.size = size;\n\n    item.dirty = false;\n\n    true\n}\n\n\npub fn binn_object_get_value<T: AsRef<[u8]>>(ptr: Option<T>, key: &str, value: &mut Binn) -> bool {\n    let ptr = binn_ptr(ptr.as_ref().map(|x| x.as_ref()));\n    if ptr.is_none() || key.is_empty() || value.is_null() {\n        return false;\n    }\n\n    let mut type_ = 0;\n    let mut count = 0;\n    let mut size = 0;\n    let mut header_size = 0;\n\n    let ptr_ref = ptr.as_ref().unwrap();\n    if !IsValidBinnHeader(ptr_ref, &mut type_, &mut count, &mut size, &mut header_size) {\n        return false;\n    }\n\n    if type_ != BINN_OBJECT {\n        return false;\n    }\n\n    if count == 0 {\n        return false;\n    }\n\n    let mut p = ptr.unwrap();\n    let plimit = p.len() as i32 - 1;\n\n    let p = SearchForKey(&mut p, header_size, size, count, key);\n    if p.is_none() {\n        return false;\n    }\n\n    let mut p = p.unwrap();\n    let mut plimit_vec = p.clone();\n    plimit_vec.truncate(plimit as usize);\n\n    GetValue(&mut p, &mut plimit_vec, value)\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn binn_get_read_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => return BINN_STORAGE_DWORD,\n        BINN_DOUBLE_STR => return BINN_STORAGE_QWORD,\n        BINN_BOOL => return BINN_STORAGE_DWORD,\n        BINN_TRUE => return BINN_STORAGE_DWORD,\n        BINN_FALSE => return BINN_STORAGE_DWORD,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            return storage_type;\n        }\n    }\n}\n\n\npub fn GetValue(p: &mut Vec<u8>, plimit: &mut Vec<u8>, value: &mut Binn) -> bool {\n    let mut byte: u8;\n    let mut data_type: i32;\n    let mut storage_type: i32;\n    let mut data_size: i32;\n    let mut p2: Vec<u8> = Vec::new();\n\n    if value.is_null() {\n        return false;\n    }\n    *value = Binn::default();\n    value.header = BINN_MAGIC;\n\n    p2 = p.clone();\n\n    if p > plimit {\n        return false;\n    }\n    byte = p[0];\n    p.remove(0);\n    storage_type = (byte as i32) & BINN_STORAGE_MASK;\n    if (byte as i32) & BINN_STORAGE_HAS_MORE != 0 {\n        data_type = (byte as i32) << 8;\n        if p > plimit {\n            return false;\n        }\n        byte = p[0];\n        p.remove(0);\n        data_type |= byte as i32;\n    } else {\n        data_type = byte as i32;\n    }\n\n    value.type_ = data_type;\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_STRING => {\n            if p > plimit {\n                return false;\n            }\n            data_size = p[0] as i32;\n            if (data_size & 0x80) != 0 {\n                if p.len() + 3 > plimit.len() {\n                    return false;\n                }\n                let mut data_size_bytes = [0u8; 4];\n                copy_be32(&mut data_size_bytes, &i32::from_be_bytes([p[0], p[1], p[2], p[3]]));\n                data_size = i32::from_be_bytes(data_size_bytes);\n                data_size &= 0x7FFFFFFF;\n                p.drain(0..4);\n            } else {\n                p.remove(0);\n            }\n            if p.len() + data_size as usize - 1 > plimit.len() {\n                return false;\n            }\n            value.size = data_size;\n            value.ptr = p.clone();\n        }\n        BINN_STORAGE_CONTAINER => {\n            value.ptr = p2.clone();\n            if !IsValidBinnHeader(&p2, &mut 0, &mut value.count, &mut value.size, &mut 0) {\n                return false;\n            }\n        }\n        _ => return false,\n    }\n\n    match value.type_ {\n        BINN_TRUE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = true;\n            value.ptr = vec![value.vbool as u8];\n        }\n        BINN_FALSE => {\n            value.type_ = BINN_BOOL;\n            value.vbool = false;\n            value.ptr = vec![value.vbool as u8];\n        }\n        _ => (),\n    }\n\n    true\n}\n\n\npub fn binn_get_ptr_type<T>(ptr: Option<T>) -> i32 {\n    if ptr.is_none() {\n        return BINN_BUFFER;\n    }\n\n    match ptr {\n        Some(_) => BINN_STRUCT,\n        None => BINN_BUFFER,\n    }\n}\n\n\npub fn copy_float_value<T: Into<f64> + From<f64> + From<f32>>(psource: T, pdest: &mut T, source_type: i32, dest_type: i32) -> bool {\n    match source_type {\n        BINN_FLOAT32 => {\n            *pdest = T::from(psource.into() as f32);\n            true\n        }\n        BINN_FLOAT64 => {\n            *pdest = T::from(psource.into());\n            true\n        }\n        _ => false,\n    }\n}\n\n\npub fn copy_value<T: Into<i64> + From<i64> + Into<f64> + From<f64> + From<f32>>(psource: T, pdest: &mut T, source_type: i32, dest_type: i32, data_store: i32) -> bool {\n    if type_family(source_type) != type_family(dest_type) {\n        return false;\n    }\n\n    if type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type {\n        let psource_wrap: i64 = psource.into();\n        let mut pdest_wrap: i64 = (*pdest).into();\n        let result = copy_int_value(&psource_wrap, &mut pdest_wrap, source_type, dest_type);\n        *pdest = T::from(pdest_wrap);\n        return result;\n    } else if type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type {\n        return copy_float_value(psource, pdest, source_type, dest_type);\n    } else {\n        let temp = psource;\n        return copy_raw_value(temp, pdest, data_store);\n    }\n}\n\n\npub fn IsValidBinnHeader(pbuf: &Vec<u8>, ptype: &mut i32, pcount: &mut i32, psize: &mut i32, pheadersize: &mut i32) -> bool {\n    let mut p = pbuf.as_ptr();\n    let mut plimit: *const u8 = std::ptr::null();\n    let mut int32: i32;\n    let mut type_: i32;\n    let mut size: i32;\n    let mut count: i32;\n\n    if pbuf.is_empty() {\n        return false;\n    }\n\n    if *psize > 0 {\n        if *psize < MIN_BINN_SIZE {\n            return false;\n        }\n        plimit = unsafe { p.offset(*psize as isize - 1) };\n    }\n\n    // get the type\n    let byte = unsafe { *p };\n    p = unsafe { p.offset(1) };\n    if (byte as i32 & BINN_STORAGE_MASK) != BINN_STORAGE_CONTAINER {\n        return false;\n    }\n    if byte as i32 & BINN_STORAGE_HAS_MORE != 0 {\n        return false;\n    }\n    type_ = byte as i32;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return false,\n    }\n\n    // get the size\n    if !plimit.is_null() && p > plimit {\n        return false;\n    }\n    int32 = unsafe { *p as i32 };\n    if int32 & 0x80 != 0 {\n        if !plimit.is_null() && unsafe { p.offset(3) } > plimit {\n            return false;\n        }\n        let mut temp = [0u8; 4];\n        unsafe { std::ptr::copy_nonoverlapping(p, temp.as_mut_ptr(), 4) };\n        int32 = i32::from_be_bytes(temp);\n        int32 &= 0x7FFFFFFF;\n        p = unsafe { p.offset(4) };\n    } else {\n        p = unsafe { p.offset(1) };\n    }\n    size = int32;\n\n    // get the count\n    if !plimit.is_null() && p > plimit {\n        return false;\n    }\n    int32 = unsafe { *p as i32 };\n    if int32 & 0x80 != 0 {\n        if !plimit.is_null() && unsafe { p.offset(3) } > plimit {\n            return false;\n        }\n        let mut temp = [0u8; 4];\n        unsafe { std::ptr::copy_nonoverlapping(p, temp.as_mut_ptr(), 4) };\n        int32 = i32::from_be_bytes(temp);\n        int32 &= 0x7FFFFFFF;\n        p = unsafe { p.offset(4) };\n    } else {\n        p = unsafe { p.offset(1) };\n    }\n    count = int32;\n\n    if size < MIN_BINN_SIZE || count < 0 {\n        return false;\n    }\n\n    // return the values\n    *ptype = type_;\n    *pcount = count;\n    *psize = size;\n    *pheadersize = unsafe { p.offset_from(pbuf.as_ptr()) } as i32;\n    true\n}\n\n\npub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    let source = psource.to_be_bytes();\n    let dest = &mut pdest.to_be_bytes();\n    for i in 0..8 {\n        dest[i] = source[7 - i];\n    }\n}\n\n\npub fn binn_ptr<T: AsRef<[u8]>>(ptr: Option<T>) -> Option<Vec<u8>> {\n    match binn_get_ptr_type(ptr.as_ref().map(|_| ())) {\n        BINN_STRUCT => {\n            let mut item = Binn::default();\n            if item.writable && item.dirty {\n                binn_save_header(&mut item);\n            }\n            Some(item.ptr.clone())\n        }\n        BINN_BUFFER => Some(ptr.unwrap().as_ref().to_vec()),\n        _ => None,\n    }\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    if cfg!(target_endian = \"little\") {\n        let source = psource.to_be_bytes();\n        *pdest = u16::from_be_bytes([source[1], source[0]]);\n    } else {\n        *pdest = *psource;\n    }\n}\n\n\npub fn copy_raw_value<T>(psource: T, mut pdest: T, data_store: i32) -> bool {\n    match data_store {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_BYTE => {\n            pdest = psource;\n        }\n        BINN_STORAGE_WORD => {\n            pdest = psource;\n        }\n        BINN_STORAGE_DWORD => {\n            pdest = psource;\n        }\n        BINN_STORAGE_QWORD => {\n            pdest = psource;\n        }\n        BINN_STORAGE_BLOB => {\n            pdest = psource;\n        }\n        BINN_STORAGE_STRING => {\n            pdest = psource;\n        }\n        BINN_STORAGE_CONTAINER => {\n            pdest = psource;\n        }\n        _ => return false,\n    }\n    true\n}\n\n\npub fn zero_value<T>(pvalue: &mut T, type_: i32) {\n    match binn_get_read_storage(type_) {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_BYTE => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_WORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_DWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_QWORD => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_BLOB => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_STRING => *pvalue = unsafe { std::mem::zeroed() },\n        BINN_STORAGE_CONTAINER => *pvalue = unsafe { std::mem::zeroed() },\n        _ => {}\n    }\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, key: &str) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = p.len() as i32 - 1;\n    let mut p = p.split_off(header_size as usize);\n    let keylen = key.len() as i32;\n\n    for _ in 0..numitems {\n        if p.len() as i32 > plimit {\n            break;\n        }\n        let len = p[0] as i32;\n        p.remove(0);\n        if p.len() as i32 + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if p[0..len as usize].eq_ignore_ascii_case(key.as_bytes()) {\n                if keylen == len {\n                    p.drain(0..len as usize);\n                    return Some(p);\n                }\n            }\n            p.drain(0..len as usize);\n        } else if len == keylen {\n            return Some(p);\n        }\n        p = match AdvanceDataPos(&mut p, &base) {\n            Some(new_p) => new_p,\n            None => break,\n        };\n        if p.len() < base.len() {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: &Vec<u8>) -> Option<Vec<u8>> {\n    if p.as_ptr() > plimit.as_ptr() {\n        return None;\n    }\n\n    let byte = p[0] as i32;\n    p.remove(0);\n    let storage_type = byte & BINN_STORAGE_MASK;\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        p.remove(0);\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_STRING => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n                p.drain(0..4);\n            } else {\n                p.remove(0);\n            }\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n            p.remove(0);\n        }\n        BINN_STORAGE_CONTAINER => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n            }\n            DataSize -= 1;\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n        }\n        _ => {\n            return None;\n        }\n    }\n\n    Some(p.clone())\n}\n\n\npub fn binn_object_get<T: AsRef<[u8]>, U: Default + PartialEq + From<Vec<u8>> + Into<Vec<u8>> + From<i64> + From<f64> + From<f32>>(ptr: Option<T>, key: &str, type_: i32, pvalue: &mut U, psize: &mut i32) -> bool {\n    let storage_type = binn_get_read_storage(type_);\n    let default_value = U::default();\n    if storage_type != BINN_STORAGE_NOBYTES && *pvalue == default_value {\n        return false;\n    }\n\n    zero_value(pvalue, type_);\n\n    let mut value = Binn::default();\n    if !binn_object_get_value(ptr, key, &mut value) {\n        return false;\n    }\n\n    let value_ptr = value.ptr.into();\n    let mut temp_value = U::default();\n    if !copy_value(value_ptr, &mut temp_value, value.type_, type_, storage_type) {\n        return false;\n    }\n\n    *pvalue = temp_value;\n    *psize = value.size;\n\n    true\n}\n\nfn main(){}\n\n\n //编译报错信息：error[E0308]: mismatched types\n   --> ../../exp/binn/Output/tmp/test-binn_binn_object_get/temp.rs:483:37\n    |\n468 | pub fn copy_value<T: Into<i64> + From<i64> + Into<f64> + From<f64> + From<f32>>(psource: T, pdest: &mut T, source_type: i...\n    |                   - expected this type parameter\n...\n483 |         return copy_raw_value(temp, pdest, data_store);\n    |                -------------- ----  ^^^^^ expected type parameter `T`, found `&mut T`\n    |                |              |\n    |                |              expected some other arguments to be a type parameter `T` type to match the type of this parameter\n    |                arguments to this function are incorrect\n    |\n    = note: expected type parameter `_`\n            found mutable reference `&mut _`\nnote: function defined here\n   --> ../../exp/binn/Output/tmp/test-binn_binn_object_get/temp.rs:608:8\n    |\n608 | pub fn copy_raw_value<T>(psource: T, mut pdest: T, data_store: i32) -> bool {\n    |        ^^^^^^^^^^^^^^ -  ----------  ------------  ---------------\n    |                       |  |           |\n    |                       |  |           this parameter needs to match the type parameter `T` type of `psource`\n    |                       |  `pdest` needs to match the type parameter `T` type of this parameter\n    |                       `psource` and `pdest` all reference this parameter T\n\nerror[E0277]: the trait bound `i64: From<U>` is not satisfied\n   --> ../../exp/binn/Output/tmp/test-binn_binn_object_get/temp.rs:817:9\n    |\n817 |     if !copy_value(value_ptr, &mut temp_value, value.type_, type_, storage_type) {\n    |         ^^^^^^^^^^ the trait `From<U>` is not implemented for `i64`\n    |\n    = note: required for `U` to implement `Into<i64>`\nnote: required by a bound in `copy_value`\n   --> ../../exp/binn/Output/tmp/test-binn_binn_object_get/temp.rs:468:22\n    |\n468 | pub fn copy_value<T: Into<i64> + From<i64> + Into<f64> + From<f64> + From<f32>>(psource: T, pdest: &mut T, source_type: i...\n    |                      ^^^^^^^^^ required by this bound in `copy_value`\n",
        "binn_map_set": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn read_map_id(pp: &mut Vec<u8>, plimit: &Vec<u8>) -> i32 {\n    let mut p = pp.clone();\n    let mut id: i32 = 0;\n    let mut extra_bytes: i32 = 0;\n    let mut sign: u8 = 0;\n    let mut type_: u8 = 0;\n\n    if p.len() > plimit.len() {\n        return 0;\n    }\n\n    let c = p.remove(0);\n\n    if c & 0x80 != 0 {\n        extra_bytes = (((c & 0x60) >> 5) as i32) + 1;\n        if p.len() + extra_bytes as usize > plimit.len() {\n            *pp = p;\n            return 0;\n        }\n    }\n\n    type_ = c & 0xE0;\n    sign = c & 0x10;\n\n    if (c & 0x80) == 0 {\n        sign = c & 0x40;\n        id = (c & 0x3F) as i32;\n    } else if type_ == 0x80 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n    } else if type_ == 0xA0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n    } else if type_ == 0xC0 {\n        id = (c & 0x0F) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n        id = (id << 8) | p.remove(0) as i32;\n    } else if type_ == 0xE0 {\n        let mut id_bytes = [0u8; 4];\n        id_bytes.copy_from_slice(&p[0..4]);\n        id = i32::from_be_bytes(id_bytes);\n        p.drain(0..4);\n    } else {\n        *pp = plimit.clone();\n        return 0;\n    }\n\n    if sign != 0 {\n        id = -id;\n    }\n\n    *pp = p;\n\n    id\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: &Vec<u8>) -> Option<Vec<u8>> {\n    if p.as_ptr() > plimit.as_ptr() {\n        return None;\n    }\n\n    let byte = p[0] as i32;\n    p.remove(0);\n    let storage_type = byte & BINN_STORAGE_MASK;\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        p.remove(0);\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_STRING => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n                p.drain(0..4);\n            } else {\n                p.remove(0);\n            }\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n            p.remove(0);\n        }\n        BINN_STORAGE_CONTAINER => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n            }\n            DataSize -= 1;\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n        }\n        _ => {\n            return None;\n        }\n    }\n\n    Some(p.clone())\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn SearchForID(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, id: i32) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = base.len() as i32 - 1;\n    let mut p = base.split_off(header_size as usize);\n\n    for _ in 0..numitems {\n        let int32 = read_map_id(&mut p, &base);\n        if p.len() > plimit as usize {\n            break;\n        }\n        if int32 == id {\n            return Some(p);\n        }\n        match AdvanceDataPos(&mut p, &base) {\n            Some(new_p) => p = new_p,\n            None => break,\n        }\n        if p.len() < base.len() {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    let source = psource.to_be_bytes();\n    let dest = &mut pdest.to_be_bytes();\n    for i in 0..8 {\n        dest[i] = source[7 - i];\n    }\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    if cfg!(target_endian = \"little\") {\n        let source = psource.to_be_bytes();\n        *pdest = u16::from_be_bytes([source[1], source[0]]);\n    } else {\n        *pdest = *psource;\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Vec<u8>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: String = String::with_capacity(128);\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => {}\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_SINGLE => {\n            f1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f32)) };\n            d1 = f1 as f64;\n            type_ = BINN_SINGLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_DOUBLE => {\n            d1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f64)) };\n            type_ = BINN_DOUBLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        BINN_DECIMAL | BINN_CURRENCYSTR => {\n            return true;\n        }\n        BINN_DATE | BINN_DATETIME | BINN_TIME => {\n            return true;\n        }\n        BINN_BOOL => {\n            let bool_value = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const bool)) };\n            if bool_value {\n                type_ = BINN_TRUE;\n            } else {\n                type_ = BINN_FALSE;\n            }\n            *ptype = type_;\n        }\n        _ => {}\n    }\n\n    true\n}\n\n\npub fn binn_map_set(map: &mut Binn, id: i32, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n    if !GetWriteConvertedData(&mut type_, &mut pvalue, &mut size) {\n        return false;\n    }\n    binn_map_set_raw(map, id, type_, pvalue, size)\n}\n\n\npub fn binn_map_set_raw(item: &mut Binn, id: i32, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    if item.type_ != BINN_MAP || !item.writable {\n        return false;\n    }\n\n    if let Some(_) = SearchForID(&mut item.pbuf, MAX_BINN_HEADER, item.used_size, item.count, id) {\n        return false;\n    }\n\n    if !CheckAllocation(item, 5) {\n        return false;\n    }\n\n    let mut p = item.pbuf.len();\n    item.pbuf.resize(p + 5, 0);\n    let mut base = p;\n    let mut sign = id < 0;\n    let mut id = if sign { -id } else { id };\n\n    if id <= 0x3F {\n        item.pbuf[p] = (sign as u8) << 6 | id as u8;\n        p += 1;\n    } else if id <= 0xFFF {\n        item.pbuf[p] = 0x80 | (sign as u8) << 4 | ((id & 0xF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n    } else if id <= 0xFFFFF {\n        item.pbuf[p] = 0xA0 | (sign as u8) << 4 | ((id & 0xF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n    } else if id <= 0xFFFFFFF {\n        item.pbuf[p] = 0xC0 | (sign as u8) << 4 | ((id & 0xF000000) >> 24) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF0000) >> 16) as u8;\n        p += 1;\n        item.pbuf[p] = ((id & 0xFF00) >> 8) as u8;\n        p += 1;\n        item.pbuf[p] = (id & 0xFF) as u8;\n        p += 1;\n    } else {\n        item.pbuf[p] = 0xE0;\n        p += 1;\n        if sign { id = -id; }\n        let mut id_bytes = [0u8; 4];\n        copy_be32(&mut id_bytes, &id);\n        item.pbuf[p..p+4].copy_from_slice(&id_bytes);\n        p += 4;\n    }\n\n    let id_size = p - base;\n    item.used_size += id_size as i32;\n\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= id_size as i32;\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    if !binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type)) {\n        return false;\n    }\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => {}\n            BINN_STORAGE_STRING => {\n                if size == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    let pvalue = if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        compress_int(&mut storage_type, &mut type_, pvalue)\n    } else {\n        pvalue\n    };\n\n    let (size, ArgSize) = match storage_type {\n        BINN_STORAGE_NOBYTES => (0, 0),\n        BINN_STORAGE_DWORD => (4, 4),\n        BINN_STORAGE_WORD => (2, 2),\n        BINN_STORAGE_QWORD => (8, 8),\n        BINN_STORAGE_STRING => {\n            if size < 0 { return false; }\n            let size = if size == 0 { pvalue.as_ref().map_or(0, |v| v.len() as i32) } else { size };\n            (size, size + 5)\n        }\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 { return false; }\n            (size, size)\n        }\n        _ => return false,\n    };\n\n    let ArgSize = ArgSize + 2;\n    if !CheckAllocation(item, ArgSize) {\n        return false;\n    }\n\n    let mut p = item.pbuf.len();\n    item.pbuf.resize(p + ArgSize as usize, 0);\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut type16_bytes = [0u8; 2];\n            copy_be16(&mut type16_bytes, &type16);\n            item.pbuf[p..p+2].copy_from_slice(&type16_bytes);\n            p += 2;\n            item.used_size += 2;\n        } else {\n            item.pbuf[p] = type_ as u8;\n            p += 1;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_DWORD => {\n            let value = pvalue.as_ref().map_or(0, |v| (v[0] as u32) << 24 | (v[1] as u32) << 16 | (v[2] as u32) << 8 | v[3] as u32);\n            let mut value_bytes = [0u8; 4];\n            copy_be32(&mut value_bytes, &(value as i32));\n            item.pbuf[p..p+4].copy_from_slice(&value_bytes);\n            item.used_size += 4;\n        }\n        BINN_STORAGE_WORD => {\n            let value = pvalue.as_ref().map_or(0, |v| (v[0] as u16) << 8 | v[1] as u16);\n            let mut value_bytes = [0u8; 2];\n            copy_be16(&mut value_bytes, &value);\n            item.pbuf[p..p+2].copy_from_slice(&value_bytes);\n            item.used_size += 2;\n        }\n        BINN_STORAGE_QWORD => {\n            let value = pvalue.as_ref().map_or(0, |v| (v[0] as u64) << 56 | (v[1] as u64) << 48 | (v[2] as u64) << 40 | (v[3] as u64) << 32 | (v[4] as u64) << 24 | (v[5] as u64) << 16 | (v[6] as u64) << 8 | v[7] as u64);\n            let mut value_bytes = [0u8; 8];\n            copy_be64(&mut value_bytes, &value);\n            item.pbuf[p..p+8].copy_from_slice(&value_bytes);\n            item.used_size += 8;\n        }\n        BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = size | 0x80000000;\n                let mut int32_bytes = [0u8; 4];\n                copy_be32(&mut int32_bytes, &int32);\n                item.pbuf[p..p+4].copy_from_slice(&int32_bytes);\n                p += 4;\n                item.used_size += 4;\n            } else {\n                item.pbuf[p] = size as u8;\n                p += 1;\n                item.used_size += 1;\n            }\n            if let Some(pvalue) = pvalue {\n                item.pbuf[p..p + size as usize].copy_from_slice(&pvalue[..size as usize]);\n            }\n            item.pbuf[p + size as usize] = 0;\n            item.used_size += size + 1;\n        }\n        BINN_STORAGE_CONTAINER => {\n            if let Some(pvalue) = pvalue {\n                item.pbuf[p..p + size as usize].copy_from_slice(&pvalue[..size as usize]);\n            }\n            item.used_size += size;\n        }\n    }\n\n    item.dirty = true;\n    true\n}\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: Option<Vec<u8>>) -> Option<Vec<u8>> {\n    let storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut vint = 0i64;\n    let mut vuint = 0u64;\n\n    match type_ {\n        BINN_INT64 => vint = psource.as_ref().map_or(0, |v| (v[0] as i64) << 56 | (v[1] as i64) << 48 | (v[2] as i64) << 40 | (v[3] as i64) << 32 | (v[4] as i64) << 24 | (v[5] as i64) << 16 | (v[6] as i64) << 8 | v[7] as i64),\n        BINN_INT32 => vint = psource.as_ref().map_or(0, |v| (v[0] as i32) << 24 | (v[1] as i32) << 16 | (v[2] as i32) << 8 | v[3] as i32) as i64,\n        BINN_INT16 => vint = psource.as_ref().map_or(0, |v| (v[0] as i16) << 8 | v[1] as i16) as i64,\n        BINN_UINT64 => vuint = psource.as_ref().map_or(0, |v| (v[0] as u64) << 56 | (v[1] as u64) << 48 | (v[2] as u64) << 40 | (v[3] as u64) << 32 | (v[4] as u64) << 24 | (v[5] as u64) << 16 | (v[6] as u64) << 8 | v[7] as u64),\n        BINN_UINT32 => vuint = psource.as_ref().map_or(0, |v| (v[0] as u32) << 24 | (v[1] as u32) << 16 | (v[2] as u32) << 8 | v[3] as u32) as u64,\n        BINN_UINT16 => vuint = psource.as_ref().map_or(0, |v| (v[0] as u16) << 8 | v[1] as u16) as u64,\n        _ => return psource,\n    }\n\n    if vint >= 0 {\n        vuint = vint as u64;\n    } else {\n        if vint >= i8::MIN as i64 {\n            type2 = BINN_INT8;\n        } else if vint >= i16::MIN as i64 {\n            type2 = BINN_INT16;\n        } else if vint >= i32::MIN as i64 {\n            type2 = BINN_INT32;\n        }\n    }\n\n    if vuint <= u8::MAX as u64 {\n        type2 = BINN_UINT8;\n    } else if vuint <= u16::MAX as u64 {\n        type2 = BINN_UINT16;\n    } else if vuint <= u32::MAX as u64 {\n        type2 = BINN_UINT32;\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n        let size2 = match storage_type2 {\n            BINN_STORAGE_BYTE => 1,\n            BINN_STORAGE_WORD => 2,\n            BINN_STORAGE_DWORD => 4,\n            BINN_STORAGE_QWORD => 8,\n            _ => return psource,\n        };\n        let mut pvalue = psource.unwrap_or_default();\n        pvalue.truncate(size2);\n        Some(pvalue)\n    } else {\n        psource\n    }\n}\n\n\nfn main(){}\n\n\n //编译报错信息：error[E0425]: cannot find value `BINN_STORAGE_BYTE` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set/temp.rs:676:24\n    |\n7   | const BINN_STORAGE_NOBYTES: i32 = 0x00;\n    | --------------------------------------- similarly named constant `BINN_STORAGE_NOBYTES` defined here\n...\n676 |     if storage_type == BINN_STORAGE_BYTE {\n    |                        ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_NOBYTES`\n\nerror[E0308]: mismatched types\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set/temp.rs:609:23\n    |\n609 |             copy_be16(&mut type16_bytes, &type16);\n    |             --------- ^^^^^^^^^^^^^^^^^ expected `&mut u16`, found `&mut [u8; 2]`\n    |             |\n    |             arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut u16`\n               found mutable reference `&mut [u8; 2]`\nnote: function defined here\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set/temp.rs:393:8\n    |\n393 | pub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    |        ^^^^^^^^^ ---------------\n\nerror[E0308]: mismatched types\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set/temp.rs:632:23\n    |\n632 |             copy_be16(&mut value_bytes, &value);\n    |             --------- ^^^^^^^^^^^^^^^^ expected `&mut u16`, found `&mut [u8; 2]`\n    |             |\n    |             arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut u16`\n               found mutable reference `&mut [u8; 2]`\nnote: function defined here\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set/temp.rs:393:8\n    |\n393 | pub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    |        ^^^^^^^^^ ---------------\n\nerror[E0308]: mismatched types\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set/temp.rs:639:23\n    |\n639 |             copy_be64(&mut value_bytes, &value);\n    |             --------- ^^^^^^^^^^^^^^^^ expected `&mut u64`, found `&mut [u8; 8]`\n    |             |\n    |             arguments to this function are incorrect\n    |\n    = note: expected mutable reference `&mut u64`\n               found mutable reference `&mut [u8; 8]`\nnote: function defined here\n   --> ../../exp/binn/Output/tmp/test-binn_binn_map_set/temp.rs:384:8\n    |\n384 | pub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    |        ^^^^^^^^^ ---------------\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
        "binn_object_set": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn AdvanceDataPos(p: &mut Vec<u8>, plimit: &Vec<u8>) -> Option<Vec<u8>> {\n    if p.as_ptr() > plimit.as_ptr() {\n        return None;\n    }\n\n    let byte = p[0] as i32;\n    p.remove(0);\n    let storage_type = byte & BINN_STORAGE_MASK;\n    if byte & BINN_STORAGE_HAS_MORE != 0 {\n        p.remove(0);\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_STRING => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n                p.drain(0..4);\n            } else {\n                p.remove(0);\n            }\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n            p.remove(0);\n        }\n        BINN_STORAGE_CONTAINER => {\n            if p.as_ptr() > plimit.as_ptr() {\n                return None;\n            }\n            let mut DataSize = p[0] as i32;\n            if DataSize & 0x80 != 0 {\n                if p.len() < 4 {\n                    return None;\n                }\n                let mut temp = [0u8; 4];\n                temp.copy_from_slice(&p[0..4]);\n                DataSize = i32::from_be_bytes(temp) & 0x7FFFFFFF;\n            }\n            DataSize -= 1;\n            if p.len() < DataSize as usize {\n                return None;\n            }\n            p.drain(0..DataSize as usize);\n        }\n        _ => {\n            return None;\n        }\n    }\n\n    Some(p.clone())\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    let source = psource.to_be_bytes();\n    let dest = &mut pdest.to_be_bytes();\n    for i in 0..8 {\n        dest[i] = source[7 - i];\n    }\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    if cfg!(target_endian = \"little\") {\n        let source = psource.to_be_bytes();\n        *pdest = u16::from_be_bytes([source[1], source[0]]);\n    } else {\n        *pdest = *psource;\n    }\n}\n\n\npub fn SearchForKey(p: &mut Vec<u8>, header_size: i32, size: i32, numitems: i32, key: &str) -> Option<Vec<u8>> {\n    let mut base = p.clone();\n    let plimit = p.len() as i32 - 1;\n    let mut p = p.split_off(header_size as usize);\n    let keylen = key.len() as i32;\n\n    for _ in 0..numitems {\n        if p.len() as i32 > plimit {\n            break;\n        }\n        let len = p[0] as i32;\n        p.remove(0);\n        if p.len() as i32 + len > plimit {\n            break;\n        }\n        if len > 0 {\n            if p[0..len as usize].eq_ignore_ascii_case(key.as_bytes()) {\n                if keylen == len {\n                    p.drain(0..len as usize);\n                    return Some(p);\n                }\n            }\n            p.drain(0..len as usize);\n        } else if len == keylen {\n            return Some(p);\n        }\n        p = match AdvanceDataPos(&mut p, &base) {\n            Some(new_p) => new_p,\n            None => break,\n        };\n        if p.len() < base.len() {\n            break;\n        }\n    }\n\n    None\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Vec<u8>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: String = String::with_capacity(128);\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => {}\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_SINGLE => {\n            f1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f32)) };\n            d1 = f1 as f64;\n            type_ = BINN_SINGLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_DOUBLE => {\n            d1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f64)) };\n            type_ = BINN_DOUBLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        BINN_DECIMAL | BINN_CURRENCYSTR => {\n            return true;\n        }\n        BINN_DATE | BINN_DATETIME | BINN_TIME => {\n            return true;\n        }\n        BINN_BOOL => {\n            let bool_value = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const bool)) };\n            if bool_value {\n                type_ = BINN_TRUE;\n            } else {\n                type_ = BINN_FALSE;\n            }\n            *ptype = type_;\n        }\n        _ => {}\n    }\n\n    true\n}\n\n\npub fn binn_object_set(obj: &mut Binn, key: &str, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n    if !GetWriteConvertedData(&mut type_, &mut pvalue, &mut size) {\n        return false;\n    }\n    binn_object_set_raw(obj, key, type_, pvalue, size)\n}\n\n\npub fn binn_object_set_raw(item: &mut Binn, key: &str, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    if item.type_ != BINN_OBJECT || !item.writable {\n        return false;\n    }\n    if key.is_empty() {\n        return false;\n    }\n    let key_len = key.len();\n    if key_len > 255 {\n        return false;\n    }\n    if SearchForKey(&mut item.pbuf, MAX_BINN_HEADER, item.used_size, item.count, key).is_some() {\n        return false;\n    }\n    if !CheckAllocation(item, 1 + key_len as i32) {\n        return false;\n    }\n    let mut p = item.pbuf.len();\n    item.pbuf.resize(p + 1 + key_len, 0);\n    item.pbuf[p] = key_len as u8;\n    p += 1;\n    item.pbuf[p..p + key_len].copy_from_slice(key.as_bytes());\n    item.used_size += 1 + key_len as i32;\n    if !AddValue(item, type_, pvalue, size) {\n        item.used_size -= 1 + key_len as i32;\n        return false;\n    }\n    item.count += 1;\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut storage_type = 0;\n    let mut extra_type = 0;\n    if !binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type)) {\n        return false;\n    }\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => {}\n            BINN_STORAGE_STRING => {\n                if size == 0 {}\n            }\n            _ => return false,\n        }\n    }\n    let mut pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        pvalue = Some(compress_int(&mut storage_type, &mut type_, pvalue.unwrap()));\n    }\n    let mut ArgSize = match storage_type {\n        BINN_STORAGE_NOBYTES => 0,\n        BINN_STORAGE_WORD => 2,\n        BINN_STORAGE_DWORD => 4,\n        BINN_STORAGE_QWORD => 8,\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let size = if size == 0 {\n                strlen2(pvalue.as_ref().map(|v| String::from_utf8_lossy(v).to_string())) as i32\n            } else {\n                size\n            };\n            size + 5\n        }\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            size\n        }\n        _ => return false,\n    };\n    ArgSize += 2;\n    if !CheckAllocation(item, ArgSize) {\n        return false;\n    }\n    let mut p = item.pbuf.len();\n    item.pbuf.resize(p + ArgSize as usize, 0);\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            let mut type16_bytes = [0u8; 2];\n            type16_bytes.copy_from_slice(&type16.to_be_bytes());\n            item.pbuf[p..p + 2].copy_from_slice(&type16_bytes);\n            p += 2;\n            item.used_size += 2;\n        } else {\n            item.pbuf[p] = type_ as u8;\n            p += 1;\n            item.used_size += 1;\n        }\n    }\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_WORD => {\n            let value = u16::from_ne_bytes(pvalue.unwrap()[..2].try_into().unwrap());\n            item.pbuf[p..p + 2].copy_from_slice(&value.to_be_bytes());\n            item.used_size += 2;\n        }\n        BINN_STORAGE_DWORD => {\n            let value = u32::from_ne_bytes(pvalue.unwrap()[..4].try_into().unwrap());\n            item.pbuf[p..p + 4].copy_from_slice(&value.to_be_bytes());\n            item.used_size += 4;\n        }\n        BINN_STORAGE_QWORD => {\n            let value = u64::from_ne_bytes(pvalue.unwrap()[..8].try_into().unwrap());\n            item.pbuf[p..p + 8].copy_from_slice(&value.to_be_bytes());\n            item.used_size += 8;\n        }\n        BINN_STORAGE_STRING => {\n            if size > 127 {\n                let int32 = size | 0x80000000;\n                item.pbuf[p..p + 4].copy_from_slice(&int32.to_be_bytes());\n                p += 4;\n                item.used_size += 4;\n            } else {\n                item.pbuf[p] = size as u8;\n                p += 1;\n                item.used_size += 1;\n            }\n            item.pbuf[p..p + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.pbuf[p + size as usize] = 0;\n            item.used_size += size + 1;\n        }\n        BINN_STORAGE_CONTAINER => {\n            item.pbuf[p..p + size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        }\n    }\n    item.dirty = true;\n    true\n}\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: Vec<u8>) -> Vec<u8> {\n    let storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n    let type_ = *ptype;\n    let mut type2 = 0;\n    let mut pvalue = psource;\n    match type_ {\n        BINN_INT64 => {\n            let vint = i64::from_ne_bytes(pvalue[..8].try_into().unwrap());\n            if vint >= 0 {\n                let vuint = vint as u64;\n                if vuint <= u8::MAX as u64 {\n                    type2 = BINN_UINT8;\n                } else if vuint <= u16::MAX as u64 {\n                    type2 = BINN_UINT16;\n                } else if vuint <= u32::MAX as u64 {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= i8::MIN as i64 {\n                    type2 = BINN_INT8;\n                } else if vint >= i16::MIN as i64 {\n                    type2 = BINN_INT16;\n                } else if vint >= i32::MIN as i64 {\n                    type2 = BINN_INT32;\n                }\n            }\n        }\n        BINN_INT32 => {\n            let vint = i32::from_ne_bytes(pvalue[..4].try_into().unwrap());\n            if vint >= 0 {\n                let vuint = vint as u32;\n                if vuint <= u8::MAX as u32 {\n                    type2 = BINN_UINT8;\n                } else if vuint <= u16::MAX as u32 {\n                    type2 = BINN_UINT16;\n                } else if vuint <= u32::MAX as u32 {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= i8::MIN as i32 {\n                    type2 = BINN_INT8;\n                } else if vint >= i16::MIN as i32 {\n                    type2 = BINN_INT16;\n                } else if vint >= i32::MIN as i32 {\n                    type2 = BINN_INT32;\n                }\n            }\n        }\n        BINN_INT16 => {\n            let vint = i16::from_ne_bytes(pvalue[..2].try_into().unwrap());\n            if vint >= 0 {\n                let vuint = vint as u16;\n                if vuint <= u8::MAX as u16 {\n                    type2 = BINN_UINT8;\n                } else if vuint <= u16::MAX as u16 {\n                    type2 = BINN_UINT16;\n                } else if vuint <= u32::MAX as u16 {\n                    type2 = BINN_UINT32;\n                }\n            } else {\n                if vint >= i8::MIN as i16 {\n                    type2 = BINN_INT8;\n                } else if vint >= i16::MIN as i16 {\n                    type2 = BINN_INT16;\n                } else if vint >= i32::MIN as i16 {\n                    type2 = BINN_INT32;\n                }\n            }\n        }\n        BINN_UINT64 => {\n            let vuint = u64::from_ne_bytes(pvalue[..8].try_into().unwrap());\n            if vuint <= u8::MAX as u64 {\n                type2 = BINN_UINT8;\n            } else if vuint <= u16::MAX as u64 {\n                type2 = BINN_UINT16;\n            } else if vuint <= u32::MAX as u64 {\n                type2 = BINN_UINT32;\n            }\n        }\n        BINN_UINT32 => {\n            let vuint = u32::from_ne_bytes(pvalue[..4].try_into().unwrap());\n            if vuint <= u8::MAX as u32 {\n                type2 = BINN_UINT8;\n            } else if vuint <= u16::MAX as u32 {\n                type2 = BINN_UINT16;\n            } else if vuint <= u32::MAX as u32 {\n                type2 = BINN_UINT32;\n            }\n        }\n        BINN_UINT16 => {\n            let vuint = u16::from_ne_bytes(pvalue[..2].try_into().unwrap());\n            if vuint <= u8::MAX as u16 {\n                type2 = BINN_UINT8;\n            } else if vuint <= u16::MAX as u16 {\n                type2 = BINN_UINT16;\n            } else if vuint <= u32::MAX as u16 {\n                type2 = BINN_UINT32;\n            }\n        }\n        _ => {}\n    }\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n        pvalue = pvalue[pvalue.len() - get_storage_size(storage_type2) as usize..].to_vec();\n    }\n    pvalue\n}\n\n\nfn main(){}\n\n\n //编译报错信息：error[E0425]: cannot find value `BINN_STORAGE_BYTE` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_binn_object_set/temp.rs:582:24\n    |\n7   | const BINN_STORAGE_NOBYTES: i32 = 0x00;\n    | --------------------------------------- similarly named constant `BINN_STORAGE_NOBYTES` defined here\n...\n582 |     if storage_type == BINN_STORAGE_BYTE {\n    |                        ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_NOBYTES`\n\nerror[E0599]: no method named `try_into` found for slice `[u8]` in the current scope\n   --> ../../exp/binn/Output/tmp/test-binn_binn_object_set/temp.rs:542:65\n    |\n542 |             let value = u16::from_ne_bytes(pvalue.unwrap()[..2].try_into().unwrap());\n    |                                                                 ^^^^^^^^\n    |\n",
        "binn_list_add": "const BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    let source = psource.to_be_bytes();\n    let dest = &mut pdest.to_be_bytes();\n    for i in 0..8 {\n        dest[i] = source[7 - i];\n    }\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    if cfg!(target_endian = \"little\") {\n        let source = psource.to_be_bytes();\n        *pdest = u16::from_be_bytes([source[1], source[0]]);\n    } else {\n        *pdest = *psource;\n    }\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &i32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Vec<u8>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: String = String::with_capacity(128);\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => {}\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_SINGLE => {\n            f1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f32)) };\n            d1 = f1 as f64;\n            type_ = BINN_SINGLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_DOUBLE => {\n            d1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f64)) };\n            type_ = BINN_DOUBLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        BINN_DECIMAL | BINN_CURRENCYSTR => {\n            return true;\n        }\n        BINN_DATE | BINN_DATETIME | BINN_TIME => {\n            return true;\n        }\n        BINN_BOOL => {\n            let bool_value = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const bool)) };\n            if bool_value {\n                type_ = BINN_TRUE;\n            } else {\n                type_ = BINN_FALSE;\n            }\n            *ptype = type_;\n        }\n        _ => {}\n    }\n\n    true\n}\n\n\npub fn binn_list_add(mut list: Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = pvalue;\n    let mut size = size;\n    if !GetWriteConvertedData(&mut type_, &mut pvalue, &mut size) {\n        return false;\n    }\n    binn_list_add_raw(list, type_, pvalue, size)\n}\n\n\npub fn binn_list_add_raw(mut item: Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    if item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n    if !AddValue(&mut item, type_, pvalue, size) {\n        return false;\n    }\n    item.count += 1;\n    true\n}\n\n\npub fn AddValue(mut item: Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut int32: i32 = 0;\n    let mut ArgSize: i32 = 0;\n    let mut storage_type: i32 = 0;\n    let mut extra_type: i32 = 0;\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => {}\n            BINN_STORAGE_STRING => {\n                if size == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        let compressed_value = compress_int(&mut storage_type, &mut type_, pvalue.as_ref().unwrap());\n        pvalue = Some(compressed_value.to_vec());\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {\n            size = 0;\n            ArgSize = size;\n        }\n        BINN_STORAGE_BYTE => {\n            size = 1;\n            ArgSize = size;\n        }\n        BINN_STORAGE_WORD => {\n            size = 2;\n            ArgSize = size;\n        }\n        BINN_STORAGE_DWORD => {\n            size = 4;\n            ArgSize = size;\n        }\n        BINN_STORAGE_QWORD => {\n            size = 8;\n            ArgSize = size;\n        }\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            if size == 0 {\n                size = strlen2(pvalue.as_ref().map(|v| String::from_utf8(v.clone()).unwrap())) as i32;\n            }\n            ArgSize = size + 5;\n        }\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            ArgSize = size;\n        }\n        _ => return false,\n    }\n\n    ArgSize += 2;\n    if !CheckAllocation(&mut item, ArgSize) {\n        return false;\n    }\n\n    let mut p: Vec<u8> = item.pbuf.clone();\n    let mut p_slice = &mut p[item.used_size as usize..];\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16: u16 = type_ as u16;\n            copy_be16(&mut p_slice[0..2], &type16);\n            p_slice = &mut p_slice[2..];\n            item.used_size += 2;\n        } else {\n            p_slice[0] = type_ as u8;\n            p_slice = &mut p_slice[1..];\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_BYTE => {\n            p_slice[0] = pvalue.as_ref().unwrap()[0];\n            item.used_size += 1;\n        }\n        BINN_STORAGE_WORD => {\n            let value: u16 = u16::from_ne_bytes(pvalue.as_ref().unwrap()[0..2].try_into().unwrap());\n            copy_be16(&mut p_slice[0..2], &value);\n            item.used_size += 2;\n        }\n        BINN_STORAGE_DWORD => {\n            let value: u32 = u32::from_ne_bytes(pvalue.as_ref().unwrap()[0..4].try_into().unwrap());\n            copy_be32(&mut p_slice[0..4], &value);\n            item.used_size += 4;\n        }\n        BINN_STORAGE_QWORD => {\n            let value: u64 = u64::from_ne_bytes(pvalue.as_ref().unwrap()[0..8].try_into().unwrap());\n            copy_be64(&mut p_slice[0..8], &value);\n            item.used_size += 8;\n        }\n        BINN_STORAGE_STRING => {\n            if size > 127 {\n                int32 = size | 0x80000000;\n                copy_be32(&mut p_slice[0..4], &int32);\n                p_slice = &mut p_slice[4..];\n                item.used_size += 4;\n            } else {\n                p_slice[0] = size as u8;\n                p_slice = &mut p_slice[1..];\n                item.used_size += 1;\n            }\n            p_slice[..size as usize].copy_from_slice(&pvalue.as_ref().unwrap()[..size as usize]);\n            p_slice[size as usize] = 0;\n            size += 1;\n            item.used_size += size;\n        }\n        BINN_STORAGE_CONTAINER => {\n            p_slice[..size as usize].copy_from_slice(&pvalue.as_ref().unwrap()[..size as usize]);\n            item.used_size += size;\n        }\n    }\n\n    item.dirty = true;\n    true\n}\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: &Vec<u8>) -> Vec<u8> {\n    let storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource.clone();\n    }\n\n    let type_ = *ptype;\n    let mut type2: i32 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n    let mut pvalue: Vec<u8> = psource.clone();\n\n    match type_ {\n        BINN_INT64 => {\n            vint = i64::from_ne_bytes(psource[0..8].try_into().unwrap());\n        }\n        BINN_INT32 => {\n            vint = i32::from_ne_bytes(psource[0..4].try_into().unwrap()) as i64;\n        }\n        BINN_INT16 => {\n            vint = i16::from_ne_bytes(psource[0..2].try_into().unwrap()) as i64;\n        }\n        BINN_UINT64 => {\n            vuint = u64::from_ne_bytes(psource[0..8].try_into().unwrap());\n        }\n        BINN_UINT32 => {\n            vuint = u32::from_ne_bytes(psource[0..4].try_into().unwrap()) as u64;\n        }\n        BINN_UINT16 => {\n            vuint = u16::from_ne_bytes(psource[0..2].try_into().unwrap()) as u64;\n        }\n        _ => return pvalue,\n    }\n\n    if vint >= 0 {\n        vuint = vint as u64;\n        if vuint <= u8::MAX as u64 {\n            type2 = BINN_UINT8;\n        } else if vuint <= u16::MAX as u64 {\n            type2 = BINN_UINT16;\n        } else if vuint <= u32::MAX as u64 {\n            type2 = BINN_UINT32;\n        }\n    } else {\n        if vint >= i8::MIN as i64 {\n            type2 = BINN_INT8;\n        } else if vint >= i16::MIN as i64 {\n            type2 = BINN_INT16;\n        } else if vint >= i32::MIN as i64 {\n            type2 = BINN_INT32;\n        }\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n        let size1 = get_storage_size(storage_type);\n        let size2 = get_storage_size(storage_type2);\n        pvalue = pvalue[(size1 - size2)..].to_vec();\n    }\n\n    pvalue\n}\n\n\nfn main(){}\n\n\n //编译报错信息：error[E0425]: cannot find value `BINN_STORAGE_BYTE` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_binn_list_add/temp.rs:484:24\n    |\n7   | const BINN_STORAGE_NOBYTES: i32 = 0x00;\n    | --------------------------------------- similarly named constant `BINN_STORAGE_NOBYTES` defined here\n...\n484 |     if storage_type == BINN_STORAGE_BYTE {\n    |                        ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_NOBYTES`\n\nerror[E0308]: mismatched types\n   --> ../../exp/binn/Output/tmp/test-binn_binn_list_add/temp.rs:345:18\n    |\n345 |     if !AddValue(&mut item, type_, pvalue, size) {\n    |         -------- ^^^^^^^^^ expected `Binn`, found `&mut Binn`\n    |         |\n    |         arguments to this function are incorrect\n    |\nnote: function defined here\n   --> ../../exp/binn/Output/tmp/test-binn_binn_list_add/temp.rs:353:8\n    |\n353 | pub fn AddValue(mut item: Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    |        ^^^^^^^^ --------------\n"
    },
    "test-binn": {
        "test_add_and_read_blob": "\n// 全局变量\npub static BINN_STORAGE_BLOB: u8 = 0x01;\npub static BINN_STORAGE_STRING: u8 = 0x02;\n\n// 结构体\npub struct BinnValue {\n    pub storage_type: u8,\n    pub value: Vec<u8>,\n}\n\n// 枚举定义\npub enum BinnType {\n    Blob,\n    String,\n}\n\n// 宏定义\nmacro_rules! binn_storage_type {\n    ($t:expr) => {\n        match $t {\n            BINN_STORAGE_BLOB => BinnType::Blob,\n            BINN_STORAGE_STRING => BinnType::String,\n            _ => panic!(\"Unknown storage type\"),\n        }\n    };\n}\n\n// 模块导入语句\nuse std::vec::Vec;\n\n\n\n //编译报错信息：error: expected one of `!` or `::`, found `<eof>`\n --> ../../exp/binn/Output/tmp/test-binn_test_add_and_read_blob/temp.rs:1:1\n  |\n1 | 上下文长度超过限制\n  | ^^^^^^^^^^^^^^^^^^ expected one of `!` or `::`\n\nerror: aborting due to 1 previous error\n\n",
        "test_binn_blob_operations": "\n// 全局变量\npub static BINN_STORAGE_BLOB: u8 = 0x10;\npub static BINN_STORAGE_STRING: u8 = 0x11;\n\n// 结构体\npub struct BinnValue {\n    pub storage_type: u8,\n    pub value: Vec<u8>,\n}\n\n// 枚举定义\npub enum BinnType {\n    Blob,\n    String,\n}\n\n// 宏定义\nmacro_rules! binn_type {\n    ($t:expr) => {\n        match $t {\n            BINN_STORAGE_BLOB => BinnType::Blob,\n            BINN_STORAGE_STRING => BinnType::String,\n            _ => panic!(\"Unknown type\"),\n        }\n    };\n}\n\n// 模块导入语句\nuse std::vec::Vec;\n\n// 修改后的函数\n\n\npub fn AddValue(value: &BinnValue) {\n    match value.storage_type {\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            let binn_type = binn_type!(value.storage_type);\n            match binn_type {\n                BinnType::Blob => {\n                    // 处理 BINN_STORAGE_BLOB 的逻辑\n                },\n                BinnType::String => {\n                    // 处理 BINN_STORAGE_STRING 的逻辑\n                },\n            }\n        },\n        _ => {\n            // 处理其他类型的逻辑\n        },\n    }\n}\n\n\n //编译报错信息：error: expected one of `!` or `::`, found `<eof>`\n --> ../../exp/binn/Output/tmp/test-binn_test_binn_blob_operations/temp.rs:1:1\n  |\n1 | 上下文长度超过限制\n  | ^^^^^^^^^^^^^^^^^^ expected one of `!` or `::`\n\nerror: aborting due to 1 previous error\n\n",
        "test_add_and_read_integer": "pub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\nconst BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\n\n\n\n\n\npub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    *pdest = psource.to_be();\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Vec<u8>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: String = String::with_capacity(128);\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => {}\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_SINGLE => {\n            f1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f32)) };\n            d1 = f1 as f64;\n            type_ = BINN_SINGLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_DOUBLE => {\n            d1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f64)) };\n            type_ = BINN_DOUBLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        BINN_DECIMAL | BINN_CURRENCYSTR => {\n            return true;\n        }\n        BINN_DATE | BINN_DATETIME | BINN_TIME => {\n            return true;\n        }\n        BINN_BOOL => {\n            let bool_value = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const bool)) };\n            if bool_value {\n                type_ = BINN_TRUE;\n            } else {\n                type_ = BINN_FALSE;\n            }\n            *ptype = type_;\n        }\n        _ => {}\n    }\n\n    true\n}\n\n\npub fn binn_malloc(size: i32) -> Vec<u8> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(malloc_fn_wrap) = &malloc_fn {\n            malloc_fn_wrap(size as usize)\n        } else {\n            vec![]\n        }\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n\n    let mut alloc_size = size;\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            alloc_size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(pointer) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = pointer;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if alloc_size == 0 { CHUNK_SIZE } else { alloc_size };\n        let pointer = binn_malloc(alloc_size);\n        if pointer.is_empty() {\n            return retval;\n        }\n        item.pbuf = pointer;\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER;\n    item.type_ = type_;\n    item.dirty = true;\n\n    retval = true;\n    retval\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    *pdest = psource.to_be();\n}\n\n\npub fn binn_list() -> Option<Binn> {\n    binn_new(BINN_LIST, 0, None)\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Binn> {\n    let mut item = Binn::default();\n\n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn binn_free(item: Option<Binn>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.unwrap();\n    if item.writable && !item.pre_allocated {\n        if let Some(free_fn_wrap) = unsafe { &mut free_fn } {\n            free_fn_wrap(item.pbuf.clone());\n        }\n    }\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr);\n    }\n    if item.allocated {\n        if let Some(free_fn_wrap) = unsafe { &mut free_fn } {\n            free_fn_wrap(item.pbuf);\n        }\n    } else {\n        item = Binn::default();\n        item.header = BINN_MAGIC;\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(Box::new(|size: usize| -> Vec<u8> {\n                vec![0; size]\n            }));\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(Box::new(|mut vec: Vec<u8>, new_size: usize| -> Vec<u8> {\n                vec.resize(new_size, 0);\n                vec\n            }));\n        }\n        if free_fn.is_none() {\n            free_fn = Some(Box::new(|_vec: Vec<u8>| {}));\n        }\n    }\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn test_add_and_read_integer() {\n    let mut list = binn_list().unwrap();\n    let value: i32 = 123;\n\n    assert!(binn_list_add(&mut list, BINN_INT32, &value, 0));\n\n    let mut read_value: i32 = 0;\n    assert!(binn_list_get_int32_wrap(&list, 1, &mut read_value));\n    assert_eq!(read_value, value);\n\n    binn_free(Some(list));\n}\n\n\nfn binn_list_get_int32_wrap(list: &Binn, index: i32, pvalue: &mut i32) -> bool {\n    let mut temp_value: i32 = 0;\n    if binn_list_get_int32(list, index, &mut temp_value) {\n        *pvalue = temp_value;\n        true\n    } else {\n        false\n    }\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: &i32, size: i32) -> bool {\n    let mut type_mut = type_;\n    let mut pvalue_mut = Some(vec![*pvalue as u8]);\n    let mut size_mut = size;\n\n    if !GetWriteConvertedData(&mut type_mut, &mut pvalue_mut, &mut size_mut) {\n        return false;\n    }\n\n    binn_list_add_raw(list, type_mut, pvalue_mut, size_mut)\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    if item.type_ != BINN_LIST || !item.writable {\n        return false;\n    }\n\n    if !AddValue(item, type_, pvalue, size) {\n        return false;\n    }\n\n    item.count += 1;\n    true\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut storage_type: i32 = 0;\n    let mut extra_type: i32 = 0;\n\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => {}\n            BINN_STORAGE_BLOB => {\n                if size == 0 {}\n            }\n            BINN_STORAGE_STRING => {\n                if size == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    let pvalue = if type_family(type_) == BINN_FAMILY_INT && !item.disable_int_compression {\n        compress_int(&mut storage_type, &mut type_, pvalue)\n    } else {\n        pvalue\n    };\n\n    let mut ArgSize = match storage_type {\n        BINN_STORAGE_NOBYTES => 0,\n        BINN_STORAGE_WORD => 2,\n        BINN_STORAGE_DWORD => 4,\n        BINN_STORAGE_QWORD => 8,\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return false;\n            }\n            size + 4\n        }\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return false;\n            }\n            let size = if size == 0 {\n                strlen2(Some(String::from_utf8(pvalue.clone().unwrap()).unwrap()))\n            } else {\n                size as usize\n            };\n            size as i32 + 5\n        }\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return false;\n            }\n            size\n        }\n        _ => return false,\n    };\n\n    ArgSize += 2;\n    if !CheckAllocation(item, ArgSize) {\n        return false;\n    }\n\n    let mut p = item.pbuf[item.used_size as usize..].to_vec();\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            copy_be16(&mut p[0..2].try_into().unwrap(), &type16);\n            item.used_size += 2;\n        } else {\n            p[0] = type_ as u8;\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {}\n        BINN_STORAGE_WORD => {\n            let value = u16::from_ne_bytes(pvalue.unwrap()[0..2].try_into().unwrap());\n            copy_be16(&mut p[0..2].try_into().unwrap(), &value);\n            item.used_size += 2;\n        }\n        BINN_STORAGE_DWORD => {\n            let value = u32::from_ne_bytes(pvalue.unwrap()[0..4].try_into().unwrap());\n            copy_be32(&mut p[0..4].try_into().unwrap(), &value);\n            item.used_size += 4;\n        }\n        BINN_STORAGE_QWORD => {\n            let value = u64::from_ne_bytes(pvalue.unwrap()[0..8].try_into().unwrap());\n            copy_be64(&mut p[0..8].try_into().unwrap(), &value);\n            item.used_size += 8;\n        }\n        BINN_STORAGE_BLOB => {\n            let size = size as usize;\n            if size > 127 {\n                let int32 = size as i32 | 0x80000000;\n                copy_be32(&mut p[0..4].try_into().unwrap(), &(int32 as u32));\n                item.used_size += 4;\n            } else {\n                p[0] = size as u8;\n                item.used_size += 1;\n            }\n            p[0..size].copy_from_slice(&pvalue.unwrap()[0..size]);\n            item.used_size += size as i32;\n        }\n        BINN_STORAGE_STRING => {\n            let size = size as usize;\n            if size > 127 {\n                let int32 = size as i32 | 0x80000000;\n                copy_be32(&mut p[0..4].try_into().unwrap(), &(int32 as u32));\n                item.used_size += 4;\n            } else {\n                p[0] = size as u8;\n                item.used_size += 1;\n            }\n            p[0..size].copy_from_slice(&pvalue.unwrap()[0..size]);\n            p[size] = 0;\n            item.used_size += size as i32 + 1;\n        }\n        BINN_STORAGE_CONTAINER => {\n            p[0..size as usize].copy_from_slice(&pvalue.unwrap()[0..size as usize]);\n            item.used_size += size;\n        }\n    }\n\n    item.dirty = true;\n    true\n}\n\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: Option<Vec<u8>>) -> Option<Vec<u8>> {\n    let storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_NOBYTES {\n        return psource;\n    }\n\n    let type_ = *ptype;\n\n    let mut type2 = 0;\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            vint = i64::from_ne_bytes(psource.clone().unwrap()[0..8].try_into().unwrap());\n        }\n        BINN_INT32 => {\n            vint = i32::from_ne_bytes(psource.clone().unwrap()[0..4].try_into().unwrap()) as i64;\n        }\n        BINN_INT16 => {\n            vint = i16::from_ne_bytes(psource.clone().unwrap()[0..2].try_into().unwrap()) as i64;\n        }\n        BINN_UINT64 => {\n            vuint = u64::from_ne_bytes(psource.clone().unwrap()[0..8].try_into().unwrap());\n        }\n        BINN_UINT32 => {\n            vuint = u32::from_ne_bytes(psource.clone().unwrap()[0..4].try_into().unwrap()) as u64;\n        }\n        BINN_UINT16 => {\n            vuint = u16::from_ne_bytes(psource.clone().unwrap()[0..2].try_into().unwrap()) as u64;\n        }\n        _ => return psource,\n    }\n\n    if vint >= 0 {\n        vuint = vint as u64;\n    } else {\n        if vint >= i8::MIN as i64 {\n            type2 = BINN_INT8;\n        } else if vint >= i16::MIN as i64 {\n            type2 = BINN_INT16;\n        } else if vint >= i32::MIN as i64 {\n            type2 = BINN_INT32;\n        }\n    }\n\n    if vuint <= u8::MAX as u64 {\n        type2 = BINN_UINT8;\n    } else if vuint <= u16::MAX as u64 {\n        type2 = BINN_UINT16;\n    } else if vuint <= u32::MAX as u64 {\n        type2 = BINN_UINT32;\n    }\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n        let size1 = get_storage_size(storage_type);\n        let size2 = get_storage_size(storage_type2);\n        let mut pvalue = psource.unwrap();\n        pvalue.drain(0..(size1 - size2));\n        Some(pvalue)\n    } else {\n        psource\n    }\n}\n\nfn main(){}\n\n\n //编译报错信息：error[E0425]: cannot find function `binn_list_get_int32` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_test_add_and_read_integer/temp.rs:467:8\n    |\n467 |     if binn_list_get_int32(list, index, &mut temp_value) {\n    |        ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `try_into` found for slice `[u8]` in the current scope\n   --> ../../exp/binn/Output/tmp/test-binn_test_add_and_read_integer/temp.rs:569:36\n    |\n569 |             copy_be16(&mut p[0..2].try_into().unwrap(), &type16);\n    |                                    ^^^^^^^^\n    |\n",
        "test_valid_add_operations": "//同时处理的函数过多，无法处理",
        "test_invalid_binn_operations": "//同时处理的函数过多，无法处理",
        "test_read_keys": "\npub struct BinnValue {\n    pub storage_type: u8,\n    pub value: Vec<u8>,\n}\n\npub enum BinnStorageType {\n    Blob = 0,\n    String = 1,\n}\n\npub const BINN_STORAGE_BLOB: u8 = BinnStorageType::Blob as u8;\npub const BINN_STORAGE_STRING: u8 = BinnStorageType::String as u8;\n\n\n\npub fn AddValue<T: AsRef<[u8]>>(value: &mut BinnValue, data: T) {\n    match value.storage_type {\n        BINN_STORAGE_BLOB | BINN_STORAGE_STRING => {\n            value.value.extend_from_slice(data.as_ref());\n        }\n        _ => {}\n    }\n}\n\n\n //编译报错信息：error: expected one of `!` or `::`, found `<eof>`\n --> ../../exp/binn/Output/tmp/test-binn_test_read_keys/temp.rs:1:1\n  |\n1 | 上下文长度超过限制\n  | ^^^^^^^^^^^^^^^^^^ expected one of `!` or `::`\n\nerror: aborting due to 1 previous error\n\n",
        "test_binn_string_operations": "\n// 全局变量\npub const BINN_STORAGE_STRING: u8 = 0;\npub const BINN_STORAGE_BLOB: u8 = 1;\n\n// 结构体\npub struct BinnValue {\n    pub storage_type: u8,\n    pub value: String,\n}\n\n// 枚举定义\npub enum BinnType {\n    String,\n    Blob,\n}\n\n// 宏定义\nmacro_rules! binn_value {\n    ($type:expr, $value:expr) => {\n        BinnValue {\n            storage_type: $type,\n            value: $value.to_string(),\n        }\n    };\n}\n\n// 模块导入语句\nuse std::collections::HashMap;\n\n\n\n //编译报错信息：error: expected one of `!` or `::`, found `<eof>`\n --> ../../exp/binn/Output/tmp/test-binn_test_binn_string_operations/temp.rs:1:1\n  |\n1 | 上下文长度超过限制\n  | ^^^^^^^^^^^^^^^^^^ expected one of `!` or `::`\n\nerror: aborting due to 1 previous error\n\n",
        "test_valid_binn_operations": "//同时处理的函数过多，无法处理",
        "test_add_and_read_string": "\n// 全局变量\npub static GLOBAL_VAR: i32 = 42;\n\n// 结构体\npub struct MyStruct {\n    pub field1: i32,\n    pub field2: String,\n}\n\n// 宏定义\nmacro_rules! my_macro {\n    ($x:expr) => {\n        $x * 2\n    };\n}\n\n// 枚举定义\npub enum MyEnum {\n    Variant1,\n    Variant2(i32),\n    Variant3 { field: String },\n}\n\n// 模块导入语句\nuse std::collections::HashMap;\n\n// 修改后的函数\n\n\n\n\n\n\n\n\n\n\n\npub fn func1<T: Clone>(value: T) -> T {\n    value.clone()\n}\n\n\npub fn func2<T: std::fmt::Debug>(value: T) {\n    println!(\"{:?}\", value);\n}\n\n\npub fn func3() {\n    let mut map = HashMap::new();\n    map.insert(\"key\", \"value\");\n    let value = map.get(\"key\").unwrap();\n    println!(\"{}\", value);\n}\n\n\npub fn func4() {\n    let x = 10;\n    let y = 20;\n    let result = x + y;\n    println!(\"{}\", result);\n}\n\n\npub fn func5() {\n    let x = 10 as u32;\n    let y = 20 as u32;\n    let result = x | y;\n    println!(\"{}\", result);\n}\n\n\npub fn func6() {\n    let x = 10.0;\n    let y = 20.0;\n    let result = x + y;\n    println!(\"{}\", result);\n}\n\n\npub fn func7() {\n    let x = 10;\n    let y = 20;\n    let result = x * y;\n    println!(\"{}\", result);\n}\n\n\npub fn func8() {\n    let x = 10;\n    let y = 20;\n    let result = x - y;\n    println!(\"{}\", result);\n}\n\n\npub fn func9() {\n    let x = 10;\n    let y = 20;\n    let result = x / y;\n    println!(\"{}\", result);\n}\n\n\npub fn func10() {\n    let x = 10;\n    let y = 20;\n    let result = x % y;\n    println!(\"{}\", result);\n}\n\n\n //编译报错信息：error: expected one of `!` or `::`, found `<eof>`\n --> ../../exp/binn/Output/tmp/test-binn_test_add_and_read_string/temp.rs:1:1\n  |\n1 | 上下文长度超过限制\n  | ^^^^^^^^^^^^^^^^^^ expected one of `!` or `::`\n\nerror: aborting due to 1 previous error\n\n",
        "test_binn_integer_operations": "pub const EPSILON: f64 = 1.0E-8;\npub const VERYSMALL: f64 = 1.0E-150;\npub const TRUE: bool = true;\npub const FALSE: bool = false;\nconst BINN_STORAGE_MASK: i32 = 0xE0;\nconst BINN_TYPE_MASK: i32 = 0x0F;\nconst BINN_STORAGE_MASK16: i32 = 0xE000;\nconst BINN_TYPE_MASK16: i32 = 0x0FFF;\nconst BINN_STORAGE_VIRTUAL: i32 = 0x80000;\nconst BINN_STORAGE_STRING: i32 = 0xA0;\nconst BINN_STORAGE_NOBYTES: i32 = 0x00;\nconst BINN_STORAGE_CONTAINER: i32 = 0xE0;\nconst BINN_STORAGE_HAS_MORE: i32 = 0x10;\nconst MIN_BINN_SIZE: i32 = 3;\n\nconst BINN_INT8: i32 = 0x21;\nconst BINN_INT16: i32 = 0x41;\nconst BINN_INT32: i32 = 0x61;\nconst BINN_INT64: i32 = 0x81;\nconst BINN_UINT8: i32 = 0x20;\nconst BINN_UINT16: i32 = 0x40;\nconst BINN_UINT32: i32 = 0x60;\nconst BINN_UINT64: i32 = 0x80;\nconst BINN_SIGNED_INT: i32 = 11;\nconst BINN_UNSIGNED_INT: i32 = 22;\n\nconst BINN_STRUCT: i32 = 1;\nconst BINN_BUFFER: i32 = 2;\nconst BINN_LIST: i32 = 0xE0;\nconst BINN_MAP: i32 = 0xE1;\nconst BINN_OBJECT: i32 = 0xE2;\n\nconst MAX_BINN_HEADER: i32 = 9;\n\nconst BINN_FLOAT32: i32 = 0x62;\nconst BINN_FLOAT64: i32 = 0x82;\nconst BINN_SINGLE_STR: i32 = 0xA6;\nconst BINN_DOUBLE_STR: i32 = 0xA7;\n\nconst BINN_STRING: i32 = 0xA0;\nconst BINN_HTML: i32 = 0xB001;\nconst BINN_CSS: i32 = 0xB005;\nconst BINN_XML: i32 = 0xB002;\nconst BINN_JSON: i32 = 0xB003;\nconst BINN_JAVASCRIPT: i32 = 0xB004;\n\nconst BINN_BLOB: i32 = 0xC0;\nconst BINN_JPEG: i32 = 0xD001;\nconst BINN_GIF: i32 = 0xD002;\nconst BINN_PNG: i32 = 0xD003;\nconst BINN_BMP: i32 = 0xD004;\n\nconst BINN_DECIMAL: i32 = 0xA4;\nconst BINN_CURRENCYSTR: i32 = 0xA5;\nconst BINN_CURRENCY: i32 = 0x83;\nconst BINN_DATE: i32 = 0xA2;\nconst BINN_TIME: i32 = 0xA3;\nconst BINN_DATETIME: i32 = 0xA1;\n\nconst BINN_BOOL: i32 = 0x80061;\nconst BINN_NULL: i32 = 0x00;\n\nconst BINN_FAMILY_BINN: i32 = 0xf7;\nconst BINN_FAMILY_INT: i32 = 0xf2;\nconst BINN_FAMILY_FLOAT: i32 = 0xf3;\nconst BINN_FAMILY_STRING: i32 = 0xf4;\nconst BINN_FAMILY_BLOB: i32 = 0xf5;\nconst BINN_FAMILY_BOOL: i32 = 0xf6;\nconst BINN_FAMILY_NULL: i32 = 0xf1;\nconst BINN_FAMILY_NONE: i32 = 0x00;\n\nconst BINN_MAGIC: i32 = 0x1F22B11F;\n\nconst BINN_STORAGE_DWORD: i32 = 0x60;\nconst BINN_STORAGE_WORD: i32 = 0x40;\nconst BINN_STORAGE_QWORD: i32 = 0x80;\nconst BINN_TRUE: i32 = 0x01;\nconst BINN_FALSE: i32 = 0x02;\n\nconst CHUNK_SIZE: i32 = 256;\n\ntype binn_mem_free = fn(Vec<u8>);\n\nstatic mut malloc_fn: Option<Box<dyn Fn(usize) -> Vec<u8>>> = None;\nstatic mut realloc_fn: Option<Box<dyn Fn(Vec<u8>, usize) -> Vec<u8>>> = None;\nstatic mut free_fn: Option<Box<dyn Fn(Vec<u8>)>> = None;\n\n#[derive(Clone)]\npub struct Binn {\n    pub header: i32,\n    pub allocated: bool,\n    pub writable: bool,\n    pub dirty: bool,\n    pub pbuf: Vec<u8>,\n    pub pre_allocated: bool,\n    pub alloc_size: i32,\n    pub used_size: i32,\n    pub type_: i32,\n    pub ptr: Vec<u8>,\n    pub size: i32,\n    pub count: i32,\n    pub freefn: Option<binn_mem_free>,\n    pub disable_int_compression: bool,\n    pub vuint8: u8,\n    pub vint16: i16,\n    pub vint32: i32,\n    pub vint64: i64,\n    pub vbool: bool,\n}\n\nimpl Default for Binn {\n    fn default() -> Self {\n        Binn {\n            header: 0,\n            allocated: false,\n            writable: false,\n            dirty: false,\n            pbuf: Vec::new(),\n            pre_allocated: false,\n            alloc_size: 0,\n            used_size: 0,\n            type_: 0,\n            ptr: Vec::new(),\n            size: 0,\n            count: 0,\n            freefn: None,\n            disable_int_compression: false,\n            vuint8: 0,\n            vint16: 0,\n            vint32: 0,\n            vint64: 0,\n            vbool: false,\n        }\n    }\n}\n\nimpl Binn {\n    pub fn is_null(&self) -> bool {\n        self.type_ == BINN_NULL\n    }\n}\n\n\n\n\n\n\n\n\npub fn copy_be64(pdest: &mut u64, psource: &u64) {\n    *pdest = psource.to_be();\n}\n\n\npub fn binn_get_write_storage(type_: i32) -> i32 {\n    let mut storage_type: i32 = 0;\n\n    match type_ {\n        BINN_SINGLE_STR => BINN_STORAGE_STRING,\n        BINN_DOUBLE_STR => BINN_STORAGE_STRING,\n        BINN_BOOL => BINN_STORAGE_NOBYTES,\n        _ => {\n            binn_get_type_info(type_, Some(&mut storage_type), None);\n            storage_type\n        }\n    }\n}\n\n\npub fn GetWriteConvertedData(ptype: &mut i32, ppvalue: &mut Option<Vec<u8>>, psize: &mut i32) -> bool {\n    let mut type_ = *ptype;\n    let mut f1: f32 = 0.0;\n    let mut d1: f64 = 0.0;\n    let mut pstr: String = String::with_capacity(128);\n\n    if ppvalue.is_none() {\n        match type_ {\n            BINN_NULL | BINN_TRUE | BINN_FALSE => {}\n            BINN_STRING | BINN_BLOB => {\n                if *psize == 0 {}\n            }\n            _ => return false,\n        }\n    }\n\n    match type_ {\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_SINGLE => {\n            f1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f32)) };\n            d1 = f1 as f64;\n            type_ = BINN_SINGLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        #[cfg(feature = \"BINN_EXTENDED\")]\n        BINN_DOUBLE => {\n            d1 = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const f64)) };\n            type_ = BINN_DOUBLE_STR;\n            pstr = format!(\"{:.17e}\", d1);\n            *ppvalue = Some(pstr.into_bytes());\n            *ptype = type_;\n        }\n        BINN_DECIMAL | BINN_CURRENCYSTR => {\n            return true;\n        }\n        BINN_DATE | BINN_DATETIME | BINN_TIME => {\n            return true;\n        }\n        BINN_BOOL => {\n            let bool_value = unsafe { *(*(ppvalue.as_ref().unwrap().as_ptr() as *const *const bool)) };\n            if bool_value {\n                type_ = BINN_TRUE;\n            } else {\n                type_ = BINN_FALSE;\n            }\n            *ptype = type_;\n        }\n        _ => {}\n    }\n\n    true\n}\n\n\npub fn binn_malloc(size: i32) -> Vec<u8> {\n    check_alloc_functions();\n    unsafe {\n        if let Some(malloc_fn_wrap) = &malloc_fn {\n            malloc_fn_wrap(size as usize)\n        } else {\n            vec![]\n        }\n    }\n}\n\n\npub fn CalcAllocation(needed_size: i32, alloc_size: i32) -> i32 {\n    let mut calc_size = alloc_size;\n    while calc_size < needed_size {\n        calc_size <<= 1;  // same as *= 2\n        //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n    }\n    calc_size\n}\n\n\npub fn binn_create(item: &mut Binn, type_: i32, size: i32, pointer: Option<Vec<u8>>) -> bool {\n    let mut retval = false;\n\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => (),\n        _ => return retval,\n    }\n\n    if size < 0 {\n        return retval;\n    }\n\n    let mut alloc_size = size;\n    if size < MIN_BINN_SIZE {\n        if pointer.is_some() {\n            return retval;\n        } else {\n            alloc_size = 0;\n        }\n    }\n\n    *item = Binn::default();\n\n    if let Some(pointer) = pointer {\n        item.pre_allocated = true;\n        item.pbuf = pointer;\n    } else {\n        item.pre_allocated = false;\n        let alloc_size = if alloc_size == 0 { CHUNK_SIZE } else { alloc_size };\n        let pointer = binn_malloc(alloc_size);\n        if pointer.is_empty() {\n            return retval;\n        }\n        item.pbuf = pointer;\n    }\n\n    item.alloc_size = size;\n    item.header = BINN_MAGIC;\n    item.writable = true;\n    item.used_size = MAX_BINN_HEADER;\n    item.type_ = type_;\n    item.dirty = true;\n\n    retval = true;\n    retval\n}\n\n\npub fn copy_be16(pdest: &mut u16, psource: &u16) {\n    *pdest = psource.to_be();\n}\n\n\npub fn binn_get_type_info(long_type: i32, pstorage_type: Option<&mut i32>, pextra_type: Option<&mut i32>) -> bool {\n    let mut storage_type: i32;\n    let mut extra_type: i32;\n    let mut retval: bool = true;\n\n    let mut long_type = long_type;\n\n    loop {\n        if long_type < 0 {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        } else if long_type <= 0xff {\n            storage_type = long_type & BINN_STORAGE_MASK;\n            extra_type = long_type & BINN_TYPE_MASK;\n            break;\n        } else if long_type <= 0xffff {\n            storage_type = long_type & BINN_STORAGE_MASK16;\n            storage_type >>= 8;\n            extra_type = long_type & BINN_TYPE_MASK16;\n            extra_type >>= 4;\n            break;\n        } else if long_type & BINN_STORAGE_VIRTUAL != 0 {\n            long_type &= 0xffff;\n            continue;\n        } else {\n            storage_type = -1;\n            extra_type = -1;\n            retval = false;\n            break;\n        }\n    }\n\n    if let Some(pstorage_type) = pstorage_type {\n        *pstorage_type = storage_type;\n    }\n    if let Some(pextra_type) = pextra_type {\n        *pextra_type = extra_type;\n    }\n\n    retval\n}\n\n\npub fn binn_new(type_: i32, size: i32, pointer: Option<Vec<u8>>) -> Option<Binn> {\n    let mut item = Binn::default();\n\n    if !binn_create(&mut item, type_, size, pointer) {\n        return None;\n    }\n\n    item.allocated = true;\n    Some(item)\n}\n\n\npub fn strlen2(str: Option<String>) -> usize {\n    match str {\n        Some(s) => s.len(),\n        None => 0,\n    }\n}\n\n\npub fn binn_free(item: Option<Binn>) {\n    if item.is_none() {\n        return;\n    }\n    let mut item = item.unwrap();\n    if item.writable && !item.pre_allocated {\n        if let Some(free_fn_wrap) = unsafe { &mut free_fn } {\n            free_fn_wrap(item.pbuf.clone());\n        }\n    }\n    if let Some(freefn) = item.freefn {\n        freefn(item.ptr);\n    }\n    if item.allocated {\n        if let Some(free_fn_wrap) = unsafe { &mut free_fn } {\n            free_fn_wrap(item.pbuf);\n        }\n    } else {\n        item = Binn::default();\n        item.header = BINN_MAGIC;\n    }\n}\n\n\npub fn check_alloc_functions() {\n    unsafe {\n        if malloc_fn.is_none() {\n            malloc_fn = Some(Box::new(|size: usize| -> Vec<u8> {\n                vec![0; size]\n            }));\n        }\n        if realloc_fn.is_none() {\n            realloc_fn = Some(Box::new(|mut vec: Vec<u8>, new_size: usize| -> Vec<u8> {\n                vec.resize(new_size, 0);\n                vec\n            }));\n        }\n        if free_fn.is_none() {\n            free_fn = Some(Box::new(|_vec: Vec<u8>| {}));\n        }\n    }\n}\n\n\npub fn type_family(type_: i32) -> i32 {\n    match type_ {\n        BINN_LIST | BINN_MAP | BINN_OBJECT => BINN_FAMILY_BINN,\n        BINN_INT8 | BINN_INT16 | BINN_INT32 | BINN_INT64 | BINN_UINT8 | BINN_UINT16 | BINN_UINT32 | BINN_UINT64 => BINN_FAMILY_INT,\n        BINN_FLOAT32 | BINN_FLOAT64 | BINN_SINGLE_STR | BINN_DOUBLE_STR => BINN_FAMILY_FLOAT,\n        BINN_STRING | BINN_HTML | BINN_CSS | BINN_XML | BINN_JSON | BINN_JAVASCRIPT => BINN_FAMILY_STRING,\n        BINN_BLOB | BINN_JPEG | BINN_GIF | BINN_PNG | BINN_BMP => BINN_FAMILY_BLOB,\n        BINN_DECIMAL | BINN_CURRENCY | BINN_DATE | BINN_TIME | BINN_DATETIME => BINN_FAMILY_STRING,\n        BINN_BOOL => BINN_FAMILY_BOOL,\n        BINN_NULL => BINN_FAMILY_NULL,\n        _ => BINN_FAMILY_NONE,\n    }\n}\n\n\npub fn CheckAllocation(item: &mut Binn, add_size: i32) -> bool {\n    if item.used_size + add_size > item.alloc_size {\n        if item.pre_allocated {\n            return false;\n        }\n        let alloc_size = CalcAllocation(item.used_size + add_size, item.alloc_size);\n        let mut new_buf = Vec::with_capacity(alloc_size as usize);\n        new_buf.extend_from_slice(&item.pbuf);\n        item.pbuf = new_buf;\n        item.alloc_size = alloc_size;\n    }\n    true\n}\n\n\npub fn copy_be32(pdest: &mut [u8; 4], psource: &u32) {\n    let source_bytes = psource.to_be_bytes();\n    pdest.copy_from_slice(&source_bytes);\n}\n\n\npub fn test_binn_integer_operations() {\n    let mut list = binn_new(BINN_LIST, 0, None).unwrap();\n    let value: i32 = 123;\n\n    assert!(binn_list_add(&mut list, BINN_INT32, &value, 0) == TRUE);\n\n    let mut read_value: i32 = 0;\n    assert!(binn_list_get_int32(&list, 1, &mut read_value) == TRUE);\n    assert!(read_value == value);\n\n    binn_free(Some(list));\n}\n\n\npub fn binn_list_add(list: &mut Binn, type_: i32, pvalue: &i32, size: i32) -> bool {\n    let mut type_ = type_;\n    let mut pvalue = Some(vec![*pvalue as u8]);\n    let mut size = size;\n\n    if GetWriteConvertedData(&mut type_, &mut pvalue, &mut size) == FALSE {\n        return FALSE;\n    }\n\n    binn_list_add_raw(list, type_, pvalue, size)\n}\n\n\npub fn binn_list_add_raw(item: &mut Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    if item.type_ != BINN_LIST || item.writable == FALSE {\n        return FALSE;\n    }\n\n    if AddValue(item, type_, pvalue, size) == FALSE {\n        return FALSE;\n    }\n\n    item.count += 1;\n\n    TRUE\n}\n\n\npub fn AddValue(item: &mut Binn, type_: i32, pvalue: Option<Vec<u8>>, size: i32) -> bool {\n    let mut int32: i32 = 0;\n    let mut ArgSize: i32 = 0;\n    let mut storage_type: i32 = 0;\n    let mut extra_type: i32 = 0;\n\n    binn_get_type_info(type_, Some(&mut storage_type), Some(&mut extra_type));\n\n    if pvalue.is_none() {\n        match storage_type {\n            BINN_STORAGE_NOBYTES => (),\n            BINN_STORAGE_BLOB => {\n                if size == 0 {\n                    ()\n                } else {\n                    return FALSE;\n                }\n            }\n            BINN_STORAGE_STRING => {\n                if size == 0 {\n                    ()\n                } else {\n                    return FALSE;\n                }\n            }\n            _ => return FALSE,\n        }\n    }\n\n    let mut pvalue = pvalue;\n    if type_family(type_) == BINN_FAMILY_INT && item.disable_int_compression == FALSE {\n        pvalue = Some(compress_int(&mut storage_type, &mut type_, pvalue.unwrap()));\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => {\n            size = 0;\n            ArgSize = size;\n        }\n        BINN_STORAGE_BYTE => {\n            size = 1;\n            ArgSize = size;\n        }\n        BINN_STORAGE_WORD => {\n            size = 2;\n            ArgSize = size;\n        }\n        BINN_STORAGE_DWORD => {\n            size = 4;\n            ArgSize = size;\n        }\n        BINN_STORAGE_QWORD => {\n            size = 8;\n            ArgSize = size;\n        }\n        BINN_STORAGE_BLOB => {\n            if size < 0 {\n                return FALSE;\n            }\n            ArgSize = size + 4;\n        }\n        BINN_STORAGE_STRING => {\n            if size < 0 {\n                return FALSE;\n            }\n            if size == 0 {\n                size = strlen2(Some(String::from_utf8(pvalue.unwrap()).unwrap())) as i32;\n            }\n            ArgSize = size + 5;\n        }\n        BINN_STORAGE_CONTAINER => {\n            if size <= 0 {\n                return FALSE;\n            }\n            ArgSize = size;\n        }\n        _ => return FALSE,\n    }\n\n    ArgSize += 2;\n    if CheckAllocation(item, ArgSize) == FALSE {\n        return FALSE;\n    }\n\n    let mut p = item.pbuf[item.used_size as usize..].to_vec();\n\n    if storage_type != BINN_STORAGE_CONTAINER {\n        if type_ > 255 {\n            let type16 = type_ as u16;\n            copy_be16(&mut p[0..2].try_into().unwrap(), &type16);\n            p = p[2..].to_vec();\n            item.used_size += 2;\n        } else {\n            p[0] = type_ as u8;\n            p = p[1..].to_vec();\n            item.used_size += 1;\n        }\n    }\n\n    match storage_type {\n        BINN_STORAGE_NOBYTES => (),\n        BINN_STORAGE_BYTE => {\n            p[0] = pvalue.unwrap()[0];\n            item.used_size += 1;\n        }\n        BINN_STORAGE_WORD => {\n            copy_be16(&mut p[0..2].try_into().unwrap(), &pvalue.unwrap()[0..2].try_into().unwrap());\n            item.used_size += 2;\n        }\n        BINN_STORAGE_DWORD => {\n            copy_be32(&mut p[0..4].try_into().unwrap(), &pvalue.unwrap()[0..4].try_into().unwrap());\n            item.used_size += 4;\n        }\n        BINN_STORAGE_QWORD => {\n            copy_be64(&mut p[0..8].try_into().unwrap(), &pvalue.unwrap()[0..8].try_into().unwrap());\n            item.used_size += 8;\n        }\n        BINN_STORAGE_BLOB => {\n            if size > 127 {\n                int32 = size | 0x80000000;\n                copy_be32(&mut p[0..4].try_into().unwrap(), &int32);\n                p = p[4..].to_vec();\n                item.used_size += 4;\n            } else {\n                p[0] = size as u8;\n                p = p[1..].to_vec();\n                item.used_size += 1;\n            }\n            p[..size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        }\n        BINN_STORAGE_STRING => {\n            if size > 127 {\n                int32 = size | 0x80000000;\n                copy_be32(&mut p[0..4].try_into().unwrap(), &int32);\n                p = p[4..].to_vec();\n                item.used_size += 4;\n            } else {\n                p[0] = size as u8;\n                p = p[1..].to_vec();\n                item.used_size += 1;\n            }\n            p[..size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            p[size as usize] = 0;\n            size += 1;\n            item.used_size += size;\n        }\n        BINN_STORAGE_CONTAINER => {\n            p[..size as usize].copy_from_slice(&pvalue.unwrap()[..size as usize]);\n            item.used_size += size;\n        }\n    }\n\n    item.dirty = TRUE;\n\n    TRUE\n}\n\n\npub fn compress_int(pstorage_type: &mut i32, ptype: &mut i32, psource: Vec<u8>) -> Vec<u8> {\n    let mut storage_type = *pstorage_type;\n    if storage_type == BINN_STORAGE_BYTE {\n        return psource;\n    }\n\n    let type_ = *ptype;\n\n    let mut vint: i64 = 0;\n    let mut vuint: u64 = 0;\n    let mut type2: i32 = 0;\n\n    match type_ {\n        BINN_INT64 => {\n            vint = i64::from_be_bytes(psource[..8].try_into().unwrap());\n        }\n        BINN_INT32 => {\n            vint = i32::from_be_bytes(psource[..4].try_into().unwrap()) as i64;\n        }\n        BINN_INT16 => {\n            vint = i16::from_be_bytes(psource[..2].try_into().unwrap()) as i64;\n        }\n        BINN_UINT64 => {\n            vuint = u64::from_be_bytes(psource[..8].try_into().unwrap());\n        }\n        BINN_UINT32 => {\n            vuint = u32::from_be_bytes(psource[..4].try_into().unwrap()) as u64;\n        }\n        BINN_UINT16 => {\n            vuint = u16::from_be_bytes(psource[..2].try_into().unwrap()) as u64;\n        }\n        _ => (),\n    }\n\n    if vint >= 0 {\n        vuint = vint as u64;\n    } else {\n        if vint >= i8::MIN as i64 {\n            type2 = BINN_INT8;\n        } else if vint >= i16::MIN as i64 {\n            type2 = BINN_INT16;\n        } else if vint >= i32::MIN as i64 {\n            type2 = BINN_INT32;\n        }\n    }\n\n    if vuint <= u8::MAX as u64 {\n        type2 = BINN_UINT8;\n    } else if vuint <= u16::MAX as u64 {\n        type2 = BINN_UINT16;\n    } else if vuint <= u32::MAX as u64 {\n        type2 = BINN_UINT32;\n    }\n\n    let mut pvalue = psource;\n\n    if type2 != 0 && type2 != type_ {\n        *ptype = type2;\n        let storage_type2 = binn_get_write_storage(type2);\n        *pstorage_type = storage_type2;\n        pvalue = pvalue[(8 - get_storage_size(storage_type2) as usize)..].to_vec();\n    }\n\n    pvalue\n}\n\nfn main(){}\n\n\n //编译报错信息：error[E0425]: cannot find value `BINN_STORAGE_BYTE` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_test_binn_integer_operations/temp.rs:649:24\n    |\n11  | const BINN_STORAGE_NOBYTES: i32 = 0x00;\n    | --------------------------------------- similarly named constant `BINN_STORAGE_NOBYTES` defined here\n...\n649 |     if storage_type == BINN_STORAGE_BYTE {\n    |                        ^^^^^^^^^^^^^^^^^ help: a constant with a similar name exists: `BINN_STORAGE_NOBYTES`\n\nerror[E0425]: cannot find function `binn_list_get_int32` in this scope\n   --> ../../exp/binn/Output/tmp/test-binn_test_binn_integer_operations/temp.rs:453:13\n    |\n453 |     assert!(binn_list_get_int32(&list, 1, &mut read_value) == TRUE);\n    |             ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `try_into` found for slice `[u8]` in the current scope\n   --> ../../exp/binn/Output/tmp/test-binn_test_binn_integer_operations/temp.rs:577:36\n    |\n577 |             copy_be16(&mut p[0..2].try_into().unwrap(), &type16);\n    |                                    ^^^^^^^^\n    |\n",
        "print_binn": "上下文长度超过限制\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //编译报错信息：error: expected one of `!` or `::`, found `<eof>`\n --> ../../exp/binn/Output/tmp/test-binn_print_binn/temp.rs:1:1\n  |\n1 | 上下文长度超过限制\n  | ^^^^^^^^^^^^^^^^^^ expected one of `!` or `::`\n\nerror: aborting due to 1 previous error\n\n",
        "memdup": "请求出错: Error code: 400 - {'error': {'code': 'Arrearage', 'param': None, 'message': 'Access denied, please make sure your account is in good standing.', 'type': 'Arrearage'}, 'id': 'chatcmpl-76eac84f-dc81-9a51-95be-5180abf2ab58', 'request_id': '76eac84f-dc81-9a51-95be-5180abf2ab58'}\n\n\n //编译报错信息：error: character literal may only contain one codepoint\n --> ../../benchmarks/crown/binn/Output/tmp/test-binn_memdup/temp.rs:8:26\n  |\n8 | 请求出错: Error code: 400 - {'error': {'code': 'Arrearage', 'param': None, 'message': 'Access denied, please make sure your account is in good standing.', 'type': 'Arrearage'}, 'id': 'chatcmpl-3823bbc8-e7c4-92e6-a439- ...\n  |                              ^^^^^^^\n  |\n"
    }
}