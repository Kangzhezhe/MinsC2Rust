{
    "urlparser": {
        "ParseURL": "pub fn ParseURL(URL: String, pURL_Parts: &mut URL_PARTS) -> bool {\n    let mut i: usize;\n    let mut c: u8;\n    let mut b: bool = false;\n\n    // Clear the data\n    *pURL_Parts = URL_PARTS {\n        scheme: String::new(),\n        authority: String::new(),\n        port: String::new(),\n        path: String::new(),\n        query: String::new(),\n        fragment: String::new(),\n    };\n\n    // Setup our parser pointer\n    let mut string = URL.as_bytes();\n\n    // Check for the authority preceding double slash\n    let authority = match str::from_utf8(string).unwrap().find(\"//\") {\n        Some(pos) => {\n            let scheme_end = pos;\n            i = 0;\n            while i < scheme_end {\n                c = string[i];\n                if c == b':' || c == b'/' {\n                    break;\n                }\n                if pURL_Parts.scheme.len() == MAX_URL_SCHEME_LEN - 1 {\n                    return false;\n                }\n                pURL_Parts.scheme.push(c as char);\n                i += 1;\n            }\n            &string[pos + 2..]\n        }\n        None => string,\n    };\n\n    c = authority[0];\n    if c == b'[' {\n        b = true;\n        string = &authority[1..];\n    } else {\n        string = authority;\n    }\n\n    // Parse the authority\n    i = 0;\n    while i < string.len() {\n        c = string[i];\n        if c == b' ' {\n            i += 1;\n            continue;\n        }\n        if c == b'/' || c == b'?' || c == b'#' || (c == b':' && !b) {\n            break;\n        }\n        if b && c == b']' {\n            i += 1;\n            break;\n        }\n        if pURL_Parts.authority.len() == MAX_URL_AUTHORITY_LEN - 1 {\n            return false;\n        }\n        pURL_Parts.authority.push(c as char);\n        i += 1;\n    }\n\n    string = &string[i..];\n\n    // Check for a port number\n    if !string.is_empty() && string[0] == b':' {\n        string = &string[1..];\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'/' || c == b'?' || c == b'#' {\n                break;\n            }\n            if pURL_Parts.port.len() == MAX_URL_PORT_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.port.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a path\n    if !string.is_empty() && string[0] == b'/' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'?' || c == b'#' {\n                break;\n            }\n            if pURL_Parts.path.len() == MAX_URL_PATH_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.path.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a query\n    if !string.is_empty() && string[0] == b'?' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if c == b'#' {\n                break;\n            }\n            if pURL_Parts.query.len() == MAX_URL_QUERY_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.query.push(c as char);\n            i += 1;\n        }\n        string = &string[i..];\n    }\n\n    // Check for a fragment\n    if !string.is_empty() && string[0] == b'#' {\n        i = 0;\n        while i < string.len() {\n            c = string[i];\n            if pURL_Parts.fragment.len() == MAX_URL_FRAGMENT_LEN - 1 {\n                return false;\n            }\n            pURL_Parts.fragment.push(c as char);\n            i += 1;\n        }\n    }\n\n    true\n}\n\n",
        "extra": "use std::str;\n\npub const MAX_URL_FRAGMENT_LEN: usize = 256;\npub const MAX_URL_SCHEME_LEN: usize = 32;\npub const MAX_URL_PATH_LEN: usize = 1024;\npub const MAX_URL_QUERY_LEN: usize = 1024;\npub const MAX_URL_AUTHORITY_LEN: usize = 512;\npub const MAX_URL_PORT_LEN: usize = 64;\n\npub struct URL_PARTS {\n    pub scheme: String,\n    pub authority: String,\n    pub port: String,\n    pub path: String,\n    pub query: String,\n    pub fragment: String,\n}\n"
    },
    "test-urlparser": {
        "main": "fn main(){}\n",
        "test_parse_url": "pub fn test_parse_url() {\n    let mut url_parts = URL_PARTS {\n        scheme: String::new(),\n        authority: String::new(),\n        port: String::new(),\n        path: String::new(),\n        query: String::new(),\n        fragment: String::new(),\n    };\n\n    // Test case 1: Basic HTTP URL\n    assert!(ParseURL(\"http://sullewarehouse.com/login\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"http\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"\"); // No port specified\n    assert_eq!(url_parts.path, \"/login\");\n    assert_eq!(url_parts.query, \"\"); // No query\n    assert_eq!(url_parts.fragment, \"\"); // No fragment\n\n    // Test case 2: HTTPS URL with port\n    assert!(ParseURL(\"https://sullewarehouse.com:1000/login\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"1000\");\n    assert_eq!(url_parts.path, \"/login\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 3: URL with query parameters\n    assert!(ParseURL(\"https://sullewarehouse.com:1000/api/get?username=myuser\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"1000\");\n    assert_eq!(url_parts.path, \"/api/get\");\n    assert_eq!(url_parts.query, \"?username=myuser\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 4: URL without scheme\n    assert!(ParseURL(\"sullewarehouse.com/register\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"\"); // No scheme\n    assert_eq!(url_parts.authority, \"sullewarehouse.com\");\n    assert_eq!(url_parts.port, \"\");\n    assert_eq!(url_parts.path, \"/register\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 5: IPv6 URL\n    assert!(ParseURL(\"http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]/newpage\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"http\");\n    assert_eq!(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n    assert_eq!(url_parts.port, \"\");\n    assert_eq!(url_parts.path, \"/newpage\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    // Test case 6: IPv6 URL with port\n    assert!(ParseURL(\"https://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:2678/blog\".to_string(), &mut url_parts));\n    assert_eq!(url_parts.scheme, \"https\");\n    assert_eq!(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\");\n    assert_eq!(url_parts.port, \"2678\");\n    assert_eq!(url_parts.path, \"/blog\");\n    assert_eq!(url_parts.query, \"\");\n    assert_eq!(url_parts.fragment, \"\");\n\n    println!(\"All tests passed!\");\n}\n\n",
        "extra": "\nuse test_project::urlparser::{ParseURL, URL_PARTS, MAX_URL_FRAGMENT_LEN, MAX_URL_SCHEME_LEN, MAX_URL_PATH_LEN, MAX_URL_QUERY_LEN, MAX_URL_AUTHORITY_LEN, MAX_URL_PORT_LEN};\n"
    }
}