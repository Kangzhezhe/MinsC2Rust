{
    "PrintURL": "void PrintURL(struct URL_PARTS* pURL_Parts)\n{\n    // Safety check\n    if (pURL_Parts == NULL) {\n        fprintf(stderr, \"%s\\n\", \"PrintURL Error: Parameter 'pURL_Parts' is NULL\");\n        return;\n    }\n\n    // Print each individually\n    printf(\"Scheme: %s\\nAuthority: %s\\nPort: %s\\nPath: %s\\nQuery: %s\\nFragment: %s\\n\",\n        pURL_Parts->scheme, pURL_Parts->authority, pURL_Parts->port,\n        pURL_Parts->path, pURL_Parts->query, pURL_Parts->fragment);\n\n    // Print as a single URL\n    if (strlen(pURL_Parts->scheme) != 0) {\n        printf(\"%s://%s\", pURL_Parts->scheme, pURL_Parts->authority);\n    } else if (strlen(pURL_Parts->authority) != 0) {\n        printf(\"%s\", pURL_Parts->authority);\n    }\n    if (strlen(pURL_Parts->port) != 0) {\n        printf(\":%s\", pURL_Parts->port);\n    }\n    if (strlen(pURL_Parts->path) != 0) {\n        printf(\"%s\", pURL_Parts->path);\n    }\n    if (strlen(pURL_Parts->query) != 0) {\n        printf(\"%s\", pURL_Parts->query);\n    }\n    if (strlen(pURL_Parts->fragment) != 0) {\n        printf(\"%s\", pURL_Parts->fragment);\n    }\n\n    printf(\"%s\", \"\\n\");\n}\n",
    "ParseURL": "bool ParseURL(char* URL, URL_PARTS* pURL_Parts)\n{\n    int i;\n    unsigned char c;\n    bool b = false;\n\n    // Clear the data\n    memset(pURL_Parts, 0, sizeof(URL_PARTS));\n\n    // Setup our parser pointer\n    char* string = URL;\n\n    // Check for the authority preceding double slash\n    char* authority = strstr(string, \"//\");\n    if (authority == NULL) {\n        authority = string;\n    }\n    else\n    {\n        // Parse the sheme\n        i = 0;\n        while (string < authority)\n        {\n            unsigned char c = *string;\n            if (c == ':') {\n                // End of scheme\n                break;\n            }\n            if (c == '/') {\n                // End of scheme\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_SCHEME_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->scheme[i] = c;\n            string++;\n            i++;\n        }\n\n        // Skip the slashes\n        authority += 2;\n    }\n\n    c = *authority;\n    if (c == '[') {\n        b = true;\n        authority++;\n    }\n\n    // Parse the authority\n    i = 0;\n    while ((c = *authority) != 0)\n    {\n        // Skip spaces\n        if (c == ' ') {\n            authority++;\n            continue;\n        }\n        // Check for path\n        if (c == '/') {\n            break;\n        }\n        // Check for port number\n        if (c == ':') {\n            // Check if bracket used (IPv6)\n            if (!b) {\n                break;\n            }\n        }\n        // Check for query\n        if (c == '?') {\n            break;\n        }\n        // Check for fragment\n        if (c == '#') {\n            break;\n        }\n        // Should we check for closing bracket?\n        if (b) {\n            if (c == ']') {\n                authority++;\n                break;\n            }\n        }\n        // Check for overflow\n        if (i == (MAX_URL_AUTHORITY_LEN - 1)) {\n            return false;\n        }\n        pURL_Parts->authority[i] = c;\n        authority++;\n        i++;\n    }\n\n    // Switch back to string variable\n    string = authority;\n\n    // Check for a port number\n    if (*string == ':')\n    {\n        string++;\n        // Parse the port number\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for path\n            if (c == '/') {\n                break;\n            }\n            // Check for query\n            if (c == '?') {\n                break;\n            }\n            // Check for fragment\n            if (c == '#') {\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_PORT_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->port[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    // Check for a path\n    if (*string == '/')\n    {\n        // Parse the path\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for query\n            if (c == '?') {\n                break;\n            }\n            // Check for fragment\n            if (c == '#') {\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_PATH_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->path[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    // Check for a query\n    if (*string == '?')\n    {\n        // Parse the query\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for fragment\n            if (c == '#') {\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_QUERY_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->query[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    // Check for a fragment\n    if (*string == '#')\n    {\n        // Parse the fragment\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for overflow\n            if (i == (MAX_URL_FRAGMENT_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->fragment[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    return true;\n}\n",
    "extra": "{'MAX_URL_AUTHORITY_LEN': '#define MAX_URL_AUTHORITY_LEN 512', 'MAX_URL_FRAGMENT_LEN': '#define MAX_URL_FRAGMENT_LEN 256', 'MAX_URL_PATH_LEN': '#define MAX_URL_PATH_LEN 1024', 'MAX_URL_PORT_LEN': '#define MAX_URL_PORT_LEN 64', 'MAX_URL_QUERY_LEN': '#define MAX_URL_QUERY_LEN 1024', 'MAX_URL_SCHEME_LEN': '#define MAX_URL_SCHEME_LEN 32', 'URL_PARSER_H': '#define URL_PARSER_H', 'URL_PARTS': '} URL_PARTS;'} extract_info: [//\n// Copyright (c) 2023 Brian Sullender\n// All rights reserved.\n//\n// This source code is licensed under the terms provided in the README file.\n//\n// https://github.com/b-sullender/url-parser\n//\n\n//\n// Copyright (c) 2023 Brian Sullender\n// All rights reserved.\n//\n// This source code is licensed under the terms provided in the README file.\n//\n// https://github.com/b-sullender/url-parser\n//\n\n#ifndef URL_PARSER_H\n#define URL_PARSER_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n// Maximum scheme length\n#define MAX_URL_SCHEME_LEN 32\n// Maximum authority length\n#define MAX_URL_AUTHORITY_LEN 512\n// Maximum port length\n#define MAX_URL_PORT_LEN 64\n// Maximum path length\n#define MAX_URL_PATH_LEN 1024\n// Maximum query length\n#define MAX_URL_QUERY_LEN 1024\n// Maximum fragment length\n#define MAX_URL_FRAGMENT_LEN 256\n\ntypedef struct URL_PARTS {\n    char scheme[MAX_URL_SCHEME_LEN];\n    char authority[MAX_URL_AUTHORITY_LEN];\n    char port[MAX_URL_PORT_LEN];\n    char path[MAX_URL_PATH_LEN];\n    char query[MAX_URL_QUERY_LEN];\n    char fragment[MAX_URL_FRAGMENT_LEN];\n} URL_PARTS;\n\n// ParseURL\n// This function parses a URL string\n// @URL: The URL string the parse\n// @pURL_Parts: A pointer to a URL_PARTS struct to fill\n// @return: true on success, false otherwise\nbool ParseURL(char* URL, URL_PARTS* pURL_Parts);\n\n// PrintURL\n// This function prints each part of a URL_PARTS struct individually,\n// and the entire URL on a single line. For testing purposes only\n// @pURL_Parts: A pointer to a URL_PARTS struct to print\nvoid PrintURL(struct URL_PARTS* pURL_Parts);\n\n#endif // !URL_PARSER_H\n\n\n\n]"
}