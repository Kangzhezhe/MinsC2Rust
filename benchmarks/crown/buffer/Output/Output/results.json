{
    "buffer": {
        "buffer_resize": "pub fn buffer_resize(buffer: &mut Buffer, n: usize) -> i32 {\n    let n = ((n + 1023) / 1024) * 1024;\n    buffer.len = n;\n    buffer.alloc = String::with_capacity(n + 1);\n    buffer.data = buffer.alloc.clone();\n    buffer.alloc.push('\\0');\n    0\n}\n\n",
        "extra": "pub const BUFFER_DEFAULT_SIZE: usize = 1024;\n\n#[derive(Clone)]\npub struct Buffer {\n    pub len: usize,\n    pub alloc: String,\n    pub data: String,\n}\n",
        "buffer_length": "pub fn buffer_length(buffer: &Buffer) -> usize {\n    buffer.data.len()\n}\n\n",
        "buffer_append_n": "pub fn buffer_append_n(buffer: &mut Buffer, str: &str, len: usize) -> i32 {\n    let prev = buffer.data.len();\n    let needed = len + prev;\n\n    if buffer.len > needed {\n        buffer.data.push_str(&str[..len]);\n        return 0;\n    }\n\n    let ret = buffer_resize(buffer, needed);\n    if ret == -1 {\n        return -1;\n    }\n\n    buffer.data.push_str(&str[..len]);\n    0\n}\n\n",
        "buffer_new_with_size": "pub fn buffer_new_with_size(n: usize) -> Result<Buffer, String> {\n    let mut buffer = Buffer {\n        len: n,\n        alloc: String::with_capacity(n + 1),\n        data: String::with_capacity(n + 1),\n    };\n    buffer.alloc.push_str(&\"\\0\".repeat(n + 1));\n    buffer.data.push_str(&\"\\0\".repeat(n + 1));\n    Ok(buffer)\n}\n\n",
        "buffer_trim_right": "pub fn buffer_trim_right(buffer: &mut Buffer) {\n    let mut i = buffer_length(buffer) - 1;\n    while i >= 0 {\n        let c = buffer.data.chars().nth(i as usize).unwrap();\n        if !c.is_whitespace() {\n            break;\n        }\n        buffer.data.truncate(i as usize);\n        i -= 1;\n        if i < 0 {\n            break;\n        }\n    }\n}\n\n",
        "buffer_trim_left": "pub fn buffer_trim_left(buffer: &mut Buffer) {\n    while let Some(c) = buffer.data.chars().next() {\n        if !c.is_whitespace() {\n            break;\n        }\n        buffer.data = buffer.data[1..].to_string();\n    }\n}\n\n",
        "buffer_fill": "pub fn buffer_fill(buffer: &mut Buffer, c: i32) {\n    buffer.data = vec![c as u8; buffer.len].iter().map(|&b| b as char).collect();\n}\n\n",
        "buffer_free": "pub fn buffer_free(buffer: Buffer) {\n    // Function to free the buffer's allocated memory\n    // No explicit free needed in Rust due to ownership and drop semantics\n}\n\n",
        "buffer_prepend": "pub fn buffer_prepend(buffer: &mut Buffer, str: String) -> i32 {\n    let len = str.len();\n    let prev = buffer.data.len();\n    let needed = len + prev;\n\n    if buffer.len > needed {\n        // enough space\n    } else {\n        // resize\n        let ret = buffer_resize(buffer, needed);\n        if ret == -1 {\n            return -1;\n        }\n    }\n\n    // move\n    let mut new_data = String::with_capacity(needed + 1);\n    new_data.push_str(&str);\n    new_data.push_str(&buffer.data);\n    buffer.data = new_data;\n\n    0\n}\n\n",
        "buffer_append": "pub fn buffer_append(buffer: &mut Buffer, str: &str) -> i32 {\n    buffer_append_n(buffer, str, str.len())\n}\n\n",
        "buffer_new": "pub fn buffer_new() -> Result<Buffer, String> {\n    buffer_new_with_size(BUFFER_DEFAULT_SIZE)\n}\n\n",
        "buffer_size": "pub fn buffer_size(buffer: &Buffer) -> usize {\n    buffer.len\n}\n\n",
        "buffer_slice": "pub fn buffer_slice(buf: &Buffer, from: usize, to: isize) -> Result<Buffer, String> {\n    let len = buf.data.len();\n\n    // bad range\n    if to < from as isize {\n        return Err(\"Invalid range\".to_string());\n    }\n\n    // relative to end\n    let to = if to < 0 {\n        len - (!to as usize)\n    } else {\n        to as usize\n    };\n\n    // cap end\n    let to = if to > len { len } else { to };\n\n    let n = to - from;\n    let mut self_buf = buffer_new_with_size(n)?;\n    self_buf.data = buf.data[from..to].to_string();\n    Ok(self_buf)\n}\n\n",
        "buffer_new_with_copy": "pub fn buffer_new_with_copy(str: String) -> Result<Buffer, String> {\n    let len = str.len();\n    let mut buffer = buffer_new_with_size(len)?;\n    buffer.alloc = str.clone();\n    buffer.data = str;\n    Ok(buffer)\n}\n\n",
        "buffer_trim": "pub fn buffer_trim(buffer: &mut Buffer) {\n    buffer_trim_left(buffer);\n    buffer_trim_right(buffer);\n}\n\n",
        "buffer_compact": "pub fn buffer_compact(buffer: &mut Buffer) -> i32 {\n    let len = buffer_length(buffer);\n    let rem = buffer.len - len;\n    let mut buf = String::with_capacity(len + 1);\n    buf.push_str(&buffer.data);\n    buffer.alloc = buf.clone();\n    buffer.data = buf;\n    buffer.len = len;\n    rem as i32\n}\n\n",
        "buffer_indexof": "pub fn buffer_indexof(buffer: &Buffer, str: String) -> i32 {\n    let sub = buffer.data.find(&str);\n    match sub {\n        Some(index) => index as i32,\n        None => -1,\n    }\n}\n\n",
        "buffer_clear": "pub fn buffer_clear(buffer: &mut Buffer) {  \n    buffer_fill(buffer, 0);  \n}\n\n",
        "buffer_appendf": "pub fn buffer_appendf(buffer: &mut Buffer, format: String, args: Vec<String>) -> i32 {\n    let length = buffer_length(buffer);\n    let required = format.len();\n    if buffer_resize(buffer, length + required) == -1 {\n        return -1;\n    }\n    let dst = &mut buffer.data[length..];\n    let mut s = dst.to_string();\n    let formatted_args = format!(\"{}\", args.join(\" \"));\n    let result = std::fmt::write(&mut s, format_args!(\"{}\", formatted_args));\n    if result.is_err() {\n        -1\n    } else {\n        0\n    }\n}\n\n",
        "buffer_equals": "pub fn buffer_equals(buffer: &Buffer, other: &Buffer) -> bool {\n    buffer.data == other.data\n}\n\n"
    },
    "test-buffer": {
        "main": "fn main(){}\n",
        "test_buffer_prepend": "pub fn test_buffer_prepend() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \" World\"));\n    assert_eq!(0, buffer_prepend(&mut buf, \"Hello\".to_string()));\n    assert_eq!(\"Hello World\".len(), buffer_length(&buf));\n    equal(\"Hello World\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "equal": "pub fn equal(a: &str, b: &str) {\n    if a != b {\n        println!();\n        println!(\"  expected: '{}'\", a);\n        println!(\"    actual: '{}'\", b);\n        println!();\n        std::process::exit(1);\n    }\n}\n\n",
        "extra": "use test_project::buffer::{BUFFER_DEFAULT_SIZE, Buffer, buffer_new, buffer_append, buffer_prepend, buffer_length, buffer_free, buffer_size, buffer_new_with_size, buffer_new_with_copy, buffer_slice, buffer_trim, buffer_compact, buffer_append_n, buffer_fill, buffer_indexof, buffer_trim_left, buffer_trim_right, buffer_clear, buffer_appendf, buffer_equals};",
        "test_buffer_new": "pub fn test_buffer_new() {\n    let buf = buffer_new().unwrap();\n    assert_eq!(BUFFER_DEFAULT_SIZE, buffer_size(&buf));\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_new_with_size": "pub fn test_buffer_new_with_size() {\n    let buf = buffer_new_with_size(1024).unwrap();\n    assert_eq!(1024, buffer_size(&buf));\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__end_overflow": "pub fn test_buffer_slice__end_overflow() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n    let a = buffer_slice(&buf, 5, 1000).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"Ferret\", &a.data);\n    buffer_free(a);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_compact": "pub fn test_buffer_compact() {\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim(&mut buf);\n    assert_eq!(5, buffer_length(&buf));\n    assert_eq!(10, buffer_size(&buf));\n\n    let removed = buffer_compact(&mut buf);\n    assert_eq!(5, removed);\n    assert_eq!(5, buffer_length(&buf));\n    assert_eq!(5, buffer_size(&buf));\n    equal(\"Hello\", &buf.data);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append": "pub fn test_buffer_append() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \"Hello\"));\n    assert_eq!(0, buffer_append(&mut buf, \" World\"));\n    assert_eq!(\"Hello World\".len(), buffer_length(&buf));\n    equal(\"Hello World\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append_n": "pub fn test_buffer_append_n() {\n    let mut buf = buffer_new().unwrap();\n    assert_eq!(0, buffer_append_n(&mut buf, \"subway\", 3));\n    assert_eq!(0, buffer_append_n(&mut buf, \"marines\", 6));\n    assert_eq!(\"submarine\".len(), buffer_length(&buf));\n    equal(\"submarine\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_append__grow": "pub fn test_buffer_append__grow() {\n    let mut buf = buffer_new_with_size(10).unwrap();\n    assert_eq!(0, buffer_append(&mut buf, \"Hello\"));\n    assert_eq!(0, buffer_append(&mut buf, \" tobi\"));\n    assert_eq!(0, buffer_append(&mut buf, \" was\"));\n    assert_eq!(0, buffer_append(&mut buf, \" here\"));\n\n    let str = \"Hello tobi was here\";\n    equal(str, &buf.data);\n    assert_eq!(1024, buffer_size(&buf));\n    assert_eq!(str.len(), buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_prepend_issue_15": "pub fn test_buffer_prepend_issue_15() {\n    let mut file = buffer_new().unwrap();\n    assert_eq!(0, buffer_append(&mut file, \"layout.bk.html\"));\n    assert_eq!(0, buffer_prepend(&mut file, \"./example/\".to_string()));\n    assert_eq!(\"./example/layout.bk.html\".len(), buffer_length(&file));\n    equal(\"./example/layout.bk.html\", &file.data);\n    buffer_free(file);\n}\n\n",
        "test_buffer_fill": "pub fn test_buffer_fill() {\n    let mut buf = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    assert_eq!(5, buffer_length(&buf));\n\n    buffer_fill(&mut buf, 0);\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_indexof": "pub fn test_buffer_indexof() {\n    let buf = buffer_new_with_copy(String::from(\"Tobi is a ferret\")).unwrap();\n\n    let i = buffer_indexof(&buf, String::from(\"is\"));\n    assert_eq!(5, i);\n\n    let i = buffer_indexof(&buf, String::from(\"a\"));\n    assert_eq!(8, i);\n\n    let i = buffer_indexof(&buf, String::from(\"something\"));\n    assert_eq!(-1, i);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_trim": "pub fn test_buffer_trim() {\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim(&mut buf);\n    equal(\"Hello\", &buf.data);\n\n    buffer_free(buf);\n\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim_left(&mut buf);\n    equal(\"Hello\\n\\n \", &buf.data);\n\n    buffer_free(buf);\n\n    let mut buf = buffer_new_with_copy(\"  Hello\\n\\n \".to_string()).unwrap();\n    buffer_trim_right(&mut buf);\n    equal(\"  Hello\", &buf.data);\n\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__range_error": "pub fn test_buffer_slice__range_error() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n    let a = buffer_slice(&buf, 10, 2);\n    assert!(a.is_err());\n    buffer_free(buf);\n}\n\n",
        "test_buffer_slice__end": "pub fn test_buffer_slice__end() {\n    let buf = buffer_new_with_copy(\"Tobi Ferret\".to_string()).unwrap();\n\n    let a = buffer_slice(&buf, 5, -1).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"Ferret\", &a.data);\n\n    let b = buffer_slice(&buf, 5, -3).unwrap();\n    equal(\"Ferr\", &b.data);\n\n    let c = buffer_slice(&buf, 8, -1).unwrap();\n    equal(\"ret\", &c.data);\n\n    buffer_free(buf);\n    buffer_free(a);\n    buffer_free(b);\n    buffer_free(c);\n}\n\n",
        "test_buffer_clear": "pub fn test_buffer_clear() {\n    let mut buf = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    assert_eq!(5, buffer_length(&buf));\n\n    buffer_clear(&mut buf);\n    assert_eq!(0, buffer_length(&buf));\n    buffer_free(buf);\n}\n\n",
        "test_buffer_formatting": "pub fn test_buffer_formatting() {\n    let mut buf = buffer_new().expect(\"Failed to create buffer\");\n    let result = buffer_appendf(&mut buf, \"%d %s\".to_string(), vec![\"3\".to_string(), \"cow\".to_string()]);\n    assert_eq!(0, result);\n    equal(\"3 cow\", &buf.data);\n    let result = buffer_appendf(&mut buf, \" - 0x%08X\".to_string(), vec![\"0xDEADBEEF\".to_string()]);\n    assert_eq!(0, result);\n    equal(\"3 cow - 0xDEADBEEF\", &buf.data);\n    buffer_free(buf);\n}\n\n",
        "test_buffer_equals": "pub fn test_buffer_equals() {\n    let a = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n    let b = buffer_new_with_copy(\"Hello\".to_string()).unwrap();\n\n    assert!(buffer_equals(&a, &b));\n\n    buffer_append(&mut b.clone(), \" World\");\n    assert!(!buffer_equals(&a, &b));\n\n    buffer_free(a);\n    buffer_free(b);\n}\n\n",
        "test_buffer_slice": "pub fn test_buffer_slice() {\n    let mut buf = buffer_new().unwrap();\n    buffer_append(&mut buf, \"Tobi Ferret\");\n\n    let a = buffer_slice(&buf, 2, 8).unwrap();\n    equal(\"Tobi Ferret\", &buf.data);\n    equal(\"bi Fer\", &a.data);\n\n    buffer_free(buf);\n    buffer_free(a);\n}\n\nfn nearest_multiple_of(base: usize, n: usize) -> usize {\n    ((n + base - 1) / base) * base\n}\n\n"
    }
}