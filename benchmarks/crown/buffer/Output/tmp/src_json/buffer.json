{
    "buffer_appendf": "int buffer_appendf(buffer_t *self, const char *format, ...) {\n  va_list ap;\n  va_list tmpa;\n  char *dst = NULL;\n  int length = 0;\n  int required = 0;\n  int bytes = 0;\n\n  va_start(ap, format);\n\n  length = buffer_length(self);\n\n  // First, we compute how many bytes are needed\n  // for the formatted string and allocate that\n  // much more space in the buffer.\n  va_copy(tmpa, ap);\n  required = vsnprintf(NULL, 0, format, tmpa);\n  va_end(tmpa);\n  if (-1 == buffer_resize(self, length + required)) {\n    va_end(ap);\n    return -1;\n  }\n\n  // Next format the string into the space that we\n  // have made room for.\n  dst = self->data + length;\n  bytes = vsnprintf(dst, 1 + required, format, ap);\n  va_end(ap);\n\n  return bytes < 0\n    ? -1\n    : 0;\n}\n",
    "buffer_append": "buffer_append(buffer_t *self, const char *str) {\n  return buffer_append_n(self, str, strlen(str));\n}\n",
    "buffer_resize": "buffer_resize(buffer_t *self, size_t n) {\n  n = nearest_multiple_of(1024, n);\n  self->len = n;\n  self->alloc = self->data = realloc(self->alloc, n + 1);\n  if (!self->alloc) return -1;\n  self->alloc[n] = '\\0';\n  return 0;\n}\n",
    "buffer_indexof": "buffer_indexof(buffer_t *self, char *str) {\n  char *sub = strstr(self->data, str);\n  if (!sub) return -1;\n  return sub - self->data;\n}\n",
    "buffer_new_with_copy": "buffer_new_with_copy(char *str) {\n  size_t len = strlen(str);\n  buffer_t *self = buffer_new_with_size(len);\n  if (!self) return NULL;\n  memcpy(self->alloc, str, len);\n  self->data = self->alloc;\n  return self;\n}\n",
    "buffer_trim_right": "buffer_trim_right(buffer_t *self) {\n  int c;\n  size_t i = buffer_length(self) - 1;\n  while ((c = self->data[i]) && isspace(c)) {\n    self->data[i--] = 0;\n  }\n",
    "buffer_compact": "buffer_compact(buffer_t *self) {\n  size_t len = buffer_length(self);\n  size_t rem = self->len - len;\n  char *buf = calloc(len + 1, 1);\n  if (!buf) return -1;\n  memcpy(buf, self->data, len);\n  free(self->alloc);\n  self->len = len;\n  self->data = self->alloc = buf;\n  return rem;\n}\n",
    "buffer_trim": "buffer_trim(buffer_t *self) {\n  buffer_trim_left(self);\n  buffer_trim_right(self);\n}\n",
    "buffer_print": "buffer_print(buffer_t *self) {\n  int i;\n  size_t len = self->len;\n\n  printf(\"\\n \");\n\n  // hex\n  for (i = 0; i < len; ++i) {\n    printf(\" %02x\", self->alloc[i]);\n    if ((i + 1) % 8 == 0) printf(\"\\n \");\n  }\n\n  printf(\"\\n\");\n}\n",
    "buffer_new_with_size": "buffer_new_with_size(size_t n) {\n  buffer_t *self = malloc(sizeof(buffer_t));\n  if (!self) return NULL;\n  self->len = n;\n  self->data = self->alloc = calloc(n + 1, 1);\n  return self;\n}\n",
    "buffer_slice": "buffer_slice(buffer_t *buf, size_t from, ssize_t to) {\n  size_t len = strlen(buf->data);\n\n  // bad range\n  if (to < from) return NULL;\n\n  // relative to end\n  if (to < 0) to = len - ~to;\n\n  // cap end\n  if (to > len) to = len;\n\n  size_t n = to - from;\n  buffer_t *self = buffer_new_with_size(n);\n  memcpy(self->data, buf->data + from, n);\n  return self;\n}\n",
    "buffer_prepend": "buffer_prepend(buffer_t *self, char *str) {\n  size_t len = strlen(str);\n  size_t prev = strlen(self->data);\n  size_t needed = len + prev;\n\n  // enough space\n  if (self->len > needed) goto move;\n\n  // resize\n  int ret = buffer_resize(self, needed);\n  if (-1 == ret) return -1;\n\n  // move\n  move:\n  memmove(self->data + len, self->data, prev + 1);\n  memcpy(self->data, str, len);\n\n  return 0;\n}\n",
    "buffer_append_n": "buffer_append_n(buffer_t *self, const char *str, size_t len) {\n  size_t prev = strlen(self->data);\n  size_t needed = len + prev;\n\n  // enough space\n  if (self->len > needed) {\n    strncat(self->data, str, len);\n    return 0;\n  }\n\n  // resize\n  int ret = buffer_resize(self, needed);\n  if (-1 == ret) return -1;\n  strncat(self->data, str, len);\n\n  return 0;\n}\n",
    "buffer_equals": "buffer_equals(buffer_t *self, buffer_t *other) {\n  return 0 == strcmp(self->data, other->data);\n}\n",
    "buffer_new_with_string_length": "buffer_new_with_string_length(char *str, size_t len) {\n  buffer_t *self = malloc(sizeof(buffer_t));\n  if (!self) return NULL;\n  self->len = len;\n  self->data = self->alloc = str;\n  return self;\n}\n",
    "buffer_new_with_string": "buffer_new_with_string(char *str) {\n  return buffer_new_with_string_length(str, strlen(str));\n}\n",
    "buffer_length": "buffer_length(buffer_t *self) {\n  return strlen(self->data);\n}\n",
    "buffer_clear": "buffer_clear(buffer_t *self) {\n  buffer_fill(self, 0);\n}\n",
    "buffer_free": "buffer_free(buffer_t *self) {\n  free(self->alloc);\n  free(self);\n}\n",
    "buffer_size": "buffer_size(buffer_t *self) {\n  return self->len;\n}\n",
    "buffer_trim_left": "buffer_trim_left(buffer_t *self) {\n  int c;\n  while ((c = *self->data) && isspace(c)) {\n    ++self->data;\n  }\n",
    "buffer_fill": "buffer_fill(buffer_t *self, int c) {\n  memset(self->data, c, self->len);\n}\n",
    "buffer_new": "buffer_new() {\n  return buffer_new_with_size(BUFFER_DEFAULT_SIZE);\n}\n",
    "extra": "{'BUFFER_DEFAULT_SIZE': '#define BUFFER_DEFAULT_SIZE 64', 'BUFFER_H': '#define BUFFER_H 1', 'buffer_string': '#define buffer_string(self) (self->data)', 'nearest_multiple_of': '#define nearest_multiple_of(a, b) \\\\', 'buffer_t': '} buffer_t;'} extract_info: [//\n// buffer.c\n//\n// Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <sys/types.h>\n\n//\n// buffer.h\n//\n// Copyright (c) 2012 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#ifndef BUFFER_H\n#define BUFFER_H 1\n\n#include <sys/types.h>\n\n/*\n * Default buffer size.\n */\n\n#ifndef BUFFER_DEFAULT_SIZE\n#define BUFFER_DEFAULT_SIZE 64\n#endif\n\n/*\n * Buffer struct.\n */\n\ntypedef struct {\n  size_t len;\n  char *alloc;\n  char *data;\n} buffer_t;\n\n// prototypes\n\nbuffer_t *\nbuffer_new();\n\nbuffer_t *\nbuffer_new_with_size(size_t n);\n\nbuffer_t *\nbuffer_new_with_string(char *str);\n\nbuffer_t *\nbuffer_new_with_string_length(char *str, size_t len);\n\nbuffer_t *\nbuffer_new_with_copy(char *str);\n\nsize_t\nbuffer_size(buffer_t *self);\n\nsize_t\nbuffer_length(buffer_t *self);\n\nvoid\nbuffer_free(buffer_t *self);\n\nint\nbuffer_prepend(buffer_t *self, char *str);\n\nint\nbuffer_append(buffer_t *self, const char *str);\n\nint\nbuffer_appendf(buffer_t *self, const char *format, ...);\n\nint\nbuffer_append_n(buffer_t *self, const char *str, size_t len);\n\nint\nbuffer_equals(buffer_t *self, buffer_t *other);\n\nssize_t\nbuffer_indexof(buffer_t *self, char *str);\n\nbuffer_t *\nbuffer_slice(buffer_t *self, size_t from, ssize_t to);\n\nssize_t\nbuffer_compact(buffer_t *self);\n\nvoid\nbuffer_fill(buffer_t *self, int c);\n\nvoid\nbuffer_clear(buffer_t *self);\n\nvoid\nbuffer_trim_left(buffer_t *self);\n\nvoid\nbuffer_trim_right(buffer_t *self);\n\nvoid\nbuffer_trim(buffer_t *self);\n\nvoid\nbuffer_print(buffer_t *self);\n\n#define buffer_string(self) (self->data)\n\n#endif\n\n// TODO: shared with reference counting\n// TODO: linked list for append/prepend etc\n\n/*\n * Compute the nearest multiple of `a` from `b`.\n */\n\n#define nearest_multiple_of(a, b) \\\n  (((b) + ((a) - 1)) & ~((a) - 1))\n\n/*\n * Allocate a new buffer with BUFFER_DEFAULT_SIZE.\n */\n\nbuffer_t *\n\n/*\n * Allocate a new buffer with `n` bytes.\n */\n\nbuffer_t *\n\n/*\n * Allocate a new buffer with `str`.\n */\n\nbuffer_t *\n\n/*\n * Allocate a new buffer with `str` and `len`.\n */\n\nbuffer_t *\n\n/*\n * Allocate a new buffer with a copy of `str`.\n */\n\nbuffer_t *\n\n/*\n * Deallocate excess memory, the number\n * of bytes removed or -1.\n */\n\nssize_t\n\n/*\n * Free the buffer.\n */\n\nvoid\n\n/*\n * Return buffer size.\n */\n\nsize_t\n\n/*\n * Return string length.\n */\n\nsize_t\n\n/*\n * Resize to hold `n` bytes.\n */\n\nint\n\n/*\n * Append a printf-style formatted string to the buffer.\n */\n\n\n/*\n * Append `str` to `self` and return 0 on success, -1 on failure.\n */\n\nint\n\n/*\n * Append the first `len` bytes from `str` to `self` and\n * return 0 on success, -1 on failure.\n */\nint\n\n/*\n * Prepend `str` to `self` and return 0 on success, -1 on failure.\n */\n\nint\n\n/*\n * Return a new buffer based on the `from..to` slice of `buf`,\n * or NULL on error.\n */\n\nbuffer_t *\n\n/*\n * Return 1 if the buffers contain equivalent data.\n */\n\nint\n\n/*\n * Return the index of the substring `str`, or -1 on failure.\n */\n\nssize_t\n\n/*\n * Trim leading whitespace.\n */\n\nvoid\n}\n\n/*\n * Trim trailing whitespace.\n */\n\nvoid\n}\n\n/*\n * Trim trailing and leading whitespace.\n */\n\nvoid\n\n/*\n * Fill the buffer with `c`.\n */\n\nvoid\n\n/*\n * Fill the buffer with 0.\n */\n\nvoid\n\n/*\n * Print a hex dump of the buffer.\n */\n\nvoid\n]"
}