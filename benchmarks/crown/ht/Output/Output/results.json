{
    "ht": {
        "hash_key": "pub fn hash_key(key: String) -> u64 {\n    let mut hash: u64 = 14695981039346656037;\n    for c in key.chars() {\n        hash ^= c as u64;\n        hash = hash.wrapping_mul(1099511628211);\n    }\n    hash\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse std::fmt;\n\nconst INITIAL_CAPACITY: usize = 16;\n\n#[derive(Debug)]\npub struct HtEntry<T> {\n    pub key: Option<String>,\n    pub value: Option<T>,\n}\n\n#[derive(Debug)]\npub struct Ht<T> {\n    pub entries: Vec<Rc<RefCell<HtEntry<T>>>>,\n    pub capacity: usize,\n    pub length: usize,\n}\n\npub struct HtIterator<T> {\n    pub key: Option<String>,\n    pub value: Option<T>,\n    pub _table: Rc<RefCell<Ht<T>>>,\n    pub _index: usize,\n}\n",
        "ht_set_entry": "pub fn ht_set_entry<T>(entries: &mut Vec<Rc<RefCell<HtEntry<T>>>>, capacity: usize, key: String, value: T, plength: &mut usize) -> Option<String> {\n    let hash = hash_key(key.clone());\n    let mut index = (hash & (capacity as u64 - 1)) as usize;\n\n    loop {\n        let entry = entries[index].borrow();\n        if let Some(existing_key) = &entry.key {\n            if *existing_key == key {\n                entries[index].borrow_mut().value = Some(value);\n                return Some(existing_key.clone());\n            }\n            index += 1;\n            if index >= capacity {\n                index = 0;\n            }\n        } else {\n            break;\n        }\n    }\n\n    if *plength != 0 {\n        *plength += 1;\n    }\n    entries[index].borrow_mut().key = Some(key.clone());\n    entries[index].borrow_mut().value = Some(value);\n    Some(key)\n}\n\n",
        "ht_expand": "pub fn ht_expand<T: Clone>(entries: &mut Vec<Rc<RefCell<HtEntry<T>>>>, capacity: &mut usize, length: &mut usize) -> bool {\n    let new_capacity = *capacity * 2;\n    if new_capacity < *capacity {\n        return false;  // overflow (capacity would be too big)\n    }\n\n    let mut new_entries = Vec::with_capacity(new_capacity);\n    for _ in 0..new_capacity {\n        new_entries.push(Rc::new(RefCell::new(HtEntry { key: None, value: None })));\n    }\n\n    for i in 0..*capacity {\n        let entry = entries[i].borrow();\n        if let Some(key) = &entry.key {\n            let value = entry.value.as_ref().unwrap().clone();\n            ht_set_entry(&mut new_entries, new_capacity, key.clone(), value, length);\n        }\n    }\n\n    *entries = new_entries;\n    *capacity = new_capacity;\n    true\n}\n\n",
        "ht_destroy": "pub fn ht_destroy<T>(table: Ht<T>) {\n    // First free allocated keys.\n    for i in 0..table.capacity {\n        let mut entry = table.entries[i].borrow_mut();\n        entry.key = None;\n    }\n\n    // Then free entries array and table itself.\n    // Rust's ownership system will automatically handle the cleanup of the Vec and Ht struct.\n}\n\n",
        "ht_create": "pub fn ht_create<T>() -> Ht<T> {\n    let mut table = Ht {\n        entries: Vec::with_capacity(INITIAL_CAPACITY),\n        capacity: INITIAL_CAPACITY,\n        length: 0,\n    };\n    for _ in 0..INITIAL_CAPACITY {\n        table.entries.push(Rc::new(RefCell::new(HtEntry {\n            key: None,\n            value: None,\n        })));\n    }\n    table\n}\n\n",
        "ht_set": "pub fn ht_set<T: Clone>(table: &mut Ht<T>, key: String, value: T) -> Option<String> {\n    if table.length >= table.capacity / 2 {\n        if !ht_expand(&mut table.entries, &mut table.capacity, &mut table.length) {\n            return None;\n        }\n    }\n    ht_set_entry(&mut table.entries, table.capacity, key, value, &mut table.length)\n}\n\n",
        "ht_length": "pub fn ht_length<T>(table: &Ht<T>) -> usize {\n    table.length\n}\n\n",
        "ht_get": "pub fn ht_get<T: Clone>(table: &Ht<T>, key: String) -> Option<Rc<RefCell<T>>> {\n    let hash = hash_key(key.clone());\n    let mut index = (hash & (table.capacity as u64 - 1)) as usize;\n\n    while table.entries[index].borrow().key.is_some() {\n        if table.entries[index].borrow().key.as_ref().unwrap() == &key {\n            let value = table.entries[index].borrow().value.as_ref().unwrap().clone();\n            return Some(Rc::new(RefCell::new(value)));\n        }\n        index += 1;\n        if index >= table.capacity {\n            index = 0;\n        }\n    }\n    None\n}\n\n",
        "ht_iterator": "pub fn ht_iterator<T>(table: Rc<RefCell<Ht<T>>>) -> HtIterator<T> {\n    HtIterator {\n        key: None,\n        value: None,\n        _table: table,\n        _index: 0,\n    }\n}\n\n",
        "ht_next": "pub fn ht_next<T: Clone>(mut it: HtIterator<T>) -> (bool, HtIterator<T>) {\n    let table = Rc::clone(&it._table);\n    let mut table_borrow = table.borrow_mut();\n    while it._index < table_borrow.capacity {\n        let i = it._index;\n        it._index += 1;\n        if let Some(entry) = &table_borrow.entries[i].borrow().key {\n            let entry_borrow = table_borrow.entries[i].borrow();\n            it.key = entry_borrow.key.clone();\n            it.value = entry_borrow.value.as_ref().map(|v| v.clone());\n            return (true, it);\n        }\n    }\n    (false, it)\n}\n\n"
    },
    "test-ht": {
        "main": "fn main(){}\n\n",
        "test_ht_update_value": "pub fn test_ht_update_value() {\n    let mut table = ht_create::<i32>();\n    \n    // Insert a key-value pair\n    let value1 = 42;\n    let key = String::from(\"key\");\n    assert!(ht_set(&mut table, key.clone(), value1).is_some());\n    \n    // Update the value for the same key\n    let value2 = 84;\n    assert!(ht_set(&mut table, key.clone(), value2).is_some());\n    \n    // Retrieve the updated value\n    let retrieved_value = ht_get(&table, key.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value2);\n    \n    // Check the length of the hash table (should still be 1)\n    assert_eq!(ht_length(&table), 1);\n    \n    ht_destroy(table);\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\nuse test_project::ht::{ht_iterator, ht_length, ht_set_entry, ht_create, hash_key, ht_next, ht_destroy, ht_set, ht_expand, ht_get, Ht, HtEntry, HtIterator};",
        "test_ht_memory_management": "pub fn test_ht_memory_management() {\n    let mut table = ht_create::<Rc<RefCell<i32>>>();\n    \n    let value1 = Rc::new(RefCell::new(42));\n    let value2 = Rc::new(RefCell::new(84));\n    \n    assert!(ht_set(&mut table, \"key1\".to_string(), Rc::clone(&value1)).is_some());\n    assert!(ht_set(&mut table, \"key2\".to_string(), Rc::clone(&value2)).is_some());\n    \n    let mut it = ht_iterator(Rc::new(RefCell::new(table)));\n    loop {\n        let (has_next, new_it) = ht_next(it);\n        it = new_it;\n        if !has_next {\n            break;\n        }\n    }\n    \n    let table = Rc::try_unwrap(it._table).unwrap().into_inner();\n    ht_destroy(table);\n}\n\n",
        "test_ht_set_and_get": "pub fn test_ht_set_and_get() {\n    let mut table = ht_create::<i32>();\n\n    // Insert a key-value pair\n    let value1 = 42;\n    let key1 = String::from(\"key1\");\n    assert!(ht_set(&mut table, key1.clone(), value1).is_some());\n\n    // Retrieve the value\n    let retrieved_value = ht_get(&table, key1.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value1);\n\n    // Insert another key-value pair\n    let value2 = 84;\n    let key2 = String::from(\"key2\");\n    assert!(ht_set(&mut table, key2.clone(), value2).is_some());\n\n    // Retrieve the second value\n    let retrieved_value = ht_get(&table, key2.clone());\n    assert!(retrieved_value.is_some());\n    assert_eq!(*retrieved_value.unwrap().borrow(), value2);\n\n    // Check the length of the hash table\n    assert_eq!(ht_length(&table), 2);\n\n    ht_destroy(table);\n}\n\n",
        "test_ht_create_and_destroy": "pub fn test_ht_create_and_destroy() {\n    let mut table = ht_create::<i32>();\n    assert_eq!(ht_length(&table), 0);\n    ht_destroy(table);\n}\n\n",
        "test_ht_iterator": "pub fn test_ht_iterator() {\n    let mut table = ht_create();\n    let value1 = 1;\n    let value2 = 2;\n    let value3 = 3;\n    assert!(ht_set(&mut table, \"key1\".to_string(), value1).is_some());\n    assert!(ht_set(&mut table, \"key2\".to_string(), value2).is_some());\n    assert!(ht_set(&mut table, \"key3\".to_string(), value3).is_some());\n\n    let it = ht_iterator(Rc::new(RefCell::new(table)));\n    let mut count = 0;\n    let mut it = it;\n    loop {\n        let (has_next, new_it) = ht_next(it);\n        it = new_it;\n        if !has_next {\n            break;\n        }\n        assert!(it.key.is_some());\n        assert!(it.value.is_some());\n        count += 1;\n    }\n\n    assert_eq!(count, 3);\n\n    let table = it._table.borrow();\n    let table_clone = Ht {\n        entries: table.entries.clone(),\n        capacity: table.capacity,\n        length: table.length,\n    };\n    ht_destroy(table_clone);\n}\n\n"
    }
}