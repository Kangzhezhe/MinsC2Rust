{
    "bst": {
        "_bst_subtree_min_val": "pub fn _bst_subtree_min_val<T: Ord + Clone>(n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<T> {\n    // The minimum value in any subtree is just the leftmost value. Keep going \n    // left till we get there.\n    let mut current = n;\n    while let Some(node) = current {\n        if node.borrow().left.is_none() {\n            return Some(node.borrow().val.clone());\n        }\n        current = node.borrow().left.clone();\n    }\n    None\n}\n\n",
        "extra": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BstNode<T> {\n    pub val: T,\n    pub left: Option<Rc<RefCell<BstNode<T>>>>,\n    pub right: Option<Rc<RefCell<BstNode<T>>>>,\n}\n\npub struct Bst<T> {\n    pub root: Option<Rc<RefCell<BstNode<T>>>>,\n}\n",
        "_bst_subtree_remove": "pub fn _bst_subtree_remove<T: Ord + Clone>(val: T, n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<Rc<RefCell<BstNode<T>>>> {\n    if n.is_none() {\n        return None;\n    }\n\n    let node = n.unwrap();\n    let mut node_borrow = node.borrow_mut();\n\n    if val < node_borrow.val {\n        let left = node_borrow.left.take();\n        node_borrow.left = _bst_subtree_remove(val, left);\n        drop(node_borrow);\n        return Some(node);\n    } else if val > node_borrow.val {\n        let right = node_borrow.right.take();\n        node_borrow.right = _bst_subtree_remove(val, right);\n        drop(node_borrow);\n        return Some(node);\n    } else {\n        if node_borrow.left.is_some() && node_borrow.right.is_some() {\n            let min_val = _bst_subtree_min_val(node_borrow.right.clone()).unwrap();\n            node_borrow.val = min_val.clone();\n            let right = node_borrow.right.take();\n            node_borrow.right = _bst_subtree_remove(min_val, right);\n            drop(node_borrow);\n            return Some(node);\n        } else if node_borrow.left.is_some() {\n            let left = node_borrow.left.take();\n            drop(node_borrow);\n            return left;\n        } else if node_borrow.right.is_some() {\n            let right = node_borrow.right.take();\n            drop(node_borrow);\n            return right;\n        } else {\n            drop(node_borrow);\n            return None;\n        }\n    }\n}\n\n",
        "_bst_node_create": "pub fn _bst_node_create<T>(val: T) -> Rc<RefCell<BstNode<T>>> {\n    let node = Rc::new(RefCell::new(BstNode {\n        val,\n        left: None,\n        right: None,\n    }));\n    node\n}\n\n",
        "bst_remove": "pub fn bst_remove<T: Ord + Clone>(val: T, bst: &mut Bst<T>) {\n    assert!(bst.root.is_some());\n\n    // We remove val by using our subtree removal function starting with the\n    // subtree rooted at bst->root (i.e. the whole tree).\n    let root = bst.root.take();\n    bst.root = _bst_subtree_remove(val, root);\n}\n\n",
        "bst_isempty": "pub fn bst_isempty<T>(bst: &Bst<T>) -> bool {\n    bst.root.is_none()\n}\n\n",
        "_bst_subtree_insert": "pub fn _bst_subtree_insert<T: PartialOrd + Clone>(val: T, n: Option<Rc<RefCell<BstNode<T>>>>) -> Option<Rc<RefCell<BstNode<T>>>> {\n    match n {\n        None => {\n            Some(_bst_node_create(val))\n        },\n        Some(node) => {\n            let mut node_mut = node.borrow_mut();\n            if val < node_mut.val {\n                node_mut.left = _bst_subtree_insert(val, node_mut.left.clone());\n            } else {\n                node_mut.right = _bst_subtree_insert(val, node_mut.right.clone());\n            }\n            Some(node.clone())\n        }\n    }\n}\n\n",
        "bst_free": "pub fn bst_free<T: Ord + Clone>(mut bst: Bst<T>) {\n    assert!(bst.root.is_some());\n\n    // Assume that bst_remove() frees each node it removes and use it to free\n    // all of the nodes in the tree.\n    while !bst_isempty(&bst) {\n        let root_val = bst.root.as_ref().unwrap().borrow().val.clone();\n        bst_remove(root_val, &mut bst);\n    }\n}\n\n",
        "bst_contains": "pub fn bst_contains<T: PartialOrd>(val: T, bst: &Bst<T>) -> bool {\n    assert!(bst.root.is_some());\n\n    let mut cur = bst.root.clone();\n    while let Some(node) = cur {\n        let node_ref = node.borrow();\n        if val == node_ref.val {\n            return true;\n        } else if val < node_ref.val {\n            cur = node_ref.left.clone();\n        } else {\n            cur = node_ref.right.clone();\n        }\n    }\n\n    false\n}\n\n",
        "bst_insert": "pub fn bst_insert<T: PartialOrd + Clone>(val: T, bst: &mut Bst<T>) {\n    assert!(bst.root.is_some());\n    bst.root = _bst_subtree_insert(val, bst.root.clone());\n}\n\n",
        "bst_create": "pub fn bst_create<T>() -> Bst<T> {\n    Bst { root: None }\n}\n\n"
    },
    "test-bst": {
        "main": "fn main(){}\n",
        "test_bst": "pub fn test_bst() {\n    let mut bst = bst_create();\n    let good_nums = [32, 16, 8, 12, 4, 64, 48, 80];\n    let bad_nums = [1, 3, 5, 7, 9, 11, 13, 15];\n\n    // Initialize the tree.\n    for i in 0..8 {\n        bst_insert(good_nums[i], &mut bst);\n    }\n\n    // Test containment.\n    for i in 0..8 {\n        assert!(bst_contains(good_nums[i], &bst));\n    }\n    println!(\"== Verified that BST contains all the expected values.\");\n\n    for i in 0..8 {\n        assert!(!bst_contains(bad_nums[i], &bst));\n    }\n    println!(\"== Verified that BST contains none of the unexpected values.\");\n\n    /*\n     * Test removal by removing one good number at a time and making sure the\n     * remaining good numbers are still in the tree.\n     */\n    for i in 0..8 {\n        bst_remove(good_nums[i], &mut bst);\n        assert!(!bst_contains(good_nums[i], &bst));\n        for j in (i + 1)..8 {\n            assert!(bst_contains(good_nums[j], &bst));\n        }\n    }\n    println!(\"== Verified removal works as expected.\");\n\n    bst_free(bst);\n}\n\n",
        "extra": "\nuse test_project::bst::{_bst_subtree_insert, bst_free, bst_contains, bst_isempty, bst_create, _bst_subtree_remove, _bst_node_create, bst_remove, _bst_subtree_min_val, bst_insert};\n"
    }
}