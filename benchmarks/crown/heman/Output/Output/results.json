{
    "test-heman": {
        "draw_circle": "pub fn draw_circle() -> HemanImage {\n    let mut img = heman_image_create(SIZE, SIZE, 1);\n    let inv = 1.0f32 / SIZE as f32;\n\n    for y in 0..SIZE {\n        let v = y as f32 * inv;\n        let dv2 = (v - 0.5f32) * (v - 0.5f32);\n        let dst_start = (y * SIZE) as usize;\n        let dst_end = dst_start + SIZE as usize;\n        let dst = &mut img.data[dst_start..dst_end];\n\n        for x in 0..SIZE {\n            let u = x as f32 * inv;\n            let du2 = (u - 0.5f32) * (u - 0.5f32);\n            dst[x as usize] = if du2 + dv2 < 0.0625f32 { 1.0 } else { 0.0 };\n        }\n    }\n\n    img\n}\n\n",
        "main": "fn main(){}\n\n",
        "extra": "pub const SIZE: i32 = 512;\npub type HEMAN_FLOAT = f64;\n\npub struct HemanImage {\n    pub width: i32,\n    pub height: i32,\n    pub channels: i32,\n    pub data: Vec<HEMAN_FLOAT>,\n}\n\npub const COUNT_CP_COLORS: usize = 7;\npub const CP_LOCATIONS: [i32; COUNT_CP_COLORS] = [0, 126, 127, 128, 160, 200, 255];\npub const CP_COLORS: [u32; COUNT_CP_COLORS] = [\n    0x001070, 0x2C5A7C, 0xE0F0A0, 0x5D943C, 0x606011, 0xFFFFFF, 0xFFFFFF,\n];\npub const OUTFOLDER: &str = \"./\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
        "test_lighting": "pub fn test_lighting() {\n    let grad = heman_color_create_gradient(256, COUNT_CP_COLORS, &CP_LOCATIONS, &CP_COLORS);\n\n    let mut hmap = heman_generate_island_heightmap(SIZE, SIZE, 1);\n    let hmapviz = heman_ops_normalize_f32(&hmap, -0.5, 0.5);\n\n    let occ = heman_lighting_compute_occlusion(&hmap);\n\n    let norm = heman_lighting_compute_normals(&hmap);\n    let normviz = heman_ops_normalize_f32(&norm, -1.0, 1.0);\n\n    let albedo = heman_color_apply_gradient(&hmap, -0.5, 0.5, &grad);\n\n    let lightpos = [-0.5f32, 0.5f32, 1.0f32];\n    let final_img = heman_lighting_apply(&hmap, &albedo, 1.0, 1.0, 0.5, &lightpos);\n\n    let mut frames: Vec<HemanImage> = Vec::new();\n    frames.push(heman_color_from_grayscale(&hmapviz));\n    frames.push(heman_color_from_grayscale(&occ));\n    frames.push(normviz);\n    frames.push(albedo);\n    frames.push(final_img);\n    \n    let filmstrip = heman_ops_stitch_horizontal(&frames);\n    hut_write_image(OUTFOLDER.to_string() + \"filmstrip.png\", &filmstrip, 0.0, 1.0);\n    heman_export_ply(&hmap, &(OUTFOLDER.to_string() + \"heightmap.ply\"));\n    heman_export_with_colors_ply(&hmap, &frames[4], &(OUTFOLDER.to_string() + \"colors.ply\"));\n}\n\n",
        "test_points_density": "pub fn test_points_density() {\n    pub const IMGRES: i32 = 256;\n\n    let mut density = heman_generate_island_heightmap(IMGRES, IMGRES, 1);\n    let tmp = heman_ops_normalize_f32(&density, -0.5, 0.5);\n    density = tmp;\n\n    let mut curvature = heman_ops_laplacian(&density);\n    let tmp = heman_ops_normalize_f32(&curvature, 0.0, 0.0005);\n    curvature = tmp;\n    heman_ops_accumulate(&mut curvature, &density);\n\n    let mut points = heman_points_from_density(&curvature, 0.001, 0.03);\n    let mut modulated = HemanImage {\n        width: IMGRES,\n        height: IMGRES,\n        channels: 1,\n        data: vec![0.0; (IMGRES * IMGRES) as usize],\n    };\n    heman_draw_points(&mut modulated, &points, 1.0);\n\n    let mut splats = HemanImage {\n        width: IMGRES,\n        height: IMGRES,\n        channels: 1,\n        data: vec![0.0; (IMGRES * IMGRES) as usize],\n    };\n    heman_draw_splats(&mut splats, &points, 4, 0.0);\n    splats = heman_ops_normalize_f32(&splats, 0.0, 0.4);\n\n    let frames = vec![density, curvature, modulated, splats];\n    let filmstrip = heman_ops_stitch_horizontal(&frames);\n\n    hut_write_image(OUTFOLDER.to_string() + \"densitypoints.png\", &filmstrip, 0.0, 1.0);\n}\n\npub fn heman_image_create(width: i32, height: i32, channels: i32) -> HemanImage {\n    HemanImage {\n        width,\n        height,\n        channels,\n        data: vec![0.0; (width * height * channels) as usize],\n    }\n}\n\n\npub fn heman_image_data(img: &mut HemanImage) -> &mut [HEMAN_FLOAT] {\n    &mut img.data\n}\n\n\npub fn heman_color_create_gradient(_width: i32, _count: usize, _locations: &[i32], _colors: &[u32]) -> HemanImage {\n    HemanImage {\n        width: 0,\n        height: 0,\n        channels: 0,\n        data: vec![],\n    }\n}\n\n\npub fn heman_lighting_compute_occlusion(_img: &HemanImage) -> HemanImage {\n    HemanImage {\n        width: 0,\n        height: 0,\n        channels: 0,\n        data: vec![],\n    }\n}\n\n\npub fn heman_lighting_compute_normals(_img: &HemanImage) -> HemanImage {\n    HemanImage {\n        width: 0,\n        height: 0,\n        channels: 0,\n        data: vec![],\n    }\n}\n\n\npub fn heman_color_apply_gradient(_img: &HemanImage, _min: f64, _max: f64, _grad: &HemanImage) -> HemanImage {\n    HemanImage {\n        width: 0,\n        height: 0,\n        channels: 0,\n        data: vec![],\n    }\n}\n\n\npub fn heman_lighting_apply(_hmap: &HemanImage, _albedo: &HemanImage, _a: f64, _b: f64, _c: f64, _lightpos: &[f32]) -> HemanImage {\n    HemanImage {\n        width: 0,\n        height: 0,\n        channels: 0,\n        data: vec![],\n    }\n}\n\n\npub fn heman_color_from_grayscale(_img: &HemanImage) -> HemanImage {\n    HemanImage {\n        width: 0,\n        height: 0,\n        channels: 0,\n        data: vec![],\n    }\n}\n\n\npub fn heman_export_ply(_img: &HemanImage, _path: &str) {}\n\n\npub fn heman_export_with_colors_ply(_img: &HemanImage, _colors: &HemanImage, _path: &str) {}\n\n\npub fn heman_generate_island_heightmap(width: i32, height: i32, channels: i32) -> HemanImage {\n    HemanImage {\n        width,\n        height,\n        channels,\n        data: vec![0.0; (width * height * channels) as usize],\n    }\n}\n\n\npub fn heman_ops_normalize_f32(img: &HemanImage, min: f64, max: f64) -> HemanImage {\n    let mut result = HemanImage {\n        width: img.width,\n        height: img.height,\n        channels: img.channels,\n        data: img.data.clone(),\n    };\n    result\n}\n\n\npub fn heman_ops_laplacian(img: &HemanImage) -> HemanImage {\n    HemanImage {\n        width: img.width,\n        height: img.height,\n        channels: img.channels,\n        data: img.data.clone(),\n    }\n}\n\n\npub fn heman_ops_accumulate(dst: &mut HemanImage, src: &HemanImage) {\n    for (d, s) in dst.data.iter_mut().zip(src.data.iter()) {\n        *d += s;\n    }\n}\n\n\npub fn heman_points_from_density(img: &HemanImage, min: f64, max: f64) -> Vec<(i32, i32)> {\n    vec![]\n}\n\n\npub fn heman_draw_points(img: &mut HemanImage, points: &[(i32, i32)], value: f64) {\n    for &(x, y) in points {\n        if x >= 0 && x < img.width && y >= 0 && y < img.height {\n            let idx = (y * img.width + x) as usize;\n            img.data[idx] = value;\n        }\n    }\n}\n\n\npub fn heman_draw_splats(img: &mut HemanImage, points: &[(i32, i32)], radius: i32, value: f64) {\n    for &(x, y) in points {\n        for dy in -radius..=radius {\n            for dx in -radius..=radius {\n                let nx = x + dx;\n                let ny = y + dy;\n                if nx >= 0 && nx < img.width && ny >= 0 && ny < img.height {\n                    let idx = (ny * img.width + nx) as usize;\n                    img.data[idx] = value;\n                }\n            }\n        }\n    }\n}\n\n\npub fn hut_write_image(path: String, img: &HemanImage, min: f64, max: f64) {}\n\n\npub fn heman_ops_stitch_horizontal(images: &[HemanImage]) -> HemanImage {\n    let width = images.iter().map(|img| img.width).sum();\n    let height = images[0].height;\n    let channels = images[0].channels;\n    let mut data = vec![0.0; (width * height * channels) as usize];\n    HemanImage {\n        width,\n        height,\n        channels,\n        data,\n    }\n}\n\n"
    },
    "test-planet": {
        "make_island": "pub fn make_island(seed: i32, grad: HemanImage<f32>) -> HemanImage<f32> {\n    let mut hmap = heman_generate_island_heightmap(HEIGHT, HEIGHT, seed);\n    let mut albedo = heman_color_apply_gradient(hmap.clone(), -0.5, 0.5, grad);\n    let island = heman_lighting_apply(hmap, albedo, 1.0, 1.0, 0.75, LIGHTPOS);\n    island\n}\n\npub fn heman_generate_island_heightmap(width: i32, height: i32, seed: i32) -> HemanImage<f32> {\n    HemanImage {\n        data: vec![0.0; (width * height) as usize],\n        width,\n        height,\n    }\n}\n\n\npub fn heman_color_apply_gradient(hmap: HemanImage<f32>, min: f32, max: f32, grad: HemanImage<f32>) -> HemanImage<f32> {\n    HemanImage {\n        data: vec![0.0; (hmap.width * hmap.height) as usize],\n        width: hmap.width,\n        height: hmap.height,\n    }\n}\n\n\npub fn heman_lighting_apply(hmap: HemanImage<f32>, albedo: HemanImage<f32>, ambient: f32, diffuse: f32, specular: f32, lightpos: [f32; 3]) -> HemanImage<f32> {\n    HemanImage {\n        data: vec![0.0; (hmap.width * hmap.height) as usize],\n        width: hmap.width,\n        height: hmap.height,\n    }\n}\n\n",
        "main": "fn main(){}\n",
        "extra": "\n\npub const HEIGHT: i32 = 128;\npub static LIGHTPOS: [f32; 3] = [-0.5f32, 0.5f32, 1.0f32];\n\npub struct HemanImage<T> {\n    pub data: Vec<T>,\n    pub width: i32,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for HemanImage<T> {\n    fn clone(&self) -> Self {\n        HemanImage {\n            data: self.data.clone(),\n            width: self.width,\n            height: self.height,\n        }\n    }\n}\n\n\n\n\n\n\n"
    }
}