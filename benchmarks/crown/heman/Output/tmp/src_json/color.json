{
    "heman_color_set_gamma": "void heman_color_set_gamma(float g) { _gamma = g; }\n",
    "heman_color_from_cpcf": "heman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture)\n{\n    if (!texture) {\n        return heman_internal_rg(cfield);\n    }\n    assert(cfield->nbands == 2);\n    assert(texture->nbands == 3 || texture->nbands == 4);\n    assert(cfield->width == texture->width);\n    assert(cfield->height == texture->height);\n    int w = cfield->width;\n    int h = cfield->height;\n    heman_image* target = heman_image_create(w, h, texture->nbands);\n    HEMAN_FLOAT* dst = target->data;\n    HEMAN_FLOAT* src = cfield->data;\n    int size = w * h;\n    for (int i = 0; i < size; i++) {\n        HEMAN_FLOAT u = *src++;\n        HEMAN_FLOAT v = *src++;\n        HEMAN_FLOAT* texel = heman_image_texel(texture, u, v);\n        for (int c = 0; c < texture->nbands; c++) {\n            *dst++ = *texel++;\n        }\n    }\n    return target;\n}\n",
    "heman_color_from_grayscale": "heman_image* heman_color_from_grayscale(heman_image* grayscale)\n{\n    assert(grayscale->nbands == 1);\n    int w = grayscale->width;\n    int h = grayscale->height;\n    heman_image* result = heman_image_create(w, h, 3);\n    int size = w * h;\n    HEMAN_FLOAT* dst = result->data;\n    const HEMAN_FLOAT* src = grayscale->data;\n    for (int i = 0; i < size; i++) {\n        HEMAN_FLOAT v = *src++;\n        *dst++ = v;\n        *dst++ = v;\n        *dst++ = v;\n    }\n    return result;\n}\n",
    "heman_color_to_grayscale": "heman_image* heman_color_to_grayscale(heman_image* colorimg)\n{\n    assert(colorimg->nbands == 3);\n    int w = colorimg->width;\n    int h = colorimg->height;\n    heman_image* result = heman_image_create(w, h, 1);\n    int size = w * h;\n    HEMAN_FLOAT* dst = result->data;\n    const HEMAN_FLOAT* src = colorimg->data;\n    for (int i = 0; i < size; i++) {\n        HEMAN_FLOAT r = *src++;\n        HEMAN_FLOAT g = *src++;\n        HEMAN_FLOAT b = *src++;\n        *dst++ = 0.299 * r + 0.587 * g + 0.114 * b;\n    }\n    return result;\n}\n",
    "heman_color_create_gradient": "heman_image* heman_color_create_gradient(int width, int num_colors,\n    const int* cp_locations, const heman_color* cp_values)\n{\n    assert(width > 0 && num_colors >= 2);\n    assert(cp_locations[0] == 0);\n    assert(cp_locations[num_colors - 1] == width - 1);\n\n    // Convert incoming colors to HEMAN_FLOATs and decode gamma.\n    HEMAN_FLOAT* f32colors = malloc(sizeof(HEMAN_FLOAT) * 3 * num_colors);\n    HEMAN_FLOAT inv = 1.0f / 255.0f;\n    HEMAN_FLOAT* f32color = f32colors;\n    const heman_color* u32color = cp_values;\n    for (int index = 0; index < num_colors; index++) {\n        heman_color rgb = *u32color++;\n        HEMAN_FLOAT r = (HEMAN_FLOAT)(rgb >> 16) * inv;\n        HEMAN_FLOAT g = (HEMAN_FLOAT)((rgb >> 8) & 0xff) * inv;\n        HEMAN_FLOAT b = (HEMAN_FLOAT)(rgb & 0xff) * inv;\n        *f32color++ = pow(r, _gamma);\n        *f32color++ = pow(g, _gamma);\n        *f32color++ = pow(b, _gamma);\n    }\n\n    // Create and populate a width x 1 image.\n    heman_image* result = heman_image_create(width, 1, 3);\n    int index0 = 0;\n    int index1 = 1;\n    HEMAN_FLOAT* dst = result->data;\n    HEMAN_FLOAT t, invgamma = 1.0f / _gamma;\n    for (int x = 0; x < width; x++) {\n        int loc0 = cp_locations[index0];\n        int loc1 = cp_locations[index1];\n        if (loc0 == loc1) {\n            t = 0;\n        } else {\n            t = (x - loc0) / (HEMAN_FLOAT)(loc1 - loc0);\n            if (t >= 1) {\n                --x;\n                ++index0;\n                index1 = MIN(index1 + 1, num_colors - 1);\n                continue;\n            }\n        }\n        HEMAN_FLOAT r0 = f32colors[index0 * 3];\n        HEMAN_FLOAT g0 = f32colors[index0 * 3 + 1];\n        HEMAN_FLOAT b0 = f32colors[index0 * 3 + 2];\n        HEMAN_FLOAT r1 = f32colors[index1 * 3];\n        HEMAN_FLOAT g1 = f32colors[index1 * 3 + 1];\n        HEMAN_FLOAT b1 = f32colors[index1 * 3 + 2];\n        HEMAN_FLOAT invt = 1.0f - t;\n        HEMAN_FLOAT r = (r0 * invt) + (r1 * t);\n        HEMAN_FLOAT g = (g0 * invt) + (g1 * t);\n        HEMAN_FLOAT b = (b0 * invt) + (b1 * t);\n        *dst++ = pow(r, invgamma);\n        *dst++ = pow(g, invgamma);\n        *dst++ = pow(b, invgamma);\n    }\n\n    free(f32colors);\n    return result;\n}\n",
    "heman_internal_rg": "heman_image* heman_internal_rg(heman_image* cfield)\n{\n    assert(cfield->nbands == 2);\n    int w = cfield->width;\n    int h = cfield->height;\n    heman_image* target = heman_image_create(w, h, 3);\n    HEMAN_FLOAT* dst = target->data;\n    HEMAN_FLOAT* src = cfield->data;\n    int size = w * h;\n    for (int i = 0; i < size; i++) {\n        HEMAN_FLOAT u = *src++ / w;\n        HEMAN_FLOAT v = *src++ / h;\n        *dst++ = u;\n        *dst++ = v;\n        *dst++ = 0;\n    }\n    return target;\n}\n",
    "heman_color_apply_gradient": "heman_image* heman_color_apply_gradient(heman_image* heightmap,\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient)\n{\n    assert(heightmap->nbands == 1);\n    assert(gradient->height == 1);\n    assert(gradient->nbands == 3);\n    int w = heightmap->width;\n    int h = heightmap->height;\n    heman_image* result = heman_image_create(w, h, 3);\n    int size = result->height * result->width;\n    HEMAN_FLOAT* dst = result->data;\n    const HEMAN_FLOAT* src = heightmap->data;\n    HEMAN_FLOAT scale = 1.0f / (maxheight - minheight);\n    for (int i = 0; i < size; i++, dst += 3, src++) {\n        HEMAN_FLOAT u = CLAMP01((*src - minheight) * scale);\n        heman_image_sample(gradient, u, 0.5f, dst);\n    }\n    return result;\n}\n",
    "extra": "{'heman_image_s': 'struct heman_image_s {\\n    int width;\\n    int height;\\n    int nbands;\\n    HEMAN_FLOAT* data;\\n};', '_gamma': 'float _gamma = 2.2f;', 'CLAMP': '#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))', 'CLAMP01': '#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)', 'EDGE': '#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))', 'HEMAN_FLOAT': '#define HEMAN_FLOAT double', 'MAX': '#define MAX(a, b) (a > b ? a : b)', 'MIN': '#define MIN(a, b) (a > b ? b : a)', 'PI': '#define PI (3.1415926535)', 'SGN': '#define SGN(x) ((x > 0) - (x < 0))', 'SQR': '#define SQR(x) ((x) * (x))', 'SWAP': '#define SWAP(type,a,b) {type _=a;a=b;b=_;}', 'TWO_OVER_PI': '#define TWO_OVER_PI (0.63661977236)', 'heman_byte': 'typedef unsigned char heman_byte;', 'heman_color': 'typedef unsigned int heman_color;', 'heman_image': 'typedef struct heman_image_s heman_image;', 'heman_points': 'typedef struct heman_image_s heman_points;'} extract_info: [// This is a private header.  Clients should not include it.\n\n#pragma once\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// An \"image\" encapsulates three integers (width, height, number of bands)\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\n// the API disallows struct definitions, so this is just an opaque handle.\ntypedef struct heman_image_s heman_image;\n\n// Point lists are actually one-dimensional images in disguise, usually with\n// two bands (X and Y coordinates).\ntypedef struct heman_image_s heman_points;\n\n// Image values in heman are always floating point, but clients may\n// choose either 32-bit floats or 64-bit floats at compile time.\n#ifdef USE_DOUBLE_PRECISION\n#define HEMAN_FLOAT double\n#else\n#define HEMAN_FLOAT float\n#endif\n\n// Occasionally the heman API accepts four-byte color for convenience.  For now\n// we're only using the lower three bytes (XRGB).\ntypedef unsigned int heman_color;\ntypedef unsigned char heman_byte;\n\n// Allocate a floating-point image with dimensions width x height x nbands.\nheman_image* heman_image_create(int width, int height, int nbands);\n\n// Obtain image properties.\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\n\n// Peek at the stored texel values.\nHEMAN_FLOAT* heman_image_data(heman_image*);\n\n// Peek at the stored texel values in a SWIG-amenable way.\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\n\n// Peek at the given texel value.\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\n\n// Find a reasonable value for the given normalized texture coord.\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\n\n// Set every band of every texel to the given value.\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\n\n// Free memory for a image.\nvoid heman_image_destroy(heman_image*);\n\n// Create a one-band image from a four-band image by extracting the 4th channel.\nheman_image* heman_image_extract_alpha(heman_image*);\n\n// Create a three-band image from a four-band image by extracting first 3 bands.\nheman_image* heman_image_extract_rgb(heman_image*);\n\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\n// the given control points, in a gamma correct way.  Each control point is\n// defined by an X location (one integer each) and an RGB value (one 32-bit\n// word for each color).\nheman_image* heman_color_create_gradient(int width, int num_colors,\n    const int* cp_locations, const heman_color* cp_colors);\n\n// This sets some global state that affects lighting and color interpolation.\n// The default value is 2.2.\nvoid heman_color_set_gamma(float f);\n\n// Create a 3-band image with the same dimensions as the given heightmap by\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\n// are normalized using the given minval, maxval range.\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\n\n// Convert a single-channel image into a 3-channel image via duplication.\nheman_image* heman_color_from_grayscale(heman_image* gray);\n\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\n\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\n\n// High-level function that uses several octaves of simplex noise and a signed\n// distance field to generate an interesting height map.\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\n\n// High-level function that deforms a hemisphere with simplex noise.\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\n\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\n// domain to generate an interesting lat-long height map.\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\n\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\n// Points can be 3-tuples, in which case the 3rd component represents the\n// strength of the seed point.\nheman_image* heman_generate_archipelago_heightmap(\n    int width, int height, heman_points* points, float noiseamt, int seed);\n\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\n// purely political boundaries are ignored when generating the finalized\n// height map.\nvoid heman_generate_archipelago_political(int width, int height,\n    heman_points* points, const heman_color* colors, heman_color ocean,\n    int seed, heman_image** elevation, heman_image** political,\n    int elevation_mode);\n\n// High-level function that sums up a number of noise octaves, also known as\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\n// fractals; this makes them more fractal-like. A good starting point is to use\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\n\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\nheman_image* heman_lighting_apply(heman_image* heightmap,\n    heman_image* colorbuffer, float occlusion, float diffuse,\n    float diffuse_softening, const float* light_position);\n\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\n// using simple forward differencing and OpenMP.\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\n\n// Compute occlusion values for the given heightmap, as described at\n// http://nothings.org/gamedev/horizon/.\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\n\n// Sets some global state that affects ambient occlusion computations.\nvoid heman_lighting_set_occlusion_scale(float s);\n\n// Create a one-band \"signed distance field\" based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\n\n// Create a one-band unsigned distance field based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_df(heman_image* monochrome);\n\n// Create a two-band \"closest point coordinate field\" containing the\n// non-normalized texture coordinates of the nearest seed.  The result is\n// related to the distance field but has a greater amount of information.\nheman_image* heman_distance_create_cpcf(heman_image* seed);\n\n// Convert a two-band coordinate field into an unsigned distance field.\nheman_image* heman_distance_from_cpcf(heman_image* cf);\n\n// Create a two-band CPCF where each texel contains its own coordinate.\nheman_image* heman_distance_identity_cpcf(int width, int height);\n\n// Create a single-channel floating point point image from bytes, such that\n// [0, 255] map to the given [minval, maxval] range.\nheman_image* heman_import_u8(int width, int height, int nbands,\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Create a mesh with (width - 1) x (height - 1) quads.\nvoid heman_export_ply(heman_image*, const char* filename);\n\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\nvoid heman_export_with_colors_ply(\n    heman_image* heightmap, heman_image* colors, const char* filename);\n\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\n// the result to \"dest\".  Values outside the range are clamped.\nvoid heman_export_u8(\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\n\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\n\n// Given a set of same-sized images, copy them into a vertical filmstrip.\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\n\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\n// result.  Values outside the range are clamped.  The source image is\n// untouched.\nheman_image* heman_ops_normalize_f32(\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Compute the maximum value between two height maps.\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\n\n// Generate a monochrome image by applying a step function.\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\n\n// Takes a 1-band elevation image and makes it tiered (scalloped).\n// Optionally takes a color mask, and applies the step operator only\n// in the regions with the given mask color.\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Similar to stairstep, but tries to guarantee that every tier\n// has the same total land area.\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Generate a height x 1 x 1 image by averaging the values across each row.\nheman_image* heman_ops_sweep(heman_image* image);\n\n// Provide a cheap way of measuring \"curvature\" that doesn't work well\n// at saddle points.  Returns a single-band image.\nheman_image* heman_ops_laplacian(heman_image* heightmap);\n\n// Highlight edges using the Sobel operator\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\n\n// Add the values of src into dst.\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\n\n// Use FBM and Perlin noise to warp the given image.\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\n\n// Same as ops_warp, but alos applies the warping operation to a point list.\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\n    heman_points* pts);\n\n// Consume a 3-band image and a color of interest; produce a 1-band image.\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\n\n// Replace a region of solid color with texture.\nheman_image* heman_ops_replace_color(\n    heman_image* src, heman_color color, heman_image* texture);\n\n// Create a 4-band image by merging a 3-band political image with\n// a 1-band elevation image.\nheman_image* heman_ops_merge_political(\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\n\n// Add coarse-grain noise to ocean and fine-grain noise to land.\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\n\n// Create a point list.\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\n\n// Free memory for a point list.\nvoid heman_points_destroy(heman_points*);\n\n// Perform simple stratified sampling over a grid.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\n\n// Perform Bridson's algorithm for Fast Poisson Disk sampling.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_poisson(\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\n\n// Perform Bridson's sampling algorithm, modulated by a density field.\n// Creates a two-band point list, sorted from high-density (low radius) to\n// low-density (high radius).\nheman_points* heman_points_from_density(\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\n\n// Set the given list of texels to the given value.\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\n\n// Set the given list of texels to the given list of colors.\nvoid heman_draw_colored_points(\n    heman_image* target, heman_points* coords, const heman_color* colors);\n\n// Draw colored circles into the given render target.\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\n    int radius, const heman_color* colors);\n\n// Draw a Gaussian splat at each given point.\n// The blend_mode parameter is ignored for now (it's always ADD).\nvoid heman_draw_splats(\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\n\n// Treats a set of points like blobs and draws a contour around them.\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\n    heman_color color, float mind, float maxd, int filterd);\n\n// This returns omp_get_max_threads() for diagnostic purposes.\nint heman_get_num_threads();\n\n#ifdef __cplusplus\n}\n#endif\n\nstruct heman_image_s {\n    int width;\n    int height;\n    int nbands;\n    HEMAN_FLOAT* data;\n};\n\nextern float _gamma;\n\n#define MIN(a, b) (a > b ? b : a)\n#define MAX(a, b) (a > b ? a : b)\n#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))\n#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)\n#define SGN(x) ((x > 0) - (x < 0))\n#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))\n#define TWO_OVER_PI (0.63661977236)\n#define PI (3.1415926535)\n#define SQR(x) ((x) * (x))\n#define SWAP(type,a,b) {type _=a;a=b;b=_;}\n\ninline HEMAN_FLOAT smoothstep(\n    HEMAN_FLOAT edge0, HEMAN_FLOAT edge1, HEMAN_FLOAT x)\n{\n    HEMAN_FLOAT t;\n    t = CLAMP01((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid generate_gaussian_row(int* target, int fwidth);\nvoid generate_gaussian_splat(HEMAN_FLOAT* target, int fwidth);\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\nfloat _gamma = 2.2f;\n\n\n\n\n\n\n\n]"
}