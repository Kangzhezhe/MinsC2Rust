{
    "heman_ops_sweep": "heman_image* heman_ops_sweep(heman_image* hmap)\n{\n    assert(hmap->nbands == 1);\n    heman_image* result = heman_image_create(hmap->height, 1, 1);\n    HEMAN_FLOAT* dst = result->data;\n    const HEMAN_FLOAT* src = hmap->data;\n    HEMAN_FLOAT invw = 1.0f / hmap->width;\n    for (int y = 0; y < hmap->height; y++) {\n        HEMAN_FLOAT acc = 0;\n        for (int x = 0; x < hmap->width; x++) {\n            acc += *src++;\n        }\n        *dst++ = (acc * invw);\n    }\n    return result;\n}\n",
    "heman_ops_replace_color": "heman_image* heman_ops_replace_color(\n    heman_image* source, heman_color color, heman_image* texture)\n{\n    assert(source->nbands == 3);\n    assert(texture->nbands == 3);\n    int height = source->height;\n    int width = source->width;\n    assert(texture->width == width);\n    assert(texture->height == height);\n    HEMAN_FLOAT inv = 1.0f / 255.0f;\n    HEMAN_FLOAT r = (HEMAN_FLOAT)(color >> 16) * inv;\n    HEMAN_FLOAT g = (HEMAN_FLOAT)((color >> 8) & 0xff) * inv;\n    HEMAN_FLOAT b = (HEMAN_FLOAT)(color & 0xff) * inv;\n    heman_image* result = heman_image_create(width, height, 3);\n\n    int y;\n#pragma omp parallel for\n    for (y = 0; y < height; y++) {\n        HEMAN_FLOAT* dst = result->data + y * width * 3;\n        HEMAN_FLOAT* src = source->data + y * width * 3;\n        HEMAN_FLOAT* tex = texture->data + y * width * 3;\n        for (int x = 0; x < width; x++, src += 3, dst += 3, tex += 3) {\n            if ((src[0] == r) && (src[1] == g) && (src[2] == b)) {\n                dst[0] = tex[0];\n                dst[1] = tex[1];\n                dst[2] = tex[2];\n            } else {\n                dst[0] = src[0];\n                dst[1] = src[1];\n                dst[2] = src[2];\n            }\n        }\n    }\n\n    return result;\n}\n",
    "heman_ops_laplacian": "heman_image* heman_ops_laplacian(heman_image* heightmap)\n{\n    assert(heightmap->nbands == 1);\n    int width = heightmap->width;\n    int height = heightmap->height;\n    heman_image* result = heman_image_create(width, height, 1);\n    int maxx = width - 1;\n    int maxy = height - 1;\n\n    int y;\n#pragma omp parallel for\n    for (y = 0; y < height; y++) {\n        int y1 = MIN(y + 1, maxy);\n        HEMAN_FLOAT* dst = result->data + y * width;\n        for (int x = 0; x < width; x++) {\n            int x1 = MIN(x + 1, maxx);\n            HEMAN_FLOAT p = *heman_image_texel(heightmap, x, y);\n            HEMAN_FLOAT px = *heman_image_texel(heightmap, x1, y);\n            HEMAN_FLOAT py = *heman_image_texel(heightmap, x, y1);\n            *dst++ = (p - px) * (p - px) + (p - py) * (p - py);\n        }\n    }\n\n    return result;\n}\n",
    "heman_ops_accumulate": "void heman_ops_accumulate(heman_image* dst, heman_image* src)\n{\n    assert(dst->nbands == src->nbands);\n    assert(dst->width == src->width);\n    assert(dst->height == src->height);\n    int size = dst->height * dst->width;\n    HEMAN_FLOAT* sdata = src->data;\n    HEMAN_FLOAT* ddata = dst->data;\n    for (int i = 0; i < size; ++i) {\n        *ddata++ += (*sdata++);\n    }\n",
    "heman_ops_emboss": "heman_image* heman_ops_emboss(heman_image* img, int mode)\n{\n    int seed = 1;\n    int octaves = 4;\n\n    struct osn_context* ctx;\n    open_simplex_noise(seed, &ctx);\n    int width = img->width;\n    int height = img->height;\n    assert(img->nbands == 1);\n    heman_image* result = heman_image_create(width, height, 1);\n    HEMAN_FLOAT invw = 1.0 / width;\n    HEMAN_FLOAT invh = 1.0 / height;\n    HEMAN_FLOAT inv = MIN(invw, invh);\n    float gain = 0.6;\n    float lacunarity = 2.0;\n    float land_amplitude = 0.0005;\n    float land_frequency = 256.0;\n    float ocean_amplitude = 0.5;\n    float ocean_frequency = 1.0;\n\n    int y;\n#pragma omp parallel for\n    for (y = 0; y < height; y++) {\n        HEMAN_FLOAT* dst = result->data + y * width;\n        for (int x = 0; x < width; x++) {\n            HEMAN_FLOAT z = *heman_image_texel(img, x, y);\n            if (z > 0 && mode == 1) {\n                float s = x * inv;\n                float t = y * inv;\n                float a = land_amplitude;\n                float f = land_frequency;\n                for (int i = 0; i < octaves; i++) {\n                    z += NOISEX(s, t, a, f);\n                    a *= gain;\n                    f *= lacunarity;\n                }\n            } else if (z <= 0 && mode == -1) {\n                z = MAX(z, -0.1);\n                float soften = fabsf(z);\n                float s = x * inv;\n                float t = y * inv;\n                float a = ocean_amplitude;\n                float f = ocean_frequency;\n                for (int i = 0; i < octaves; i++) {\n                    z += soften * NOISEX(s, t, a, f);\n                    a *= gain;\n                    f *= lacunarity;\n                }\n            }\n            *dst++ = z;\n        }\n    }\n\n    open_simplex_noise_free(ctx);\n    return result;\n}\n",
    "heman_ops_extract_mask": "heman_image* heman_ops_extract_mask(\n    heman_image* source, heman_color color, int invert)\n{\n    assert(source->nbands == 3);\n    HEMAN_FLOAT inv = 1.0f / 255.0f;\n    HEMAN_FLOAT r = (HEMAN_FLOAT)(color >> 16) * inv;\n    HEMAN_FLOAT g = (HEMAN_FLOAT)((color >> 8) & 0xff) * inv;\n    HEMAN_FLOAT b = (HEMAN_FLOAT)(color & 0xff) * inv;\n    int height = source->height;\n    int width = source->width;\n    heman_image* result = heman_image_create(width, height, 1);\n\n    int y;\n#pragma omp parallel for\n    for (y = 0; y < height; y++) {\n        HEMAN_FLOAT* dst = result->data + y * width;\n        HEMAN_FLOAT* src = source->data + y * width * 3;\n        for (int x = 0; x < width; x++, src += 3) {\n            HEMAN_FLOAT val = ((src[0] == r) && (src[1] == g) && (src[2] == b));\n            if (!invert) {\n                val = 1 - val;\n            }\n            *dst++ = val;\n        }\n    }\n\n    return result;\n}\n",
    "heman_ops_max": "heman_image* heman_ops_max(heman_image* imga, heman_image* imgb)\n{\n    assert(imga->width == imgb->width);\n    assert(imga->height == imgb->height);\n    assert(imga->nbands == imgb->nbands);\n    heman_image* result =\n        heman_image_create(imga->width, imga->height, imga->nbands);\n    int size = imga->height * imga->width * imga->nbands;\n    HEMAN_FLOAT* srca = imga->data;\n    HEMAN_FLOAT* srcb = imgb->data;\n    HEMAN_FLOAT* dst = result->data;\n    for (int i = 0; i < size; ++i, ++dst, ++srca, ++srcb) {\n        *dst = MAX(*srca, *srcb);\n    }\n    return result;\n}\n",
    "heman_ops_warp_core": "heman_image* heman_ops_warp_core(\n    heman_image* img, heman_image* secondary, int seed, int octaves)\n{\n    struct osn_context* ctx;\n    open_simplex_noise(seed, &ctx);\n    int width = img->width;\n    int height = img->height;\n    int nbands = img->nbands;\n    heman_image* result = heman_image_create(width, height, nbands);\n    heman_image* result2 =\n        secondary ? heman_image_create(width, height, secondary->nbands) : 0;\n    HEMAN_FLOAT invw = 1.0 / width;\n    HEMAN_FLOAT invh = 1.0 / height;\n    HEMAN_FLOAT inv = MIN(invw, invh);\n    HEMAN_FLOAT aspect = (float) width / height;\n    float gain = 0.6;\n    float lacunarity = 2.0;\n    float initial_amplitude = 0.05;\n    float initial_frequency = 8.0;\n\n    int y;\n#pragma omp parallel for\n    for (y = 0; y < height; y++) {\n        HEMAN_FLOAT* dst = result->data + y * width * nbands;\n        for (int x = 0; x < width; x++) {\n            float a = initial_amplitude;\n            float f = initial_frequency;\n\n            HEMAN_FLOAT* src;\n\n            // This is a little hack that modulates noise according to\n            // elevation, to prevent \"swimming\" at high elevations.\n            if (nbands == 4) {\n                src = heman_image_texel(img, x, y);\n                HEMAN_FLOAT elev = 1 - src[3];\n                a *= pow(elev, 4);\n            }\n\n            float s = x * inv;\n            float t = y * inv;\n            float u = x * invw;\n            float v = y * invh;\n            for (int i = 0; i < octaves; i++) {\n                u += NOISEX(s, t, a, f);\n                v += aspect * NOISEY(s, t, a, f);\n                a *= gain;\n                f *= lacunarity;\n            }\n            int i = CLAMP(u * width, 0, width - 1);\n            int j = CLAMP(v * height, 0, height - 1);\n            src = heman_image_texel(img, i, j);\n            for (int n = 0; n < nbands; n++) {\n                *dst++ = *src++;\n            }\n            if (secondary) {\n                src = heman_image_texel(secondary, x, y);\n                HEMAN_FLOAT* dst2 = heman_image_texel(result2, i, j);\n                for (int n = 0; n < secondary->nbands; n++) {\n                    *dst2++ = *src++;\n                }\n            }\n        }\n    }\n    open_simplex_noise_free(ctx);\n    if (secondary) {\n        free(secondary->data);\n        secondary->data = result2->data;\n        free(result2);\n    }\n    return result;\n}\n",
    "heman_ops_step": "heman_image* heman_ops_step(heman_image* hmap, HEMAN_FLOAT threshold)\n{\n    assert(hmap->nbands == 1);\n    heman_image* result = heman_image_create(hmap->width, hmap->height, 1);\n    int size = hmap->height * hmap->width;\n    HEMAN_FLOAT* src = hmap->data;\n    HEMAN_FLOAT* dst = result->data;\n    for (int i = 0; i < size; ++i) {\n        *dst++ = (*src++) >= threshold ? 1 : 0;\n    }\n    return result;\n}\n",
    "qselect": "static float qselect(float* v, int len, int k)\n{\n    int i, st;\n    for (st = i = 0; i < len - 1; i++) {\n        if (v[i] > v[len - 1]) {\n            continue;\n        }\n        SWAP(float, v[i], v[st]);\n        st++;\n    }\n    SWAP(float, v[len - 1], v[st]);\n    return k == st  ? v[st]\n           : st > k ? qselect(v, st, k)\n                    : qselect(v + st, len - st, k - st);\n}\n",
    "heman_ops_stairstep": "heman_image* heman_ops_stairstep(heman_image* hmap, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset)\n{\n    assert(hmap->nbands == 1);\n    assert(!mask || mask->nbands == 3);\n    int size = hmap->height * hmap->width;\n    HEMAN_FLOAT* src = hmap->data;\n    HEMAN_FLOAT minv = 1000;\n    HEMAN_FLOAT maxv = -1000;\n    for (int i = 0; i < size; ++i) {\n        if (!mask || _match(mask, mask_color, invert_mask, i)) {\n            minv = MIN(minv, src[i]);\n            maxv = MAX(maxv, src[i]);\n        }\n    }\n    HEMAN_FLOAT range = maxv - minv;\n    for (int i = 0; i < size; ++i) {\n        HEMAN_FLOAT e = *src;\n        if (!mask || _match(mask, mask_color, invert_mask, i)) {\n            e = e - minv;\n            e /= range;\n            e = floor(e * nsteps) / nsteps;\n            e = e * range + minv;\n        }\n        *src++ = e + offset;\n    }\n    return hmap;\n}\n",
    "heman_ops_stitch_vertical": "heman_image* heman_ops_stitch_vertical(heman_image** images, int count)\n{\n    assert(count > 0);\n    int width = images[0]->width;\n    int height = images[0]->height;\n    int nbands = images[0]->nbands;\n    for (int i = 1; i < count; i++) {\n        assert(images[i]->width == width);\n        assert(images[i]->height == height);\n        assert(images[i]->nbands == nbands);\n    }\n    heman_image* result = heman_image_create(width, height * count, nbands);\n    int size = width * height * nbands;\n    HEMAN_FLOAT* dst = result->data;\n    for (int tile = 0; tile < count; tile++) {\n        memcpy(dst, images[tile]->data, size * sizeof(float));\n        dst += size;\n    }\n    return result;\n}\n",
    "heman_ops_stitch_horizontal": "heman_image* heman_ops_stitch_horizontal(heman_image** images, int count)\n{\n    assert(count > 0);\n    int width = images[0]->width;\n    int height = images[0]->height;\n    int nbands = images[0]->nbands;\n    for (int i = 1; i < count; i++) {\n        assert(images[i]->width == width);\n        assert(images[i]->height == height);\n        assert(images[i]->nbands == nbands);\n    }\n    heman_image* result = heman_image_create(width * count, height, nbands);\n\n    int y;\n#pragma omp parallel for\n    for (y = 0; y < height; y++) {\n        for (int tile = 0; tile < count; tile++) {\n            copy_row(images[tile], result, tile * width, y);\n        }\n    }\n\n    return result;\n}\n",
    "heman_ops_percentiles": "heman_image* heman_ops_percentiles(heman_image* hmap, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset)\n{\n    assert(hmap->nbands == 1);\n    assert(!mask || mask->nbands == 3);\n    int size = hmap->height * hmap->width;\n    HEMAN_FLOAT* src = hmap->data;\n    HEMAN_FLOAT minv = 1000;\n    HEMAN_FLOAT maxv = -1000;\n    int npixels = 0;\n    for (int i = 0; i < size; ++i) {\n        if (!mask || _match(mask, mask_color, invert_mask, i)) {\n            minv = MIN(minv, src[i]);\n            maxv = MAX(maxv, src[i]);\n            npixels++;\n        }\n    }\n\n    HEMAN_FLOAT* vals = malloc(sizeof(HEMAN_FLOAT) * npixels);\n    npixels = 0;\n    for (int i = 0; i < size; ++i) {\n        if (!mask || _match(mask, mask_color, invert_mask, i)) {\n            vals[npixels++] = src[i];\n        }\n    }\n    HEMAN_FLOAT* percentiles = malloc(sizeof(HEMAN_FLOAT) * nsteps);\n    for (int tier = 0; tier < nsteps; tier++) {\n        float height = qselect(vals, npixels, tier * npixels / nsteps);\n        percentiles[tier] = height;\n    }\n    free(vals);\n\n    for (int i = 0; i < size; ++i) {\n        HEMAN_FLOAT e = *src;\n        if (!mask || _match(mask, mask_color, invert_mask, i)) {\n            for (int tier = nsteps - 1; tier >= 0; tier--) {\n                if (e > percentiles[tier]) {\n                    e = percentiles[tier];\n                    break;\n                }\n            }\n        }\n        *src++ = e + offset;\n    }\n    free(percentiles);\n\n    return hmap;\n}\n",
    "heman_get_num_threads": "int heman_get_num_threads() { return omp_get_max_threads(); }\n",
    "heman_ops_sobel": "heman_image* heman_ops_sobel(heman_image* img, heman_color rgb)\n{\n    int width = img->width;\n    int height = img->height;\n    assert(img->nbands == 3);\n    heman_image* result = heman_image_create(width, height, 3);\n    heman_image* gray = heman_color_to_grayscale(img);\n    HEMAN_FLOAT inv = 1.0f / 255.0f;\n\n    kmVec3 edge_rgb;\n    edge_rgb.x = (HEMAN_FLOAT)(rgb >> 16) * inv;\n    edge_rgb.y = (HEMAN_FLOAT)((rgb >> 8) & 0xff) * inv;\n    edge_rgb.z = (HEMAN_FLOAT)(rgb & 0xff) * inv;\n\n    int y;\n#pragma omp parallel for\n    for (y = 0; y < height; y++) {\n        kmVec3* dst = (kmVec3*) result->data + y * width;\n        const kmVec3* src = (kmVec3*) img->data + y * width;\n        for (int x = 0; x < width; x++) {\n            int xm1 = MAX(x - 1, 0);\n            int xp1 = MIN(x + 1, width - 1);\n            int ym1 = MAX(y - 1, 0);\n            int yp1 = MIN(y + 1, height - 1);\n            HEMAN_FLOAT t00 = *heman_image_texel(gray, xm1, ym1);\n            HEMAN_FLOAT t10 = *heman_image_texel(gray, x, ym1);\n            HEMAN_FLOAT t20 = *heman_image_texel(gray, xp1, ym1);\n            HEMAN_FLOAT t01 = *heman_image_texel(gray, xm1, 0);\n            HEMAN_FLOAT t21 = *heman_image_texel(gray, xp1, 0);\n            HEMAN_FLOAT t02 = *heman_image_texel(gray, xm1, yp1);\n            HEMAN_FLOAT t12 = *heman_image_texel(gray, x, yp1);\n            HEMAN_FLOAT t22 = *heman_image_texel(gray, xp1, yp1);\n            HEMAN_FLOAT gx = t00 + 2.0 * t01 + t02 - t20 - 2.0 * t21 - t22;\n            HEMAN_FLOAT gy = t00 + 2.0 * t10 + t20 - t02 - 2.0 * t12 - t22;\n            HEMAN_FLOAT is_edge = gx * gx + gy * gy > 1e-5;\n            kmVec3Lerp(dst++, src++, &edge_rgb, is_edge);\n        }\n    }\n\n    heman_image_destroy(gray);\n    return result;\n}\n",
    "heman_ops_warp_points": "heman_image* heman_ops_warp_points(\n    heman_image* img, int seed, int octaves, heman_points* pts)\n{\n    int width = img->width;\n    int height = img->height;\n    heman_image* mapping = heman_distance_identity_cpcf(width, height);\n    heman_image* retval = heman_ops_warp_core(img, mapping, seed, octaves);\n    HEMAN_FLOAT* src = pts->data;\n    for (int k = 0; k < pts->width; k++, src += pts->nbands) {\n        HEMAN_FLOAT x = src[0];\n        HEMAN_FLOAT y = src[1];\n        int i = x * mapping->width;\n        int j = y * mapping->height;\n        if (i < 0 || i >= mapping->width || j < 0 || j >= mapping->height) {\n            continue;\n        }\n        HEMAN_FLOAT* texel = heman_image_texel(mapping, i, j);\n        src[0] = texel[0] / mapping->width;\n        src[1] = texel[1] / mapping->height;\n    }\n    heman_image_destroy(mapping);\n    return retval;\n}\n",
    "_match": "static int _match(\n    heman_image* mask, heman_color mask_color, int invert_mask, int pixel_index)\n{\n    HEMAN_FLOAT* mcolor = mask->data + pixel_index * 3;\n    unsigned char r1 = mcolor[0] * 255;\n    unsigned char g1 = mcolor[1] * 255;\n    unsigned char b1 = mcolor[2] * 255;\n    unsigned char r2 = mask_color >> 16;\n    unsigned char g2 = (mask_color >> 8) & 0xff;\n    unsigned char b2 = (mask_color & 0xff);\n    int retval = r1 == r2 && g1 == g2 && b1 == b2;\n    return invert_mask ? (1 - retval) : retval;\n}\n",
    "heman_ops_merge_political": "heman_image* heman_ops_merge_political(\n    heman_image* hmap, heman_image* cmap, heman_color ocean)\n{\n    assert(hmap->nbands == 1);\n    assert(cmap->nbands == 3);\n    heman_image* result = heman_image_create(hmap->width, hmap->height, 4);\n    HEMAN_FLOAT* pheight = hmap->data;\n    HEMAN_FLOAT* pcolour = cmap->data;\n    HEMAN_FLOAT* pmerged = result->data;\n    HEMAN_FLOAT inv = 1.0f / 255.0f;\n    HEMAN_FLOAT oceanr = (HEMAN_FLOAT)(ocean >> 16) * inv;\n    HEMAN_FLOAT oceang = (HEMAN_FLOAT)((ocean >> 8) & 0xff) * inv;\n    HEMAN_FLOAT oceanb = (HEMAN_FLOAT)(ocean & 0xff) * inv;\n    int size = hmap->height * hmap->width;\n    float minh = 1000;\n    float maxh = -1000;\n    for (int i = 0; i < size; ++i) {\n        minh = MIN(minh, pheight[i]);\n        maxh = MIN(maxh, pheight[i]);\n    }\n    for (int i = 0; i < size; ++i) {\n        HEMAN_FLOAT h = *pheight++;\n        if (h < 0) {\n            *pmerged++ = oceanr;\n            *pmerged++ = oceang;\n            *pmerged++ = oceanb;\n            pcolour += 3;\n        } else {\n            *pmerged++ = *pcolour++;\n            *pmerged++ = *pcolour++;\n            *pmerged++ = *pcolour++;\n        }\n        *pmerged++ = (h - minh) / (maxh - minh);\n    }\n    return result;\n}\n",
    "heman_ops_warp": "heman_image* heman_ops_warp(heman_image* img, int seed, int octaves)\n{\n    return heman_ops_warp_core(img, 0, seed, octaves);\n}\n",
    "copy_row": "static void copy_row(heman_image* src, heman_image* dst, int dstx, int y)\n{\n    int width = src->width;\n    if (src->nbands == 1) {\n        for (int x = 0; x < width; x++) {\n            HEMAN_FLOAT* srcp = heman_image_texel(src, x, y);\n            HEMAN_FLOAT* dstp = heman_image_texel(dst, dstx + x, y);\n            *dstp = *srcp;\n        }\n        return;\n    }\n    for (int x = 0; x < width; x++) {\n        HEMAN_FLOAT* srcp = heman_image_texel(src, x, y);\n        HEMAN_FLOAT* dstp = heman_image_texel(dst, dstx + x, y);\n        int nbands = src->nbands;\n        while (nbands--) {\n            *dstp++ = *srcp++;\n        }\n",
    "heman_ops_normalize_f32": "heman_image* heman_ops_normalize_f32(\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv)\n{\n    heman_image* result =\n        heman_image_create(source->width, source->height, source->nbands);\n    HEMAN_FLOAT* src = source->data;\n    HEMAN_FLOAT* dst = result->data;\n    HEMAN_FLOAT scale = 1.0f / (maxv - minv);\n    int size = source->height * source->width * source->nbands;\n    for (int i = 0; i < size; ++i) {\n        HEMAN_FLOAT v = (*src++ - minv) * scale;\n        *dst++ = CLAMP(v, 0, 1);\n    }\n    return result;\n}\n",
    "extra": "{'heman_image_s': 'struct heman_image_s {\\n    int width;\\n    int height;\\n    int nbands;\\n    HEMAN_FLOAT* data;\\n};', 'kmVec3': '} kmVec3;', 'CLAMP': '#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))', 'CLAMP01': '#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)', 'EDGE': '#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))', 'HEMAN_FLOAT': '#define HEMAN_FLOAT double', 'KM_CONTAINS_ALL': '#define KM_CONTAINS_ALL (kmEnum)2', 'KM_CONTAINS_NONE': '#define KM_CONTAINS_NONE (kmEnum)0', 'KM_CONTAINS_PARTIAL': '#define KM_CONTAINS_PARTIAL (kmEnum)1', 'KM_FALSE': '#define KM_FALSE 0', 'KM_TRUE': '#define KM_TRUE 1', 'MAX': '#define MAX(a, b) (a > b ? a : b)', 'MIN': '#define MIN(a, b) (a > b ? b : a)', 'NOISEX': '#define NOISEX(U, V, A, F) (A * open_simplex_noise2(ctx, U * F, V * F))', 'NOISEY': '#define NOISEY(U, V, A, F) (A * open_simplex_noise2(ctx, U * F + 0.5, V * F))', 'OPEN_SIMPLEX_NOISE_H__': '#define OPEN_SIMPLEX_NOISE_H__', 'PI': '#define PI (3.1415926535)', 'SGN': '#define SGN(x) ((x > 0) - (x < 0))', 'SQR': '#define SQR(x) ((x) * (x))', 'SWAP': '#define SWAP(type,a,b) {type _=a;a=b;b=_;}', 'TWO_OVER_PI': '#define TWO_OVER_PI (0.63661977236)', 'UTILITY_H_INCLUDED': '#define UTILITY_H_INCLUDED', 'VEC3_H_INCLUDED': '#define VEC3_H_INCLUDED', 'kmBool': '#define kmBool unsigned char', 'kmEnum': '#define kmEnum unsigned int', 'kmEpsilon': '#define kmEpsilon 0.0001', 'kmInt': '#define kmInt int', 'kmPI': '#define kmPI 3.14159265358979323846f', 'kmPIOver180': '#define kmPIOver180  (kmPI / 180.0f)', 'kmPIUnder180': '#define kmPIUnder180 (180.0 / kmPI)', 'kmScalar': '#define kmScalar double', 'kmUchar': '#define kmUchar unsigned char', 'kmUint': '#define kmUint unsigned int', 'heman_byte': 'typedef unsigned char heman_byte;', 'heman_color': 'typedef unsigned int heman_color;', 'heman_image': 'typedef struct heman_image_s heman_image;', 'heman_points': 'typedef struct heman_image_s heman_points;'} extract_info: [// This is a private header.  Clients should not include it.\n\n#pragma once\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// An \"image\" encapsulates three integers (width, height, number of bands)\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\n// the API disallows struct definitions, so this is just an opaque handle.\ntypedef struct heman_image_s heman_image;\n\n// Point lists are actually one-dimensional images in disguise, usually with\n// two bands (X and Y coordinates).\ntypedef struct heman_image_s heman_points;\n\n// Image values in heman are always floating point, but clients may\n// choose either 32-bit floats or 64-bit floats at compile time.\n#ifdef USE_DOUBLE_PRECISION\n#define HEMAN_FLOAT double\n#else\n#define HEMAN_FLOAT float\n#endif\n\n// Occasionally the heman API accepts four-byte color for convenience.  For now\n// we're only using the lower three bytes (XRGB).\ntypedef unsigned int heman_color;\ntypedef unsigned char heman_byte;\n\n// Allocate a floating-point image with dimensions width x height x nbands.\nheman_image* heman_image_create(int width, int height, int nbands);\n\n// Obtain image properties.\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\n\n// Peek at the stored texel values.\nHEMAN_FLOAT* heman_image_data(heman_image*);\n\n// Peek at the stored texel values in a SWIG-amenable way.\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\n\n// Peek at the given texel value.\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\n\n// Find a reasonable value for the given normalized texture coord.\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\n\n// Set every band of every texel to the given value.\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\n\n// Free memory for a image.\nvoid heman_image_destroy(heman_image*);\n\n// Create a one-band image from a four-band image by extracting the 4th channel.\nheman_image* heman_image_extract_alpha(heman_image*);\n\n// Create a three-band image from a four-band image by extracting first 3 bands.\nheman_image* heman_image_extract_rgb(heman_image*);\n\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\n// the given control points, in a gamma correct way.  Each control point is\n// defined by an X location (one integer each) and an RGB value (one 32-bit\n// word for each color).\nheman_image* heman_color_create_gradient(int width, int num_colors,\n    const int* cp_locations, const heman_color* cp_colors);\n\n// This sets some global state that affects lighting and color interpolation.\n// The default value is 2.2.\nvoid heman_color_set_gamma(float f);\n\n// Create a 3-band image with the same dimensions as the given heightmap by\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\n// are normalized using the given minval, maxval range.\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\n\n// Convert a single-channel image into a 3-channel image via duplication.\nheman_image* heman_color_from_grayscale(heman_image* gray);\n\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\n\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\n\n// High-level function that uses several octaves of simplex noise and a signed\n// distance field to generate an interesting height map.\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\n\n// High-level function that deforms a hemisphere with simplex noise.\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\n\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\n// domain to generate an interesting lat-long height map.\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\n\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\n// Points can be 3-tuples, in which case the 3rd component represents the\n// strength of the seed point.\nheman_image* heman_generate_archipelago_heightmap(\n    int width, int height, heman_points* points, float noiseamt, int seed);\n\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\n// purely political boundaries are ignored when generating the finalized\n// height map.\nvoid heman_generate_archipelago_political(int width, int height,\n    heman_points* points, const heman_color* colors, heman_color ocean,\n    int seed, heman_image** elevation, heman_image** political,\n    int elevation_mode);\n\n// High-level function that sums up a number of noise octaves, also known as\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\n// fractals; this makes them more fractal-like. A good starting point is to use\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\n\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\nheman_image* heman_lighting_apply(heman_image* heightmap,\n    heman_image* colorbuffer, float occlusion, float diffuse,\n    float diffuse_softening, const float* light_position);\n\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\n// using simple forward differencing and OpenMP.\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\n\n// Compute occlusion values for the given heightmap, as described at\n// http://nothings.org/gamedev/horizon/.\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\n\n// Sets some global state that affects ambient occlusion computations.\nvoid heman_lighting_set_occlusion_scale(float s);\n\n// Create a one-band \"signed distance field\" based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\n\n// Create a one-band unsigned distance field based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_df(heman_image* monochrome);\n\n// Create a two-band \"closest point coordinate field\" containing the\n// non-normalized texture coordinates of the nearest seed.  The result is\n// related to the distance field but has a greater amount of information.\nheman_image* heman_distance_create_cpcf(heman_image* seed);\n\n// Convert a two-band coordinate field into an unsigned distance field.\nheman_image* heman_distance_from_cpcf(heman_image* cf);\n\n// Create a two-band CPCF where each texel contains its own coordinate.\nheman_image* heman_distance_identity_cpcf(int width, int height);\n\n// Create a single-channel floating point point image from bytes, such that\n// [0, 255] map to the given [minval, maxval] range.\nheman_image* heman_import_u8(int width, int height, int nbands,\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Create a mesh with (width - 1) x (height - 1) quads.\nvoid heman_export_ply(heman_image*, const char* filename);\n\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\nvoid heman_export_with_colors_ply(\n    heman_image* heightmap, heman_image* colors, const char* filename);\n\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\n// the result to \"dest\".  Values outside the range are clamped.\nvoid heman_export_u8(\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\n\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\n\n// Given a set of same-sized images, copy them into a vertical filmstrip.\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\n\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\n// result.  Values outside the range are clamped.  The source image is\n// untouched.\nheman_image* heman_ops_normalize_f32(\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Compute the maximum value between two height maps.\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\n\n// Generate a monochrome image by applying a step function.\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\n\n// Takes a 1-band elevation image and makes it tiered (scalloped).\n// Optionally takes a color mask, and applies the step operator only\n// in the regions with the given mask color.\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Similar to stairstep, but tries to guarantee that every tier\n// has the same total land area.\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Generate a height x 1 x 1 image by averaging the values across each row.\nheman_image* heman_ops_sweep(heman_image* image);\n\n// Provide a cheap way of measuring \"curvature\" that doesn't work well\n// at saddle points.  Returns a single-band image.\nheman_image* heman_ops_laplacian(heman_image* heightmap);\n\n// Highlight edges using the Sobel operator\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\n\n// Add the values of src into dst.\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\n\n// Use FBM and Perlin noise to warp the given image.\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\n\n// Same as ops_warp, but alos applies the warping operation to a point list.\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\n    heman_points* pts);\n\n// Consume a 3-band image and a color of interest; produce a 1-band image.\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\n\n// Replace a region of solid color with texture.\nheman_image* heman_ops_replace_color(\n    heman_image* src, heman_color color, heman_image* texture);\n\n// Create a 4-band image by merging a 3-band political image with\n// a 1-band elevation image.\nheman_image* heman_ops_merge_political(\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\n\n// Add coarse-grain noise to ocean and fine-grain noise to land.\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\n\n// Create a point list.\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\n\n// Free memory for a point list.\nvoid heman_points_destroy(heman_points*);\n\n// Perform simple stratified sampling over a grid.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\n\n// Perform Bridson's algorithm for Fast Poisson Disk sampling.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_poisson(\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\n\n// Perform Bridson's sampling algorithm, modulated by a density field.\n// Creates a two-band point list, sorted from high-density (low radius) to\n// low-density (high radius).\nheman_points* heman_points_from_density(\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\n\n// Set the given list of texels to the given value.\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\n\n// Set the given list of texels to the given list of colors.\nvoid heman_draw_colored_points(\n    heman_image* target, heman_points* coords, const heman_color* colors);\n\n// Draw colored circles into the given render target.\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\n    int radius, const heman_color* colors);\n\n// Draw a Gaussian splat at each given point.\n// The blend_mode parameter is ignored for now (it's always ADD).\nvoid heman_draw_splats(\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\n\n// Treats a set of points like blobs and draws a contour around them.\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\n    heman_color color, float mind, float maxd, int filterd);\n\n// This returns omp_get_max_threads() for diagnostic purposes.\nint heman_get_num_threads();\n\n#ifdef __cplusplus\n}\n#endif\n\nstruct heman_image_s {\n    int width;\n    int height;\n    int nbands;\n    HEMAN_FLOAT* data;\n};\n\nextern float _gamma;\n\n#define MIN(a, b) (a > b ? b : a)\n#define MAX(a, b) (a > b ? a : b)\n#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))\n#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)\n#define SGN(x) ((x > 0) - (x < 0))\n#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))\n#define TWO_OVER_PI (0.63661977236)\n#define PI (3.1415926535)\n#define SQR(x) ((x) * (x))\n#define SWAP(type,a,b) {type _=a;a=b;b=_;}\n\ninline HEMAN_FLOAT smoothstep(\n    HEMAN_FLOAT edge0, HEMAN_FLOAT edge1, HEMAN_FLOAT x)\n{\n    HEMAN_FLOAT t;\n    t = CLAMP01((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid generate_gaussian_row(int* target, int fwidth);\nvoid generate_gaussian_splat(HEMAN_FLOAT* target, int fwidth);\n#ifndef OPEN_SIMPLEX_NOISE_H__\n#define OPEN_SIMPLEX_NOISE_H__\n\n/*\n * OpenSimplex (Simplectic) Noise in C.\n * Ported to C from Kurt Spencer's java implementation by Stephen M. Cameron\n *\n * v1.1 (October 6, 2014)\n * - Ported to C\n *\n * v1.1 (October 5, 2014)\n * - Added 2D and 4D implementations.\n * - Proper gradient sets for all dimensions, from a\n *   dimensionally-generalizable scheme with an actual\n *   rhyme and reason behind it.\n * - Removed default permutation array in favor of\n *   default seed.\n * - Changed seed-based constructor to be independent\n *   of any particular randomization library, so results\n *   will be the same when ported to other languages.\n */\n#include <stdint.h>\n\nstruct osn_context;\n\nint open_simplex_noise(int64_t seed, struct osn_context** ctx);\nvoid open_simplex_noise_free(struct osn_context* ctx);\nint open_simplex_noise_init_perm(\n    struct osn_context* ctx, int16_t p[], int nelements);\ndouble open_simplex_noise2(struct osn_context* ctx, double x, double y);\ndouble open_simplex_noise3(\n    struct osn_context* ctx, double x, double y, double z);\ndouble open_simplex_noise4(\n    struct osn_context* ctx, double x, double y, double z, double w);\n\n#endif\n#include <assert.h>\n/*\nCopyright (c) 2008, Luke Benstead.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef VEC3_H_INCLUDED\n#define VEC3_H_INCLUDED\n\n#include <assert.h>\n/*\nCopyright (c) 2008, Luke Benstead.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef UTILITY_H_INCLUDED\n#define UTILITY_H_INCLUDED\n\n#include <math.h>\n\n#ifndef kmScalar\n#ifdef USE_DOUBLE_PRECISION\n#define kmScalar double\n#else\n#define kmScalar float\n#endif\n\n#endif\n\n#ifndef kmBool\n#define kmBool unsigned char\n#endif\n\n#ifndef kmUchar\n#define kmUchar unsigned char\n#endif\n\n#ifndef kmEnum\n#define kmEnum unsigned int\n#endif\n\n#ifndef kmUint\n#define kmUint unsigned int\n#endif\n\n#ifndef kmInt\n#define kmInt int\n#endif\n\n#ifndef KM_FALSE\n#define KM_FALSE 0\n#endif\n\n#ifndef KM_TRUE\n#define KM_TRUE 1\n#endif\n\n#define kmPI 3.14159265358979323846f\n#define kmPIOver180  (kmPI / 180.0f)\n#define kmPIUnder180 (180.0 / kmPI)\n#define kmEpsilon 0.0001\n\n#define KM_CONTAINS_NONE (kmEnum)0\n#define KM_CONTAINS_PARTIAL (kmEnum)1\n#define KM_CONTAINS_ALL (kmEnum)2\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern kmScalar kmSQR(kmScalar s);\nextern kmScalar kmDegreesToRadians(kmScalar degrees);\nextern kmScalar kmRadiansToDegrees(kmScalar radians);\n\nextern kmScalar kmMin(kmScalar lhs, kmScalar rhs);\nextern kmScalar kmMax(kmScalar lhs, kmScalar rhs);\nextern kmBool kmAlmostEqual(kmScalar lhs, kmScalar rhs);\n\nextern kmScalar kmClamp(kmScalar x, kmScalar min, kmScalar max);\nextern kmScalar kmLerp(kmScalar x, kmScalar y, kmScalar factor);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* UTILITY_H_INCLUDED */\n\nstruct kmMat4;\nstruct kmMat3;\nstruct kmPlane;\n\ntypedef struct kmVec3 {\n\tkmScalar x;\n\tkmScalar y;\n\tkmScalar z;\n} kmVec3;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nkmVec3* kmVec3Fill(kmVec3* pOut, kmScalar x, kmScalar y, kmScalar z);\nkmScalar kmVec3Length(const kmVec3* pIn); /** Returns the length of the vector */\nkmScalar kmVec3LengthSq(const kmVec3* pIn); /** Returns the square of the length of the vector */\nkmVec3* kmVec3Lerp(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2, kmScalar t);\nkmVec3* kmVec3Normalize(kmVec3* pOut, const kmVec3* pIn); /** Returns the vector passed in set to unit length */\nkmVec3* kmVec3Cross(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2); /** Returns a vector perpendicular to 2 other vectors */\nkmScalar kmVec3Dot(const kmVec3* pV1, const kmVec3* pV2); /** Returns the cosine of the angle between 2 vectors */\nkmVec3* kmVec3Add(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2); /** Adds 2 vectors and returns the result */\nkmVec3* kmVec3Subtract(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2); /** Subtracts 2 vectors and returns the result */\nkmVec3* kmVec3Mul( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 ); \nkmVec3* kmVec3Div( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 );\n\nkmVec3* kmVec3MultiplyMat3(kmVec3 *pOut, const kmVec3 *pV, const struct kmMat3* pM);\nkmVec3* kmVec3MultiplyMat4(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);\n\nkmVec3* kmVec3Transform(kmVec3* pOut, const kmVec3* pV1, const struct kmMat4* pM); /** Transforms a vector (assuming w=1) by a given matrix */\nkmVec3* kmVec3TransformNormal(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);/**Transforms a 3D normal by a given matrix */\nkmVec3* kmVec3TransformCoord(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM); /**Transforms a 3D vector by a given matrix, projecting the result back into w = 1. */\n\nkmVec3* kmVec3Scale(kmVec3* pOut, const kmVec3* pIn, const kmScalar s); /** Scales a vector to length s */\nint \tkmVec3AreEqual(const kmVec3* p1, const kmVec3* p2);\nkmVec3* kmVec3InverseTransform(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);\nkmVec3* kmVec3InverseTransformNormal(kmVec3* pOut, const kmVec3* pVect, const struct kmMat4* pM);\nkmVec3* kmVec3Assign(kmVec3* pOut, const kmVec3* pIn);\nkmVec3* kmVec3Zero(kmVec3* pOut);\nkmVec3* kmVec3GetHorizontalAngle(kmVec3* pOut, const kmVec3 *pIn); /** Get the rotations that would make a (0,0,1) direction vector point in the same direction as this direction vector. */\nkmVec3* kmVec3RotationToDirection(kmVec3* pOut, const kmVec3* pIn, const kmVec3* forwards); /** Builds a direction vector from input vector. */\n\nkmVec3* kmVec3ProjectOnToPlane(kmVec3* pOut, const kmVec3* point, const struct kmPlane* plane);\n\nkmVec3* kmVec3Reflect(kmVec3* pOut, const kmVec3* pIn, const kmVec3* normal); /**< Reflects a vector about a given surface normal. The surface normal is assumed to be of unit length. */\n\nextern const kmVec3 KM_VEC3_NEG_Z;\nextern const kmVec3 KM_VEC3_POS_Z;\nextern const kmVec3 KM_VEC3_POS_Y;\nextern const kmVec3 KM_VEC3_NEG_Y;\nextern const kmVec3 KM_VEC3_NEG_X;\nextern const kmVec3 KM_VEC3_POS_X;\nextern const kmVec3 KM_VEC3_ZERO;\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* VEC3_H_INCLUDED */\n#include <memory.h>\n#include <omp.h>\n#include <stdlib.h>\n\n#define NOISEX(U, V, A, F) (A * open_simplex_noise2(ctx, U * F, V * F))\n\n#define NOISEY(U, V, A, F) (A * open_simplex_noise2(ctx, U * F + 0.5, V * F))\n\n\n\n\n\n    }\n}\n\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n]"
}