{
    "heman_export_with_colors_ply": "void heman_export_with_colors_ply(\n    heman_image* hmap, heman_image* colors, const char* filename)\n{\n    int width = hmap->width;\n    int height = hmap->height;\n    assert(hmap->nbands == 1);\n    assert(colors->nbands == 3);\n    assert(colors->width == width);\n    assert(colors->height == height);\n    FILE* fout = fopen(filename, \"wb\");\n    int ncols = (hmap->width - 1);\n    int nrows = (hmap->height - 1);\n    int ncells = ncols * nrows;\n    int nverts = hmap->width * hmap->height;\n    unsigned char* colordata = malloc(width * height * 3);\n    heman_export_u8(colors, 0.0, 1.0, colordata);\n    fprintf(fout,\n        \"ply\\n\"\n        \"format binary_little_endian 1.0\\n\"\n        \"comment heman\\n\"\n        \"element vertex %d\\n\"\n        \"property float32 x\\n\"\n        \"property float32 y\\n\"\n        \"property float32 z\\n\"\n        \"property uchar red\\n\"\n        \"property uchar green\\n\"\n        \"property uchar blue\\n\"\n        \"property uchar alpha\\n\"\n        \"element face %d\\n\"\n        \"property list int32 int32 vertex_indices\\n\"\n        \"end_header\\n\",\n        nverts, ncells);\n    float invw = 2.0f / width;\n    float invh = 2.0f / height;\n    heman_byte* pcolor = colordata;\n    float vert[3];\n    for (int j = 0; j < height; j++) {\n        for (int i = 0; i < width; i++) {\n            vert[0] = -1 + i * invw;\n            vert[1] = -1 + j * invh;\n            vert[2] = *heman_image_texel(hmap, i, j);\n            fwrite(vert, sizeof(vert), 1, fout);\n            fwrite(pcolor, 3, 1, fout);\n            pcolor += 3;\n            fputc(255, fout);\n        }\n    }\n    int face[5];\n    face[0] = 4;\n    for (int j = 0; j < nrows; j++) {\n        int p = j * width;\n        for (int i = 0; i < ncols; i++, p++) {\n            face[1] = p;\n            face[2] = p + 1;\n            face[3] = p + hmap->width + 1;\n            face[4] = p + hmap->width;\n            fwrite(face, sizeof(face), 1, fout);\n        }\n    }\n    fclose(fout);\n    free(colordata);\n}\n",
    "heman_export_ply": "void heman_export_ply(heman_image* img, const char* filename)\n{\n    assert(img->nbands == 1);\n    FILE* fout = fopen(filename, \"wb\");\n    int ncols = (img->width - 1);\n    int nrows = (img->height - 1);\n    int ncells = ncols * nrows;\n    int nverts = img->width * img->height;\n    fprintf(fout,\n        \"ply\\n\"\n        \"format binary_little_endian 1.0\\n\"\n        \"comment heman\\n\"\n        \"element vertex %d\\n\"\n        \"property float32 x\\n\"\n        \"property float32 y\\n\"\n        \"property float32 z\\n\"\n        \"element face %d\\n\"\n        \"property list int32 int32 vertex_indices\\n\"\n        \"end_header\\n\",\n        nverts, ncells);\n    float invw = 2.0f / img->width;\n    float invh = 2.0f / img->height;\n    float vert[3];\n    for (int j = 0; j < img->height; j++) {\n        for (int i = 0; i < img->width; i++) {\n            vert[0] = -1 + i * invw;\n            vert[1] = -1 + j * invh;\n            vert[2] = *heman_image_texel(img, i, j);\n            fwrite(vert, sizeof(vert), 1, fout);\n        }\n    }\n    int face[5];\n    face[0] = 4;\n    for (int j = 0; j < nrows; j++) {\n        int p = j * img->width;\n        for (int i = 0; i < ncols; i++, p++) {\n            face[1] = p;\n            face[2] = p + 1;\n            face[3] = p + img->width + 1;\n            face[4] = p + img->width;\n            fwrite(face, sizeof(face), 1, fout);\n        }\n    }\n    fclose(fout);\n}\n",
    "heman_export_u8": "void heman_export_u8(\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp)\n{\n    const HEMAN_FLOAT* inp = source->data;\n    HEMAN_FLOAT scale = 1.0f / (maxv - minv);\n    int size = source->height * source->width * source->nbands;\n    for (int i = 0; i < size; ++i) {\n        HEMAN_FLOAT v = 255 * (*inp++ - minv) * scale;\n        *outp++ = CLAMP(v, 0, 255);\n    }\n",
    "extra": "{'heman_image_s': 'struct heman_image_s {\\n    int width;\\n    int height;\\n    int nbands;\\n    HEMAN_FLOAT* data;\\n};', 'CLAMP': '#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))', 'CLAMP01': '#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)', 'EDGE': '#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))', 'HEMAN_FLOAT': '#define HEMAN_FLOAT double', 'MAX': '#define MAX(a, b) (a > b ? a : b)', 'MIN': '#define MIN(a, b) (a > b ? b : a)', 'PI': '#define PI (3.1415926535)', 'SGN': '#define SGN(x) ((x > 0) - (x < 0))', 'SQR': '#define SQR(x) ((x) * (x))', 'SWAP': '#define SWAP(type,a,b) {type _=a;a=b;b=_;}', 'TWO_OVER_PI': '#define TWO_OVER_PI (0.63661977236)', 'heman_byte': 'typedef unsigned char heman_byte;', 'heman_color': 'typedef unsigned int heman_color;', 'heman_image': 'typedef struct heman_image_s heman_image;', 'heman_points': 'typedef struct heman_image_s heman_points;'} extract_info: [// This is a private header.  Clients should not include it.\n\n#pragma once\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// An \"image\" encapsulates three integers (width, height, number of bands)\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\n// the API disallows struct definitions, so this is just an opaque handle.\ntypedef struct heman_image_s heman_image;\n\n// Point lists are actually one-dimensional images in disguise, usually with\n// two bands (X and Y coordinates).\ntypedef struct heman_image_s heman_points;\n\n// Image values in heman are always floating point, but clients may\n// choose either 32-bit floats or 64-bit floats at compile time.\n#ifdef USE_DOUBLE_PRECISION\n#define HEMAN_FLOAT double\n#else\n#define HEMAN_FLOAT float\n#endif\n\n// Occasionally the heman API accepts four-byte color for convenience.  For now\n// we're only using the lower three bytes (XRGB).\ntypedef unsigned int heman_color;\ntypedef unsigned char heman_byte;\n\n// Allocate a floating-point image with dimensions width x height x nbands.\nheman_image* heman_image_create(int width, int height, int nbands);\n\n// Obtain image properties.\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\n\n// Peek at the stored texel values.\nHEMAN_FLOAT* heman_image_data(heman_image*);\n\n// Peek at the stored texel values in a SWIG-amenable way.\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\n\n// Peek at the given texel value.\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\n\n// Find a reasonable value for the given normalized texture coord.\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\n\n// Set every band of every texel to the given value.\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\n\n// Free memory for a image.\nvoid heman_image_destroy(heman_image*);\n\n// Create a one-band image from a four-band image by extracting the 4th channel.\nheman_image* heman_image_extract_alpha(heman_image*);\n\n// Create a three-band image from a four-band image by extracting first 3 bands.\nheman_image* heman_image_extract_rgb(heman_image*);\n\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\n// the given control points, in a gamma correct way.  Each control point is\n// defined by an X location (one integer each) and an RGB value (one 32-bit\n// word for each color).\nheman_image* heman_color_create_gradient(int width, int num_colors,\n    const int* cp_locations, const heman_color* cp_colors);\n\n// This sets some global state that affects lighting and color interpolation.\n// The default value is 2.2.\nvoid heman_color_set_gamma(float f);\n\n// Create a 3-band image with the same dimensions as the given heightmap by\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\n// are normalized using the given minval, maxval range.\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\n\n// Convert a single-channel image into a 3-channel image via duplication.\nheman_image* heman_color_from_grayscale(heman_image* gray);\n\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\n\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\n\n// High-level function that uses several octaves of simplex noise and a signed\n// distance field to generate an interesting height map.\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\n\n// High-level function that deforms a hemisphere with simplex noise.\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\n\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\n// domain to generate an interesting lat-long height map.\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\n\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\n// Points can be 3-tuples, in which case the 3rd component represents the\n// strength of the seed point.\nheman_image* heman_generate_archipelago_heightmap(\n    int width, int height, heman_points* points, float noiseamt, int seed);\n\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\n// purely political boundaries are ignored when generating the finalized\n// height map.\nvoid heman_generate_archipelago_political(int width, int height,\n    heman_points* points, const heman_color* colors, heman_color ocean,\n    int seed, heman_image** elevation, heman_image** political,\n    int elevation_mode);\n\n// High-level function that sums up a number of noise octaves, also known as\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\n// fractals; this makes them more fractal-like. A good starting point is to use\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\n\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\nheman_image* heman_lighting_apply(heman_image* heightmap,\n    heman_image* colorbuffer, float occlusion, float diffuse,\n    float diffuse_softening, const float* light_position);\n\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\n// using simple forward differencing and OpenMP.\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\n\n// Compute occlusion values for the given heightmap, as described at\n// http://nothings.org/gamedev/horizon/.\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\n\n// Sets some global state that affects ambient occlusion computations.\nvoid heman_lighting_set_occlusion_scale(float s);\n\n// Create a one-band \"signed distance field\" based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\n\n// Create a one-band unsigned distance field based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_df(heman_image* monochrome);\n\n// Create a two-band \"closest point coordinate field\" containing the\n// non-normalized texture coordinates of the nearest seed.  The result is\n// related to the distance field but has a greater amount of information.\nheman_image* heman_distance_create_cpcf(heman_image* seed);\n\n// Convert a two-band coordinate field into an unsigned distance field.\nheman_image* heman_distance_from_cpcf(heman_image* cf);\n\n// Create a two-band CPCF where each texel contains its own coordinate.\nheman_image* heman_distance_identity_cpcf(int width, int height);\n\n// Create a single-channel floating point point image from bytes, such that\n// [0, 255] map to the given [minval, maxval] range.\nheman_image* heman_import_u8(int width, int height, int nbands,\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Create a mesh with (width - 1) x (height - 1) quads.\nvoid heman_export_ply(heman_image*, const char* filename);\n\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\nvoid heman_export_with_colors_ply(\n    heman_image* heightmap, heman_image* colors, const char* filename);\n\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\n// the result to \"dest\".  Values outside the range are clamped.\nvoid heman_export_u8(\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\n\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\n\n// Given a set of same-sized images, copy them into a vertical filmstrip.\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\n\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\n// result.  Values outside the range are clamped.  The source image is\n// untouched.\nheman_image* heman_ops_normalize_f32(\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Compute the maximum value between two height maps.\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\n\n// Generate a monochrome image by applying a step function.\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\n\n// Takes a 1-band elevation image and makes it tiered (scalloped).\n// Optionally takes a color mask, and applies the step operator only\n// in the regions with the given mask color.\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Similar to stairstep, but tries to guarantee that every tier\n// has the same total land area.\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Generate a height x 1 x 1 image by averaging the values across each row.\nheman_image* heman_ops_sweep(heman_image* image);\n\n// Provide a cheap way of measuring \"curvature\" that doesn't work well\n// at saddle points.  Returns a single-band image.\nheman_image* heman_ops_laplacian(heman_image* heightmap);\n\n// Highlight edges using the Sobel operator\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\n\n// Add the values of src into dst.\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\n\n// Use FBM and Perlin noise to warp the given image.\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\n\n// Same as ops_warp, but alos applies the warping operation to a point list.\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\n    heman_points* pts);\n\n// Consume a 3-band image and a color of interest; produce a 1-band image.\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\n\n// Replace a region of solid color with texture.\nheman_image* heman_ops_replace_color(\n    heman_image* src, heman_color color, heman_image* texture);\n\n// Create a 4-band image by merging a 3-band political image with\n// a 1-band elevation image.\nheman_image* heman_ops_merge_political(\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\n\n// Add coarse-grain noise to ocean and fine-grain noise to land.\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\n\n// Create a point list.\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\n\n// Free memory for a point list.\nvoid heman_points_destroy(heman_points*);\n\n// Perform simple stratified sampling over a grid.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\n\n// Perform Bridson's algorithm for Fast Poisson Disk sampling.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_poisson(\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\n\n// Perform Bridson's sampling algorithm, modulated by a density field.\n// Creates a two-band point list, sorted from high-density (low radius) to\n// low-density (high radius).\nheman_points* heman_points_from_density(\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\n\n// Set the given list of texels to the given value.\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\n\n// Set the given list of texels to the given list of colors.\nvoid heman_draw_colored_points(\n    heman_image* target, heman_points* coords, const heman_color* colors);\n\n// Draw colored circles into the given render target.\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\n    int radius, const heman_color* colors);\n\n// Draw a Gaussian splat at each given point.\n// The blend_mode parameter is ignored for now (it's always ADD).\nvoid heman_draw_splats(\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\n\n// Treats a set of points like blobs and draws a contour around them.\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\n    heman_color color, float mind, float maxd, int filterd);\n\n// This returns omp_get_max_threads() for diagnostic purposes.\nint heman_get_num_threads();\n\n#ifdef __cplusplus\n}\n#endif\n\nstruct heman_image_s {\n    int width;\n    int height;\n    int nbands;\n    HEMAN_FLOAT* data;\n};\n\nextern float _gamma;\n\n#define MIN(a, b) (a > b ? b : a)\n#define MAX(a, b) (a > b ? a : b)\n#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))\n#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)\n#define SGN(x) ((x > 0) - (x < 0))\n#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))\n#define TWO_OVER_PI (0.63661977236)\n#define PI (3.1415926535)\n#define SQR(x) ((x) * (x))\n#define SWAP(type,a,b) {type _=a;a=b;b=_;}\n\ninline HEMAN_FLOAT smoothstep(\n    HEMAN_FLOAT edge0, HEMAN_FLOAT edge1, HEMAN_FLOAT x)\n{\n    HEMAN_FLOAT t;\n    t = CLAMP01((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid generate_gaussian_row(int* target, int fwidth);\nvoid generate_gaussian_splat(HEMAN_FLOAT* target, int fwidth);\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n\n\n}\n]"
}