{
    "heman_points_from_density": "heman_points* heman_points_from_density(\n    heman_image* density, HEMAN_FLOAT minradius, HEMAN_FLOAT maxradius)\n{\n    assert(density->nbands == 1);\n    float width = 1, height = 1;\n    int maxattempts = 30;\n    float rscale = 1.0f / UINT_MAX;\n    unsigned int seed = 0;\n    kmVec2 rvec;\n    rvec.x = rvec.y = maxradius;\n    int gindex;\n\n    // Acceleration grid.\n    float cellsize = maxradius / sqrtf(2);\n    float invcell = 1.0f / cellsize;\n    int ncols = ceil(width * invcell);\n    int nrows = ceil(height * invcell);\n    int maxcol = ncols - 1;\n    int maxrow = nrows - 1;\n    int ncells = ncols * nrows;\n    int ntexels = cellsize * density->width;\n    int gcapacity = ntexels * ntexels;\n    int* grid = malloc(ncells * sizeof(int) * gcapacity);\n    int* ngrid = malloc(ncells * sizeof(int));\n    for (int i = 0; i < ncells; i++) {\n        ngrid[i] = 0;\n    }\n\n    // Active list and resulting sample list.\n    int* actives = malloc(ncells * sizeof(int));\n    int nactives = 0;\n    int maxsamples = ncells * gcapacity;\n    heman_points* result = heman_image_create(maxsamples, 1, 2);\n    kmVec2* samples = (kmVec2*) result->data;\n    int nsamples = 0;\n\n    // First sample.\n    kmVec2 pt;\n    pt.x = width * randhash(seed++) * rscale;\n    pt.y = height * randhash(seed++) * rscale;\n    actives[nactives++] = nsamples;\n    GRID_INSERT(pt, nsamples);\n    samples[nsamples++] = pt;\n\n    while (nsamples < maxsamples) {\n        int aindex = MIN(randhashf(seed++, 0, nactives), nactives - 1);\n        int sindex = actives[aindex];\n        int found = 0;\n        kmVec2 j, minj, maxj, delta;\n        int attempt;\n        for (attempt = 0; attempt < maxattempts && !found; attempt++) {\n            pt = sample_annulus(maxradius, samples[sindex], &seed);\n\n            // Check that this sample is within bounds.\n            if (pt.x < 0 || pt.x >= width || pt.y < 0 || pt.y >= height) {\n                continue;\n            }\n\n            // Test proximity to nearby samples.\n            minj = maxj = pt;\n            kmVec2Add(&maxj, &maxj, &rvec);\n            kmVec2Subtract(&minj, &minj, &rvec);\n            kmVec2Scale(&minj, &minj, invcell);\n            kmVec2Scale(&maxj, &maxj, invcell);\n            minj.x = CLAMP((int) minj.x, 0, maxcol);\n            maxj.x = CLAMP((int) maxj.x, 0, maxcol);\n            minj.y = CLAMP((int) minj.y, 0, maxrow);\n            maxj.y = CLAMP((int) maxj.y, 0, maxrow);\n            int reject = 0;\n\n            HEMAN_FLOAT densityval;\n            heman_image_sample(density, pt.x, pt.y, &densityval);\n\n            // The following square root seems to lead to more satisfying\n            // results, although we should perhaps let the client decide...\n            densityval = sqrt(densityval);\n\n            float mindist = maxradius - densityval * (maxradius - minradius);\n            float r2 = mindist * mindist;\n\n            for (j.y = minj.y; j.y <= maxj.y && !reject; j.y++) {\n                for (j.x = minj.x; j.x <= maxj.x && !reject; j.x++) {\n                    for (int g = GRID_BEGIN(j); g < GRID_END(j); ++g) {\n                        int entry = grid[g];\n                        if (entry != sindex) {\n                            kmVec2Subtract(&delta, &samples[entry], &pt);\n                            if (kmVec2LengthSq(&delta) < r2) {\n                                reject = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            if (reject) {\n                continue;\n            }\n            found = 1;\n        }\n        if (found && ngrid[NGRID_INDEX(pt)] >= gcapacity) {\n            found = 0;\n        }\n        if (found) {\n            actives[nactives++] = nsamples;\n            GRID_INSERT(pt, nsamples);\n            samples[nsamples++] = pt;\n        } else {\n            if (--nactives <= 0) {\n                break;\n            }\n            actives[aindex] = actives[nactives];\n        }\n    }\n\n    // We don't usually fill the pre-allocated buffer, since it was\n    // allocated for the worst case, so adjust the size:\n    result->width = nsamples;\n\n    free(grid);\n    free(ngrid);\n    free(actives);\n    return result;\n}\n",
    "heman_points_from_poisson": "heman_points* heman_points_from_poisson(\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT radius)\n{\n    int maxattempts = 30;\n    float rscale = 1.0f / UINT_MAX;\n    unsigned int seed = 0;\n    kmVec2 rvec;\n    rvec.x = rvec.y = radius;\n    float r2 = radius * radius;\n\n    // Acceleration grid.\n    float cellsize = radius / sqrtf(2);\n    float invcell = 1.0f / cellsize;\n    int ncols = ceil(width * invcell);\n    int nrows = ceil(height * invcell);\n    int maxcol = ncols - 1;\n    int maxrow = nrows - 1;\n    int ncells = ncols * nrows;\n    int* grid = malloc(ncells * sizeof(int));\n    for (int i = 0; i < ncells; i++) {\n        grid[i] = -1;\n    }\n\n    // Active list and resulting sample list.\n    int* actives = malloc(ncells * sizeof(int));\n    int nactives = 0;\n    heman_points* result = heman_image_create(ncells, 1, 2);\n    kmVec2* samples = (kmVec2*) result->data;\n    int nsamples = 0;\n\n    // First sample.\n    kmVec2 pt;\n    pt.x = width * randhash(seed++) * rscale;\n    pt.y = height * randhash(seed++) * rscale;\n    GRIDF(pt) = actives[nactives++] = nsamples;\n    samples[nsamples++] = pt;\n\n    while (nsamples < ncells) {\n        int aindex = MIN(randhashf(seed++, 0, nactives), nactives - 1);\n        int sindex = actives[aindex];\n        int found = 0;\n        kmVec2 j, minj, maxj, delta;\n        int attempt;\n        for (attempt = 0; attempt < maxattempts && !found; attempt++) {\n            pt = sample_annulus(radius, samples[sindex], &seed);\n\n            // Check that this sample is within bounds.\n            if (pt.x < 0 || pt.x >= width || pt.y < 0 || pt.y >= height) {\n                continue;\n            }\n\n            // Test proximity to nearby samples.\n            minj = maxj = pt;\n            kmVec2Add(&maxj, &maxj, &rvec);\n            kmVec2Subtract(&minj, &minj, &rvec);\n            kmVec2Scale(&minj, &minj, invcell);\n            kmVec2Scale(&maxj, &maxj, invcell);\n            minj.x = CLAMP((int) minj.x, 0, maxcol);\n            maxj.x = CLAMP((int) maxj.x, 0, maxcol);\n            minj.y = CLAMP((int) minj.y, 0, maxrow);\n            maxj.y = CLAMP((int) maxj.y, 0, maxrow);\n            int reject = 0;\n            for (j.y = minj.y; j.y <= maxj.y && !reject; j.y++) {\n                for (j.x = minj.x; j.x <= maxj.x && !reject; j.x++) {\n                    int entry = GRIDI(j);\n                    if (entry > -1 && entry != sindex) {\n                        kmVec2Subtract(&delta, &samples[entry], &pt);\n                        if (kmVec2LengthSq(&delta) < r2) {\n                            reject = 1;\n                        }\n                    }\n                }\n            }\n            if (reject) {\n                continue;\n            }\n            found = 1;\n        }\n        if (found) {\n            GRIDF(pt) = actives[nactives++] = nsamples;\n            samples[nsamples++] = pt;\n        } else {\n            if (--nactives <= 0) {\n                break;\n            }\n            actives[aindex] = actives[nactives];\n        }\n    }\n\n    // The following line probably isn't necessary.  Paranoia.\n    result->width = nsamples;\n\n    free(grid);\n    free(actives);\n    return result;\n}\n",
    "sample_annulus": "kmVec2 sample_annulus(float radius, kmVec2 center, unsigned int* seedptr)\n{\n    unsigned int seed = *seedptr;\n    kmVec2 r;\n    float rscale = 1.0f / UINT_MAX;\n    while (1) {\n        r.x = 4 * rscale * randhash(seed++) - 2;\n        r.y = 4 * rscale * randhash(seed++) - 2;\n        float r2 = kmVec2LengthSq(&r);\n        if (r2 > 1 && r2 <= 4) {\n            break;\n        }\n    }\n    *seedptr = seed;\n    kmVec2Scale(&r, &r, radius);\n    kmVec2Add(&r, &r, &center);\n    return r;\n}\n",
    "randhash": "unsigned int randhash(unsigned int seed)\n{\n    unsigned int i = (seed ^ 12345391u) * 2654435769u;\n    i ^= (i << 6) ^ (i >> 26);\n    i *= 2654435769u;\n    i += (i << 5) ^ (i >> 12);\n    return i;\n}\n",
    "randhashf": "float randhashf(unsigned int seed, float a, float b)\n{\n    return (b - a) * randhash(seed) / (float) UINT_MAX + a;\n}\n",
    "heman_points_create": "heman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands)\n{\n    heman_points* img = malloc(sizeof(heman_image));\n    img->width = npoints;\n    img->height = 1;\n    img->nbands = nbands;\n    int nbytes = sizeof(HEMAN_FLOAT) * npoints * nbands;\n    img->data = malloc(nbytes);\n    memcpy(img->data, xy, nbytes);\n    return img;\n}\n",
    "heman_points_destroy": "void heman_points_destroy(heman_points* img)\n{\n    free(img->data);\n    free(img);\n}\n",
    "heman_points_from_grid": "heman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter)\n{\n    int cols = width / cellsize;\n    int rows = height / cellsize;\n    int ncells = cols * rows;\n    heman_points* result = heman_image_create(ncells, 1, 2);\n    HEMAN_FLOAT rscale = 2.0 * jitter / (HEMAN_FLOAT) RAND_MAX;\n\n// TODO it would be good to avoid ANSI rand() and add some determinism\n// in a thread-safe way.  Maybe we should add a seed argument and use\n// Bridson's randhash?\n\n    int j;\n#pragma omp parallel for\n    for (j = 0; j < rows; j++) {\n        HEMAN_FLOAT* dst = result->data + j * cols * 2;\n        HEMAN_FLOAT y = cellsize * 0.5 + cellsize * j;\n        HEMAN_FLOAT x = cellsize * 0.5;\n        for (int i = 0; i < cols; i++) {\n            HEMAN_FLOAT rx = rand() * rscale - jitter;\n            HEMAN_FLOAT ry = rand() * rscale - jitter;\n            *dst++ = x + rx;\n            *dst++ = y + ry;\n            x += cellsize;\n        }\n    }\n\n    return result;\n}\n",
    "extra": "{'heman_image_s': 'struct heman_image_s {\\n    int width;\\n    int height;\\n    int nbands;\\n    HEMAN_FLOAT* data;\\n};', 'kmVec2': '} kmVec2;', 'CLAMP': '#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))', 'CLAMP01': '#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)', 'EDGE': '#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))', 'GRIDF': '#define GRIDF(vec) \\\\', 'GRIDI': '#define GRIDI(vec) grid[(int) vec.y * ncols + (int) vec.x]', 'GRID_BEGIN': '#define GRID_BEGIN(ipt) (NGRID_BEGIN(ipt) * gcapacity)', 'GRID_END': '#define GRID_END(ipt) (GRID_BEGIN(ipt) + ngrid[NGRID_BEGIN(ipt)])', 'GRID_INDEX': '#define GRID_INDEX(fpt) (gcapacity * NGRID_INDEX(fpt))', 'GRID_INSERT': '#define GRID_INSERT(fpt, sindex)                       \\\\', 'HEMAN_FLOAT': '#define HEMAN_FLOAT double', 'KM_CONTAINS_ALL': '#define KM_CONTAINS_ALL (kmEnum)2', 'KM_CONTAINS_NONE': '#define KM_CONTAINS_NONE (kmEnum)0', 'KM_CONTAINS_PARTIAL': '#define KM_CONTAINS_PARTIAL (kmEnum)1', 'KM_FALSE': '#define KM_FALSE 0', 'KM_TRUE': '#define KM_TRUE 1', 'MAX': '#define MAX(a, b) (a > b ? a : b)', 'MIN': '#define MIN(a, b) (a > b ? b : a)', 'NGRID_BEGIN': '#define NGRID_BEGIN(ipt) ((int) ipt.y * ncols + (int) ipt.x)', 'NGRID_INDEX': '#define NGRID_INDEX(fpt) \\\\', 'PI': '#define PI (3.1415926535)', 'SGN': '#define SGN(x) ((x > 0) - (x < 0))', 'SQR': '#define SQR(x) ((x) * (x))', 'SWAP': '#define SWAP(type,a,b) {type _=a;a=b;b=_;}', 'TWO_OVER_PI': '#define TWO_OVER_PI (0.63661977236)', 'UTILITY_H_INCLUDED': '#define UTILITY_H_INCLUDED', 'VEC2_H_INCLUDED': '#define VEC2_H_INCLUDED', 'kmBool': '#define kmBool unsigned char', 'kmEnum': '#define kmEnum unsigned int', 'kmEpsilon': '#define kmEpsilon 0.0001', 'kmInt': '#define kmInt int', 'kmPI': '#define kmPI 3.14159265358979323846f', 'kmPIOver180': '#define kmPIOver180  (kmPI / 180.0f)', 'kmPIUnder180': '#define kmPIUnder180 (180.0 / kmPI)', 'kmScalar': '#define kmScalar double', 'kmUchar': '#define kmUchar unsigned char', 'kmUint': '#define kmUint unsigned int', 'heman_byte': 'typedef unsigned char heman_byte;', 'heman_color': 'typedef unsigned int heman_color;', 'heman_image': 'typedef struct heman_image_s heman_image;', 'heman_points': 'typedef struct heman_image_s heman_points;'} extract_info: [// This is a private header.  Clients should not include it.\n\n#pragma once\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// An \"image\" encapsulates three integers (width, height, number of bands)\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\n// the API disallows struct definitions, so this is just an opaque handle.\ntypedef struct heman_image_s heman_image;\n\n// Point lists are actually one-dimensional images in disguise, usually with\n// two bands (X and Y coordinates).\ntypedef struct heman_image_s heman_points;\n\n// Image values in heman are always floating point, but clients may\n// choose either 32-bit floats or 64-bit floats at compile time.\n#ifdef USE_DOUBLE_PRECISION\n#define HEMAN_FLOAT double\n#else\n#define HEMAN_FLOAT float\n#endif\n\n// Occasionally the heman API accepts four-byte color for convenience.  For now\n// we're only using the lower three bytes (XRGB).\ntypedef unsigned int heman_color;\ntypedef unsigned char heman_byte;\n\n// Allocate a floating-point image with dimensions width x height x nbands.\nheman_image* heman_image_create(int width, int height, int nbands);\n\n// Obtain image properties.\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\n\n// Peek at the stored texel values.\nHEMAN_FLOAT* heman_image_data(heman_image*);\n\n// Peek at the stored texel values in a SWIG-amenable way.\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\n\n// Peek at the given texel value.\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\n\n// Find a reasonable value for the given normalized texture coord.\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\n\n// Set every band of every texel to the given value.\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\n\n// Free memory for a image.\nvoid heman_image_destroy(heman_image*);\n\n// Create a one-band image from a four-band image by extracting the 4th channel.\nheman_image* heman_image_extract_alpha(heman_image*);\n\n// Create a three-band image from a four-band image by extracting first 3 bands.\nheman_image* heman_image_extract_rgb(heman_image*);\n\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\n// the given control points, in a gamma correct way.  Each control point is\n// defined by an X location (one integer each) and an RGB value (one 32-bit\n// word for each color).\nheman_image* heman_color_create_gradient(int width, int num_colors,\n    const int* cp_locations, const heman_color* cp_colors);\n\n// This sets some global state that affects lighting and color interpolation.\n// The default value is 2.2.\nvoid heman_color_set_gamma(float f);\n\n// Create a 3-band image with the same dimensions as the given heightmap by\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\n// are normalized using the given minval, maxval range.\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\n\n// Convert a single-channel image into a 3-channel image via duplication.\nheman_image* heman_color_from_grayscale(heman_image* gray);\n\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\n\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\n\n// High-level function that uses several octaves of simplex noise and a signed\n// distance field to generate an interesting height map.\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\n\n// High-level function that deforms a hemisphere with simplex noise.\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\n\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\n// domain to generate an interesting lat-long height map.\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\n\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\n// Points can be 3-tuples, in which case the 3rd component represents the\n// strength of the seed point.\nheman_image* heman_generate_archipelago_heightmap(\n    int width, int height, heman_points* points, float noiseamt, int seed);\n\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\n// purely political boundaries are ignored when generating the finalized\n// height map.\nvoid heman_generate_archipelago_political(int width, int height,\n    heman_points* points, const heman_color* colors, heman_color ocean,\n    int seed, heman_image** elevation, heman_image** political,\n    int elevation_mode);\n\n// High-level function that sums up a number of noise octaves, also known as\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\n// fractals; this makes them more fractal-like. A good starting point is to use\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\n\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\nheman_image* heman_lighting_apply(heman_image* heightmap,\n    heman_image* colorbuffer, float occlusion, float diffuse,\n    float diffuse_softening, const float* light_position);\n\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\n// using simple forward differencing and OpenMP.\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\n\n// Compute occlusion values for the given heightmap, as described at\n// http://nothings.org/gamedev/horizon/.\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\n\n// Sets some global state that affects ambient occlusion computations.\nvoid heman_lighting_set_occlusion_scale(float s);\n\n// Create a one-band \"signed distance field\" based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\n\n// Create a one-band unsigned distance field based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_df(heman_image* monochrome);\n\n// Create a two-band \"closest point coordinate field\" containing the\n// non-normalized texture coordinates of the nearest seed.  The result is\n// related to the distance field but has a greater amount of information.\nheman_image* heman_distance_create_cpcf(heman_image* seed);\n\n// Convert a two-band coordinate field into an unsigned distance field.\nheman_image* heman_distance_from_cpcf(heman_image* cf);\n\n// Create a two-band CPCF where each texel contains its own coordinate.\nheman_image* heman_distance_identity_cpcf(int width, int height);\n\n// Create a single-channel floating point point image from bytes, such that\n// [0, 255] map to the given [minval, maxval] range.\nheman_image* heman_import_u8(int width, int height, int nbands,\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Create a mesh with (width - 1) x (height - 1) quads.\nvoid heman_export_ply(heman_image*, const char* filename);\n\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\nvoid heman_export_with_colors_ply(\n    heman_image* heightmap, heman_image* colors, const char* filename);\n\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\n// the result to \"dest\".  Values outside the range are clamped.\nvoid heman_export_u8(\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\n\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\n\n// Given a set of same-sized images, copy them into a vertical filmstrip.\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\n\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\n// result.  Values outside the range are clamped.  The source image is\n// untouched.\nheman_image* heman_ops_normalize_f32(\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Compute the maximum value between two height maps.\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\n\n// Generate a monochrome image by applying a step function.\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\n\n// Takes a 1-band elevation image and makes it tiered (scalloped).\n// Optionally takes a color mask, and applies the step operator only\n// in the regions with the given mask color.\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Similar to stairstep, but tries to guarantee that every tier\n// has the same total land area.\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Generate a height x 1 x 1 image by averaging the values across each row.\nheman_image* heman_ops_sweep(heman_image* image);\n\n// Provide a cheap way of measuring \"curvature\" that doesn't work well\n// at saddle points.  Returns a single-band image.\nheman_image* heman_ops_laplacian(heman_image* heightmap);\n\n// Highlight edges using the Sobel operator\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\n\n// Add the values of src into dst.\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\n\n// Use FBM and Perlin noise to warp the given image.\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\n\n// Same as ops_warp, but alos applies the warping operation to a point list.\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\n    heman_points* pts);\n\n// Consume a 3-band image and a color of interest; produce a 1-band image.\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\n\n// Replace a region of solid color with texture.\nheman_image* heman_ops_replace_color(\n    heman_image* src, heman_color color, heman_image* texture);\n\n// Create a 4-band image by merging a 3-band political image with\n// a 1-band elevation image.\nheman_image* heman_ops_merge_political(\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\n\n// Add coarse-grain noise to ocean and fine-grain noise to land.\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\n\n// Create a point list.\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\n\n// Free memory for a point list.\nvoid heman_points_destroy(heman_points*);\n\n// Perform simple stratified sampling over a grid.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\n\n// Perform Bridson's algorithm for Fast Poisson Disk sampling.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_poisson(\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\n\n// Perform Bridson's sampling algorithm, modulated by a density field.\n// Creates a two-band point list, sorted from high-density (low radius) to\n// low-density (high radius).\nheman_points* heman_points_from_density(\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\n\n// Set the given list of texels to the given value.\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\n\n// Set the given list of texels to the given list of colors.\nvoid heman_draw_colored_points(\n    heman_image* target, heman_points* coords, const heman_color* colors);\n\n// Draw colored circles into the given render target.\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\n    int radius, const heman_color* colors);\n\n// Draw a Gaussian splat at each given point.\n// The blend_mode parameter is ignored for now (it's always ADD).\nvoid heman_draw_splats(\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\n\n// Treats a set of points like blobs and draws a contour around them.\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\n    heman_color color, float mind, float maxd, int filterd);\n\n// This returns omp_get_max_threads() for diagnostic purposes.\nint heman_get_num_threads();\n\n#ifdef __cplusplus\n}\n#endif\n\nstruct heman_image_s {\n    int width;\n    int height;\n    int nbands;\n    HEMAN_FLOAT* data;\n};\n\nextern float _gamma;\n\n#define MIN(a, b) (a > b ? b : a)\n#define MAX(a, b) (a > b ? a : b)\n#define CLAMP(v, lo, hi) MAX(lo, MIN(hi, v))\n#define CLAMP01(v) CLAMP(v, 0.0f, 1.0f)\n#define SGN(x) ((x > 0) - (x < 0))\n#define EDGE(value, upper) MAX(0, MIN(upper - 1, value))\n#define TWO_OVER_PI (0.63661977236)\n#define PI (3.1415926535)\n#define SQR(x) ((x) * (x))\n#define SWAP(type,a,b) {type _=a;a=b;b=_;}\n\ninline HEMAN_FLOAT smoothstep(\n    HEMAN_FLOAT edge0, HEMAN_FLOAT edge1, HEMAN_FLOAT x)\n{\n    HEMAN_FLOAT t;\n    t = CLAMP01((x - edge0) / (edge1 - edge0));\n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid generate_gaussian_row(int* target, int fwidth);\nvoid generate_gaussian_splat(HEMAN_FLOAT* target, int fwidth);\n#include <stdlib.h>\n#include <memory.h>\n#include <assert.h>\n#include <limits.h>\n/*\nCopyright (c) 2008, Luke Benstead.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef VEC2_H_INCLUDED\n#define VEC2_H_INCLUDED\n\n/*\nCopyright (c) 2008, Luke Benstead.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef UTILITY_H_INCLUDED\n#define UTILITY_H_INCLUDED\n\n#include <math.h>\n\n#ifndef kmScalar\n#ifdef USE_DOUBLE_PRECISION\n#define kmScalar double\n#else\n#define kmScalar float\n#endif\n\n#endif\n\n#ifndef kmBool\n#define kmBool unsigned char\n#endif\n\n#ifndef kmUchar\n#define kmUchar unsigned char\n#endif\n\n#ifndef kmEnum\n#define kmEnum unsigned int\n#endif\n\n#ifndef kmUint\n#define kmUint unsigned int\n#endif\n\n#ifndef kmInt\n#define kmInt int\n#endif\n\n#ifndef KM_FALSE\n#define KM_FALSE 0\n#endif\n\n#ifndef KM_TRUE\n#define KM_TRUE 1\n#endif\n\n#define kmPI 3.14159265358979323846f\n#define kmPIOver180  (kmPI / 180.0f)\n#define kmPIUnder180 (180.0 / kmPI)\n#define kmEpsilon 0.0001\n\n#define KM_CONTAINS_NONE (kmEnum)0\n#define KM_CONTAINS_PARTIAL (kmEnum)1\n#define KM_CONTAINS_ALL (kmEnum)2\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern kmScalar kmSQR(kmScalar s);\nextern kmScalar kmDegreesToRadians(kmScalar degrees);\nextern kmScalar kmRadiansToDegrees(kmScalar radians);\n\nextern kmScalar kmMin(kmScalar lhs, kmScalar rhs);\nextern kmScalar kmMax(kmScalar lhs, kmScalar rhs);\nextern kmBool kmAlmostEqual(kmScalar lhs, kmScalar rhs);\n\nextern kmScalar kmClamp(kmScalar x, kmScalar min, kmScalar max);\nextern kmScalar kmLerp(kmScalar x, kmScalar y, kmScalar factor);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* UTILITY_H_INCLUDED */\n\nstruct kmMat3;\n\n#pragma pack(push)  /* push current alignment to stack */\n#pragma pack(1)     /* set alignment to 1 byte boundary */\ntypedef struct kmVec2 {\n    kmScalar x;\n    kmScalar y;\n} kmVec2;\n\n#pragma pack(pop)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nkmVec2* kmVec2Fill(kmVec2* pOut, kmScalar x, kmScalar y);\nkmScalar kmVec2Length(const kmVec2* pIn); /**< Returns the length of the vector*/\nkmScalar kmVec2LengthSq(const kmVec2* pIn); /**< Returns the square of the length of the vector*/\nkmVec2* kmVec2Normalize(kmVec2* pOut, const kmVec2* pIn); /**< Returns the vector passed in set to unit length*/\nkmVec2* kmVec2Lerp(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2, kmScalar t);\nkmVec2* kmVec2Add(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2); /**< Adds 2 vectors and returns the result*/\nkmScalar kmVec2Dot(const kmVec2* pV1, const kmVec2* pV2); /** Returns the Dot product which is the cosine of the angle between the two vectors multiplied by their lengths */\nkmScalar kmVec2Cross(const kmVec2* pV1, const kmVec2* pV2);\nkmVec2* kmVec2Subtract(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2); /**< Subtracts 2 vectors and returns the result*/\nkmVec2* kmVec2Mul( kmVec2* pOut,const kmVec2* pV1, const kmVec2* pV2 ); /**< Component-wise multiplication */\nkmVec2* kmVec2Div( kmVec2* pOut,const kmVec2* pV1, const kmVec2* pV2 ); /**< Component-wise division*/\nkmVec2* kmVec2Transform(kmVec2* pOut, const kmVec2* pV1, const struct kmMat3* pM); /** Transform the Vector */\nkmVec2* kmVec2TransformCoord(kmVec2* pOut, const kmVec2* pV, const struct kmMat3* pM); /**<Transforms a 2D vector by a given matrix, projecting the result back into w = 1.*/\nkmVec2* kmVec2Scale(kmVec2* pOut, const kmVec2* pIn, const kmScalar s); /**< Scales a vector to length s*/\nint\tkmVec2AreEqual(const kmVec2* p1, const kmVec2* p2); /**< Returns 1 if both vectors are equal*/\nkmVec2* kmVec2Assign(kmVec2* pOut, const kmVec2* pIn);\nkmVec2* kmVec2RotateBy(kmVec2* pOut, const kmVec2* pIn, const kmScalar degrees, const kmVec2* center); /**<Rotates the point anticlockwise around a center by an amount of degrees.*/\nkmScalar kmVec2DegreesBetween(const kmVec2* v1, const kmVec2* v2);\nkmScalar kmVec2DistanceBetween(const kmVec2* v1, const kmVec2* v2);\nkmVec2* kmVec2MidPointBetween(kmVec2* pOut, const kmVec2* v1, const kmVec2* v2);\nkmVec2* kmVec2Reflect(kmVec2* pOut, const kmVec2* pIn, const kmVec2* normal); /**< Reflects a vector about a given surface normal. The surface normal is assumed to be of unit length. */\n\nextern const kmVec2 KM_VEC2_POS_Y;\nextern const kmVec2 KM_VEC2_NEG_Y;\nextern const kmVec2 KM_VEC2_NEG_X;\nextern const kmVec2 KM_VEC2_POS_X;\nextern const kmVec2 KM_VEC2_ZERO;\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif /* VEC2_H_INCLUDED */\n\n// Transforms even the sequence 0,1,2,3,... into reasonably good random numbers.\n\n\n\n\n\n\n#define GRIDF(vec) \\\n    grid[(int) (vec.x * invcell) + ncols * (int) (vec.y * invcell)]\n\n#define GRIDI(vec) grid[(int) vec.y * ncols + (int) vec.x]\n\n\n#undef GRIDF\n#undef GRIDI\n\n#define NGRID_INDEX(fpt) \\\n    ((int) (fpt.x * invcell) + ncols * (int) (fpt.y * invcell))\n\n#define GRID_INDEX(fpt) (gcapacity * NGRID_INDEX(fpt))\n\n#define GRID_INSERT(fpt, sindex)                       \\\n    gindex = NGRID_INDEX(fpt);                         \\\n    grid[gcapacity * gindex + ngrid[gindex]] = sindex; \\\n    ngrid[gindex]++\n\n#define NGRID_BEGIN(ipt) ((int) ipt.y * ncols + (int) ipt.x)\n\n#define GRID_BEGIN(ipt) (NGRID_BEGIN(ipt) * gcapacity)\n\n#define GRID_END(ipt) (GRID_BEGIN(ipt) + ngrid[NGRID_BEGIN(ipt)])\n\n]"
}