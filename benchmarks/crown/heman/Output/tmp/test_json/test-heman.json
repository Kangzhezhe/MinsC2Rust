{
    "test_noise": "static void test_noise()\n{\n    printf(\"Generating noise.\\n\");\n    double begin = omp_get_wtime();\n    float frequency = 4;\n    float amplitude = 1;\n    int octaves = 10;\n    float lacunarity = 2;\n    float gain = 0.65f;\n    int seed = 5000;\n    heman_image* img = heman_generate_simplex_fbm(\n        SIZE, SIZE, frequency, amplitude, octaves, lacunarity, gain, seed);\n    double duration = omp_get_wtime() - begin;\n    printf(\"Noise generated in %.3f seconds.\\n\", duration);\n    hut_write_image(OUTFOLDER \"noise.png\", img, -1, 1);\n    heman_image_destroy(img);\n}\n",
    "draw_circle": "static heman_image* draw_circle()\n{\n    heman_image* img = heman_image_create(SIZE, SIZE, 1);\n    float inv = 1.0f / SIZE;\n\n#pragma omp parallel for\n    for (int y = 0; y < SIZE; ++y) {\n        float v = y * inv;\n        float dv2 = (v - 0.5f) * (v - 0.5f);\n        HEMAN_FLOAT* dst = heman_image_data(img) + y * SIZE;\n        for (int x = 0; x < SIZE; ++x) {\n            float u = x * inv;\n            float du2 = (u - 0.5f) * (u - 0.5f);\n            *dst++ = du2 + dv2 < 0.0625f ? 1 : 0;\n        }\n    }\n\n    return img;\n}\n",
    "test_color": "static void test_color()\n{\n    int cp_locations[] = {\n        000, 255,\n    };\n    heman_color cp_colors[] = {\n        0xFF0000, 0x00FF00,\n    };\n    assert(COUNT(cp_locations) == COUNT(cp_colors));\n    heman_image* grad = heman_color_create_gradient(\n        256, COUNT(cp_colors), cp_locations, cp_colors);\n\n    hut_write_image_scaled(OUTFOLDER \"gradient.png\", grad, 256, 256);\n    heman_image_destroy(grad);\n}\n",
    "test_political": "void test_political()\n{\n    const int imgres = 1024;\n    const int seed = 0;\n\n    heman_points* pts = heman_image_create(3, 1, 3);\n    kmVec3* coords = (kmVec3*) heman_image_data(pts);\n    coords[0] = (kmVec3){0.5, 0.4, 0.4};\n    coords[1] = (kmVec3){0.3, 0.5, 0.6};\n    coords[2] = (kmVec3){0.7, 0.7, 0.2};\n    heman_color colors[3] = {0xC8758A, 0xDE935A, 0xE0BB5E};\n    heman_color ocean = 0x83B2B2;\n    heman_color beach = 0x303030;\n    heman_image* contour = heman_image_create(imgres, imgres, 3);\n    heman_image_clear(contour, 0);\n    heman_draw_contour_from_points(contour, pts, ocean, 0.40, 0.41, 1);\n    heman_draw_colored_circles(contour, pts, 10, colors);\n\n    heman_color previous = cp_colors[2];\n    cp_colors[2] = beach;\n    heman_image* grad = heman_color_create_gradient(\n        256, COUNT(cp_colors), cp_locations, cp_colors);\n    cp_colors[2] = previous;\n    HEMAN_FLOAT* grad_data = heman_image_data(grad);\n\n    // Create some interesting contour lines by injecting brightness\n    // at certain spots in the color gradient.\n    for (int x = 0; x < 128; x += 8) {\n        grad_data[x * 3 + 0] *= 1 + x / 128.0;\n        grad_data[x * 3 + 1] *= 1 + x / 128.0;\n        grad_data[x * 3 + 2] *= 1 + x / 128.0;\n    }\n\n    heman_image* elev;\n    heman_image* poli;\n    heman_generate_archipelago_political(\n        imgres, imgres, pts, colors, ocean, seed, &elev, &poli, 1);\n    heman_image* oceanimg = heman_color_apply_gradient(elev, -0.5, 0.5, grad);\n    heman_ops_stairstep(elev, 3, poli, colors[0], 0, 0);\n    heman_ops_stairstep(elev, 2, poli, ocean, 0, 0);\n    poli = heman_ops_sobel(poli, beach);\n    poli = heman_ops_replace_color(poli, ocean, oceanimg);\n    heman_image* final = heman_lighting_apply(elev, poli, 1, 1, 0.5, 0);\n    hut_write_image_scaled(\n        OUTFOLDER \"archifinal.png\", final, imgres / 2, imgres / 2);\n    heman_image_destroy(oceanimg);\n    heman_image_destroy(elev);\n    heman_image_destroy(poli);\n    heman_image_destroy(final);\n\n    heman_image_destroy(pts);\n    heman_image* cf = heman_distance_create_cpcf(contour);\n    heman_image* voronoi1 = heman_color_from_cpcf(cf, contour);\n    heman_image* rg1 = heman_color_from_cpcf(cf, 0);\n    heman_image* toon1 = heman_ops_sobel(voronoi1, beach);\n\n    heman_image* warped_cpcf = heman_ops_warp(cf, seed, 4);\n    heman_image* voronoi2 = heman_color_from_cpcf(warped_cpcf, contour);\n    heman_image* rg2 = heman_color_from_cpcf(warped_cpcf, 0);\n    heman_image* toon2 = heman_ops_sobel(voronoi2, beach);\n\n    heman_image* frames1[] = {contour, toon1, toon2};\n    heman_image* filmstrip1 = heman_ops_stitch_horizontal(frames1, 3);\n\n    heman_points_destroy(cf);\n    heman_points_destroy(warped_cpcf);\n    heman_points_destroy(voronoi1);\n    heman_points_destroy(voronoi2);\n    heman_points_destroy(toon1);\n    heman_points_destroy(toon2);\n\n    heman_image* frames2[] = {contour, rg1, rg2};\n    heman_image* filmstrip2 = heman_ops_stitch_horizontal(frames2, 3);\n\n    heman_points_destroy(contour);\n    heman_points_destroy(rg1);\n    heman_points_destroy(rg2);\n\n    hut_write_image_scaled(OUTFOLDER \"political.png\", filmstrip1, 1152, 384);\n    heman_points_destroy(filmstrip1);\n\n    hut_write_image_scaled(OUTFOLDER \"coordfields.png\", filmstrip2, 1152, 384);\n    heman_points_destroy(filmstrip2);\n}\n",
    "test_points_grid": "static void test_points_grid()\n{\n    const int imgres = 192;\n    const int ptsize = 4;\n    const float cellsize = 0.05;\n    const float maxjitter = 0.02;\n    const float lpos[] = {-0.5f, 0.5f, 1.0f};\n    const int cp_locations[] = {0, 126, 255};\n    const heman_color cp_colors[] = {0x2C5A7C, 0x2C5A7C, 0xE0F0A0};\n\n    heman_points* points = heman_points_from_grid(1, 1, cellsize, 0);\n    heman_image* uniform = heman_image_create(imgres, imgres, 1);\n    heman_image_clear(uniform, 0);\n    heman_draw_splats(uniform, points, ptsize, 0);\n    heman_points_destroy(points);\n\n    points = heman_points_from_grid(1, 1, cellsize, maxjitter);\n    heman_image* jittered = heman_image_create(imgres, imgres, 1);\n    heman_image_clear(jittered, 0);\n    heman_draw_splats(jittered, points, ptsize, 0);\n    heman_points_destroy(points);\n\n    points = heman_points_from_poisson(1, 1, cellsize / sqrtf(2));\n    heman_image* poisson = heman_image_create(imgres, imgres, 1);\n    heman_image_clear(poisson, 0);\n    heman_draw_splats(poisson, points, ptsize, 0);\n    heman_points_destroy(points);\n\n    heman_image* frames[] = {uniform, jittered, poisson};\n    heman_image* elev = heman_ops_stitch_horizontal(frames, 3);\n    heman_image_destroy(uniform);\n    heman_image_destroy(jittered);\n    heman_image_destroy(poisson);\n\n    heman_image* grad = heman_color_create_gradient(\n        256, COUNT(cp_colors), cp_locations, cp_colors);\n    heman_image* albedo = heman_color_apply_gradient(elev, 0.0, 0.05, grad);\n    heman_image* final = heman_lighting_apply(elev, albedo, 1, 1, 0.75, lpos);\n\n    hut_write_image(OUTFOLDER \"gridpoints.png\", final, 0, 1);\n    heman_image_destroy(final);\n    heman_image_destroy(grad);\n    heman_image_destroy(albedo);\n    heman_image_destroy(elev);\n}\n",
    "test_distance": "static void test_distance()\n{\n    heman_image* img = draw_circle();\n    double begin = omp_get_wtime();\n    heman_image* sdf = heman_distance_create_sdf(img);\n    double duration = omp_get_wtime() - begin;\n    printf(\"Distance field generated in %.3f seconds.\\n\", duration);\n    hut_write_image(OUTFOLDER \"distance.png\", sdf, -1, 1);\n    heman_image_destroy(img);\n    heman_image_destroy(sdf);\n}\n",
    "main": "int main(int argc, char** argv)\n{\n    printf(\"%d threads available.\\n\", omp_get_max_threads());\n    test_noise();\n    test_distance();\n    test_color();\n    test_lighting();\n    test_points_grid();\n    test_points_density();\n    test_coordfield();\n    test_generate();\n    test_political();\n}\n",
    "test_generate": "void test_generate()\n{\n    srand(time(0));\n    int seed = rand();\n    heman_image* grad = heman_color_create_gradient(\n        256, COUNT(cp_colors), cp_locations, cp_colors);\n    HEMAN_FLOAT* grad_data = heman_image_data(grad);\n\n    // Create some interesting contour lines by injecting brightness\n    // at certain spots in the color gradient.\n    for (int x = 0; x < 128; x += 8) {\n        grad_data[x * 3 + 0] *= 1 + x / 128.0;\n        grad_data[x * 3 + 1] *= 1 + x / 128.0;\n        grad_data[x * 3 + 2] *= 1 + x / 128.0;\n    }\n\n    heman_image* finals[3];\n    heman_image** pfinal = finals;\n    for (float noise = 0.0; noise < 0.7; noise += 0.2) {\n        heman_points* pts = heman_image_create(3, 1, 3);\n        kmVec3* coords = (kmVec3*) heman_image_data(pts);\n        coords[0] = (kmVec3){0.5, 0.4, 0.4};\n        coords[1] = (kmVec3){0.3, 0.5, 0.6};\n        coords[2] = (kmVec3){0.7, 0.7, 0.2};\n        heman_image* elev =\n            heman_generate_archipelago_heightmap(800, 450, pts, noise, seed);\n        heman_image_destroy(pts);\n        heman_image* albedo = heman_color_apply_gradient(elev, -0.5, 0.5, grad);\n        *pfinal++ = heman_lighting_apply(elev, albedo, 1, 1, 0.5, 0);\n        heman_image_destroy(elev);\n        heman_image_destroy(albedo);\n    }\n\n    heman_image* final = heman_ops_stitch_horizontal(finals, 3);\n    for (int i = 0; i < 3; i++) {\n        heman_image_destroy(finals[i]);\n    }\n\n    hut_write_image_scaled(OUTFOLDER \"archipelago.png\", final, 400 * 3, 225);\n    heman_image_destroy(final);\n    heman_image_destroy(grad);\n}\n",
    "test_coordfield": "void test_coordfield()\n{\n    const int imgres = 768;\n    const int npoints = 3;\n\n    heman_image* seed = heman_image_create(imgres, imgres, 3);\n    heman_points* pts = heman_image_create(npoints, 1, 2);\n    kmVec2* coords = (kmVec2*) heman_image_data(pts);\n    heman_color* colors = malloc(sizeof(heman_color) * npoints);\n    coords[0] = (kmVec2){0.5, 0.2};\n    colors[0] = 0xff0000;\n    coords[1] = (kmVec2){0.2, 0.8};\n    colors[1] = 0x00ff00;\n    coords[2] = (kmVec2){0.8, 0.8};\n    colors[2] = 0x0000ff;\n    heman_image_clear(seed, 0);\n    heman_draw_colored_points(seed, pts, colors);\n    heman_points_destroy(pts);\n    free(colors);\n    hut_write_image(OUTFOLDER \"seed.png\", seed, 0, 1);\n\n    heman_image* cf = heman_distance_create_cpcf(seed);\n    heman_image* voronoi = heman_color_from_cpcf(cf, seed);\n    hut_write_image(OUTFOLDER \"coordfield.png\", voronoi, 0, 1);\n\n    heman_image_destroy(voronoi);\n    heman_image_destroy(seed);\n    heman_image_destroy(cf);\n}\n",
    "test_lighting": "static void test_lighting()\n{\n    heman_image* grad = heman_color_create_gradient(\n        256, COUNT(cp_colors), cp_locations, cp_colors);\n\n    // Generate the heightmap.\n    heman_image* hmap = heman_generate_island_heightmap(SIZE, SIZE, time(0));\n    heman_image* hmapviz = heman_ops_normalize_f32(hmap, -0.5, 0.5);\n\n    // Compute ambient occlusion.\n    heman_image* occ = heman_lighting_compute_occlusion(hmap);\n\n    // Create a normal map.\n    heman_image* norm = heman_lighting_compute_normals(hmap);\n    heman_image* normviz = heman_ops_normalize_f32(norm, -1, 1);\n\n    // Create an albedo image.\n    heman_image* albedo = heman_color_apply_gradient(hmap, -0.5, 0.5, grad);\n    heman_image_destroy(grad);\n\n    // Perform lighting.\n    float lightpos[] = {-0.5f, 0.5f, 1.0f};\n    heman_image* final =\n        heman_lighting_apply(hmap, albedo, 1, 1, 0.5, lightpos);\n\n    heman_image* frames[] = {0, 0, normviz, albedo, final};\n    frames[0] = heman_color_from_grayscale(hmapviz);\n    frames[1] = heman_color_from_grayscale(occ);\n    heman_image* filmstrip = heman_ops_stitch_horizontal(frames, 5);\n    hut_write_image(OUTFOLDER \"filmstrip.png\", filmstrip, 0, 1);\n    heman_export_ply(hmap, OUTFOLDER \"heightmap.ply\");\n    heman_export_with_colors_ply(hmap, final, OUTFOLDER \"colors.ply\");\n    heman_image_destroy(frames[0]);\n    heman_image_destroy(frames[1]);\n    heman_image_destroy(hmap);\n    heman_image_destroy(hmapviz);\n    heman_image_destroy(occ);\n    heman_image_destroy(norm);\n    heman_image_destroy(normviz);\n    heman_image_destroy(albedo);\n    heman_image_destroy(final);\n}\n",
    "test_points_density": "static void test_points_density()\n{\n    const int imgres = 256;\n\n    heman_image* density = heman_generate_island_heightmap(imgres, imgres, 1);\n    heman_image* tmp = heman_ops_normalize_f32(density, -0.5, 0.5);\n    heman_image_destroy(density);\n    density = tmp;\n\n    heman_image* curvature = heman_ops_laplacian(density);\n    tmp = heman_ops_normalize_f32(curvature, 0, 0.0005);\n    heman_image_destroy(curvature);\n    curvature = tmp;\n    heman_ops_accumulate(curvature, density);\n\n    heman_points* points = heman_points_from_density(curvature, 0.001, 0.03);\n    heman_image* modulated = heman_image_create(imgres, imgres, 1);\n    heman_image_clear(modulated, 0);\n    heman_draw_points(modulated, points, 1);\n\n    heman_image* splats = heman_image_create(imgres, imgres, 1);\n    heman_image_clear(splats, 0);\n    heman_draw_splats(splats, points, 4, 0);\n    splats = heman_ops_normalize_f32(splats, 0, 0.4);\n    heman_points_destroy(points);\n\n    heman_image* frames[] = {density, curvature, modulated, splats};\n    heman_image* filmstrip = heman_ops_stitch_horizontal(frames, 4);\n    heman_image_destroy(density);\n    heman_image_destroy(curvature);\n    heman_image_destroy(modulated);\n    heman_image_destroy(splats);\n\n    hut_write_image(OUTFOLDER \"densitypoints.png\", filmstrip, 0, 1);\n    heman_image_destroy(filmstrip);\n}\n",
    "extra": "{'__anona3b55b0e0508': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e0608': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e0708': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e0a08': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e0b08': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e0d08': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e0e08': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e0e08::__anona3b55b0e0f08': '   {\\n      // compute adler32 on input\\n      unsigned int i=0, s1=1, s2=0, blocklen = data_len % 5552;\\n      int j=0;\\n      while (j < data_len) {\\n         for (i=0; i < blocklen; ++i) s1 += data[j+i], s2 += s1;\\n         s1 %= 65521, s2 %= 65521;\\n         j += blocklen;\\n         blocklen = 5552;\\n      }\\n      stbiw__sbpush(out, (unsigned char) (s2 >> 8));\\n      stbiw__sbpush(out, (unsigned char) s2);\\n      stbiw__sbpush(out, (unsigned char) (s1 >> 8));\\n      stbiw__sbpush(out, (unsigned char) s1);\\n   };', '__anona3b55b0e0f08': '   {\\n      // compute adler32 on input\\n      unsigned int i=0, s1=1, s2=0, blocklen = data_len % 5552;\\n      int j=0;\\n      while (j < data_len) {\\n         for (i=0; i < blocklen; ++i) s1 += data[j+i], s2 += s1;\\n         s1 %= 65521, s2 %= 65521;\\n         j += blocklen;\\n         blocklen = 5552;\\n      }\\n      stbiw__sbpush(out, (unsigned char) (s2 >> 8));\\n      stbiw__sbpush(out, (unsigned char) s2);\\n      stbiw__sbpush(out, (unsigned char) (s1 >> 8));\\n      stbiw__sbpush(out, (unsigned char) s1);\\n   };', '__anona3b55b0e1008': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e1108': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e1208': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e1308': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e1408': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e1608': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e1708': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', '__anona3b55b0e1808': '{\\n#endif\\n\\n// An \"image\" encapsulates three integers (width, height, number of bands)\\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\\n// the API disallows struct definitions, so this is just an opaque handle.\\ntypedef struct heman_image_s heman_image;\\n\\n// Point lists are actually one-dimensional images in disguise, usually with\\n// two bands (X and Y coordinates).\\ntypedef struct heman_image_s heman_points;\\n\\n// Image values in heman are always floating point, but clients may\\n// choose either 32-bit floats or 64-bit floats at compile time.\\n#ifdef USE_DOUBLE_PRECISION\\n#define HEMAN_FLOAT double\\n#else\\n#define HEMAN_FLOAT float\\n#endif\\n\\n// Occasionally the heman API accepts four-byte color for convenience.  For now\\n// we\\'re only using the lower three bytes (XRGB).\\ntypedef unsigned int heman_color;\\ntypedef unsigned char heman_byte;\\n\\n// Allocate a floating-point image with dimensions width x height x nbands.\\nheman_image* heman_image_create(int width, int height, int nbands);\\n\\n// Obtain image properties.\\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\\n\\n// Peek at the stored texel values.\\nHEMAN_FLOAT* heman_image_data(heman_image*);\\n\\n// Peek at the stored texel values in a SWIG-amenable way.\\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\\n\\n// Peek at the given texel value.\\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\\n\\n// Find a reasonable value for the given normalized texture coord.\\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\\n\\n// Set every band of every texel to the given value.\\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\\n\\n// Free memory for a image.\\nvoid heman_image_destroy(heman_image*);\\n\\n// Create a one-band image from a four-band image by extracting the 4th channel.\\nheman_image* heman_image_extract_alpha(heman_image*);\\n\\n// Create a three-band image from a four-band image by extracting first 3 bands.\\nheman_image* heman_image_extract_rgb(heman_image*);\\n\\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\\n// the given control points, in a gamma correct way.  Each control point is\\n// defined by an X location (one integer each) and an RGB value (one 32-bit\\n// word for each color).\\nheman_image* heman_color_create_gradient(int width, int num_colors,\\n    const int* cp_locations, const heman_color* cp_colors);\\n\\n// This sets some global state that affects lighting and color interpolation.\\n// The default value is 2.2.\\nvoid heman_color_set_gamma(float f);\\n\\n// Create a 3-band image with the same dimensions as the given heightmap by\\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\\n// are normalized using the given minval, maxval range.\\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\\n\\n// Convert a single-channel image into a 3-channel image via duplication.\\nheman_image* heman_color_from_grayscale(heman_image* gray);\\n\\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\\n\\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\\n\\n// High-level function that uses several octaves of simplex noise and a signed\\n// distance field to generate an interesting height map.\\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\\n\\n// High-level function that deforms a hemisphere with simplex noise.\\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\\n\\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\\n// domain to generate an interesting lat-long height map.\\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\\n\\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\\n// Points can be 3-tuples, in which case the 3rd component represents the\\n// strength of the seed point.\\nheman_image* heman_generate_archipelago_heightmap(\\n    int width, int height, heman_points* points, float noiseamt, int seed);\\n\\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\\n// purely political boundaries are ignored when generating the finalized\\n// height map.\\nvoid heman_generate_archipelago_political(int width, int height,\\n    heman_points* points, const heman_color* colors, heman_color ocean,\\n    int seed, heman_image** elevation, heman_image** political,\\n    int elevation_mode);\\n\\n// High-level function that sums up a number of noise octaves, also known as\\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\\n// fractals; this makes them more fractal-like. A good starting point is to use\\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\\n\\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\\nheman_image* heman_lighting_apply(heman_image* heightmap,\\n    heman_image* colorbuffer, float occlusion, float diffuse,\\n    float diffuse_softening, const float* light_position);\\n\\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\\n// using simple forward differencing and OpenMP.\\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\\n\\n// Compute occlusion values for the given heightmap, as described at\\n// http://nothings.org/gamedev/horizon/.\\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\\n\\n// Sets some global state that affects ambient occlusion computations.\\nvoid heman_lighting_set_occlusion_scale(float s);\\n\\n// Create a one-band \"signed distance field\" based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\\n\\n// Create a one-band unsigned distance field based on the given input, using\\n// the fast algorithm described in Felzenszwalb 2012.\\nheman_image* heman_distance_create_df(heman_image* monochrome);\\n\\n// Create a two-band \"closest point coordinate field\" containing the\\n// non-normalized texture coordinates of the nearest seed.  The result is\\n// related to the distance field but has a greater amount of information.\\nheman_image* heman_distance_create_cpcf(heman_image* seed);\\n\\n// Convert a two-band coordinate field into an unsigned distance field.\\nheman_image* heman_distance_from_cpcf(heman_image* cf);\\n\\n// Create a two-band CPCF where each texel contains its own coordinate.\\nheman_image* heman_distance_identity_cpcf(int width, int height);\\n\\n// Create a single-channel floating point point image from bytes, such that\\n// [0, 255] map to the given [minval, maxval] range.\\nheman_image* heman_import_u8(int width, int height, int nbands,\\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads.\\nvoid heman_export_ply(heman_image*, const char* filename);\\n\\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\\nvoid heman_export_with_colors_ply(\\n    heman_image* heightmap, heman_image* colors, const char* filename);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\\n// the result to \"dest\".  Values outside the range are clamped.\\nvoid heman_export_u8(\\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\\n\\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\\n\\n// Given a set of same-sized images, copy them into a vertical filmstrip.\\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\\n\\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\\n// result.  Values outside the range are clamped.  The source image is\\n// untouched.\\nheman_image* heman_ops_normalize_f32(\\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\\n\\n// Compute the maximum value between two height maps.\\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\\n\\n// Generate a monochrome image by applying a step function.\\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\\n\\n// Takes a 1-band elevation image and makes it tiered (scalloped).\\n// Optionally takes a color mask, and applies the step operator only\\n// in the regions with the given mask color.\\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Similar to stairstep, but tries to guarantee that every tier\\n// has the same total land area.\\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\\n    heman_image* mask, heman_color mask_color, int invert_mask,\\n    HEMAN_FLOAT offset);\\n\\n// Generate a height x 1 x 1 image by averaging the values across each row.\\nheman_image* heman_ops_sweep(heman_image* image);\\n\\n// Provide a cheap way of measuring \"curvature\" that doesn\\'t work well\\n// at saddle points.  Returns a single-band image.\\nheman_image* heman_ops_laplacian(heman_image* heightmap);\\n\\n// Highlight edges using the Sobel operator\\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\\n\\n// Add the values of src into dst.\\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\\n\\n// Use FBM and Perlin noise to warp the given image.\\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\\n\\n// Same as ops_warp, but alos applies the warping operation to a point list.\\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\\n    heman_points* pts);\\n\\n// Consume a 3-band image and a color of interest; produce a 1-band image.\\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\\n\\n// Replace a region of solid color with texture.\\nheman_image* heman_ops_replace_color(\\n    heman_image* src, heman_color color, heman_image* texture);\\n\\n// Create a 4-band image by merging a 3-band political image with\\n// a 1-band elevation image.\\nheman_image* heman_ops_merge_political(\\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\\n\\n// Add coarse-grain noise to ocean and fine-grain noise to land.\\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\\n\\n// Create a point list.\\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\\n\\n// Free memory for a point list.\\nvoid heman_points_destroy(heman_points*);\\n\\n// Perform simple stratified sampling over a grid.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\\n\\n// Perform Bridson\\'s algorithm for Fast Poisson Disk sampling.\\n// Creates a two-band point list of X Y coordinates.\\nheman_points* heman_points_from_poisson(\\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\\n\\n// Perform Bridson\\'s sampling algorithm, modulated by a density field.\\n// Creates a two-band point list, sorted from high-density (low radius) to\\n// low-density (high radius).\\nheman_points* heman_points_from_density(\\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\\n\\n// Set the given list of texels to the given value.\\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\\n\\n// Set the given list of texels to the given list of colors.\\nvoid heman_draw_colored_points(\\n    heman_image* target, heman_points* coords, const heman_color* colors);\\n\\n// Draw colored circles into the given render target.\\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\\n    int radius, const heman_color* colors);\\n\\n// Draw a Gaussian splat at each given point.\\n// The blend_mode parameter is ignored for now (it\\'s always ADD).\\nvoid heman_draw_splats(\\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\\n\\n// Treats a set of points like blobs and draws a contour around them.\\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\\n    heman_color color, float mind, float maxd, int filterd);\\n\\n// This returns omp_get_max_threads() for diagnostic purposes.\\nint heman_get_num_threads();\\n\\n#ifdef __cplusplus\\n};', 'kmVec2': '} kmVec2;', 'kmVec3': '} kmVec3;', 'SIZE': 'static const int SIZE = 512;', 'cp_colors': 'heman_color cp_colors[] = {\\n    0x001070,  // Dark Blue\\n    0x2C5A7C,  // Light Blue\\n    0xE0F0A0,  // Yellow\\n    0x5D943C,  // Dark Green\\n    0x606011,  // Brown\\n    0xFFFFFF,  // White\\n    0xFFFFFF,  // White\\n};', 'cp_locations': 'int cp_locations[] = {\\n    000,  // Dark Blue\\n    126,  // Light Blue\\n    127,  // Yellow\\n    128,  // Dark Green\\n    160,  // Brown\\n    200,  // White\\n    255,  // White\\n};', 'first_row_filter': 'static stbi_uc first_row_filter[5] =\\n{\\n   STBI__F_none, STBI__F_sub, STBI__F_none, STBI__F_avg_first, STBI__F_paeth_first\\n};', 'fp32_to_srgb8_tab4': 'static const stbir_uint32 fp32_to_srgb8_tab4[104] = {\\n    0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d, 0x009a000d, 0x00a1000d,\\n    0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a, 0x0101001a,\\n    0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,\\n    0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067,\\n    0x037800ce, 0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5,\\n    0x06970158, 0x07420142, 0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2,\\n    0x0b0f01cb, 0x0bf401ae, 0x0ccb0195, 0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143,\\n    0x11070264, 0x1238023e, 0x1357021d, 0x14660201, 0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af,\\n    0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d, 0x201a0270, 0x21520256, 0x227d0240,\\n    0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341, 0x2ebe031f, 0x304d0300,\\n    0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a, 0x42bd0401,\\n    0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,\\n    0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723,\\n};', 'stbi__YCbCr_installed': 'static stbi_YCbCr_to_RGB_run stbi__YCbCr_installed = stbi__YCbCr_to_RGB_row;', 'stbi__bmask': 'static stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};', 'stbi__de_iphone_flag': 'static int stbi__de_iphone_flag = 0;', 'stbi__g_failure_reason': 'static const char *stbi__g_failure_reason;', 'stbi__h2l_gamma_i': 'static float stbi__h2l_gamma_i=1.0f\\\\/2.2f, stbi__h2l_scale_i=1.0f;', 'stbi__h2l_scale_i': 'static float stbi__h2l_gamma_i=1.0f\\\\/2.2f, stbi__h2l_scale_i=1.0f;', 'stbi__idct_installed': 'static stbi_idct_8x8 stbi__idct_installed = stbi__idct_block;', 'stbi__jpeg_dezigzag': 'static stbi_uc stbi__jpeg_dezigzag[64+15] =\\n{\\n    0,  1,  8, 16,  9,  2,  3, 10,\\n   17, 24, 32, 25, 18, 11,  4,  5,\\n   12, 19, 26, 33, 40, 48, 41, 34,\\n   27, 20, 13,  6,  7, 14, 21, 28,\\n   35, 42, 49, 56, 57, 50, 43, 36,\\n   29, 22, 15, 23, 30, 37, 44, 51,\\n   58, 59, 52, 45, 38, 31, 39, 46,\\n   53, 60, 61, 54, 47, 55, 62, 63,\\n   // let corrupt input sample past end\\n   63, 63, 63, 63, 63, 63, 63, 63,\\n   63, 63, 63, 63, 63, 63, 63\\n};', 'stbi__l2h_gamma': 'static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;', 'stbi__l2h_scale': 'static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;', 'stbi__stdio_callbacks': 'static stbi_io_callbacks stbi__stdio_callbacks =\\n{\\n   stbi__stdio_read,\\n   stbi__stdio_skip,\\n   stbi__stdio_eof,\\n};', 'stbi__unpremultiply_on_load': 'static int stbi__unpremultiply_on_load = 0;', 'stbi__zdefault_distance': 'static stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];', 'stbi__zdefault_length': 'static stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];', 'stbi__zdist_base': 'static int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};', 'stbi__zdist_extra': 'static int stbi__zdist_extra[32] =\\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};', 'stbi__zlength_base': 'static int stbi__zlength_base[31] = {\\n   3,4,5,6,7,8,9,10,11,13,\\n   15,17,19,23,27,31,35,43,51,59,\\n   67,83,99,115,131,163,195,227,258,0,0 };', 'stbi__zlength_extra': 'static int stbi__zlength_extra[31]= \\n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };', 'stbir__filter_info_table': 'static stbir__filter_info stbir__filter_info_table[] = {\\n        { NULL,                     stbir__support_zero },\\n        { stbir__filter_trapezoid,  stbir__support_trapezoid },\\n        { stbir__filter_triangle,   stbir__support_one },\\n        { stbir__filter_cubic,      stbir__support_two },\\n        { stbir__filter_catmullrom, stbir__support_two },\\n        { stbir__filter_mitchell,   stbir__support_two },\\n};', 'stbir__srgb_offset_to_linear_scaled': 'static int stbir__srgb_offset_to_linear_scaled[256] =\\n{\\n            0,     40738,    122216,    203693,    285170,    366648,    448125,    529603,\\n       611080,    692557,    774035,    855852,    942009,   1033024,   1128971,   1229926,\\n      1335959,   1447142,   1563542,   1685229,   1812268,   1944725,   2082664,   2226148,\\n      2375238,   2529996,   2690481,   2856753,   3028870,   3206888,   3390865,   3580856,\\n      3776916,   3979100,   4187460,   4402049,   4622919,   4850123,   5083710,   5323731,\\n      5570236,   5823273,   6082892,   6349140,   6622065,   6901714,   7188133,   7481369,\\n      7781466,   8088471,   8402427,   8723380,   9051372,   9386448,   9728650,  10078021,\\n     10434603,  10798439,  11169569,  11548036,  11933879,  12327139,  12727857,  13136073,\\n     13551826,  13975156,  14406100,  14844697,  15290987,  15745007,  16206795,  16676389,\\n     17153826,  17639142,  18132374,  18633560,  19142734,  19659934,  20185196,  20718552,\\n     21260042,  21809696,  22367554,  22933648,  23508010,  24090680,  24681686,  25281066,\\n     25888850,  26505076,  27129772,  27762974,  28404716,  29055026,  29713942,  30381490,\\n     31057708,  31742624,  32436272,  33138682,  33849884,  34569912,  35298800,  36036568,\\n     36783260,  37538896,  38303512,  39077136,  39859796,  40651528,  41452360,  42262316,\\n     43081432,  43909732,  44747252,  45594016,  46450052,  47315392,  48190064,  49074096,\\n     49967516,  50870356,  51782636,  52704392,  53635648,  54576432,  55526772,  56486700,\\n     57456236,  58435408,  59424248,  60422780,  61431036,  62449032,  63476804,  64514376,\\n     65561776,  66619028,  67686160,  68763192,  69850160,  70947088,  72053992,  73170912,\\n     74297864,  75434880,  76581976,  77739184,  78906536,  80084040,  81271736,  82469648,\\n     83677792,  84896192,  86124888,  87363888,  88613232,  89872928,  91143016,  92423512,\\n     93714432,  95015816,  96327688,  97650056,  98982952, 100326408, 101680440, 103045072,\\n    104420320, 105806224, 107202800, 108610064, 110028048, 111456776, 112896264, 114346544,\\n    115807632, 117279552, 118762328, 120255976, 121760536, 123276016, 124802440, 126339832,\\n    127888216, 129447616, 131018048, 132599544, 134192112, 135795792, 137410592, 139036528,\\n    140673648, 142321952, 143981456, 145652208, 147334208, 149027488, 150732064, 152447968,\\n    154175200, 155913792, 157663776, 159425168, 161197984, 162982240, 164777968, 166585184,\\n    168403904, 170234160, 172075968, 173929344, 175794320, 177670896, 179559120, 181458992,\\n    183370528, 185293776, 187228736, 189175424, 191133888, 193104112, 195086128, 197079968,\\n    199085648, 201103184, 203132592, 205173888, 207227120, 209292272, 211369392, 213458480,\\n    215559568, 217672656, 219797792, 221934976, 224084240, 226245600, 228419056, 230604656,\\n    232802400, 235012320, 237234432, 239468736, 241715280, 243974080, 246245120, 248528464,\\n    250824112, 253132064, 255452368, 257785040, 260130080, 262487520, 264857376, 267239664,\\n};', 'stbir__srgb_uchar_to_linear_float': 'static float stbir__srgb_uchar_to_linear_float[256] = {\\n    0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f, 0.001518f, 0.001821f, 0.002125f, 0.002428f, 0.002732f, 0.003035f,\\n    0.003347f, 0.003677f, 0.004025f, 0.004391f, 0.004777f, 0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f,\\n    0.008023f, 0.008568f, 0.009134f, 0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f, 0.014444f,\\n    0.015209f, 0.015996f, 0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f, 0.021219f, 0.022174f, 0.023153f, 0.024158f,\\n    0.025187f, 0.026241f, 0.027321f, 0.028426f, 0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f, 0.036889f,\\n    0.038204f, 0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f, 0.051269f, 0.052861f,\\n    0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f, 0.064803f, 0.066626f, 0.068478f, 0.070360f, 0.072272f,\\n    0.074214f, 0.076185f, 0.078187f, 0.080220f, 0.082283f, 0.084376f, 0.086500f, 0.088656f, 0.090842f, 0.093059f, 0.095307f,\\n    0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f, 0.114435f, 0.116971f, 0.119538f, 0.122139f,\\n    0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f, 0.138432f, 0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f,\\n    0.155926f, 0.158961f, 0.162029f, 0.165132f, 0.168269f, 0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f, 0.187821f,\\n    0.191202f, 0.194618f, 0.198069f, 0.201556f, 0.205079f, 0.208637f, 0.212231f, 0.215861f, 0.219526f, 0.223228f, 0.226966f,\\n    0.230740f, 0.234551f, 0.238398f, 0.242281f, 0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f,\\n    0.274677f, 0.278894f, 0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f, 0.313989f, 0.318547f,\\n    0.323143f, 0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f, 0.351533f, 0.356400f, 0.361307f, 0.366253f, 0.371238f,\\n    0.376262f, 0.381326f, 0.386430f, 0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f, 0.423268f, 0.428691f,\\n    0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f, 0.479320f, 0.485150f, 0.491021f,\\n    0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f, 0.527115f, 0.533276f, 0.539480f, 0.545725f, 0.552011f, 0.558340f,\\n    0.564712f, 0.571125f, 0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f, 0.610496f, 0.617207f, 0.623960f, 0.630757f,\\n    0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f, 0.679543f, 0.686685f, 0.693872f, 0.701102f, 0.708376f,\\n    0.715694f, 0.723055f, 0.730461f, 0.737911f, 0.745404f, 0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f,\\n    0.799103f, 0.806952f, 0.814847f, 0.822786f, 0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f, 0.871367f, 0.879622f,\\n    0.887923f, 0.896269f, 0.904661f, 0.913099f, 0.921582f, 0.930111f, 0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f,\\n    0.982251f, 0.991102f, 1.0f\\n};', 'stbir__type_size': 'static unsigned char stbir__type_size[] = {\\n    1, // STBIR_TYPE_UINT8\\n    2, // STBIR_TYPE_UINT16\\n    4, // STBIR_TYPE_UINT32\\n    4, // STBIR_TYPE_FLOAT\\n};', 'CASE': '      #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)', 'COMBO': '      #define COMBO(a,b)  ((a)*8+(b))', 'COUNT': '#define COUNT(a) (sizeof(a) / sizeof(a[0]))', 'FAST_BITS': '#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache', 'HEMAN_FLOAT': '#define HEMAN_FLOAT double', 'INCLUDE_STB_IMAGE_WRITE_H': '#define INCLUDE_STB_IMAGE_WRITE_H', 'KM_CONTAINS_ALL': '#define KM_CONTAINS_ALL (kmEnum)2', 'KM_CONTAINS_NONE': '#define KM_CONTAINS_NONE (kmEnum)0', 'KM_CONTAINS_PARTIAL': '#define KM_CONTAINS_PARTIAL (kmEnum)1', 'KM_FALSE': '#define KM_FALSE 0', 'KM_TRUE': '#define KM_TRUE 1', 'OUTFOLDER': '#define OUTFOLDER \"./\"', 'OVERWRITE_ARRAY_SIZE': '#define OVERWRITE_ARRAY_SIZE 8', 'PNG_TYPE': '#define PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))', 'STBIDEF': '#define STBIDEF static', 'STBIRDEF': '#define STBIRDEF static', 'STBIR_ALPHA_CHANNEL_NONE': '#define STBIR_ALPHA_CHANNEL_NONE       -1', 'STBIR_ALPHA_EPSILON': '#define STBIR_ALPHA_EPSILON ((float)1 / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20))', 'STBIR_ASSERT': '#define STBIR_ASSERT() to trigger an assert on parameter validation errors.', 'STBIR_DEFAULT_FILTER_DOWNSAMPLE': '#define STBIR_DEFAULT_FILTER_DOWNSAMPLE   STBIR_FILTER_something', 'STBIR_DEFAULT_FILTER_UPSAMPLE': '#define STBIR_DEFAULT_FILTER_UPSAMPLE     STBIR_FILTER_something', 'STBIR_FLAG_ALPHA_PREMULTIPLIED': '#define STBIR_FLAG_ALPHA_PREMULTIPLIED    (1 << 0)', 'STBIR_FLAG_ALPHA_USES_COLORSPACE': '#define STBIR_FLAG_ALPHA_USES_COLORSPACE  (1 << 1)', 'STBIR_FREE': '#define STBIR_FREE(ptr,context)   ...', 'STBIR_INCLUDE_STB_IMAGE_RESIZE_H': '#define STBIR_INCLUDE_STB_IMAGE_RESIZE_H', 'STBIR_MALLOC': '#define STBIR_MALLOC(size,context) ...', 'STBIR_MAX_CHANNELS': '#define STBIR_MAX_CHANNELS 64', 'STBIR_PROGRESS_REPORT': '#define STBIR_PROGRESS_REPORT(val)   some_func(val)', 'STBIR__ARRAY_SIZE': '#define STBIR__ARRAY_SIZE(a) (sizeof((a))/sizeof((a)[0]))', 'STBIR__DEBUG_ASSERT': '#define STBIR__DEBUG_ASSERT STBIR_ASSERT', 'STBIR__DECODE': '#define STBIR__DECODE(type, colorspace) ((type) * (STBIR_MAX_COLORSPACES) + (colorspace))', 'STBIR__ENCODE_LINEAR16': '    #define STBIR__ENCODE_LINEAR16(f)  stbir__saturate16(STBIR__ROUND_INT((f) * 65535))', 'STBIR__ENCODE_LINEAR8': '    #define STBIR__ENCODE_LINEAR8(f)   stbir__saturate8 (STBIR__ROUND_INT((f) * 255  ))', 'STBIR__NEXT_MEMPTR': '#define STBIR__NEXT_MEMPTR(current, newtype) (newtype*)(((unsigned char*)current) + current##_size)', 'STBIR__NOTUSED': '#define STBIR__NOTUSED(v)  (void)(v)', 'STBIR__ROUND_INT': '    #define STBIR__ROUND_INT(f)    ((int)          ((f)+0.5))', 'STBIR__ROUND_UINT': '    #define STBIR__ROUND_UINT(f)   ((stbir_uint32) ((f)+0.5))', 'STBIR__UNIMPLEMENTED': '#define STBIR__UNIMPLEMENTED(x) STBIR_ASSERT(!(x))', 'STBIR__UNUSED_PARAM': '#define STBIR__UNUSED_PARAM(v)  (void)(v)', 'STBIW_ASSERT': '#define STBIW_ASSERT(x) before the #include to avoid using assert.h.', 'STBIW_FREE': '#define STBIW_FREE(p)       free(p)', 'STBIW_MALLOC': '#define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace', 'STBIW_MEMMOVE': '#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)', 'STBIW_REALLOC': '#define STBIW_REALLOC(p,sz) realloc(p,sz)', 'STBI_ASSERT': '#define STBI_ASSERT(x) to avoid using assert.h.', 'STBI_HAS_LROTL': '#define STBI_HAS_LROTL', 'STBI_INCLUDE_STB_IMAGE_H': '#define STBI_INCLUDE_STB_IMAGE_H', 'STBI_NOTUSED': '#define STBI_NOTUSED(v)  (void)(v)', 'STBI_VERSION': '#define STBI_VERSION 1', 'STBI__BYTECAST': '#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings', 'STBI__HDR_BUFLEN': '#define STBI__HDR_BUFLEN  1024', 'STBI__IDCT_1D': '#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7)       \\\\', 'STBI__MARKER_none': '#define STBI__MARKER_none  0xff', 'STBI__RESTART': '#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)', 'STBI__ZFAST_BITS': '#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables', 'STBI__ZFAST_MASK': '#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)', 'STB_IMAGE_IMPLEMENTATION': '#define STB_IMAGE_IMPLEMENTATION', 'STB_IMAGE_RESIZE_IMPLEMENTATION': '#define STB_IMAGE_RESIZE_IMPLEMENTATION', 'STB_IMAGE_WRITE_IMPLEMENTATION': '#define STB_IMAGE_WRITE_IMPLEMENTATION', 'UTILITY_H_INCLUDED': '#define UTILITY_H_INCLUDED', 'VEC2_H_INCLUDED': '#define VEC2_H_INCLUDED', 'VEC3_H_INCLUDED': '#define VEC3_H_INCLUDED', 'float2fixed': '#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))', 'kmBool': '#define kmBool unsigned char', 'kmEnum': '#define kmEnum unsigned int', 'kmEpsilon': '#define kmEpsilon 0.0001', 'kmInt': '#define kmInt int', 'kmPI': '#define kmPI 3.14159265358979323846f', 'kmPIOver180': '#define kmPIOver180  (kmPI / 180.0f)', 'kmPIUnder180': '#define kmPIUnder180 (180.0 / kmPI)', 'kmScalar': '#define kmScalar double', 'kmUchar': '#define kmUchar unsigned char', 'kmUint': '#define kmUint unsigned int', 'stbi__DNL': '#define stbi__DNL(x)         ((x) == 0xdc)', 'stbi__EOI': '#define stbi__EOI(x)         ((x) == 0xd9)', 'stbi__SOF': '#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1)', 'stbi__SOI': '#define stbi__SOI(x)         ((x) == 0xd8)', 'stbi__SOS': '#define stbi__SOS(x)         ((x) == 0xda)', 'stbi__div16': '#define stbi__div16(x) ((stbi_uc) ((x) >> 4))', 'stbi__div4': '#define stbi__div4(x) ((stbi_uc) ((x) >> 2))', 'stbi__err': '   #define stbi__err(x,y)  0', 'stbi__errpf': '#define stbi__errpf(x,y)   ((float *) (stbi__err(x,y)?NULL:NULL))', 'stbi__errpuc': '#define stbi__errpuc(x,y)  ((unsigned char *) (stbi__err(x,y)?NULL:NULL))', 'stbi__f2f': '#define stbi__f2f(x)  (int) (((x) * 4096 + 0.5))', 'stbi__float2int': '#define stbi__float2int(x)   ((int) (x))', 'stbi__fsh': '#define stbi__fsh(x)  ((x) << 12)', 'stbi_inline': '   #define stbi_inline inline', 'stbi_lrot': '   #define stbi_lrot(x,y)  _lrotl(x,y)', 'stbir__inline': '#define stbir__inline inline', 'stbiw__ZHASH': '#define stbiw__ZHASH   16384', 'stbiw__max': '#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))', 'stbiw__sbcount': '#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)', 'stbiw__sbfree': '#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)', 'stbiw__sbgrow': '#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))', 'stbiw__sbm': '#define stbiw__sbm(a)   stbiw__sbraw(a)[0]', 'stbiw__sbmaybegrow': '#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)', 'stbiw__sbn': '#define stbiw__sbn(a)   stbiw__sbraw(a)[1]', 'stbiw__sbneedgrow': '#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))', 'stbiw__sbpush': '#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))', 'stbiw__sbraw': '#define stbiw__sbraw(a) ((int *) (a) - 2)', 'stbiw__wp32': '#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));', 'stbiw__wpng4': '#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=(unsigned char)(a),(o)[1]=(unsigned char)(b),(o)[2]=(unsigned char)(c),(o)[3]=(unsigned char)(d),(o)+=4)', 'stbiw__wptag': '#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])', 'stbiw__zlib_add': '#define stbiw__zlib_add(code,codebits) \\\\', 'stbiw__zlib_flush': '#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))', 'stbiw__zlib_huff': '#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))', 'stbiw__zlib_huff1': '#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)', 'stbiw__zlib_huff2': '#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)', 'stbiw__zlib_huff3': '#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)', 'stbiw__zlib_huff4': '#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)', 'stbiw__zlib_huffa': '#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)', 'stbiw__zlib_huffb': '#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))', 'heman_byte': 'typedef unsigned char heman_byte;', 'heman_color': 'typedef unsigned int heman_color;', 'heman_image': 'typedef struct heman_image_s heman_image;', 'heman_points': 'typedef struct heman_image_s heman_points;', 'resample_row_func': 'typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,\\n                                    int w, int hs);', 'stb_image_write_test': 'typedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];', 'stbi_YCbCr_to_RGB_run': 'typedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);', 'stbi__context': '} stbi__context;', 'stbi__gif': '} stbi__gif;', 'stbi__gif_lzw': '} stbi__gif_lzw;', 'stbi__huffman': '} stbi__huffman;', 'stbi__int16': 'typedef int16_t  stbi__int16;', 'stbi__int32': 'typedef int32_t  stbi__int32;', 'stbi__jpeg': '} stbi__jpeg;', 'stbi__pic_packet': '} stbi__pic_packet;', 'stbi__png': '} stbi__png;', 'stbi__pngchunk': '} stbi__pngchunk;', 'stbi__resample': '} stbi__resample;', 'stbi__uint16': 'typedef unsigned short stbi__uint16;', 'stbi__uint32': 'typedef unsigned int   stbi__uint32;', 'stbi__zbuf': '} stbi__zbuf;', 'stbi__zhuffman': '} stbi__zhuffman;', 'stbi_dequantize_t': 'typedef unsigned short stbi_dequantize_t;', 'stbi_idct_8x8': 'typedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);', 'stbi_io_callbacks': '} stbi_io_callbacks;', 'stbi_uc': 'typedef unsigned char stbi_uc;', 'stbir__FP32': '} stbir__FP32;', 'stbir__contributors': '} stbir__contributors;', 'stbir__filter_info': '} stbir__filter_info;', 'stbir__info': '} stbir__info;', 'stbir__kernel_fn': 'typedef float (stbir__kernel_fn)(float x, float scale);', 'stbir__support_fn': 'typedef float (stbir__support_fn)(float scale);', 'stbir__validate_uint32': 'typedef unsigned char stbir__validate_uint32[sizeof(stbir_uint32) == 4 ? 1 : -1];', 'stbir_colorspace': '} stbir_colorspace;', 'stbir_datatype': '} stbir_datatype;', 'stbir_edge': '} stbir_edge;', 'stbir_filter': '} stbir_filter;', 'stbir_uint16': 'typedef unsigned short stbir_uint16;', 'stbir_uint32': 'typedef unsigned int   stbir_uint32;', 'stbir_uint8': 'typedef unsigned char  stbir_uint8;', 'stbiw_uint32': 'typedef unsigned int stbiw_uint32;', 'validate_uint32': 'typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];', '__anona3b55b0e0103': '{\\n    printf(\"%d threads available.\\\\n\", omp_get_max_threads());', '__anona3b55b0e0203': '{\\n    printf(\"%d threads available.\\\\n\", omp_get_max_threads());', '__anona3b55b0e0303': '{\\n    printf(\"%d threads available.\\\\n\", omp_get_max_threads());', '__anona3b55b0e0403': '{\\n    printf(\"%d threads available.\\\\n\", omp_get_max_threads());', '__anona3b55b0e0903': '{\\n    printf(\"%d threads available.\\\\n\", omp_get_max_threads());', '__anona3b55b0e0c03': '{\\n    printf(\"%d threads available.\\\\n\", omp_get_max_threads());', '__anona3b55b0e1503': 'enum {\\n   STBI__F_none=0, STBI__F_sub=1, STBI__F_up=2, STBI__F_avg=3, STBI__F_paeth=4,\\n   STBI__F_avg_first, STBI__F_paeth_first\\n};'} extract_info: [#pragma once\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// An \"image\" encapsulates three integers (width, height, number of bands)\n// and an array of (w * h * nbands) floats, in scanline order.  For simplicity\n// the API disallows struct definitions, so this is just an opaque handle.\ntypedef struct heman_image_s heman_image;\n\n// Point lists are actually one-dimensional images in disguise, usually with\n// two bands (X and Y coordinates).\ntypedef struct heman_image_s heman_points;\n\n// Image values in heman are always floating point, but clients may\n// choose either 32-bit floats or 64-bit floats at compile time.\n#ifdef USE_DOUBLE_PRECISION\n#define HEMAN_FLOAT double\n#else\n#define HEMAN_FLOAT float\n#endif\n\n// Occasionally the heman API accepts four-byte color for convenience.  For now\n// we're only using the lower three bytes (XRGB).\ntypedef unsigned int heman_color;\ntypedef unsigned char heman_byte;\n\n// Allocate a floating-point image with dimensions width x height x nbands.\nheman_image* heman_image_create(int width, int height, int nbands);\n\n// Obtain image properties.\nvoid heman_image_info(heman_image*, int* width, int* height, int* nbands);\n\n// Peek at the stored texel values.\nHEMAN_FLOAT* heman_image_data(heman_image*);\n\n// Peek at the stored texel values in a SWIG-amenable way.\nvoid heman_image_array(heman_image* img, HEMAN_FLOAT** outview, int* n);\n\n// Peek at the given texel value.\nHEMAN_FLOAT* heman_image_texel(heman_image*, int x, int y);\n\n// Find a reasonable value for the given normalized texture coord.\nvoid heman_image_sample(heman_image*, float u, float v, HEMAN_FLOAT* result);\n\n// Set every band of every texel to the given value.\nvoid heman_image_clear(heman_image*, HEMAN_FLOAT value);\n\n// Free memory for a image.\nvoid heman_image_destroy(heman_image*);\n\n// Create a one-band image from a four-band image by extracting the 4th channel.\nheman_image* heman_image_extract_alpha(heman_image*);\n\n// Create a three-band image from a four-band image by extracting first 3 bands.\nheman_image* heman_image_extract_rgb(heman_image*);\n\n// Create a 1-pixel tall, 3-band image representing a color gradient that lerps\n// the given control points, in a gamma correct way.  Each control point is\n// defined by an X location (one integer each) and an RGB value (one 32-bit\n// word for each color).\nheman_image* heman_color_create_gradient(int width, int num_colors,\n    const int* cp_locations, const heman_color* cp_colors);\n\n// This sets some global state that affects lighting and color interpolation.\n// The default value is 2.2.\nvoid heman_color_set_gamma(float f);\n\n// Create a 3-band image with the same dimensions as the given heightmap by\n// making lookups from a 1-pixel tall color gradient.  The heightmap values\n// are normalized using the given minval, maxval range.\nheman_image* heman_color_apply_gradient(heman_image* heightmap,\n    HEMAN_FLOAT minheight, HEMAN_FLOAT maxheight, heman_image* gradient);\n\n// Convert a single-channel image into a 3-channel image via duplication.\nheman_image* heman_color_from_grayscale(heman_image* gray);\n\n// Convert 3-channel image into 1-channel image based on perceptive luminance.\nheman_image* heman_color_to_grayscale(heman_image* colorimg);\n\n// Dereference a coordinate field (see heman_distance_create_cpcf) by making\n// lookups into a color texture.  Useful for creating Voronoi diagrams.\nheman_image* heman_color_from_cpcf(heman_image* cfield, heman_image* texture);\n\n// High-level function that uses several octaves of simplex noise and a signed\n// distance field to generate an interesting height map.\nheman_image* heman_generate_island_heightmap(int width, int height, int seed);\n\n// High-level function that deforms a hemisphere with simplex noise.\nheman_image* heman_generate_rock_heightmap(int width, int height, int seed);\n\n// High-level function that uses several octaves of OpenSimplex noise over a 3D\n// domain to generate an interesting lat-long height map.\nheman_image* heman_generate_planet_heightmap(int width, int height, int seed);\n\n// Similar to generate_island, but takes a two-band (X Y) list of centers.\n// 0.3 is a good choice for the noiseamt, but 0 is useful for diagnostics.\n// Points can be 3-tuples, in which case the 3rd component represents the\n// strength of the seed point.\nheman_image* heman_generate_archipelago_heightmap(\n    int width, int height, heman_points* points, float noiseamt, int seed);\n\n// Similar to generate_archipelago_heightmap, but generates a \"political\"\n// RGB image in addition to the heightmap.  If the elevation mode is 0,\n// purely political boundaries are ignored when generating the finalized\n// height map.\nvoid heman_generate_archipelago_political(int width, int height,\n    heman_points* points, const heman_color* colors, heman_color ocean,\n    int seed, heman_image** elevation, heman_image** political,\n    int elevation_mode);\n\n// High-level function that sums up a number of noise octaves, also known as\n// Fractional Brownian Motion.  Taken alone, Perlin / Simplex noise are not\n// fractals; this makes them more fractal-like. A good starting point is to use\n// a lacunarity of 2.0 and a gain of 0.5, with only 2 or 3 octaves.\nheman_image* heman_generate_simplex_fbm(int width, int height, float frequency,\n    float amplitude, int octaves, float lacunarity, float gain, int seed);\n\n// Apply ambient occlusion and diffuse lighting to the given heightmap.\nheman_image* heman_lighting_apply(heman_image* heightmap,\n    heman_image* colorbuffer, float occlusion, float diffuse,\n    float diffuse_softening, const float* light_position);\n\n// Given a 1-band heightmap image, create a 3-band image with surface normals,\n// using simple forward differencing and OpenMP.\nheman_image* heman_lighting_compute_normals(heman_image* heightmap);\n\n// Compute occlusion values for the given heightmap, as described at\n// http://nothings.org/gamedev/horizon/.\nheman_image* heman_lighting_compute_occlusion(heman_image* heightmap);\n\n// Sets some global state that affects ambient occlusion computations.\nvoid heman_lighting_set_occlusion_scale(float s);\n\n// Create a one-band \"signed distance field\" based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_sdf(heman_image* monochrome);\n\n// Create a one-band unsigned distance field based on the given input, using\n// the fast algorithm described in Felzenszwalb 2012.\nheman_image* heman_distance_create_df(heman_image* monochrome);\n\n// Create a two-band \"closest point coordinate field\" containing the\n// non-normalized texture coordinates of the nearest seed.  The result is\n// related to the distance field but has a greater amount of information.\nheman_image* heman_distance_create_cpcf(heman_image* seed);\n\n// Convert a two-band coordinate field into an unsigned distance field.\nheman_image* heman_distance_from_cpcf(heman_image* cf);\n\n// Create a two-band CPCF where each texel contains its own coordinate.\nheman_image* heman_distance_identity_cpcf(int width, int height);\n\n// Create a single-channel floating point point image from bytes, such that\n// [0, 255] map to the given [minval, maxval] range.\nheman_image* heman_import_u8(int width, int height, int nbands,\n    const heman_byte* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Create a mesh with (width - 1) x (height - 1) quads.\nvoid heman_export_ply(heman_image*, const char* filename);\n\n// Create a mesh with (width - 1) x (height - 1) quads and per-vertex colors.\nvoid heman_export_with_colors_ply(\n    heman_image* heightmap, heman_image* colors, const char* filename);\n\n// Transform texel values so that [minval, maxval] map to [0, 255], and write\n// the result to \"dest\".  Values outside the range are clamped.\nvoid heman_export_u8(\n    heman_image* source, HEMAN_FLOAT minv, HEMAN_FLOAT maxv, heman_byte* outp);\n\n// Given a set of same-sized images, copy them into a horizontal filmstrip.\nheman_image* heman_ops_stitch_horizontal(heman_image** images, int count);\n\n// Given a set of same-sized images, copy them into a vertical filmstrip.\nheman_image* heman_ops_stitch_vertical(heman_image** images, int count);\n\n// Transform texel values so that [minval, maxval] map to [0, 1] and return the\n// result.  Values outside the range are clamped.  The source image is\n// untouched.\nheman_image* heman_ops_normalize_f32(\n    heman_image* source, HEMAN_FLOAT minval, HEMAN_FLOAT maxval);\n\n// Compute the maximum value between two height maps.\nheman_image* heman_ops_max(heman_image* imga, heman_image* imgb);\n\n// Generate a monochrome image by applying a step function.\nheman_image* heman_ops_step(heman_image* image, HEMAN_FLOAT threshold);\n\n// Takes a 1-band elevation image and makes it tiered (scalloped).\n// Optionally takes a color mask, and applies the step operator only\n// in the regions with the given mask color.\nheman_image* heman_ops_stairstep(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Similar to stairstep, but tries to guarantee that every tier\n// has the same total land area.\nheman_image* heman_ops_percentiles(heman_image* image, int nsteps,\n    heman_image* mask, heman_color mask_color, int invert_mask,\n    HEMAN_FLOAT offset);\n\n// Generate a height x 1 x 1 image by averaging the values across each row.\nheman_image* heman_ops_sweep(heman_image* image);\n\n// Provide a cheap way of measuring \"curvature\" that doesn't work well\n// at saddle points.  Returns a single-band image.\nheman_image* heman_ops_laplacian(heman_image* heightmap);\n\n// Highlight edges using the Sobel operator\nheman_image* heman_ops_sobel(heman_image* dst, heman_color edge_color);\n\n// Add the values of src into dst.\nvoid heman_ops_accumulate(heman_image* dst, heman_image* src);\n\n// Use FBM and Perlin noise to warp the given image.\nheman_image* heman_ops_warp(heman_image* src, int seed, int octaves);\n\n// Same as ops_warp, but alos applies the warping operation to a point list.\nheman_image* heman_ops_warp_points(heman_image* src, int seed, int octaves,\n    heman_points* pts);\n\n// Consume a 3-band image and a color of interest; produce a 1-band image.\nheman_image* heman_ops_extract_mask(heman_image* src, heman_color color, int invert);\n\n// Replace a region of solid color with texture.\nheman_image* heman_ops_replace_color(\n    heman_image* src, heman_color color, heman_image* texture);\n\n// Create a 4-band image by merging a 3-band political image with\n// a 1-band elevation image.\nheman_image* heman_ops_merge_political(\n    heman_image* elevation, heman_image* political, heman_color ocean_color);\n\n// Add coarse-grain noise to ocean and fine-grain noise to land.\nheman_image* heman_ops_emboss(heman_image* elevation, int mode);\n\n// Create a point list.\nheman_image* heman_points_create(HEMAN_FLOAT* xy, int npoints, int nbands);\n\n// Free memory for a point list.\nvoid heman_points_destroy(heman_points*);\n\n// Perform simple stratified sampling over a grid.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_grid(HEMAN_FLOAT width, HEMAN_FLOAT height,\n    HEMAN_FLOAT cellsize, HEMAN_FLOAT jitter);\n\n// Perform Bridson's algorithm for Fast Poisson Disk sampling.\n// Creates a two-band point list of X Y coordinates.\nheman_points* heman_points_from_poisson(\n    HEMAN_FLOAT width, HEMAN_FLOAT height, HEMAN_FLOAT mindist);\n\n// Perform Bridson's sampling algorithm, modulated by a density field.\n// Creates a two-band point list, sorted from high-density (low radius) to\n// low-density (high radius).\nheman_points* heman_points_from_density(\n    heman_image* density, HEMAN_FLOAT mindist, HEMAN_FLOAT maxdist);\n\n// Set the given list of texels to the given value.\nvoid heman_draw_points(heman_image* target, heman_points* pts, HEMAN_FLOAT val);\n\n// Set the given list of texels to the given list of colors.\nvoid heman_draw_colored_points(\n    heman_image* target, heman_points* coords, const heman_color* colors);\n\n// Draw colored circles into the given render target.\nvoid heman_draw_colored_circles(heman_image* target, heman_points* pts,\n    int radius, const heman_color* colors);\n\n// Draw a Gaussian splat at each given point.\n// The blend_mode parameter is ignored for now (it's always ADD).\nvoid heman_draw_splats(\n    heman_image* target, heman_points* pts, int radius, int blend_mode);\n\n// Treats a set of points like blobs and draws a contour around them.\n// Points can be 2-tuples (X Y) or 3-tuples (X Y Radius).\nvoid heman_draw_contour_from_points(heman_image* target, heman_points* coords,\n    heman_color color, float mind, float maxd, int filterd);\n\n// This returns omp_get_max_threads() for diagnostic purposes.\nint heman_get_num_threads();\n\n#ifdef __cplusplus\n}\n#endif\n#include <time.h>\n/*\nCopyright (c) 2008, Luke Benstead.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef VEC2_H_INCLUDED\n#define VEC2_H_INCLUDED\n\n/*\nCopyright (c) 2008, Luke Benstead.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef UTILITY_H_INCLUDED\n#define UTILITY_H_INCLUDED\n\n#include <math.h>\n\n#ifndef kmScalar\n#ifdef USE_DOUBLE_PRECISION\n#define kmScalar double\n#else\n#define kmScalar float\n#endif\n\n#endif\n\n#ifndef kmBool\n#define kmBool unsigned char\n#endif\n\n#ifndef kmUchar\n#define kmUchar unsigned char\n#endif\n\n#ifndef kmEnum\n#define kmEnum unsigned int\n#endif\n\n#ifndef kmUint\n#define kmUint unsigned int\n#endif\n\n#ifndef kmInt\n#define kmInt int\n#endif\n\n#ifndef KM_FALSE\n#define KM_FALSE 0\n#endif\n\n#ifndef KM_TRUE\n#define KM_TRUE 1\n#endif\n\n#define kmPI 3.14159265358979323846f\n#define kmPIOver180  (kmPI / 180.0f)\n#define kmPIUnder180 (180.0 / kmPI)\n#define kmEpsilon 0.0001\n\n#define KM_CONTAINS_NONE (kmEnum)0\n#define KM_CONTAINS_PARTIAL (kmEnum)1\n#define KM_CONTAINS_ALL (kmEnum)2\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern kmScalar kmSQR(kmScalar s);\nextern kmScalar kmDegreesToRadians(kmScalar degrees);\nextern kmScalar kmRadiansToDegrees(kmScalar radians);\n\nextern kmScalar kmMin(kmScalar lhs, kmScalar rhs);\nextern kmScalar kmMax(kmScalar lhs, kmScalar rhs);\nextern kmBool kmAlmostEqual(kmScalar lhs, kmScalar rhs);\n\nextern kmScalar kmClamp(kmScalar x, kmScalar min, kmScalar max);\nextern kmScalar kmLerp(kmScalar x, kmScalar y, kmScalar factor);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* UTILITY_H_INCLUDED */\n\nstruct kmMat3;\n\n#pragma pack(push)  /* push current alignment to stack */\n#pragma pack(1)     /* set alignment to 1 byte boundary */\ntypedef struct kmVec2 {\n    kmScalar x;\n    kmScalar y;\n} kmVec2;\n\n#pragma pack(pop)\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nkmVec2* kmVec2Fill(kmVec2* pOut, kmScalar x, kmScalar y);\nkmScalar kmVec2Length(const kmVec2* pIn); /**< Returns the length of the vector*/\nkmScalar kmVec2LengthSq(const kmVec2* pIn); /**< Returns the square of the length of the vector*/\nkmVec2* kmVec2Normalize(kmVec2* pOut, const kmVec2* pIn); /**< Returns the vector passed in set to unit length*/\nkmVec2* kmVec2Lerp(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2, kmScalar t);\nkmVec2* kmVec2Add(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2); /**< Adds 2 vectors and returns the result*/\nkmScalar kmVec2Dot(const kmVec2* pV1, const kmVec2* pV2); /** Returns the Dot product which is the cosine of the angle between the two vectors multiplied by their lengths */\nkmScalar kmVec2Cross(const kmVec2* pV1, const kmVec2* pV2);\nkmVec2* kmVec2Subtract(kmVec2* pOut, const kmVec2* pV1, const kmVec2* pV2); /**< Subtracts 2 vectors and returns the result*/\nkmVec2* kmVec2Mul( kmVec2* pOut,const kmVec2* pV1, const kmVec2* pV2 ); /**< Component-wise multiplication */\nkmVec2* kmVec2Div( kmVec2* pOut,const kmVec2* pV1, const kmVec2* pV2 ); /**< Component-wise division*/\nkmVec2* kmVec2Transform(kmVec2* pOut, const kmVec2* pV1, const struct kmMat3* pM); /** Transform the Vector */\nkmVec2* kmVec2TransformCoord(kmVec2* pOut, const kmVec2* pV, const struct kmMat3* pM); /**<Transforms a 2D vector by a given matrix, projecting the result back into w = 1.*/\nkmVec2* kmVec2Scale(kmVec2* pOut, const kmVec2* pIn, const kmScalar s); /**< Scales a vector to length s*/\nint\tkmVec2AreEqual(const kmVec2* p1, const kmVec2* p2); /**< Returns 1 if both vectors are equal*/\nkmVec2* kmVec2Assign(kmVec2* pOut, const kmVec2* pIn);\nkmVec2* kmVec2RotateBy(kmVec2* pOut, const kmVec2* pIn, const kmScalar degrees, const kmVec2* center); /**<Rotates the point anticlockwise around a center by an amount of degrees.*/\nkmScalar kmVec2DegreesBetween(const kmVec2* v1, const kmVec2* v2);\nkmScalar kmVec2DistanceBetween(const kmVec2* v1, const kmVec2* v2);\nkmVec2* kmVec2MidPointBetween(kmVec2* pOut, const kmVec2* v1, const kmVec2* v2);\nkmVec2* kmVec2Reflect(kmVec2* pOut, const kmVec2* pIn, const kmVec2* normal); /**< Reflects a vector about a given surface normal. The surface normal is assumed to be of unit length. */\n\nextern const kmVec2 KM_VEC2_POS_Y;\nextern const kmVec2 KM_VEC2_NEG_Y;\nextern const kmVec2 KM_VEC2_NEG_X;\nextern const kmVec2 KM_VEC2_POS_X;\nextern const kmVec2 KM_VEC2_ZERO;\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#endif /* VEC2_H_INCLUDED */\n/*\nCopyright (c) 2008, Luke Benstead.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright notice,\n      this list of conditions and the following disclaimer in the documentation\n      and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef VEC3_H_INCLUDED\n#define VEC3_H_INCLUDED\n\n#include <assert.h>\n\nstruct kmMat4;\nstruct kmMat3;\nstruct kmPlane;\n\ntypedef struct kmVec3 {\n\tkmScalar x;\n\tkmScalar y;\n\tkmScalar z;\n} kmVec3;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nkmVec3* kmVec3Fill(kmVec3* pOut, kmScalar x, kmScalar y, kmScalar z);\nkmScalar kmVec3Length(const kmVec3* pIn); /** Returns the length of the vector */\nkmScalar kmVec3LengthSq(const kmVec3* pIn); /** Returns the square of the length of the vector */\nkmVec3* kmVec3Lerp(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2, kmScalar t);\nkmVec3* kmVec3Normalize(kmVec3* pOut, const kmVec3* pIn); /** Returns the vector passed in set to unit length */\nkmVec3* kmVec3Cross(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2); /** Returns a vector perpendicular to 2 other vectors */\nkmScalar kmVec3Dot(const kmVec3* pV1, const kmVec3* pV2); /** Returns the cosine of the angle between 2 vectors */\nkmVec3* kmVec3Add(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2); /** Adds 2 vectors and returns the result */\nkmVec3* kmVec3Subtract(kmVec3* pOut, const kmVec3* pV1, const kmVec3* pV2); /** Subtracts 2 vectors and returns the result */\nkmVec3* kmVec3Mul( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 ); \nkmVec3* kmVec3Div( kmVec3* pOut,const kmVec3* pV1, const kmVec3* pV2 );\n\nkmVec3* kmVec3MultiplyMat3(kmVec3 *pOut, const kmVec3 *pV, const struct kmMat3* pM);\nkmVec3* kmVec3MultiplyMat4(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);\n\nkmVec3* kmVec3Transform(kmVec3* pOut, const kmVec3* pV1, const struct kmMat4* pM); /** Transforms a vector (assuming w=1) by a given matrix */\nkmVec3* kmVec3TransformNormal(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);/**Transforms a 3D normal by a given matrix */\nkmVec3* kmVec3TransformCoord(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM); /**Transforms a 3D vector by a given matrix, projecting the result back into w = 1. */\n\nkmVec3* kmVec3Scale(kmVec3* pOut, const kmVec3* pIn, const kmScalar s); /** Scales a vector to length s */\nint \tkmVec3AreEqual(const kmVec3* p1, const kmVec3* p2);\nkmVec3* kmVec3InverseTransform(kmVec3* pOut, const kmVec3* pV, const struct kmMat4* pM);\nkmVec3* kmVec3InverseTransformNormal(kmVec3* pOut, const kmVec3* pVect, const struct kmMat4* pM);\nkmVec3* kmVec3Assign(kmVec3* pOut, const kmVec3* pIn);\nkmVec3* kmVec3Zero(kmVec3* pOut);\nkmVec3* kmVec3GetHorizontalAngle(kmVec3* pOut, const kmVec3 *pIn); /** Get the rotations that would make a (0,0,1) direction vector point in the same direction as this direction vector. */\nkmVec3* kmVec3RotationToDirection(kmVec3* pOut, const kmVec3* pIn, const kmVec3* forwards); /** Builds a direction vector from input vector. */\n\nkmVec3* kmVec3ProjectOnToPlane(kmVec3* pOut, const kmVec3* point, const struct kmPlane* plane);\n\nkmVec3* kmVec3Reflect(kmVec3* pOut, const kmVec3* pIn, const kmVec3* normal); /**< Reflects a vector about a given surface normal. The surface normal is assumed to be of unit length. */\n\nextern const kmVec3 KM_VEC3_NEG_Z;\nextern const kmVec3 KM_VEC3_POS_Z;\nextern const kmVec3 KM_VEC3_POS_Y;\nextern const kmVec3 KM_VEC3_NEG_Y;\nextern const kmVec3 KM_VEC3_NEG_X;\nextern const kmVec3 KM_VEC3_POS_X;\nextern const kmVec3 KM_VEC3_ZERO;\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* VEC3_H_INCLUDED */\n// Heman utilities.  This is part of the test suite, not the core library.\n\n#define STB_IMAGE_IMPLEMENTATION\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#define STB_IMAGE_RESIZE_IMPLEMENTATION\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n#pragma GCC diagnostic ignored \"-Wunused-value\"\n#pragma GCC diagnostic ignored \"-Wpointer-sign\"\n#pragma GCC diagnostic ignored \"-Wunknown-pragmas\"\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n/* stb_image_write - v0.98 - public domain - http://nothings.org/stb/stb_image_write.h\n   writes out PNG/BMP/TGA images to C stdio - Sean Barrett 2010\n                            no warranty implied; use at your own risk\n\n\n   Before #including,\n\n       #define STB_IMAGE_WRITE_IMPLEMENTATION\n\n   in the file that you want to have the implementation.\n\n   Will probably not work correctly with strict-aliasing optimizations.\n\nABOUT:\n\n   This header file is a library for writing images to C stdio. It could be\n   adapted to write to memory or a general streaming interface; let me know.\n\n   The PNG output is not optimal; it is 20-50% larger than the file\n   written by a decent optimizing implementation. This library is designed\n   for source code compactness and simplicitly, not optimal image file size\n   or run-time performance.\n\nBUILDING:\n\n   You can #define STBIW_ASSERT(x) before the #include to avoid using assert.h.\n   You can #define STBIW_MALLOC(), STBIW_REALLOC(), and STBIW_FREE() to replace\n   malloc,realloc,free.\n   You can define STBIW_MEMMOVE() to replace memmove()\n\nUSAGE:\n\n   There are four functions, one for each image file format:\n\n     int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);\n     int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);\n     int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);\n     int stbi_write_hdr(char const *filename, int w, int h, int comp, const void *data);\n\n   Each function returns 0 on failure and non-0 on success.\n\n   The functions create an image file defined by the parameters. The image\n   is a rectangle of pixels stored from left-to-right, top-to-bottom.\n   Each pixel contains 'comp' channels of data stored interleaved with 8-bits\n   per channel, in the following order: 1=Y, 2=YA, 3=RGB, 4=RGBA. (Y is\n   monochrome color.) The rectangle is 'w' pixels wide and 'h' pixels tall.\n   The *data pointer points to the first byte of the top-left-most pixel.\n   For PNG, \"stride_in_bytes\" is the distance in bytes from the first byte of\n   a row of pixels to the first byte of the next row of pixels.\n\n   PNG creates output files with the same number of components as the input.\n   The BMP format expands Y to RGB in the file format and does not\n   output alpha.\n\n   PNG supports writing rectangles of data even when the bytes storing rows of\n   data are not consecutive in memory (e.g. sub-rectangles of a larger image),\n   by supplying the stride between the beginning of adjacent rows. The other\n   formats do not. (Thus you cannot write a native-format BMP through the BMP\n   writer, both because it is in BGR order and because it may have padding\n   at the end of the line.)\n\n   HDR expects linear float data. Since the format is always 32-bit rgb(e)\n   data, alpha (if provided) is discarded, and for monochrome data it is\n   replicated across all three channels.\n\nCREDITS:\n\n   PNG/BMP/TGA\n      Sean Barrett\n   HDR\n      Baldur Karlsson\n   TGA monochrome:\n      Jean-Sebastien Guay\n   misc enhancements:\n      Tim Kelsey\n   bugfixes:\n      github:Chribba\n*/\n\n#ifndef INCLUDE_STB_IMAGE_WRITE_H\n#define INCLUDE_STB_IMAGE_WRITE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern int stbi_write_png(char const *filename, int w, int h, int comp, const void  *data, int stride_in_bytes);\nextern int stbi_write_bmp(char const *filename, int w, int h, int comp, const void  *data);\nextern int stbi_write_tga(char const *filename, int w, int h, int comp, const void  *data);\nextern int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif//INCLUDE_STB_IMAGE_WRITE_H\n\n#ifdef STB_IMAGE_WRITE_IMPLEMENTATION\n\n#include <stdarg.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#if defined(STBIW_MALLOC) && defined(STBIW_FREE) && defined(STBIW_REALLOC)\n// ok\n#elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC)\n// ok\n#else\n#error \"Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC.\"\n#endif\n\n#ifndef STBIW_MALLOC\n#define STBIW_MALLOC(sz)    malloc(sz)\n#define STBIW_REALLOC(p,sz) realloc(p,sz)\n#define STBIW_FREE(p)       free(p)\n#endif\n#ifndef STBIW_MEMMOVE\n#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)\n#endif\n\n\n#ifndef STBIW_ASSERT\n#include <assert.h>\n#define STBIW_ASSERT(x) assert(x)\n#endif\n\ntypedef unsigned int stbiw_uint32;\ntypedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];\n\nstatic void writefv(FILE *f, const char *fmt, va_list v)\n{\n   while (*fmt) {\n      switch (*fmt++) {\n         case ' ': break;\n         case '1': { unsigned char x = (unsigned char) va_arg(v, int); fputc(x,f); break; }\n         case '2': { int x = va_arg(v,int); unsigned char b[2];\n                     b[0] = (unsigned char) x; b[1] = (unsigned char) (x>>8);\n                     fwrite(b,2,1,f); break; }\n         case '4': { stbiw_uint32 x = va_arg(v,int); unsigned char b[4];\n                     b[0]=(unsigned char)x; b[1]=(unsigned char)(x>>8);\n                     b[2]=(unsigned char)(x>>16); b[3]=(unsigned char)(x>>24);\n                     fwrite(b,4,1,f); break; }\n         default:\n            STBIW_ASSERT(0);\n            return;\n      }\n   }\n}\n\nstatic void write3(FILE *f, unsigned char a, unsigned char b, unsigned char c)\n{\n   unsigned char arr[3];\n   arr[0] = a, arr[1] = b, arr[2] = c;\n   fwrite(arr, 3, 1, f);\n}\n\nstatic void write_pixels(FILE *f, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)\n{\n   unsigned char bg[3] = { 255, 0, 255}, px[3];\n   stbiw_uint32 zero = 0;\n   int i,j,k, j_end;\n\n   if (y <= 0)\n      return;\n\n   if (vdir < 0)\n      j_end = -1, j = y-1;\n   else\n      j_end =  y, j = 0;\n\n   for (; j != j_end; j += vdir) {\n      for (i=0; i < x; ++i) {\n         unsigned char *d = (unsigned char *) data + (j*x+i)*comp;\n         if (write_alpha < 0)\n            fwrite(&d[comp-1], 1, 1, f);\n         switch (comp) {\n            case 1: fwrite(d, 1, 1, f);\n                    break;\n            case 2: if (expand_mono)\n                       write3(f, d[0],d[0],d[0]); // monochrome bmp\n                    else\n                       fwrite(d, 1, 1, f);  // monochrome TGA\n                    break;\n            case 4:\n               if (!write_alpha) {\n                  // composite against pink background\n                  for (k=0; k < 3; ++k)\n                     px[k] = bg[k] + ((d[k] - bg[k]) * d[3])/255;\n                  write3(f, px[1-rgb_dir],px[1],px[1+rgb_dir]);\n                  break;\n               }\n               /* FALLTHROUGH */\n            case 3:\n               write3(f, d[1-rgb_dir],d[1],d[1+rgb_dir]);\n               break;\n         }\n         if (write_alpha > 0)\n            fwrite(&d[comp-1], 1, 1, f);\n      }\n      fwrite(&zero,scanline_pad,1,f);\n   }\n}\n\nstatic int outfile(char const *filename, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)\n{\n   FILE *f;\n   if (y < 0 || x < 0) return 0;\n   f = fopen(filename, \"wb\");\n   if (f) {\n      va_list v;\n      va_start(v, fmt);\n      writefv(f, fmt, v);\n      va_end(v);\n      write_pixels(f,rgb_dir,vdir,x,y,comp,data,alpha,pad,expand_mono);\n      fclose(f);\n   }\n   return f != NULL;\n}\n\nint stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)\n{\n   int pad = (-x*3) & 3;\n   return outfile(filename,-1,-1,x,y,comp,1,(void *) data,0,pad,\n           \"11 4 22 4\" \"4 44 22 444444\",\n           'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header\n            40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header\n}\n\nint stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)\n{\n   int has_alpha = (comp == 2 || comp == 4);\n   int colorbytes = has_alpha ? comp-1 : comp;\n   int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3\n   return outfile(filename, -1,-1, x, y, comp, 0, (void *) data, has_alpha, 0,\n                  \"111 221 2222 11\", 0,0,format, 0,0,0, 0,0,x,y, (colorbytes+has_alpha)*8, has_alpha*8);\n}\n\n// *************************************************************************************************\n// Radiance RGBE HDR writer\n// by Baldur Karlsson\n#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))\n\nvoid stbiw__linear_to_rgbe(unsigned char *rgbe, float *linear)\n{\n   int exponent;\n   float maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));\n\n   if (maxcomp < 1e-32) {\n      rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;\n   } else {\n      float normalize = (float) frexp(maxcomp, &exponent) * 256.0f/maxcomp;\n\n      rgbe[0] = (unsigned char)(linear[0] * normalize);\n      rgbe[1] = (unsigned char)(linear[1] * normalize);\n      rgbe[2] = (unsigned char)(linear[2] * normalize);\n      rgbe[3] = (unsigned char)(exponent + 128);\n   }\n}\n\nvoid stbiw__write_run_data(FILE *f, int length, unsigned char databyte)\n{\n   unsigned char lengthbyte = (unsigned char) (length+128);\n   STBIW_ASSERT(length+128 <= 255);\n   fwrite(&lengthbyte, 1, 1, f);\n   fwrite(&databyte, 1, 1, f);\n}\n\nvoid stbiw__write_dump_data(FILE *f, int length, unsigned char *data)\n{\n   unsigned char lengthbyte = (unsigned char )(length & 0xff);\n   STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code\n   fwrite(&lengthbyte, 1, 1, f);\n   fwrite(data, length, 1, f);\n}\n\nvoid stbiw__write_hdr_scanline(FILE *f, int width, int comp, unsigned char *scratch, const float *scanline)\n{\n   unsigned char scanlineheader[4] = { 2, 2, 0, 0 };\n   unsigned char rgbe[4];\n   float linear[3];\n   int x;\n\n   scanlineheader[2] = (width&0xff00)>>8;\n   scanlineheader[3] = (width&0x00ff);\n\n   /* skip RLE for images too small or large */\n   if (width < 8 || width >= 32768) {\n      for (x=0; x < width; x++) {\n         switch (comp) {\n            case 4: /* fallthrough */\n            case 3: linear[2] = scanline[x*comp + 2];\n                    linear[1] = scanline[x*comp + 1];\n                    linear[0] = scanline[x*comp + 0];\n                    break;\n            case 2: /* fallthrough */\n            case 1: linear[0] = linear[1] = linear[2] = scanline[x*comp + 0];\n                    break;\n         }\n         stbiw__linear_to_rgbe(rgbe, linear);\n         fwrite(rgbe, 4, 1, f);\n      }\n   } else {\n      int c,r;\n      /* encode into scratch buffer */\n      for (x=0; x < width; x++) {\n         switch(comp) {\n            case 4: /* fallthrough */\n            case 3: linear[2] = scanline[x*comp + 2];\n                    linear[1] = scanline[x*comp + 1];\n                    linear[0] = scanline[x*comp + 0];\n                    break;\n            case 2: /* fallthrough */\n            case 1: linear[0] = linear[1] = linear[2] = scanline[x*comp + 0];\n                    break;\n         }\n         stbiw__linear_to_rgbe(rgbe, linear);\n         scratch[x + width*0] = rgbe[0];\n         scratch[x + width*1] = rgbe[1];\n         scratch[x + width*2] = rgbe[2];\n         scratch[x + width*3] = rgbe[3];\n      }\n\n      fwrite(scanlineheader, 4, 1, f);\n\n      /* RLE each component separately */\n      for (c=0; c < 4; c++) {\n         unsigned char *comp = &scratch[width*c];\n\n         x = 0;\n         while (x < width) {\n            // find first run\n            r = x;\n            while (r+2 < width) {\n               if (comp[r] == comp[r+1] && comp[r] == comp[r+2])\n                  break;\n               ++r;\n            }\n            if (r+2 >= width)\n               r = width;\n            // dump up to first run\n            while (x < r) {\n               int len = r-x;\n               if (len > 128) len = 128;\n               stbiw__write_dump_data(f, len, &comp[x]);\n               x += len;\n            }\n            // if there's a run, output it\n            if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd\n               // find next byte after run\n               while (r < width && comp[r] == comp[x])\n                  ++r;\n               // output run up to r\n               while (x < r) {\n                  int len = r-x;\n                  if (len > 127) len = 127;\n                  stbiw__write_run_data(f, len, comp[x]);\n                  x += len;\n               }\n            }\n         }\n      }\n   }\n}\n\nint stbi_write_hdr(char const *filename, int x, int y, int comp, const float *data)\n{\n   int i;\n   FILE *f;\n   if (y <= 0 || x <= 0 || data == NULL) return 0;\n   f = fopen(filename, \"wb\");\n   if (f) {\n      /* Each component is stored separately. Allocate scratch space for full output scanline. */\n      unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);\n      fprintf(f, \"#?RADIANCE\\n# Written by stb_image_write.h\\nFORMAT=32-bit_rle_rgbe\\n\"      );\n      fprintf(f, \"EXPOSURE=          1.0000000000000\\n\\n-Y %d +X %d\\n\"                 , y, x);\n      for(i=0; i < y; i++)\n         stbiw__write_hdr_scanline(f, x, comp, scratch, data + comp*i*x);\n      STBIW_FREE(scratch);\n      fclose(f);\n   }\n   return f != NULL;\n}\n\n/////////////////////////////////////////////////////////\n// PNG\n\n// stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()\n#define stbiw__sbraw(a) ((int *) (a) - 2)\n#define stbiw__sbm(a)   stbiw__sbraw(a)[0]\n#define stbiw__sbn(a)   stbiw__sbraw(a)[1]\n\n#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))\n#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)\n#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))\n\n#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))\n#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)\n#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)\n\nstatic void *stbiw__sbgrowf(void **arr, int increment, int itemsize)\n{\n   int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;\n   void *p = STBIW_REALLOC(*arr ? stbiw__sbraw(*arr) : 0, itemsize * m + sizeof(int)*2);\n   STBIW_ASSERT(p);\n   if (p) {\n      if (!*arr) ((int *) p)[1] = 0;\n      *arr = (void *) ((int *) p + 2);\n      stbiw__sbm(*arr) = m;\n   }\n   return *arr;\n}\n\nstatic unsigned char *stbiw__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)\n{\n   while (*bitcount >= 8) {\n      stbiw__sbpush(data, (unsigned char) *bitbuffer);\n      *bitbuffer >>= 8;\n      *bitcount -= 8;\n   }\n   return data;\n}\n\nstatic int stbiw__zlib_bitrev(int code, int codebits)\n{\n   int res=0;\n   while (codebits--) {\n      res = (res << 1) | (code & 1);\n      code >>= 1;\n   }\n   return res;\n}\n\nstatic unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)\n{\n   int i;\n   for (i=0; i < limit && i < 258; ++i)\n      if (a[i] != b[i]) break;\n   return i;\n}\n\nstatic unsigned int stbiw__zhash(unsigned char *data)\n{\n   stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);\n   hash ^= hash << 3;\n   hash += hash >> 5;\n   hash ^= hash << 4;\n   hash += hash >> 17;\n   hash ^= hash << 25;\n   hash += hash >> 6;\n   return hash;\n}\n\n#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))\n#define stbiw__zlib_add(code,codebits) \\\n      (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())\n#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)\n// default huffman tables\n#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)\n#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)\n#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)\n#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)\n#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))\n#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))\n\n#define stbiw__ZHASH   16384\n\nunsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)\n{\n   static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };\n   static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };\n   static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };\n   static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };\n   unsigned int bitbuf=0;\n   int i,j, bitcount=0;\n   unsigned char *out = NULL;\n   unsigned char **hash_table[stbiw__ZHASH]; // 64KB on the stack!\n   if (quality < 5) quality = 5;\n\n   stbiw__sbpush(out, 0x78);   // DEFLATE 32K window\n   stbiw__sbpush(out, 0x5e);   // FLEVEL = 1\n   stbiw__zlib_add(1,1);  // BFINAL = 1\n   stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman\n\n   for (i=0; i < stbiw__ZHASH; ++i)\n      hash_table[i] = NULL;\n\n   i=0;\n   while (i < data_len-3) {\n      // hash next 3 bytes of data to be compressed\n      int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;\n      unsigned char *bestloc = 0;\n      unsigned char **hlist = hash_table[h];\n      int n = stbiw__sbcount(hlist);\n      for (j=0; j < n; ++j) {\n         if (hlist[j]-data > i-32768) { // if entry lies within window\n            int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);\n            if (d >= best) best=d,bestloc=hlist[j];\n         }\n      }\n      // when hash table entry is too long, delete half the entries\n      if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {\n         STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);\n         stbiw__sbn(hash_table[h]) = quality;\n      }\n      stbiw__sbpush(hash_table[h],data+i);\n\n      if (bestloc) {\n         // \"lazy matching\" - check match at *next* byte, and if it's better, do cur byte as literal\n         h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);\n         hlist = hash_table[h];\n         n = stbiw__sbcount(hlist);\n         for (j=0; j < n; ++j) {\n            if (hlist[j]-data > i-32767) {\n               int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);\n               if (e > best) { // if next match is better, bail on current match\n                  bestloc = NULL;\n                  break;\n               }\n            }\n         }\n      }\n\n      if (bestloc) {\n         int d = (int) (data+i - bestloc); // distance back\n         STBIW_ASSERT(d <= 32767 && best <= 258);\n         for (j=0; best > lengthc[j+1]-1; ++j);\n         stbiw__zlib_huff(j+257);\n         if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);\n         for (j=0; d > distc[j+1]-1; ++j);\n         stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);\n         if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);\n         i += best;\n      } else {\n         stbiw__zlib_huffb(data[i]);\n         ++i;\n      }\n   }\n   // write out final bytes\n   for (;i < data_len; ++i)\n      stbiw__zlib_huffb(data[i]);\n   stbiw__zlib_huff(256); // end of block\n   // pad with 0 bits to byte boundary\n   while (bitcount)\n      stbiw__zlib_add(0,1);\n\n   for (i=0; i < stbiw__ZHASH; ++i)\n      (void) stbiw__sbfree(hash_table[i]);\n\n   {\n      // compute adler32 on input\n      unsigned int i=0, s1=1, s2=0, blocklen = data_len % 5552;\n      int j=0;\n      while (j < data_len) {\n         for (i=0; i < blocklen; ++i) s1 += data[j+i], s2 += s1;\n         s1 %= 65521, s2 %= 65521;\n         j += blocklen;\n         blocklen = 5552;\n      }\n      stbiw__sbpush(out, (unsigned char) (s2 >> 8));\n      stbiw__sbpush(out, (unsigned char) s2);\n      stbiw__sbpush(out, (unsigned char) (s1 >> 8));\n      stbiw__sbpush(out, (unsigned char) s1);\n   }\n   *out_len = stbiw__sbn(out);\n   // make returned pointer freeable\n   STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);\n   return (unsigned char *) stbiw__sbraw(out);\n}\n\nunsigned int stbiw__crc32(unsigned char *buffer, int len)\n{\n   static unsigned int crc_table[256];\n   unsigned int crc = ~0u;\n   int i,j;\n   if (crc_table[1] == 0)\n      for(i=0; i < 256; i++)\n         for (crc_table[i]=i, j=0; j < 8; ++j)\n            crc_table[i] = (crc_table[i] >> 1) ^ (crc_table[i] & 1 ? 0xedb88320 : 0);\n   for (i=0; i < len; ++i)\n      crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];\n   return ~crc;\n}\n\n#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=(unsigned char)(a),(o)[1]=(unsigned char)(b),(o)[2]=(unsigned char)(c),(o)[3]=(unsigned char)(d),(o)+=4)\n#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));\n#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])\n\nstatic void stbiw__wpcrc(unsigned char **data, int len)\n{\n   unsigned int crc = stbiw__crc32(*data - len - 4, len+4);\n   stbiw__wp32(*data, crc);\n}\n\nstatic unsigned char stbiw__paeth(int a, int b, int c)\n{\n   int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);\n   if (pa <= pb && pa <= pc) return (unsigned char) a;\n   if (pb <= pc) return (unsigned char) b;\n   return (unsigned char) c;\n}\n\nunsigned char *stbi_write_png_to_mem(unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)\n{\n   int ctype[5] = { -1, 0, 4, 2, 6 };\n   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };\n   unsigned char *out,*o, *filt, *zlib;\n   signed char *line_buffer;\n   int i,j,k,p,zlen;\n\n   if (stride_bytes == 0)\n      stride_bytes = x * n;\n\n   filt = (unsigned char *) STBIW_MALLOC((x*n+1) * y); if (!filt) return 0;\n   line_buffer = (signed char *) STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }\n   for (j=0; j < y; ++j) {\n      static int mapping[] = { 0,1,2,3,4 };\n      static int firstmap[] = { 0,1,0,5,6 };\n      int *mymap = j ? mapping : firstmap;\n      int best = 0, bestval = 0x7fffffff;\n      for (p=0; p < 2; ++p) {\n         for (k= p?best:0; k < 5; ++k) {\n            int type = mymap[k],est=0;\n            unsigned char *z = pixels + stride_bytes*j;\n            for (i=0; i < n; ++i)\n               switch (type) {\n                  case 0: line_buffer[i] = z[i]; break;\n                  case 1: line_buffer[i] = z[i]; break;\n                  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;\n                  case 3: line_buffer[i] = z[i] - (z[i-stride_bytes]>>1); break;\n                  case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-stride_bytes],0)); break;\n                  case 5: line_buffer[i] = z[i]; break;\n                  case 6: line_buffer[i] = z[i]; break;\n               }\n            for (i=n; i < x*n; ++i) {\n               switch (type) {\n                  case 0: line_buffer[i] = z[i]; break;\n                  case 1: line_buffer[i] = z[i] - z[i-n]; break;\n                  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;\n                  case 3: line_buffer[i] = z[i] - ((z[i-n] + z[i-stride_bytes])>>1); break;\n                  case 4: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-stride_bytes], z[i-stride_bytes-n]); break;\n                  case 5: line_buffer[i] = z[i] - (z[i-n]>>1); break;\n                  case 6: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;\n               }\n            }\n            if (p) break;\n            for (i=0; i < x*n; ++i)\n               est += abs((signed char) line_buffer[i]);\n            if (est < bestval) { bestval = est; best = k; }\n         }\n      }\n      // when we get here, best contains the filter type, and line_buffer contains the data\n      filt[j*(x*n+1)] = (unsigned char) best;\n      STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);\n   }\n   STBIW_FREE(line_buffer);\n   zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, 8); // increase 8 to get smaller but use more memory\n   STBIW_FREE(filt);\n   if (!zlib) return 0;\n\n   // each tag requires 12 bytes of overhead\n   out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);\n   if (!out) return 0;\n   *out_len = 8 + 12+13 + 12+zlen + 12;\n\n   o=out;\n   STBIW_MEMMOVE(o,sig,8); o+= 8;\n   stbiw__wp32(o, 13); // header length\n   stbiw__wptag(o, \"IHDR\");\n   stbiw__wp32(o, x);\n   stbiw__wp32(o, y);\n   *o++ = 8;\n   *o++ = (unsigned char) ctype[n];\n   *o++ = 0;\n   *o++ = 0;\n   *o++ = 0;\n   stbiw__wpcrc(&o,13);\n\n   stbiw__wp32(o, zlen);\n   stbiw__wptag(o, \"IDAT\");\n   STBIW_MEMMOVE(o, zlib, zlen);\n   o += zlen;\n   STBIW_FREE(zlib);\n   stbiw__wpcrc(&o, zlen);\n\n   stbiw__wp32(o,0);\n   stbiw__wptag(o, \"IEND\");\n   stbiw__wpcrc(&o,0);\n\n   STBIW_ASSERT(o == out + *out_len);\n\n   return out;\n}\n\nint stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)\n{\n   FILE *f;\n   int len;\n   unsigned char *png = stbi_write_png_to_mem((unsigned char *) data, stride_bytes, x, y, comp, &len);\n   if (!png) return 0;\n   f = fopen(filename, \"wb\");\n   if (!f) { STBIW_FREE(png); return 0; }\n   fwrite(png, 1, len, f);\n   fclose(f);\n   STBIW_FREE(png);\n   return 1;\n}\n#endif // STB_IMAGE_WRITE_IMPLEMENTATION\n\n/* Revision history\n      0.98 (2015-04-08)\n             added STBIW_MALLOC, STBIW_ASSERT etc\n      0.97 (2015-01-18)\n             fixed HDR asserts, rewrote HDR rle logic\n      0.96 (2015-01-17)\n             add HDR output\n             fix monochrome BMP\n      0.95 (2014-08-17)\n\t\t       add monochrome TGA output\n      0.94 (2014-05-31)\n             rename private functions to avoid conflicts with stb_image.h\n      0.93 (2014-05-27)\n             warning fixes\n      0.92 (2010-08-01)\n             casts to unsigned char to fix warnings\n      0.91 (2010-07-17)\n             first public release\n      0.90   first internal release\n*/\n/* stb_image_resize - v0.90 - public domain image resizing\n   by Jorge L Rodriguez (@VinoBS) - 2014\n   http://github.com/nothings/stb\n\n   Written with emphasis on usability, portability, and efficiency. (No\n   SIMD or threads, so it be easily outperformed by libs that use those.)\n   Only scaling and translation is supported, no rotations or shears.\n   Easy API downsamples w/Mitchell filter, upsamples w/cubic interpolation.\n\n   COMPILING & LINKING\n      In one C/C++ file that #includes this file, do this:\n         #define STB_IMAGE_RESIZE_IMPLEMENTATION\n      before the #include. That will create the implementation in that file.\n\n   QUICKSTART\n      stbir_resize_uint8(      input_pixels , in_w , in_h , 0,\n                               output_pixels, out_w, out_h, 0, num_channels)\n      stbir_resize_float(...)\n      stbir_resize_uint8_srgb( input_pixels , in_w , in_h , 0,\n                               output_pixels, out_w, out_h, 0,\n                               num_channels , alpha_chan  , 0)\n      stbir_resize_uint8_srgb_edgemode(\n                               input_pixels , in_w , in_h , 0, \n                               output_pixels, out_w, out_h, 0, \n                               num_channels , alpha_chan  , 0, STBIR_EDGE_CLAMP)\n                                                            // WRAP/REFLECT/ZERO\n\n   FULL API\n      See the \"header file\" section of the source for API documentation.\n\n   ADDITIONAL DOCUMENTATION\n\n      SRGB & FLOATING POINT REPRESENTATION\n         The sRGB functions presume IEEE floating point. If you do not have\n         IEEE floating point, define STBIR_NON_IEEE_FLOAT. This will use\n         a slower implementation.\n\n      MEMORY ALLOCATION\n         The resize functions here perform a single memory allocation using\n         malloc. To control the memory allocation, before the #include that\n         triggers the implementation, do:\n\n            #define STBIR_MALLOC(size,context) ...\n            #define STBIR_FREE(ptr,context)   ...\n\n         Each resize function makes exactly one call to malloc/free, so to use\n         temp memory, store the temp memory in the context and return that.\n\n      ASSERT\n         Define STBIR_ASSERT(boolval) to override assert() and not use assert.h\n\n      OPTIMIZATION\n         Define STBIR_SATURATE_INT to compute clamp values in-range using\n         integer operations instead of float operations. This may be faster\n         on some platforms.\n\n      DEFAULT FILTERS\n         For functions which don't provide explicit control over what filters\n         to use, you can change the compile-time defaults with\n\n            #define STBIR_DEFAULT_FILTER_UPSAMPLE     STBIR_FILTER_something\n            #define STBIR_DEFAULT_FILTER_DOWNSAMPLE   STBIR_FILTER_something\n\n         See stbir_filter in the header-file section for the list of filters.\n\n      NEW FILTERS\n         A number of 1D filter kernels are used. For a list of\n         supported filters see the stbir_filter enum. To add a new filter,\n         write a filter function and add it to stbir__filter_info_table.\n\n      PROGRESS\n         For interactive use with slow resize operations, you can install\n         a progress-report callback:\n\n            #define STBIR_PROGRESS_REPORT(val)   some_func(val)\n\n         The parameter val is a float which goes from 0 to 1 as progress is made.\n\n         For example:\n\n            static void my_progress_report(float progress);\n            #define STBIR_PROGRESS_REPORT(val) my_progress_report(val)\n\n            #define STB_IMAGE_RESIZE_IMPLEMENTATION\n            #include \"stb_image_resize.h\"\n\n            static void my_progress_report(float progress)\n            {\n               printf(\"Progress: %f%%\\n\", progress*100);\n            }\n\n      MAX CHANNELS\n         If your image has more than 64 channels, define STBIR_MAX_CHANNELS\n         to the max you'll have.\n\n      ALPHA CHANNEL\n         Most of the resizing functions provide the ability to control how\n         the alpha channel of an image is processed. The important things\n         to know about this:\n\n         1. The best mathematically-behaved version of alpha to use is\n         called \"premultiplied alpha\", in which the other color channels\n         have had the alpha value multiplied in. If you use premultiplied\n         alpha, linear filtering (such as image resampling done by this\n         library, or performed in texture units on GPUs) does the \"right\n         thing\". While premultiplied alpha is standard in the movie CGI\n         industry, it is still uncommon in the videogame/real-time world.\n\n         If you linearly filter non-premultiplied alpha, strange effects\n         occur. (For example, the average of 1% opaque bright green\n         and 99% opaque black produces 50% transparent dark green when\n         non-premultiplied, whereas premultiplied it produces 50%\n         transparent near-black. The former introduces green energy\n         that doesn't exist in the source image.)\n\n         2. Artists should not edit premultiplied-alpha images; artists\n         want non-premultiplied alpha images. Thus, art tools generally output\n         non-premultiplied alpha images.\n\n         3. You will get best results in most cases by converting images\n         to premultiplied alpha before processing them mathematically.\n\n         4. If you pass the flag STBIR_FLAG_ALPHA_PREMULTIPLIED, the\n         resizer does not do anything special for the alpha channel;\n         it is resampled identically to other channels. This produces\n         the correct results for premultiplied-alpha images, but produces\n         less-than-ideal results for non-premultiplied-alpha images.\n\n         5. If you do not pass the flag STBIR_FLAG_ALPHA_PREMULTIPLIED,\n         then the resizer weights the contribution of input pixels\n         based on their alpha values, or, equivalently, it multiplies\n         the alpha value into the color channels, resamples, then divides\n         by the resultant alpha value. Input pixels which have alpha=0 do\n         not contribute at all to output pixels unless _all_ of the input\n         pixels affecting that output pixel have alpha=0, in which case\n         the result for that pixel is the same as it would be without\n         STBIR_FLAG_ALPHA_PREMULTIPLIED. However, this is only true for\n         input images in integer formats. For input images in float format,\n         input pixels with alpha=0 have no effect, and output pixels\n         which have alpha=0 will be 0 in all channels. (For float images,\n         you can manually achieve the same result by adding a tiny epsilon\n         value to the alpha channel of every image, and then subtracting\n         or clamping it at the end.)\n\n         6. You can suppress the behavior described in #5 and make\n         all-0-alpha pixels have 0 in all channels by #defining\n         STBIR_NO_ALPHA_EPSILON.\n\n         7. You can separately control whether the alpha channel is\n         interpreted as linear or affected by the colorspace. By default\n         it is linear; you almost never want to apply the colorspace.\n         (For example, graphics hardware does not apply sRGB conversion\n         to the alpha channel.)\n\n   ADDITIONAL CONTRIBUTORS\n      Sean Barrett: API design, optimizations\n         \n   REVISIONS\n      0.90 (2014-09-17) first released version\n\n   LICENSE\n      This software is in the public domain. Where that dedication is not\n      recognized, you are granted a perpetual, irrevocable license to copy\n      and modify this file as you see fit.\n\n   TODO\n      Don't decode all of the image data when only processing a partial tile\n      Don't use full-width decode buffers when only processing a partial tile\n      When processing wide images, break processing into tiles so data fits in L1 cache\n      Installable filters?\n      Resize that respects alpha test coverage\n         (Reference code: FloatImage::alphaTestCoverage and FloatImage::scaleAlphaToCoverage:\n         https://code.google.com/p/nvidia-texture-tools/source/browse/trunk/src/nvimage/FloatImage.cpp )\n*/\n\n#ifndef STBIR_INCLUDE_STB_IMAGE_RESIZE_H\n#define STBIR_INCLUDE_STB_IMAGE_RESIZE_H\n\n#ifdef _MSC_VER\ntypedef unsigned char  stbir_uint8;\ntypedef unsigned short stbir_uint16;\ntypedef unsigned int   stbir_uint32;\n#else\n#include <stdint.h>\ntypedef uint8_t  stbir_uint8;\ntypedef uint16_t stbir_uint16;\ntypedef uint32_t stbir_uint32;\n#endif\n\n#ifdef STB_IMAGE_RESIZE_STATIC\n#define STBIRDEF static\n#else\n#ifdef __cplusplus\n#define STBIRDEF extern \"C\"\n#else\n#define STBIRDEF extern\n#endif\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Easy-to-use API:\n//\n//     * \"input pixels\" points to an array of image data with 'num_channels' channels (e.g. RGB=3, RGBA=4)\n//     * input_w is input image width (x-axis), input_h is input image height (y-axis)\n//     * stride is the offset between successive rows of image data in memory, in bytes. you can\n//       specify 0 to mean packed continuously in memory\n//     * alpha channel is treated identically to other channels.\n//     * colorspace is linear or sRGB as specified by function name\n//     * returned result is 1 for success or 0 in case of an error.\n//       #define STBIR_ASSERT() to trigger an assert on parameter validation errors.\n//     * Memory required grows approximately linearly with input and output size, but with\n//       discontinuities at input_w == output_w and input_h == output_h.\n//     * These functions use a \"default\" resampling filter defined at compile time. To change the filter,\n//       you can change the compile-time defaults by #defining STBIR_DEFAULT_FILTER_UPSAMPLE\n//       and STBIR_DEFAULT_FILTER_DOWNSAMPLE, or you can use the medium-complexity API.\n\nSTBIRDEF int stbir_resize_uint8(     const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                     int num_channels);\n\nSTBIRDEF int stbir_resize_float(     const float *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                           float *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                     int num_channels);\n\n\n// The following functions interpret image data as gamma-corrected sRGB. \n// Specify STBIR_ALPHA_CHANNEL_NONE if you have no alpha channel,\n// or otherwise provide the index of the alpha channel. Flags value\n// of 0 will probably do the right thing if you're not sure what\n// the flags mean.\n\n#define STBIR_ALPHA_CHANNEL_NONE       -1\n\n// Set this flag if your texture has premultiplied alpha. Otherwise, stbir will\n// use alpha-weighted resampling (effectively premultiplying, resampling,\n// then unpremultiplying).\n#define STBIR_FLAG_ALPHA_PREMULTIPLIED    (1 << 0)\n// The specified alpha channel should be handled as gamma-corrected value even\n// when doing sRGB operations.\n#define STBIR_FLAG_ALPHA_USES_COLORSPACE  (1 << 1)\n\nSTBIRDEF int stbir_resize_uint8_srgb(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                     int num_channels, int alpha_channel, int flags);\n\n\ntypedef enum\n{\n    STBIR_EDGE_CLAMP   = 1,\n    STBIR_EDGE_REFLECT = 2,\n    STBIR_EDGE_WRAP    = 3,\n    STBIR_EDGE_ZERO    = 4,\n} stbir_edge;\n\n// This function adds the ability to specify how requests to sample off the edge of the image are handled.\nSTBIRDEF int stbir_resize_uint8_srgb_edgemode(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                                    unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                              int num_channels, int alpha_channel, int flags,\n                                              stbir_edge edge_wrap_mode);\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Medium-complexity API\n//\n// This extends the easy-to-use API as follows:\n//\n//     * Alpha-channel can be processed separately\n//       * If alpha_channel is not STBIR_ALPHA_CHANNEL_NONE\n//         * Alpha channel will not be gamma corrected (unless flags&STBIR_FLAG_GAMMA_CORRECT)\n//         * Filters will be weighted by alpha channel (unless flags&STBIR_FLAG_ALPHA_PREMULTIPLIED)\n//     * Filter can be selected explicitly\n//     * uint16 image type\n//     * sRGB colorspace available for all types\n//     * context parameter for passing to STBIR_MALLOC\n\ntypedef enum\n{\n    STBIR_FILTER_DEFAULT      = 0,  // use same filter type that easy-to-use API chooses\n    STBIR_FILTER_BOX          = 1,  // A trapezoid w/1-pixel wide ramps, same result as box for integer scale ratios\n    STBIR_FILTER_TRIANGLE     = 2,  // On upsampling, produces same results as bilinear texture filtering\n    STBIR_FILTER_CUBICBSPLINE = 3,  // The cubic b-spline (aka Mitchell-Netrevalli with B=1,C=0), gaussian-esque\n    STBIR_FILTER_CATMULLROM   = 4,  // An interpolating cubic spline\n    STBIR_FILTER_MITCHELL     = 5,  // Mitchell-Netrevalli filter with B=1/3, C=1/3\n} stbir_filter;\n\ntypedef enum\n{\n    STBIR_COLORSPACE_LINEAR,\n    STBIR_COLORSPACE_SRGB,\n\n    STBIR_MAX_COLORSPACES,\n} stbir_colorspace;\n\n// The following functions are all identical except for the type of the image data\n\nSTBIRDEF int stbir_resize_uint8_generic( const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                               unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                         int num_channels, int alpha_channel, int flags,\n                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space, \n                                         void *alloc_context);\n\nSTBIRDEF int stbir_resize_uint16_generic(const stbir_uint16 *input_pixels  , int input_w , int input_h , int input_stride_in_bytes,\n                                               stbir_uint16 *output_pixels , int output_w, int output_h, int output_stride_in_bytes,\n                                         int num_channels, int alpha_channel, int flags,\n                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space, \n                                         void *alloc_context);\n\nSTBIRDEF int stbir_resize_float_generic( const float *input_pixels         , int input_w , int input_h , int input_stride_in_bytes,\n                                               float *output_pixels        , int output_w, int output_h, int output_stride_in_bytes,\n                                         int num_channels, int alpha_channel, int flags,\n                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space, \n                                         void *alloc_context);\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Full-complexity API\n//\n// This extends the medium API as follows:\n//\n//       * uint32 image type\n//     * not typesafe\n//     * separate filter types for each axis\n//     * separate edge modes for each axis\n//     * can specify scale explicitly for subpixel correctness\n//     * can specify image source tile using texture coordinates\n\ntypedef enum\n{\n    STBIR_TYPE_UINT8 ,\n    STBIR_TYPE_UINT16,\n    STBIR_TYPE_UINT32,\n    STBIR_TYPE_FLOAT ,\n\n    STBIR_MAX_TYPES\n} stbir_datatype;\n\nSTBIRDEF int stbir_resize(         const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                   stbir_datatype datatype,\n                                   int num_channels, int alpha_channel, int flags,\n                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical, \n                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,\n                                   stbir_colorspace space, void *alloc_context);\n\nSTBIRDEF int stbir_resize_subpixel(const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                   stbir_datatype datatype,\n                                   int num_channels, int alpha_channel, int flags,\n                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical, \n                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,\n                                   stbir_colorspace space, void *alloc_context,\n                                   float x_scale, float y_scale,\n                                   float x_offset, float y_offset);\n\nSTBIRDEF int stbir_resize_region(  const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                   stbir_datatype datatype,\n                                   int num_channels, int alpha_channel, int flags,\n                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical, \n                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,\n                                   stbir_colorspace space, void *alloc_context,\n                                   float s0, float t0, float s1, float t1);\n// (s0, t0) & (s1, t1) are the top-left and bottom right corner (uv addressing style: [0, 1]x[0, 1]) of a region of the input image to use.\n\n//\n//\n////   end header file   /////////////////////////////////////////////////////\n#endif // STBIR_INCLUDE_STB_IMAGE_RESIZE_H\n\n\n\n\n\n#ifdef STB_IMAGE_RESIZE_IMPLEMENTATION\n\n#ifndef STBIR_ASSERT\n#include <assert.h>\n#define STBIR_ASSERT(x) assert(x)\n#endif\n\n#ifdef STBIR_DEBUG\n#define STBIR__DEBUG_ASSERT STBIR_ASSERT\n#else\n#define STBIR__DEBUG_ASSERT\n#endif\n\n// If you hit this it means I haven't done it yet.\n#define STBIR__UNIMPLEMENTED(x) STBIR_ASSERT(!(x))\n\n// For memset\n#include <string.h>\n\n#include <math.h>\n\n#ifndef STBIR_MALLOC\n#include <stdlib.h>\n#define STBIR_MALLOC(size,c) malloc(size)\n#define STBIR_FREE(ptr,c)    free(ptr)\n#endif\n\n#ifndef _MSC_VER\n#ifdef __cplusplus\n#define stbir__inline inline\n#else\n#define stbir__inline\n#endif\n#else\n#define stbir__inline __forceinline\n#endif\n\n\n// should produce compiler error if size is wrong\ntypedef unsigned char stbir__validate_uint32[sizeof(stbir_uint32) == 4 ? 1 : -1];\n\n#ifdef _MSC_VER\n#define STBIR__NOTUSED(v)  (void)(v)\n#else\n#define STBIR__NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#define STBIR__ARRAY_SIZE(a) (sizeof((a))/sizeof((a)[0]))\n\n#ifndef STBIR_DEFAULT_FILTER_UPSAMPLE\n#define STBIR_DEFAULT_FILTER_UPSAMPLE    STBIR_FILTER_CATMULLROM\n#endif\n\n#ifndef STBIR_DEFAULT_FILTER_DOWNSAMPLE\n#define STBIR_DEFAULT_FILTER_DOWNSAMPLE  STBIR_FILTER_MITCHELL\n#endif\n\n#ifndef STBIR_PROGRESS_REPORT\n#define STBIR_PROGRESS_REPORT(float_0_to_1)\n#endif\n\n#ifndef STBIR_MAX_CHANNELS\n#define STBIR_MAX_CHANNELS 64\n#endif\n\n#if STBIR_MAX_CHANNELS > 65536\n#error \"Too many channels; STBIR_MAX_CHANNELS must be no more than 65536.\"\n// because we store the indices in 16-bit variables\n#endif\n\n// This value is added to alpha just before premultiplication to avoid\n// zeroing out color values. It is equivalent to 2^-80. If you don't want\n// that behavior (it may interfere if you have floating point images with\n// very small alpha values) then you can define STBIR_NO_ALPHA_EPSILON to\n// disable it.\n#ifndef STBIR_ALPHA_EPSILON\n#define STBIR_ALPHA_EPSILON ((float)1 / (1 << 20) / (1 << 20) / (1 << 20) / (1 << 20))\n#endif\n\n\n\n#ifdef _MSC_VER\n#define STBIR__UNUSED_PARAM(v)  (void)(v)\n#else\n#define STBIR__UNUSED_PARAM(v)  (void)sizeof(v)\n#endif\n\n// must match stbir_datatype\nstatic unsigned char stbir__type_size[] = {\n    1, // STBIR_TYPE_UINT8\n    2, // STBIR_TYPE_UINT16\n    4, // STBIR_TYPE_UINT32\n    4, // STBIR_TYPE_FLOAT\n};\n\n// Kernel function centered at 0\ntypedef float (stbir__kernel_fn)(float x, float scale);\ntypedef float (stbir__support_fn)(float scale);\n\ntypedef struct\n{\n    stbir__kernel_fn* kernel;\n    stbir__support_fn* support;\n} stbir__filter_info;\n\n// When upsampling, the contributors are which source pixels contribute.\n// When downsampling, the contributors are which destination pixels are contributed to.\ntypedef struct\n{\n    int n0; // First contributing pixel\n    int n1; // Last contributing pixel\n} stbir__contributors;\n\ntypedef struct\n{\n    const void* input_data;\n    int input_w;\n    int input_h;\n    int input_stride_bytes;\n\n    void* output_data;\n    int output_w;\n    int output_h;\n    int output_stride_bytes;\n\n    float s0, t0, s1, t1;\n\n    float horizontal_shift; // Units: output pixels\n    float vertical_shift;   // Units: output pixels\n    float horizontal_scale;\n    float vertical_scale;\n\n    int channels;\n    int alpha_channel;\n    stbir_uint32 flags;\n    stbir_datatype type;\n    stbir_filter horizontal_filter;\n    stbir_filter vertical_filter;\n    stbir_edge edge_horizontal;\n    stbir_edge edge_vertical;\n    stbir_colorspace colorspace;\n\n    stbir__contributors* horizontal_contributors;\n    float* horizontal_coefficients;\n\n    stbir__contributors* vertical_contributors;\n    float* vertical_coefficients;\n\n    int decode_buffer_pixels;\n    float* decode_buffer;\n\n    float* horizontal_buffer;\n\n    // cache these because ceil/floor are inexplicably showing up in profile\n    int horizontal_coefficient_width;\n    int vertical_coefficient_width;\n    int horizontal_filter_pixel_width;\n    int vertical_filter_pixel_width;\n    int horizontal_filter_pixel_margin;\n    int vertical_filter_pixel_margin;\n    int horizontal_num_contributors;\n    int vertical_num_contributors;\n\n    int ring_buffer_length_bytes; // The length of an individual entry in the ring buffer. The total number of ring buffers is stbir__get_filter_pixel_width(filter)\n    int ring_buffer_first_scanline;\n    int ring_buffer_last_scanline;\n    int ring_buffer_begin_index;\n    float* ring_buffer;\n\n    float* encode_buffer; // A temporary buffer to store floats so we don't lose precision while we do multiply-adds.\n\n    int horizontal_contributors_size;\n    int horizontal_coefficients_size;\n    int vertical_contributors_size;\n    int vertical_coefficients_size;\n    int decode_buffer_size;\n    int horizontal_buffer_size;\n    int ring_buffer_size;\n    int encode_buffer_size;\n} stbir__info;\n\nstatic stbir__inline int stbir__min(int a, int b)\n{\n    return a < b ? a : b;\n}\n\nstatic stbir__inline float stbir__saturate(float x)\n{\n    if (x < 0)\n        return 0;\n\n    if (x > 1)\n        return 1;\n\n    return x;\n}\n\n#ifdef STBIR_SATURATE_INT\nstatic stbir__inline stbir_uint8 stbir__saturate8(int x)\n{\n    if ((unsigned int) x <= 255)\n        return x;\n\n    if (x < 0)\n        return 0;\n\n    return 255;\n}\n\nstatic stbir__inline stbir_uint16 stbir__saturate16(int x)\n{\n    if ((unsigned int) x <= 65535)\n        return x;\n\n    if (x < 0)\n        return 0;\n\n    return 65535;\n}\n#endif\n\nstatic float stbir__srgb_uchar_to_linear_float[256] = {\n    0.000000f, 0.000304f, 0.000607f, 0.000911f, 0.001214f, 0.001518f, 0.001821f, 0.002125f, 0.002428f, 0.002732f, 0.003035f,\n    0.003347f, 0.003677f, 0.004025f, 0.004391f, 0.004777f, 0.005182f, 0.005605f, 0.006049f, 0.006512f, 0.006995f, 0.007499f,\n    0.008023f, 0.008568f, 0.009134f, 0.009721f, 0.010330f, 0.010960f, 0.011612f, 0.012286f, 0.012983f, 0.013702f, 0.014444f,\n    0.015209f, 0.015996f, 0.016807f, 0.017642f, 0.018500f, 0.019382f, 0.020289f, 0.021219f, 0.022174f, 0.023153f, 0.024158f,\n    0.025187f, 0.026241f, 0.027321f, 0.028426f, 0.029557f, 0.030713f, 0.031896f, 0.033105f, 0.034340f, 0.035601f, 0.036889f,\n    0.038204f, 0.039546f, 0.040915f, 0.042311f, 0.043735f, 0.045186f, 0.046665f, 0.048172f, 0.049707f, 0.051269f, 0.052861f,\n    0.054480f, 0.056128f, 0.057805f, 0.059511f, 0.061246f, 0.063010f, 0.064803f, 0.066626f, 0.068478f, 0.070360f, 0.072272f,\n    0.074214f, 0.076185f, 0.078187f, 0.080220f, 0.082283f, 0.084376f, 0.086500f, 0.088656f, 0.090842f, 0.093059f, 0.095307f,\n    0.097587f, 0.099899f, 0.102242f, 0.104616f, 0.107023f, 0.109462f, 0.111932f, 0.114435f, 0.116971f, 0.119538f, 0.122139f,\n    0.124772f, 0.127438f, 0.130136f, 0.132868f, 0.135633f, 0.138432f, 0.141263f, 0.144128f, 0.147027f, 0.149960f, 0.152926f,\n    0.155926f, 0.158961f, 0.162029f, 0.165132f, 0.168269f, 0.171441f, 0.174647f, 0.177888f, 0.181164f, 0.184475f, 0.187821f,\n    0.191202f, 0.194618f, 0.198069f, 0.201556f, 0.205079f, 0.208637f, 0.212231f, 0.215861f, 0.219526f, 0.223228f, 0.226966f,\n    0.230740f, 0.234551f, 0.238398f, 0.242281f, 0.246201f, 0.250158f, 0.254152f, 0.258183f, 0.262251f, 0.266356f, 0.270498f,\n    0.274677f, 0.278894f, 0.283149f, 0.287441f, 0.291771f, 0.296138f, 0.300544f, 0.304987f, 0.309469f, 0.313989f, 0.318547f,\n    0.323143f, 0.327778f, 0.332452f, 0.337164f, 0.341914f, 0.346704f, 0.351533f, 0.356400f, 0.361307f, 0.366253f, 0.371238f,\n    0.376262f, 0.381326f, 0.386430f, 0.391573f, 0.396755f, 0.401978f, 0.407240f, 0.412543f, 0.417885f, 0.423268f, 0.428691f,\n    0.434154f, 0.439657f, 0.445201f, 0.450786f, 0.456411f, 0.462077f, 0.467784f, 0.473532f, 0.479320f, 0.485150f, 0.491021f,\n    0.496933f, 0.502887f, 0.508881f, 0.514918f, 0.520996f, 0.527115f, 0.533276f, 0.539480f, 0.545725f, 0.552011f, 0.558340f,\n    0.564712f, 0.571125f, 0.577581f, 0.584078f, 0.590619f, 0.597202f, 0.603827f, 0.610496f, 0.617207f, 0.623960f, 0.630757f,\n    0.637597f, 0.644480f, 0.651406f, 0.658375f, 0.665387f, 0.672443f, 0.679543f, 0.686685f, 0.693872f, 0.701102f, 0.708376f,\n    0.715694f, 0.723055f, 0.730461f, 0.737911f, 0.745404f, 0.752942f, 0.760525f, 0.768151f, 0.775822f, 0.783538f, 0.791298f,\n    0.799103f, 0.806952f, 0.814847f, 0.822786f, 0.830770f, 0.838799f, 0.846873f, 0.854993f, 0.863157f, 0.871367f, 0.879622f,\n    0.887923f, 0.896269f, 0.904661f, 0.913099f, 0.921582f, 0.930111f, 0.938686f, 0.947307f, 0.955974f, 0.964686f, 0.973445f,\n    0.982251f, 0.991102f, 1.0f\n};\n\nstatic float stbir__srgb_to_linear(float f)\n{\n    if (f <= 0.04045f)\n        return f / 12.92f;\n    else\n        return (float)pow((f + 0.055f) / 1.055f, 2.4f);\n}\n\nstatic float stbir__linear_to_srgb(float f)\n{\n    if (f <= 0.0031308f)\n        return f * 12.92f;\n    else\n        return 1.055f * (float)pow(f, 1 / 2.4f) - 0.055f;\n}\n\n#ifndef STBIR_NON_IEEE_FLOAT\n// From https://gist.github.com/rygorous/2203834\n\ntypedef union\n{\n    stbir_uint32 u;\n    float f;\n} stbir__FP32;\n\nstatic const stbir_uint32 fp32_to_srgb8_tab4[104] = {\n    0x0073000d, 0x007a000d, 0x0080000d, 0x0087000d, 0x008d000d, 0x0094000d, 0x009a000d, 0x00a1000d,\n    0x00a7001a, 0x00b4001a, 0x00c1001a, 0x00ce001a, 0x00da001a, 0x00e7001a, 0x00f4001a, 0x0101001a,\n    0x010e0033, 0x01280033, 0x01410033, 0x015b0033, 0x01750033, 0x018f0033, 0x01a80033, 0x01c20033,\n    0x01dc0067, 0x020f0067, 0x02430067, 0x02760067, 0x02aa0067, 0x02dd0067, 0x03110067, 0x03440067,\n    0x037800ce, 0x03df00ce, 0x044600ce, 0x04ad00ce, 0x051400ce, 0x057b00c5, 0x05dd00bc, 0x063b00b5,\n    0x06970158, 0x07420142, 0x07e30130, 0x087b0120, 0x090b0112, 0x09940106, 0x0a1700fc, 0x0a9500f2,\n    0x0b0f01cb, 0x0bf401ae, 0x0ccb0195, 0x0d950180, 0x0e56016e, 0x0f0d015e, 0x0fbc0150, 0x10630143,\n    0x11070264, 0x1238023e, 0x1357021d, 0x14660201, 0x156601e9, 0x165a01d3, 0x174401c0, 0x182401af,\n    0x18fe0331, 0x1a9602fe, 0x1c1502d2, 0x1d7e02ad, 0x1ed4028d, 0x201a0270, 0x21520256, 0x227d0240,\n    0x239f0443, 0x25c003fe, 0x27bf03c4, 0x29a10392, 0x2b6a0367, 0x2d1d0341, 0x2ebe031f, 0x304d0300,\n    0x31d105b0, 0x34a80555, 0x37520507, 0x39d504c5, 0x3c37048b, 0x3e7c0458, 0x40a8042a, 0x42bd0401,\n    0x44c20798, 0x488e071e, 0x4c1c06b6, 0x4f76065d, 0x52a50610, 0x55ac05cc, 0x5892058f, 0x5b590559,\n    0x5e0c0a23, 0x631c0980, 0x67db08f6, 0x6c55087f, 0x70940818, 0x74a007bd, 0x787d076c, 0x7c330723,\n};\n \nstatic stbir_uint8 stbir__linear_to_srgb_uchar(float in)\n{\n    static const stbir__FP32 almostone = { 0x3f7fffff }; // 1-eps\n    static const stbir__FP32 minval = { (127-13) << 23 };\n    stbir_uint32 tab,bias,scale,t;\n    stbir__FP32 f;\n \n    // Clamp to [2^(-13), 1-eps]; these two values map to 0 and 1, respectively.\n    // The tests are carefully written so that NaNs map to 0, same as in the reference\n    // implementation.\n    if (!(in > minval.f)) // written this way to catch NaNs\n        in = minval.f;\n    if (in > almostone.f)\n        in = almostone.f;\n \n    // Do the table lookup and unpack bias, scale\n    f.f = in;\n    tab = fp32_to_srgb8_tab4[(f.u - minval.u) >> 20];\n    bias = (tab >> 16) << 9;\n    scale = tab & 0xffff;\n \n    // Grab next-highest mantissa bits and perform linear interpolation\n    t = (f.u >> 12) & 0xff;\n    return (unsigned char) ((bias + scale*t) >> 16);\n}\n\n#else\n// sRGB transition values, scaled by 1<<28\nstatic int stbir__srgb_offset_to_linear_scaled[256] =\n{\n            0,     40738,    122216,    203693,    285170,    366648,    448125,    529603,\n       611080,    692557,    774035,    855852,    942009,   1033024,   1128971,   1229926,\n      1335959,   1447142,   1563542,   1685229,   1812268,   1944725,   2082664,   2226148,\n      2375238,   2529996,   2690481,   2856753,   3028870,   3206888,   3390865,   3580856,\n      3776916,   3979100,   4187460,   4402049,   4622919,   4850123,   5083710,   5323731,\n      5570236,   5823273,   6082892,   6349140,   6622065,   6901714,   7188133,   7481369,\n      7781466,   8088471,   8402427,   8723380,   9051372,   9386448,   9728650,  10078021,\n     10434603,  10798439,  11169569,  11548036,  11933879,  12327139,  12727857,  13136073,\n     13551826,  13975156,  14406100,  14844697,  15290987,  15745007,  16206795,  16676389,\n     17153826,  17639142,  18132374,  18633560,  19142734,  19659934,  20185196,  20718552,\n     21260042,  21809696,  22367554,  22933648,  23508010,  24090680,  24681686,  25281066,\n     25888850,  26505076,  27129772,  27762974,  28404716,  29055026,  29713942,  30381490,\n     31057708,  31742624,  32436272,  33138682,  33849884,  34569912,  35298800,  36036568,\n     36783260,  37538896,  38303512,  39077136,  39859796,  40651528,  41452360,  42262316,\n     43081432,  43909732,  44747252,  45594016,  46450052,  47315392,  48190064,  49074096,\n     49967516,  50870356,  51782636,  52704392,  53635648,  54576432,  55526772,  56486700,\n     57456236,  58435408,  59424248,  60422780,  61431036,  62449032,  63476804,  64514376,\n     65561776,  66619028,  67686160,  68763192,  69850160,  70947088,  72053992,  73170912,\n     74297864,  75434880,  76581976,  77739184,  78906536,  80084040,  81271736,  82469648,\n     83677792,  84896192,  86124888,  87363888,  88613232,  89872928,  91143016,  92423512,\n     93714432,  95015816,  96327688,  97650056,  98982952, 100326408, 101680440, 103045072,\n    104420320, 105806224, 107202800, 108610064, 110028048, 111456776, 112896264, 114346544,\n    115807632, 117279552, 118762328, 120255976, 121760536, 123276016, 124802440, 126339832,\n    127888216, 129447616, 131018048, 132599544, 134192112, 135795792, 137410592, 139036528,\n    140673648, 142321952, 143981456, 145652208, 147334208, 149027488, 150732064, 152447968,\n    154175200, 155913792, 157663776, 159425168, 161197984, 162982240, 164777968, 166585184,\n    168403904, 170234160, 172075968, 173929344, 175794320, 177670896, 179559120, 181458992,\n    183370528, 185293776, 187228736, 189175424, 191133888, 193104112, 195086128, 197079968,\n    199085648, 201103184, 203132592, 205173888, 207227120, 209292272, 211369392, 213458480,\n    215559568, 217672656, 219797792, 221934976, 224084240, 226245600, 228419056, 230604656,\n    232802400, 235012320, 237234432, 239468736, 241715280, 243974080, 246245120, 248528464,\n    250824112, 253132064, 255452368, 257785040, 260130080, 262487520, 264857376, 267239664,\n};\n\nstatic stbir_uint8 stbir__linear_to_srgb_uchar(float f)\n{\n    int x = (int) (f * (1 << 28)); // has headroom so you don't need to clamp\n    int v = 0;\n    int i;\n\n    // Refine the guess with a short binary search.\n    i = v + 128; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n    i = v +  64; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n    i = v +  32; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n    i = v +  16; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n    i = v +   8; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n    i = v +   4; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n    i = v +   2; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n    i = v +   1; if (x >= stbir__srgb_offset_to_linear_scaled[i]) v = i;\n\n    return (stbir_uint8) v;\n}\n#endif\n\nstatic float stbir__filter_trapezoid(float x, float scale)\n{\n    float halfscale = scale / 2;\n    float t = 0.5f + halfscale;\n    STBIR__DEBUG_ASSERT(scale <= 1);\n\n    x = (float)fabs(x);\n\n    if (x >= t)\n        return 0;\n    else\n    {\n        float r = 0.5f - halfscale;\n        if (x <= r)\n            return 1;\n        else\n            return (t - x) / scale;\n    }\n}\n\nstatic float stbir__support_trapezoid(float scale)\n{\n    STBIR__DEBUG_ASSERT(scale <= 1);\n    return 0.5f + scale / 2;\n}\n\nstatic float stbir__filter_triangle(float x, float s)\n{\n    STBIR__UNUSED_PARAM(s);\n\n    x = (float)fabs(x);\n\n    if (x <= 1.0f)\n        return 1 - x;\n    else\n        return 0;\n}\n\nstatic float stbir__filter_cubic(float x, float s)\n{\n    STBIR__UNUSED_PARAM(s);\n\n    x = (float)fabs(x);\n\n    if (x < 1.0f)\n        return (4 + x*x*(3*x - 6))/6;\n    else if (x < 2.0f)\n        return (8 + x*(-12 + x*(6 - x)))/6;\n\n    return (0.0f);\n}\n\nstatic float stbir__filter_catmullrom(float x, float s)\n{\n    STBIR__UNUSED_PARAM(s);\n\n    x = (float)fabs(x);\n\n    if (x < 1.0f)\n        return 1 - x*x*(2.5f - 1.5f*x);\n    else if (x < 2.0f)\n        return 2 - x*(4 + x*(0.5f*x - 2.5f));\n\n    return (0.0f);\n}\n\nstatic float stbir__filter_mitchell(float x, float s)\n{\n    STBIR__UNUSED_PARAM(s);\n\n    x = (float)fabs(x);\n\n    if (x < 1.0f)\n        return (16 + x*x*(21 * x - 36))/18;\n    else if (x < 2.0f)\n        return (32 + x*(-60 + x*(36 - 7*x)))/18;\n\n    return (0.0f);\n}\n\nstatic float stbir__support_zero(float s)\n{\n    STBIR__UNUSED_PARAM(s);\n    return 0;\n}\n\nstatic float stbir__support_one(float s)\n{\n    STBIR__UNUSED_PARAM(s);\n    return 1;\n}\n\nstatic float stbir__support_two(float s)\n{\n    STBIR__UNUSED_PARAM(s);\n    return 2;\n}\n\nstatic stbir__filter_info stbir__filter_info_table[] = {\n        { NULL,                     stbir__support_zero },\n        { stbir__filter_trapezoid,  stbir__support_trapezoid },\n        { stbir__filter_triangle,   stbir__support_one },\n        { stbir__filter_cubic,      stbir__support_two },\n        { stbir__filter_catmullrom, stbir__support_two },\n        { stbir__filter_mitchell,   stbir__support_two },\n};\n\nstbir__inline static int stbir__use_upsampling(float ratio)\n{\n    return ratio > 1;\n}\n\nstbir__inline static int stbir__use_width_upsampling(stbir__info* stbir_info)\n{\n    return stbir__use_upsampling(stbir_info->horizontal_scale);\n}\n\nstbir__inline static int stbir__use_height_upsampling(stbir__info* stbir_info)\n{\n    return stbir__use_upsampling(stbir_info->vertical_scale);\n}\n\n// This is the maximum number of input samples that can affect an output sample\n// with the given filter\nstatic int stbir__get_filter_pixel_width(stbir_filter filter, float scale)\n{\n    STBIR_ASSERT(filter != 0);\n    STBIR_ASSERT(filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));\n\n    if (stbir__use_upsampling(scale))\n        return (int)ceil(stbir__filter_info_table[filter].support(1/scale) * 2);\n    else\n        return (int)ceil(stbir__filter_info_table[filter].support(scale) * 2 / scale);\n}\n\n// This is how much to expand buffers to account for filters seeking outside\n// the image boundaries.\nstatic int stbir__get_filter_pixel_margin(stbir_filter filter, float scale)\n{\n    return stbir__get_filter_pixel_width(filter, scale) / 2;\n}\n\nstatic int stbir__get_coefficient_width(stbir_filter filter, float scale)\n{\n    if (stbir__use_upsampling(scale))\n        return (int)ceil(stbir__filter_info_table[filter].support(1 / scale) * 2);\n    else\n        return (int)ceil(stbir__filter_info_table[filter].support(scale) * 2);\n}\n\nstatic int stbir__get_contributors(float scale, stbir_filter filter, int input_size, int output_size)\n{\n    if (stbir__use_upsampling(scale))\n        return output_size;\n    else\n        return (input_size + stbir__get_filter_pixel_margin(filter, scale) * 2);\n}\n\nstatic int stbir__get_total_horizontal_coefficients(stbir__info* info)\n{\n    return info->horizontal_num_contributors\n         * stbir__get_coefficient_width      (info->horizontal_filter, info->horizontal_scale);\n}\n\nstatic int stbir__get_total_vertical_coefficients(stbir__info* info)\n{\n    return info->vertical_num_contributors\n         * stbir__get_coefficient_width      (info->vertical_filter, info->vertical_scale);\n}\n\nstatic stbir__contributors* stbir__get_contributor(stbir__contributors* contributors, int n)\n{\n    return &contributors[n];\n}\n\n// For perf reasons this code is duplicated in stbir__resample_horizontal_upsample/downsample,\n// if you change it here change it there too.\nstatic float* stbir__get_coefficient(float* coefficients, stbir_filter filter, float scale, int n, int c)\n{\n    int width = stbir__get_coefficient_width(filter, scale);\n    return &coefficients[width*n + c];\n}\n\nstatic int stbir__edge_wrap_slow(stbir_edge edge, int n, int max)\n{\n    switch (edge)\n    {\n    case STBIR_EDGE_ZERO:\n        return 0; // we'll decode the wrong pixel here, and then overwrite with 0s later\n\n    case STBIR_EDGE_CLAMP:\n        if (n < 0)\n            return 0;\n\n        if (n >= max)\n            return max - 1;\n\n        return n; // NOTREACHED\n\n    case STBIR_EDGE_REFLECT:\n    {\n        if (n < 0)\n        {\n            if (n < max)\n                return -n;\n            else\n                return max - 1;\n        }\n\n        if (n >= max)\n        {\n            int max2 = max * 2;\n            if (n >= max2)\n                return 0;\n            else\n                return max2 - n - 1;\n        }\n\n        return n; // NOTREACHED\n    }\n\n    case STBIR_EDGE_WRAP:\n        if (n >= 0)\n            return (n % max);\n        else\n        {\n            int m = (-n) % max;\n\n            if (m != 0)\n                m = max - m;\n\n            return (m);\n        }\n        return n;  // NOTREACHED\n\n    default:\n        STBIR__UNIMPLEMENTED(\"Unimplemented edge type\");\n        return 0;\n    }\n}\n\nstbir__inline static int stbir__edge_wrap(stbir_edge edge, int n, int max)\n{\n    // avoid per-pixel switch\n    if (n >= 0 && n < max)\n        return n;\n    return stbir__edge_wrap_slow(edge, n, max);\n}\n\n// What input pixels contribute to this output pixel?\nstatic void stbir__calculate_sample_range_upsample(int n, float out_filter_radius, float scale_ratio, float out_shift, int* in_first_pixel, int* in_last_pixel, float* in_center_of_out)\n{\n    float out_pixel_center = (float)n + 0.5f;\n    float out_pixel_influence_lowerbound = out_pixel_center - out_filter_radius;\n    float out_pixel_influence_upperbound = out_pixel_center + out_filter_radius;\n\n    float in_pixel_influence_lowerbound = (out_pixel_influence_lowerbound + out_shift) / scale_ratio;\n    float in_pixel_influence_upperbound = (out_pixel_influence_upperbound + out_shift) / scale_ratio;\n\n    *in_center_of_out = (out_pixel_center + out_shift) / scale_ratio;\n    *in_first_pixel = (int)(floor(in_pixel_influence_lowerbound + 0.5));\n    *in_last_pixel = (int)(floor(in_pixel_influence_upperbound - 0.5));\n}\n\n// What output pixels does this input pixel contribute to?\nstatic void stbir__calculate_sample_range_downsample(int n, float in_pixels_radius, float scale_ratio, float out_shift, int* out_first_pixel, int* out_last_pixel, float* out_center_of_in)\n{\n    float in_pixel_center = (float)n + 0.5f;\n    float in_pixel_influence_lowerbound = in_pixel_center - in_pixels_radius;\n    float in_pixel_influence_upperbound = in_pixel_center + in_pixels_radius;\n\n    float out_pixel_influence_lowerbound = in_pixel_influence_lowerbound * scale_ratio - out_shift;\n    float out_pixel_influence_upperbound = in_pixel_influence_upperbound * scale_ratio - out_shift;\n\n    *out_center_of_in = in_pixel_center * scale_ratio - out_shift;\n    *out_first_pixel = (int)(floor(out_pixel_influence_lowerbound + 0.5));\n    *out_last_pixel = (int)(floor(out_pixel_influence_upperbound - 0.5));\n}\n\nstatic void stbir__calculate_coefficients_upsample(stbir__info* stbir_info, stbir_filter filter, float scale, int in_first_pixel, int in_last_pixel, float in_center_of_out, stbir__contributors* contributor, float* coefficient_group)\n{\n    int i;\n    float total_filter = 0;\n    float filter_scale;\n\n    STBIR__DEBUG_ASSERT(in_last_pixel - in_first_pixel <= (int)ceil(stbir__filter_info_table[filter].support(1/scale) * 2)); // Taken directly from stbir__get_coefficient_width() which we can't call because we don't know if we're horizontal or vertical.\n\n    contributor->n0 = in_first_pixel;\n    contributor->n1 = in_last_pixel;\n\n    STBIR__DEBUG_ASSERT(contributor->n1 >= contributor->n0);\n\n    for (i = 0; i <= in_last_pixel - in_first_pixel; i++)\n    {\n        float in_pixel_center = (float)(i + in_first_pixel) + 0.5f;\n        coefficient_group[i] = stbir__filter_info_table[filter].kernel(in_center_of_out - in_pixel_center, 1 / scale);\n\n        // If the coefficient is zero, skip it. (Don't do the <0 check here, we want the influence of those outside pixels.)\n        if (i == 0 && !coefficient_group[i])\n        {\n            contributor->n0 = ++in_first_pixel;\n            i--;\n            continue;\n        }\n\n        total_filter += coefficient_group[i];\n    }\n\n    STBIR__DEBUG_ASSERT(stbir__filter_info_table[filter].kernel((float)(in_last_pixel + 1) + 0.5f - in_center_of_out, 1/scale) == 0);\n\n    STBIR__DEBUG_ASSERT(total_filter > 0.9);\n    STBIR__DEBUG_ASSERT(total_filter < 1.1f); // Make sure it's not way off.\n\n    // Make sure the sum of all coefficients is 1.\n    filter_scale = 1 / total_filter;\n\n    for (i = 0; i <= in_last_pixel - in_first_pixel; i++)\n        coefficient_group[i] *= filter_scale;\n\n    for (i = in_last_pixel - in_first_pixel; i >= 0; i--)\n    {\n        if (coefficient_group[i])\n            break;\n\n        // This line has no weight. We can skip it.\n        contributor->n1 = contributor->n0 + i - 1;\n    }\n}\n\nstatic void stbir__calculate_coefficients_downsample(stbir__info* stbir_info, stbir_filter filter, float scale_ratio, int out_first_pixel, int out_last_pixel, float out_center_of_in, stbir__contributors* contributor, float* coefficient_group)\n{\n    int i;\n\n     STBIR__DEBUG_ASSERT(out_last_pixel - out_first_pixel <= (int)ceil(stbir__filter_info_table[filter].support(scale_ratio) * 2)); // Taken directly from stbir__get_coefficient_width() which we can't call because we don't know if we're horizontal or vertical.\n\n    contributor->n0 = out_first_pixel;\n    contributor->n1 = out_last_pixel;\n\n    STBIR__DEBUG_ASSERT(contributor->n1 >= contributor->n0);\n\n    for (i = 0; i <= out_last_pixel - out_first_pixel; i++)\n    {\n        float out_pixel_center = (float)(i + out_first_pixel) + 0.5f;\n        float x = out_pixel_center - out_center_of_in;\n        coefficient_group[i] = stbir__filter_info_table[filter].kernel(x, scale_ratio) * scale_ratio;\n    }\n\n    STBIR__DEBUG_ASSERT(stbir__filter_info_table[filter].kernel((float)(out_last_pixel + 1) + 0.5f - out_center_of_in, scale_ratio) == 0);\n\n    for (i = out_last_pixel - out_first_pixel; i >= 0; i--)\n    {\n        if (coefficient_group[i])\n            break;\n\n        // This line has no weight. We can skip it.\n        contributor->n1 = contributor->n0 + i - 1;\n    }\n}\n\nstatic void stbir__normalize_downsample_coefficients(stbir__info* stbir_info, stbir__contributors* contributors, float* coefficients, stbir_filter filter, float scale_ratio, float shift, int input_size, int output_size)\n{\n    int num_contributors = stbir__get_contributors(scale_ratio, filter, input_size, output_size);\n    int num_coefficients = stbir__get_coefficient_width(filter, scale_ratio);\n    int i, j;\n    int skip;\n\n    for (i = 0; i < output_size; i++)\n    {\n        float scale;\n        float total = 0;\n\n        for (j = 0; j < num_contributors; j++)\n        {\n            if (i >= contributors[j].n0 && i <= contributors[j].n1)\n            {\n                float coefficient = *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i - contributors[j].n0);\n                total += coefficient;\n            }\n            else if (i < contributors[j].n0)\n                break;\n        }\n\n        STBIR__DEBUG_ASSERT(total > 0.9f);\n        STBIR__DEBUG_ASSERT(total < 1.1f);\n\n        scale = 1 / total;\n\n        for (j = 0; j < num_contributors; j++)\n        {\n            if (i >= contributors[j].n0 && i <= contributors[j].n1)\n                *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i - contributors[j].n0) *= scale;\n            else if (i < contributors[j].n0)\n                break;\n        }\n    }\n\n    // Optimize: Skip zero coefficients and contributions outside of image bounds.\n    // Do this after normalizing because normalization depends on the n0/n1 values.\n    for (j = 0; j < num_contributors; j++)\n    {\n        int range, max, width;\n\n        skip = 0;\n        while (*stbir__get_coefficient(coefficients, filter, scale_ratio, j, skip) == 0)\n            skip++;\n\n        contributors[j].n0 += skip;\n\n        while (contributors[j].n0 < 0)\n        {\n            contributors[j].n0++;\n            skip++;\n        }\n\n        range = contributors[j].n1 - contributors[j].n0 + 1;\n        max = stbir__min(num_coefficients, range);\n\n        width = stbir__get_coefficient_width(filter, scale_ratio);\n        for (i = 0; i < max; i++)\n        {\n            if (i + skip >= width)\n                break;\n\n            *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i) = *stbir__get_coefficient(coefficients, filter, scale_ratio, j, i + skip);\n        }\n\n        continue;\n    }\n\n    // Using min to avoid writing into invalid pixels.\n    for (i = 0; i < num_contributors; i++)\n        contributors[i].n1 = stbir__min(contributors[i].n1, output_size - 1);\n}\n\n// Each scan line uses the same kernel values so we should calculate the kernel\n// values once and then we can use them for every scan line.\nstatic void stbir__calculate_filters(stbir__info* stbir_info, stbir__contributors* contributors, float* coefficients, stbir_filter filter, float scale_ratio, float shift, int input_size, int output_size)\n{\n    int n;\n    int total_contributors = stbir__get_contributors(scale_ratio, filter, input_size, output_size);\n\n    if (stbir__use_upsampling(scale_ratio))\n    {\n        float out_pixels_radius = stbir__filter_info_table[filter].support(1 / scale_ratio) * scale_ratio;\n\n        // Looping through out pixels\n        for (n = 0; n < total_contributors; n++)\n        {\n            float in_center_of_out; // Center of the current out pixel in the in pixel space\n            int in_first_pixel, in_last_pixel;\n\n            stbir__calculate_sample_range_upsample(n, out_pixels_radius, scale_ratio, shift, &in_first_pixel, &in_last_pixel, &in_center_of_out);\n\n            stbir__calculate_coefficients_upsample(stbir_info, filter, scale_ratio, in_first_pixel, in_last_pixel, in_center_of_out, stbir__get_contributor(contributors, n), stbir__get_coefficient(coefficients, filter, scale_ratio, n, 0));\n        }\n    }\n    else\n    {\n        float in_pixels_radius = stbir__filter_info_table[filter].support(scale_ratio) / scale_ratio;\n\n        // Looping through in pixels\n        for (n = 0; n < total_contributors; n++)\n        {\n            float out_center_of_in; // Center of the current out pixel in the in pixel space\n            int out_first_pixel, out_last_pixel;\n            int n_adjusted = n - stbir__get_filter_pixel_margin(filter, scale_ratio);\n\n            stbir__calculate_sample_range_downsample(n_adjusted, in_pixels_radius, scale_ratio, shift, &out_first_pixel, &out_last_pixel, &out_center_of_in);\n\n            stbir__calculate_coefficients_downsample(stbir_info, filter, scale_ratio, out_first_pixel, out_last_pixel, out_center_of_in, stbir__get_contributor(contributors, n), stbir__get_coefficient(coefficients, filter, scale_ratio, n, 0));\n        }\n\n        stbir__normalize_downsample_coefficients(stbir_info, contributors, coefficients, filter, scale_ratio, shift, input_size, output_size);\n    }\n}\n\nstatic float* stbir__get_decode_buffer(stbir__info* stbir_info)\n{\n    // The 0 index of the decode buffer starts after the margin. This makes\n    // it okay to use negative indexes on the decode buffer.\n    return &stbir_info->decode_buffer[stbir_info->horizontal_filter_pixel_margin * stbir_info->channels];\n}\n\n#define STBIR__DECODE(type, colorspace) ((type) * (STBIR_MAX_COLORSPACES) + (colorspace))\n\nstatic void stbir__decode_scanline(stbir__info* stbir_info, int n)\n{\n    int c;\n    int channels = stbir_info->channels;\n    int alpha_channel = stbir_info->alpha_channel;\n    int type = stbir_info->type;\n    int colorspace = stbir_info->colorspace;\n    int input_w = stbir_info->input_w;\n    int input_stride_bytes = stbir_info->input_stride_bytes;\n    float* decode_buffer = stbir__get_decode_buffer(stbir_info);\n    stbir_edge edge_horizontal = stbir_info->edge_horizontal;\n    stbir_edge edge_vertical = stbir_info->edge_vertical;\n    int in_buffer_row_offset = stbir__edge_wrap(edge_vertical, n, stbir_info->input_h) * input_stride_bytes;\n    const void* input_data = (char *) stbir_info->input_data + in_buffer_row_offset;\n    int max_x = input_w + stbir_info->horizontal_filter_pixel_margin;\n    int decode = STBIR__DECODE(type, colorspace);\n\n    int x = -stbir_info->horizontal_filter_pixel_margin;\n\n    // special handling for STBIR_EDGE_ZERO because it needs to return an item that doesn't appear in the input,\n    // and we want to avoid paying overhead on every pixel if not STBIR_EDGE_ZERO\n    if (edge_vertical == STBIR_EDGE_ZERO && (n < 0 || n >= stbir_info->input_h))\n    {\n        for (; x < max_x; x++)\n            for (c = 0; c < channels; c++)\n                decode_buffer[x*channels + c] = 0;\n        return;\n    }\n\n    switch (decode)\n    {\n    case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_LINEAR):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = ((float)((const unsigned char*)input_data)[input_pixel_index + c]) / 255;\n        }\n        break;\n\n    case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_SRGB):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = stbir__srgb_uchar_to_linear_float[((const unsigned char*)input_data)[input_pixel_index + c]];\n\n            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                decode_buffer[decode_pixel_index + alpha_channel] = ((float)((const unsigned char*)input_data)[input_pixel_index + alpha_channel]) / 255;\n        }\n        break;\n\n    case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_LINEAR):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = ((float)((const unsigned short*)input_data)[input_pixel_index + c]) / 65535;\n        }\n        break;\n\n    case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_SRGB):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = stbir__srgb_to_linear(((float)((const unsigned short*)input_data)[input_pixel_index + c]) / 65535);\n\n            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                decode_buffer[decode_pixel_index + alpha_channel] = ((float)((const unsigned short*)input_data)[input_pixel_index + alpha_channel]) / 65535;\n        }\n        break;\n\n    case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_LINEAR):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = (float)(((double)((const unsigned int*)input_data)[input_pixel_index + c]) / 4294967295);\n        }\n        break;\n\n    case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_SRGB):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = stbir__srgb_to_linear((float)(((double)((const unsigned int*)input_data)[input_pixel_index + c]) / 4294967295));\n\n            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                decode_buffer[decode_pixel_index + alpha_channel] = (float)(((double)((const unsigned int*)input_data)[input_pixel_index + alpha_channel]) / 4294967295);\n        }\n        break;\n\n    case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_LINEAR):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = ((const float*)input_data)[input_pixel_index + c];\n        }\n        break;\n\n    case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_SRGB):\n        for (; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n            int input_pixel_index = stbir__edge_wrap(edge_horizontal, x, input_w) * channels;\n            for (c = 0; c < channels; c++)\n                decode_buffer[decode_pixel_index + c] = stbir__srgb_to_linear(((const float*)input_data)[input_pixel_index + c]);\n\n            if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                decode_buffer[decode_pixel_index + alpha_channel] = ((const float*)input_data)[input_pixel_index + alpha_channel];\n        }\n\n        break;\n\n    default:\n        STBIR__UNIMPLEMENTED(\"Unknown type/colorspace/channels combination.\");\n        break;\n    }\n\n    if (!(stbir_info->flags & STBIR_FLAG_ALPHA_PREMULTIPLIED))\n    {\n        for (x = -stbir_info->horizontal_filter_pixel_margin; x < max_x; x++)\n        {\n            int decode_pixel_index = x * channels;\n\n            // If the alpha value is 0 it will clobber the color values. Make sure it's not.\n            float alpha = decode_buffer[decode_pixel_index + alpha_channel];\n#ifndef STBIR_NO_ALPHA_EPSILON\n            if (stbir_info->type != STBIR_TYPE_FLOAT) {\n                alpha += STBIR_ALPHA_EPSILON;\n                decode_buffer[decode_pixel_index + alpha_channel] = alpha;\n            }\n#endif\n            for (c = 0; c < channels; c++)\n            {\n                if (c == alpha_channel)\n                    continue;\n\n                decode_buffer[decode_pixel_index + c] *= alpha;\n            }\n        }\n    }\n\n    if (edge_horizontal == STBIR_EDGE_ZERO)\n    {\n        for (x = -stbir_info->horizontal_filter_pixel_margin; x < 0; x++)\n        {\n            for (c = 0; c < channels; c++)\n                decode_buffer[x*channels + c] = 0;\n        }\n        for (x = input_w; x < max_x; x++)\n        {\n            for (c = 0; c < channels; c++)\n                decode_buffer[x*channels + c] = 0;\n        }\n    }\n}\n\nstatic float* stbir__get_ring_buffer_entry(float* ring_buffer, int index, int ring_buffer_length)\n{\n    return &ring_buffer[index * ring_buffer_length];\n}\n\nstatic float* stbir__add_empty_ring_buffer_entry(stbir__info* stbir_info, int n)\n{\n    int ring_buffer_index;\n    float* ring_buffer;\n\n    if (stbir_info->ring_buffer_begin_index < 0)\n    {\n        ring_buffer_index = stbir_info->ring_buffer_begin_index = 0;\n        stbir_info->ring_buffer_first_scanline = n;\n    }\n    else\n    {\n        ring_buffer_index = (stbir_info->ring_buffer_begin_index + (stbir_info->ring_buffer_last_scanline - stbir_info->ring_buffer_first_scanline) + 1) % stbir_info->vertical_filter_pixel_width;\n        STBIR__DEBUG_ASSERT(ring_buffer_index != stbir_info->ring_buffer_begin_index);\n    }\n\n    ring_buffer = stbir__get_ring_buffer_entry(stbir_info->ring_buffer, ring_buffer_index, stbir_info->ring_buffer_length_bytes / sizeof(float));\n    memset(ring_buffer, 0, stbir_info->ring_buffer_length_bytes);\n\n    stbir_info->ring_buffer_last_scanline = n;\n\n    return ring_buffer;\n}\n\n\nstatic void stbir__resample_horizontal_upsample(stbir__info* stbir_info, int n, float* output_buffer)\n{\n    int x, k;\n    int output_w = stbir_info->output_w;\n    int kernel_pixel_width = stbir_info->horizontal_filter_pixel_width;\n    int channels = stbir_info->channels;\n    float* decode_buffer = stbir__get_decode_buffer(stbir_info);\n    stbir__contributors* horizontal_contributors = stbir_info->horizontal_contributors;\n    float* horizontal_coefficients = stbir_info->horizontal_coefficients;\n    int coefficient_width = stbir_info->horizontal_coefficient_width;\n\n    for (x = 0; x < output_w; x++)\n    {\n        int n0 = horizontal_contributors[x].n0;\n        int n1 = horizontal_contributors[x].n1;\n\n        int out_pixel_index = x * channels;\n        int coefficient_group = coefficient_width * x;\n        int coefficient_counter = 0;\n\n        STBIR__DEBUG_ASSERT(n1 >= n0);\n        STBIR__DEBUG_ASSERT(n0 >= -stbir_info->horizontal_filter_pixel_margin);\n        STBIR__DEBUG_ASSERT(n1 >= -stbir_info->horizontal_filter_pixel_margin);\n        STBIR__DEBUG_ASSERT(n0 < stbir_info->input_w + stbir_info->horizontal_filter_pixel_margin);\n        STBIR__DEBUG_ASSERT(n1 < stbir_info->input_w + stbir_info->horizontal_filter_pixel_margin);\n\n        switch (channels) {\n            case 1:\n                for (k = n0; k <= n1; k++)\n                {\n                    int in_pixel_index = k * 1;\n                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                }\n                break;\n            case 2:\n                for (k = n0; k <= n1; k++)\n                {\n                    int in_pixel_index = k * 2;\n                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;\n                }\n                break;\n            case 3:\n                for (k = n0; k <= n1; k++)\n                {\n                    int in_pixel_index = k * 3;\n                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;\n                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;\n                }\n                break;\n            case 4:\n                for (k = n0; k <= n1; k++)\n                {\n                    int in_pixel_index = k * 4;\n                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;\n                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;\n                    output_buffer[out_pixel_index + 3] += decode_buffer[in_pixel_index + 3] * coefficient;\n                }\n                break;\n            default:\n                for (k = n0; k <= n1; k++)\n                {\n                    int in_pixel_index = k * channels;\n                    float coefficient = horizontal_coefficients[coefficient_group + coefficient_counter++];\n                    int c;\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    for (c = 0; c < channels; c++)\n                        output_buffer[out_pixel_index + c] += decode_buffer[in_pixel_index + c] * coefficient;\n                }\n                break;\n        }\n    }\n}\n\nstatic void stbir__resample_horizontal_downsample(stbir__info* stbir_info, int n, float* output_buffer)\n{\n    int x, k;\n    int input_w = stbir_info->input_w;\n    int output_w = stbir_info->output_w;\n    int kernel_pixel_width = stbir_info->horizontal_filter_pixel_width;\n    int channels = stbir_info->channels;\n    float* decode_buffer = stbir__get_decode_buffer(stbir_info);\n    stbir__contributors* horizontal_contributors = stbir_info->horizontal_contributors;\n    float* horizontal_coefficients = stbir_info->horizontal_coefficients;\n    int coefficient_width = stbir_info->horizontal_coefficient_width;\n    int filter_pixel_margin = stbir_info->horizontal_filter_pixel_margin;\n    int max_x = input_w + filter_pixel_margin * 2;\n\n    STBIR__DEBUG_ASSERT(!stbir__use_width_upsampling(stbir_info));\n\n    switch (channels) {\n        case 1:\n            for (x = 0; x < max_x; x++)\n            {\n                int n0 = horizontal_contributors[x].n0;\n                int n1 = horizontal_contributors[x].n1;\n\n                int in_x = x - filter_pixel_margin;\n                int in_pixel_index = in_x * 1;\n                int max_n = n1;\n                int coefficient_group = coefficient_width * x;\n\n                for (k = n0; k <= max_n; k++)\n                {\n                    int out_pixel_index = k * 1;\n                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                }\n            }\n            break;\n\n        case 2:\n            for (x = 0; x < max_x; x++)\n            {\n                int n0 = horizontal_contributors[x].n0;\n                int n1 = horizontal_contributors[x].n1;\n\n                int in_x = x - filter_pixel_margin;\n                int in_pixel_index = in_x * 2;\n                int max_n = n1;\n                int coefficient_group = coefficient_width * x;\n\n                for (k = n0; k <= max_n; k++)\n                {\n                    int out_pixel_index = k * 2;\n                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;\n                }\n            }\n            break;\n\n        case 3:\n            for (x = 0; x < max_x; x++)\n            {\n                int n0 = horizontal_contributors[x].n0;\n                int n1 = horizontal_contributors[x].n1;\n\n                int in_x = x - filter_pixel_margin;\n                int in_pixel_index = in_x * 3;\n                int max_n = n1;\n                int coefficient_group = coefficient_width * x;\n\n                for (k = n0; k <= max_n; k++)\n                {\n                    int out_pixel_index = k * 3;\n                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;\n                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;\n                }\n            }\n            break;\n\n        case 4:\n            for (x = 0; x < max_x; x++)\n            {\n                int n0 = horizontal_contributors[x].n0;\n                int n1 = horizontal_contributors[x].n1;\n\n                int in_x = x - filter_pixel_margin;\n                int in_pixel_index = in_x * 4;\n                int max_n = n1;\n                int coefficient_group = coefficient_width * x;\n\n                for (k = n0; k <= max_n; k++)\n                {\n                    int out_pixel_index = k * 4;\n                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    output_buffer[out_pixel_index + 0] += decode_buffer[in_pixel_index + 0] * coefficient;\n                    output_buffer[out_pixel_index + 1] += decode_buffer[in_pixel_index + 1] * coefficient;\n                    output_buffer[out_pixel_index + 2] += decode_buffer[in_pixel_index + 2] * coefficient;\n                    output_buffer[out_pixel_index + 3] += decode_buffer[in_pixel_index + 3] * coefficient;\n                }\n            }\n            break;\n\n        default:\n            for (x = 0; x < max_x; x++)\n            {\n                int n0 = horizontal_contributors[x].n0;\n                int n1 = horizontal_contributors[x].n1;\n\n                int in_x = x - filter_pixel_margin;\n                int in_pixel_index = in_x * channels;\n                int max_n = n1;\n                int coefficient_group = coefficient_width * x;\n\n                for (k = n0; k <= max_n; k++)\n                {\n                    int c;\n                    int out_pixel_index = k * channels;\n                    float coefficient = horizontal_coefficients[coefficient_group + k - n0];\n                    STBIR__DEBUG_ASSERT(coefficient != 0);\n                    for (c = 0; c < channels; c++)\n                        output_buffer[out_pixel_index + c] += decode_buffer[in_pixel_index + c] * coefficient;\n                }\n            }\n            break;\n    }\n}\n\nstatic void stbir__decode_and_resample_upsample(stbir__info* stbir_info, int n)\n{\n    // Decode the nth scanline from the source image into the decode buffer.\n    stbir__decode_scanline(stbir_info, n);\n\n    // Now resample it into the ring buffer.\n    if (stbir__use_width_upsampling(stbir_info))\n        stbir__resample_horizontal_upsample(stbir_info, n, stbir__add_empty_ring_buffer_entry(stbir_info, n));\n    else\n        stbir__resample_horizontal_downsample(stbir_info, n, stbir__add_empty_ring_buffer_entry(stbir_info, n));\n\n    // Now it's sitting in the ring buffer ready to be used as source for the vertical sampling.\n}\n\nstatic void stbir__decode_and_resample_downsample(stbir__info* stbir_info, int n)\n{\n    // Decode the nth scanline from the source image into the decode buffer.\n    stbir__decode_scanline(stbir_info, n);\n\n    memset(stbir_info->horizontal_buffer, 0, stbir_info->output_w * stbir_info->channels * sizeof(float));\n\n    // Now resample it into the horizontal buffer.\n    if (stbir__use_width_upsampling(stbir_info))\n        stbir__resample_horizontal_upsample(stbir_info, n, stbir_info->horizontal_buffer);\n    else\n        stbir__resample_horizontal_downsample(stbir_info, n, stbir_info->horizontal_buffer);\n\n    // Now it's sitting in the horizontal buffer ready to be distributed into the ring buffers.\n}\n\n// Get the specified scan line from the ring buffer.\nstatic float* stbir__get_ring_buffer_scanline(int get_scanline, float* ring_buffer, int begin_index, int first_scanline, int ring_buffer_size, int ring_buffer_length)\n{\n    int ring_buffer_index = (begin_index + (get_scanline - first_scanline)) % ring_buffer_size;\n    return stbir__get_ring_buffer_entry(ring_buffer, ring_buffer_index, ring_buffer_length);\n}\n\n\nstatic void stbir__encode_scanline(stbir__info* stbir_info, int num_pixels, void *output_buffer, float *encode_buffer, int channels, int alpha_channel, int decode)\n{\n    int x;\n    int n;\n    int num_nonalpha;\n    stbir_uint16 nonalpha[STBIR_MAX_CHANNELS];\n\n    if (!(stbir_info->flags&STBIR_FLAG_ALPHA_PREMULTIPLIED))\n    {\n        for (x=0; x < num_pixels; ++x)\n        {\n            int pixel_index = x*channels;\n\n            float alpha = encode_buffer[pixel_index + alpha_channel];\n            float reciprocal_alpha = alpha ? 1.0f / alpha : 0;\n\n            // unrolling this produced a 1% slowdown upscaling a large RGBA linear-space image on my machine - stb\n            for (n = 0; n < channels; n++)\n                if (n != alpha_channel)\n                    encode_buffer[pixel_index + n] *= reciprocal_alpha;\n\n            // We added in a small epsilon to prevent the color channel from being deleted with zero alpha.\n            // Because we only add it for integer types, it will automatically be discarded on integer\n            // conversion, so we don't need to subtract it back out (which would be problematic for\n            // numeric precision reasons).\n        }\n    }\n\n    // build a table of all channels that need colorspace correction, so\n    // we don't perform colorspace correction on channels that don't need it.\n    for (x=0, num_nonalpha=0; x < channels; ++x)\n        if (x != alpha_channel || (stbir_info->flags & STBIR_FLAG_ALPHA_USES_COLORSPACE))\n            nonalpha[num_nonalpha++] = x;\n\n    #define STBIR__ROUND_INT(f)    ((int)          ((f)+0.5))\n    #define STBIR__ROUND_UINT(f)   ((stbir_uint32) ((f)+0.5))\n\n    #ifdef STBIR__SATURATE_INT\n    #define STBIR__ENCODE_LINEAR8(f)   stbir__saturate8 (STBIR__ROUND_INT((f) * 255  ))\n    #define STBIR__ENCODE_LINEAR16(f)  stbir__saturate16(STBIR__ROUND_INT((f) * 65535))\n    #else\n    #define STBIR__ENCODE_LINEAR8(f)   (unsigned char ) STBIR__ROUND_INT(stbir__saturate(f) * 255  )\n    #define STBIR__ENCODE_LINEAR16(f)  (unsigned short) STBIR__ROUND_INT(stbir__saturate(f) * 65535)\n    #endif\n\n    switch (decode)\n    {\n        case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_LINEAR):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < channels; n++)\n                {\n                    int index = pixel_index + n;\n                    ((unsigned char*)output_buffer)[index] = STBIR__ENCODE_LINEAR8(encode_buffer[index]);\n                }\n            }\n            break;\n\n        case STBIR__DECODE(STBIR_TYPE_UINT8, STBIR_COLORSPACE_SRGB):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < num_nonalpha; n++)\n                {\n                    int index = pixel_index + nonalpha[n];\n                    ((unsigned char*)output_buffer)[index] = stbir__linear_to_srgb_uchar(encode_buffer[index]);\n                }\n\n                if (!(stbir_info->flags & STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                    ((unsigned char *)output_buffer)[pixel_index + alpha_channel] = STBIR__ENCODE_LINEAR8(encode_buffer[pixel_index+alpha_channel]);\n            }\n            break;\n\n        case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_LINEAR):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < channels; n++)\n                {\n                    int index = pixel_index + n;\n                    ((unsigned short*)output_buffer)[index] = STBIR__ENCODE_LINEAR16(encode_buffer[index]);\n                }\n            }\n            break;\n\n        case STBIR__DECODE(STBIR_TYPE_UINT16, STBIR_COLORSPACE_SRGB):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < num_nonalpha; n++)\n                {\n                    int index = pixel_index + nonalpha[n];\n                    ((unsigned short*)output_buffer)[index] = (unsigned short)STBIR__ROUND_INT(stbir__linear_to_srgb(stbir__saturate(encode_buffer[index])) * 65535);\n                }\n\n                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                    ((unsigned short*)output_buffer)[pixel_index + alpha_channel] = STBIR__ENCODE_LINEAR16(encode_buffer[pixel_index + alpha_channel]);\n            }\n\n            break;\n\n        case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_LINEAR):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < channels; n++)\n                {\n                    int index = pixel_index + n;\n                    ((unsigned int*)output_buffer)[index] = (unsigned int)STBIR__ROUND_UINT(((double)stbir__saturate(encode_buffer[index])) * 4294967295);\n                }\n            }\n            break;\n\n        case STBIR__DECODE(STBIR_TYPE_UINT32, STBIR_COLORSPACE_SRGB):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < num_nonalpha; n++)\n                {\n                    int index = pixel_index + nonalpha[n];\n                    ((unsigned int*)output_buffer)[index] = (unsigned int)STBIR__ROUND_UINT(((double)stbir__linear_to_srgb(stbir__saturate(encode_buffer[index]))) * 4294967295);\n                }\n\n                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                    ((unsigned int*)output_buffer)[pixel_index + alpha_channel] = (unsigned int)STBIR__ROUND_INT(((double)stbir__saturate(encode_buffer[pixel_index + alpha_channel])) * 4294967295);\n            }\n            break;\n\n        case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_LINEAR):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < channels; n++)\n                {\n                    int index = pixel_index + n;\n                    ((float*)output_buffer)[index] = encode_buffer[index];\n                }\n            }\n            break;\n\n        case STBIR__DECODE(STBIR_TYPE_FLOAT, STBIR_COLORSPACE_SRGB):\n            for (x=0; x < num_pixels; ++x)\n            {\n                int pixel_index = x*channels;\n\n                for (n = 0; n < num_nonalpha; n++)\n                {\n                    int index = pixel_index + nonalpha[n];\n                    ((float*)output_buffer)[index] = stbir__linear_to_srgb(encode_buffer[index]);\n                }\n\n                if (!(stbir_info->flags&STBIR_FLAG_ALPHA_USES_COLORSPACE))\n                    ((float*)output_buffer)[pixel_index + alpha_channel] = encode_buffer[pixel_index + alpha_channel];\n            }\n            break;\n\n        default:\n            STBIR__UNIMPLEMENTED(\"Unknown type/colorspace/channels combination.\");\n            break;\n    }\n}\n\nstatic void stbir__resample_vertical_upsample(stbir__info* stbir_info, int n, int in_first_scanline, int in_last_scanline, float in_center_of_out)\n{\n    int x, k;\n    int output_w = stbir_info->output_w;\n    stbir__contributors* vertical_contributors = stbir_info->vertical_contributors;\n    float* vertical_coefficients = stbir_info->vertical_coefficients;\n    int channels = stbir_info->channels;\n    int alpha_channel = stbir_info->alpha_channel;\n    int type = stbir_info->type;\n    int colorspace = stbir_info->colorspace;\n    int kernel_pixel_width = stbir_info->vertical_filter_pixel_width;\n    void* output_data = stbir_info->output_data;\n    float* encode_buffer = stbir_info->encode_buffer;\n    int decode = STBIR__DECODE(type, colorspace);\n    int coefficient_width = stbir_info->vertical_coefficient_width;\n    int coefficient_counter;\n    int contributor = n;\n\n    float* ring_buffer = stbir_info->ring_buffer;\n    int ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;\n    int ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;\n    int ring_buffer_last_scanline = stbir_info->ring_buffer_last_scanline;\n    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);\n\n    int n0,n1, output_row_start;\n    int coefficient_group = coefficient_width * contributor;\n\n    n0 = vertical_contributors[contributor].n0;\n    n1 = vertical_contributors[contributor].n1;\n\n    output_row_start = n * stbir_info->output_stride_bytes;\n\n    STBIR__DEBUG_ASSERT(stbir__use_height_upsampling(stbir_info));\n\n    memset(encode_buffer, 0, output_w * sizeof(float) * channels);\n\n    // I tried reblocking this for better cache usage of encode_buffer\n    // (using x_outer, k, x_inner), but it lost speed. -- stb\n\n    coefficient_counter = 0;\n    switch (channels) {\n        case 1:\n            for (k = n0; k <= n1; k++)\n            {\n                int coefficient_index = coefficient_counter++;\n                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, kernel_pixel_width, ring_buffer_length);\n                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];\n                for (x = 0; x < output_w; ++x)\n                {\n                    int in_pixel_index = x * 1;\n                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;\n                }\n            }\n            break;\n        case 2:\n            for (k = n0; k <= n1; k++)\n            {\n                int coefficient_index = coefficient_counter++;\n                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, kernel_pixel_width, ring_buffer_length);\n                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];\n                for (x = 0; x < output_w; ++x)\n                {\n                    int in_pixel_index = x * 2;\n                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;\n                    encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;\n                }\n            }\n            break;\n        case 3:\n            for (k = n0; k <= n1; k++)\n            {\n                int coefficient_index = coefficient_counter++;\n                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, kernel_pixel_width, ring_buffer_length);\n                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];\n                for (x = 0; x < output_w; ++x)\n                {\n                    int in_pixel_index = x * 3;\n                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;\n                    encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;\n                    encode_buffer[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;\n                }\n            }\n            break;\n        case 4:\n            for (k = n0; k <= n1; k++)\n            {\n                int coefficient_index = coefficient_counter++;\n                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, kernel_pixel_width, ring_buffer_length);\n                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];\n                for (x = 0; x < output_w; ++x)\n                {\n                    int in_pixel_index = x * 4;\n                    encode_buffer[in_pixel_index + 0] += ring_buffer_entry[in_pixel_index + 0] * coefficient;\n                    encode_buffer[in_pixel_index + 1] += ring_buffer_entry[in_pixel_index + 1] * coefficient;\n                    encode_buffer[in_pixel_index + 2] += ring_buffer_entry[in_pixel_index + 2] * coefficient;\n                    encode_buffer[in_pixel_index + 3] += ring_buffer_entry[in_pixel_index + 3] * coefficient;\n                }\n            }\n            break;\n        default:\n            for (k = n0; k <= n1; k++)\n            {\n                int coefficient_index = coefficient_counter++;\n                float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, kernel_pixel_width, ring_buffer_length);\n                float coefficient = vertical_coefficients[coefficient_group + coefficient_index];\n                for (x = 0; x < output_w; ++x)\n                {\n                    int in_pixel_index = x * channels;\n                    int c;\n                    for (c = 0; c < channels; c++)\n                        encode_buffer[in_pixel_index + c] += ring_buffer_entry[in_pixel_index + c] * coefficient;\n                }\n            }\n            break;\n    }\n    stbir__encode_scanline(stbir_info, output_w, (char *) output_data + output_row_start, encode_buffer, channels, alpha_channel, decode);\n}\n\nstatic void stbir__resample_vertical_downsample(stbir__info* stbir_info, int n, int in_first_scanline, int in_last_scanline, float in_center_of_out)\n{\n    int x, k;\n    int output_w = stbir_info->output_w;\n    int output_h = stbir_info->output_h;\n    stbir__contributors* vertical_contributors = stbir_info->vertical_contributors;\n    float* vertical_coefficients = stbir_info->vertical_coefficients;\n    int channels = stbir_info->channels;\n    int kernel_pixel_width = stbir_info->vertical_filter_pixel_width;\n    void* output_data = stbir_info->output_data;\n    float* horizontal_buffer = stbir_info->horizontal_buffer;\n    int coefficient_width = stbir_info->vertical_coefficient_width;\n    int contributor = n + stbir_info->vertical_filter_pixel_margin;\n\n    float* ring_buffer = stbir_info->ring_buffer;\n    int ring_buffer_begin_index = stbir_info->ring_buffer_begin_index;\n    int ring_buffer_first_scanline = stbir_info->ring_buffer_first_scanline;\n    int ring_buffer_last_scanline = stbir_info->ring_buffer_last_scanline;\n    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);\n    int n0,n1;\n\n    n0 = vertical_contributors[contributor].n0;\n    n1 = vertical_contributors[contributor].n1;\n\n    STBIR__DEBUG_ASSERT(!stbir__use_height_upsampling(stbir_info));\n\n    for (k = n0; k <= n1; k++)\n    {\n        int coefficient_index = k - n0;\n        int coefficient_group = coefficient_width * contributor;\n        float coefficient = vertical_coefficients[coefficient_group + coefficient_index];\n\n        float* ring_buffer_entry = stbir__get_ring_buffer_scanline(k, ring_buffer, ring_buffer_begin_index, ring_buffer_first_scanline, kernel_pixel_width, ring_buffer_length);\n\n        switch (channels) {\n            case 1:\n                for (x = 0; x < output_w; x++)\n                {\n                    int in_pixel_index = x * 1;\n                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;\n                }\n                break;\n            case 2:\n                for (x = 0; x < output_w; x++)\n                {\n                    int in_pixel_index = x * 2;\n                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;\n                    ring_buffer_entry[in_pixel_index + 1] += horizontal_buffer[in_pixel_index + 1] * coefficient;\n                }\n                break;\n            case 3:\n                for (x = 0; x < output_w; x++)\n                {\n                    int in_pixel_index = x * 3;\n                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;\n                    ring_buffer_entry[in_pixel_index + 1] += horizontal_buffer[in_pixel_index + 1] * coefficient;\n                    ring_buffer_entry[in_pixel_index + 2] += horizontal_buffer[in_pixel_index + 2] * coefficient;\n                }\n                break;\n            case 4:\n                for (x = 0; x < output_w; x++)\n                {\n                    int in_pixel_index = x * 4;\n                    ring_buffer_entry[in_pixel_index + 0] += horizontal_buffer[in_pixel_index + 0] * coefficient;\n                    ring_buffer_entry[in_pixel_index + 1] += horizontal_buffer[in_pixel_index + 1] * coefficient;\n                    ring_buffer_entry[in_pixel_index + 2] += horizontal_buffer[in_pixel_index + 2] * coefficient;\n                    ring_buffer_entry[in_pixel_index + 3] += horizontal_buffer[in_pixel_index + 3] * coefficient;\n                }\n                break;\n            default:\n                for (x = 0; x < output_w; x++)\n                {\n                    int in_pixel_index = x * channels;\n\n                    int c;\n                    for (c = 0; c < channels; c++)\n                        ring_buffer_entry[in_pixel_index + c] += horizontal_buffer[in_pixel_index + c] * coefficient;\n                }\n                break;\n        }\n    }\n}\n\nstatic void stbir__buffer_loop_upsample(stbir__info* stbir_info)\n{\n    int y;\n    float scale_ratio = stbir_info->vertical_scale;\n    float out_scanlines_radius = stbir__filter_info_table[stbir_info->vertical_filter].support(1/scale_ratio) * scale_ratio;\n\n    STBIR__DEBUG_ASSERT(stbir__use_height_upsampling(stbir_info));\n\n    for (y = 0; y < stbir_info->output_h; y++)\n    {\n        float in_center_of_out = 0; // Center of the current out scanline in the in scanline space\n        int in_first_scanline = 0, in_last_scanline = 0;\n\n        stbir__calculate_sample_range_upsample(y, out_scanlines_radius, scale_ratio, stbir_info->vertical_shift, &in_first_scanline, &in_last_scanline, &in_center_of_out);\n\n        STBIR__DEBUG_ASSERT(in_last_scanline - in_first_scanline <= stbir_info->vertical_filter_pixel_width);\n\n        if (stbir_info->ring_buffer_begin_index >= 0)\n        {\n            // Get rid of whatever we don't need anymore.\n            while (in_first_scanline > stbir_info->ring_buffer_first_scanline)\n            {\n                if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)\n                {\n                    // We just popped the last scanline off the ring buffer.\n                    // Reset it to the empty state.\n                    stbir_info->ring_buffer_begin_index = -1;\n                    stbir_info->ring_buffer_first_scanline = 0;\n                    stbir_info->ring_buffer_last_scanline = 0;\n                    break;\n                }\n                else\n                {\n                    stbir_info->ring_buffer_first_scanline++;\n                    stbir_info->ring_buffer_begin_index = (stbir_info->ring_buffer_begin_index + 1) % stbir_info->vertical_filter_pixel_width;\n                }\n            }\n        }\n\n        // Load in new ones.\n        if (stbir_info->ring_buffer_begin_index < 0)\n            stbir__decode_and_resample_upsample(stbir_info, in_first_scanline);\n\n        while (in_last_scanline > stbir_info->ring_buffer_last_scanline)\n            stbir__decode_and_resample_upsample(stbir_info, stbir_info->ring_buffer_last_scanline + 1);\n\n        // Now all buffers should be ready to write a row of vertical sampling.\n        stbir__resample_vertical_upsample(stbir_info, y, in_first_scanline, in_last_scanline, in_center_of_out);\n\n        STBIR_PROGRESS_REPORT((float)y / stbir_info->output_h);\n    }\n}\n\nstatic void stbir__empty_ring_buffer(stbir__info* stbir_info, int first_necessary_scanline)\n{\n    int output_stride_bytes = stbir_info->output_stride_bytes;\n    int channels = stbir_info->channels;\n    int alpha_channel = stbir_info->alpha_channel;\n    int type = stbir_info->type;\n    int colorspace = stbir_info->colorspace;\n    int output_w = stbir_info->output_w;\n    void* output_data = stbir_info->output_data;\n    int decode = STBIR__DECODE(type, colorspace);\n\n    float* ring_buffer = stbir_info->ring_buffer;\n    int ring_buffer_length = stbir_info->ring_buffer_length_bytes/sizeof(float);\n\n    if (stbir_info->ring_buffer_begin_index >= 0)\n    {\n        // Get rid of whatever we don't need anymore.\n        while (first_necessary_scanline > stbir_info->ring_buffer_first_scanline)\n        {\n            if (stbir_info->ring_buffer_first_scanline >= 0 && stbir_info->ring_buffer_first_scanline < stbir_info->output_h)\n            {\n                int output_row_start = stbir_info->ring_buffer_first_scanline * output_stride_bytes;\n                float* ring_buffer_entry = stbir__get_ring_buffer_entry(ring_buffer, stbir_info->ring_buffer_begin_index, ring_buffer_length);\n                stbir__encode_scanline(stbir_info, output_w, (char *) output_data + output_row_start, ring_buffer_entry, channels, alpha_channel, decode);\n                STBIR_PROGRESS_REPORT((float)stbir_info->ring_buffer_first_scanline / stbir_info->output_h);\n            }\n\n            if (stbir_info->ring_buffer_first_scanline == stbir_info->ring_buffer_last_scanline)\n            {\n                // We just popped the last scanline off the ring buffer.\n                // Reset it to the empty state.\n                stbir_info->ring_buffer_begin_index = -1;\n                stbir_info->ring_buffer_first_scanline = 0;\n                stbir_info->ring_buffer_last_scanline = 0;\n                break;\n            }\n            else\n            {\n                stbir_info->ring_buffer_first_scanline++;\n                stbir_info->ring_buffer_begin_index = (stbir_info->ring_buffer_begin_index + 1) % stbir_info->vertical_filter_pixel_width;\n            }\n        }\n    }\n}\n\nstatic void stbir__buffer_loop_downsample(stbir__info* stbir_info)\n{\n    int y;\n    float scale_ratio = stbir_info->vertical_scale;\n    int output_h = stbir_info->output_h;\n    float in_pixels_radius = stbir__filter_info_table[stbir_info->vertical_filter].support(scale_ratio) / scale_ratio;\n    int pixel_margin = stbir_info->vertical_filter_pixel_margin;\n    int max_y = stbir_info->input_h + pixel_margin;\n\n    STBIR__DEBUG_ASSERT(!stbir__use_height_upsampling(stbir_info));\n\n    for (y = -pixel_margin; y < max_y; y++)\n    {\n        float out_center_of_in; // Center of the current out scanline in the in scanline space\n        int out_first_scanline, out_last_scanline;\n\n        stbir__calculate_sample_range_downsample(y, in_pixels_radius, scale_ratio, stbir_info->vertical_shift, &out_first_scanline, &out_last_scanline, &out_center_of_in);\n\n        STBIR__DEBUG_ASSERT(out_last_scanline - out_first_scanline <= stbir_info->vertical_filter_pixel_width);\n\n        if (out_last_scanline < 0 || out_first_scanline >= output_h)\n            continue;\n\n        stbir__empty_ring_buffer(stbir_info, out_first_scanline);\n\n        stbir__decode_and_resample_downsample(stbir_info, y);\n\n        // Load in new ones.\n        if (stbir_info->ring_buffer_begin_index < 0)\n            stbir__add_empty_ring_buffer_entry(stbir_info, out_first_scanline);\n\n        while (out_last_scanline > stbir_info->ring_buffer_last_scanline)\n            stbir__add_empty_ring_buffer_entry(stbir_info, stbir_info->ring_buffer_last_scanline + 1);\n\n        // Now the horizontal buffer is ready to write to all ring buffer rows.\n        stbir__resample_vertical_downsample(stbir_info, y, out_first_scanline, out_last_scanline, out_center_of_in);\n    }\n\n    stbir__empty_ring_buffer(stbir_info, stbir_info->output_h);\n}\n\nstatic void stbir__setup(stbir__info *info, int input_w, int input_h, int output_w, int output_h, int channels)\n{\n    info->input_w = input_w;\n    info->input_h = input_h;\n    info->output_w = output_w;\n    info->output_h = output_h;\n    info->channels = channels;\n}\n\nstatic void stbir__calculate_transform(stbir__info *info, float s0, float t0, float s1, float t1, float *transform)\n{\n    info->s0 = s0;\n    info->t0 = t0;\n    info->s1 = s1;\n    info->t1 = t1;\n\n    if (transform)\n    {\n        info->horizontal_scale = transform[0];\n        info->vertical_scale   = transform[1];\n        info->horizontal_shift = transform[2];\n        info->vertical_shift   = transform[3];\n    }\n    else\n    {\n        info->horizontal_scale = ((float)info->output_w / info->input_w) / (s1 - s0);\n        info->vertical_scale = ((float)info->output_h / info->input_h) / (t1 - t0);\n\n        info->horizontal_shift = s0 * info->input_w / (s1 - s0);\n        info->vertical_shift = t0 * info->input_h / (t1 - t0);\n    }\n}\n\nstatic void stbir__choose_filter(stbir__info *info, stbir_filter h_filter, stbir_filter v_filter)\n{\n    if (h_filter == 0)\n        h_filter = stbir__use_upsampling(info->horizontal_scale) ? STBIR_DEFAULT_FILTER_UPSAMPLE : STBIR_DEFAULT_FILTER_DOWNSAMPLE;\n    if (v_filter == 0)\n        v_filter = stbir__use_upsampling(info->vertical_scale)   ? STBIR_DEFAULT_FILTER_UPSAMPLE : STBIR_DEFAULT_FILTER_DOWNSAMPLE;\n    info->horizontal_filter = h_filter;\n    info->vertical_filter = v_filter;\n}\n\nstatic stbir_uint32 stbir__calculate_memory(stbir__info *info)\n{\n    int pixel_margin = stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);\n    int filter_height = stbir__get_filter_pixel_width(info->vertical_filter, info->vertical_scale);\n\n    info->horizontal_num_contributors = stbir__get_contributors(info->horizontal_scale, info->horizontal_filter, info->input_w, info->output_w);\n    info->vertical_num_contributors   = stbir__get_contributors(info->vertical_scale  , info->vertical_filter  , info->input_h, info->output_h);\n\n    info->horizontal_contributors_size = info->horizontal_num_contributors * sizeof(stbir__contributors);\n    info->horizontal_coefficients_size = stbir__get_total_horizontal_coefficients(info) * sizeof(float);\n    info->vertical_contributors_size = info->vertical_num_contributors * sizeof(stbir__contributors);\n    info->vertical_coefficients_size = stbir__get_total_vertical_coefficients(info) * sizeof(float);\n    info->decode_buffer_size = (info->input_w + pixel_margin * 2) * info->channels * sizeof(float);\n    info->horizontal_buffer_size = info->output_w * info->channels * sizeof(float);\n    info->ring_buffer_size = info->output_w * info->channels * filter_height * sizeof(float);\n    info->encode_buffer_size = info->output_w * info->channels * sizeof(float);\n\n    STBIR_ASSERT(info->horizontal_filter != 0);\n    STBIR_ASSERT(info->horizontal_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table)); // this now happens too late\n    STBIR_ASSERT(info->vertical_filter != 0);\n    STBIR_ASSERT(info->vertical_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table)); // this now happens too late\n\n    if (stbir__use_height_upsampling(info))\n        // The horizontal buffer is for when we're downsampling the height and we\n        // can't output the result of sampling the decode buffer directly into the\n        // ring buffers.\n        info->horizontal_buffer_size = 0;\n    else\n        // The encode buffer is to retain precision in the height upsampling method\n        // and isn't used when height downsampling.\n        info->encode_buffer_size = 0;\n\n    return info->horizontal_contributors_size + info->horizontal_coefficients_size\n        + info->vertical_contributors_size + info->vertical_coefficients_size\n        + info->decode_buffer_size + info->horizontal_buffer_size\n        + info->ring_buffer_size + info->encode_buffer_size;\n}\n\nstatic int stbir__resize_allocated(stbir__info *info,\n    const void* input_data, int input_stride_in_bytes,\n    void* output_data, int output_stride_in_bytes,\n    int alpha_channel, stbir_uint32 flags, stbir_datatype type,\n    stbir_edge edge_horizontal, stbir_edge edge_vertical, stbir_colorspace colorspace,\n    void* tempmem, size_t tempmem_size_in_bytes)\n{\n    size_t memory_required = stbir__calculate_memory(info);\n\n    int width_stride_input = input_stride_in_bytes ? input_stride_in_bytes : info->channels * info->input_w * stbir__type_size[type];\n    int width_stride_output = output_stride_in_bytes ? output_stride_in_bytes : info->channels * info->output_w * stbir__type_size[type];\n\n#ifdef STBIR_DEBUG_OVERWRITE_TEST\n#define OVERWRITE_ARRAY_SIZE 8\n    unsigned char overwrite_output_before_pre[OVERWRITE_ARRAY_SIZE];\n    unsigned char overwrite_tempmem_before_pre[OVERWRITE_ARRAY_SIZE];\n    unsigned char overwrite_output_after_pre[OVERWRITE_ARRAY_SIZE];\n    unsigned char overwrite_tempmem_after_pre[OVERWRITE_ARRAY_SIZE];\n\n    size_t begin_forbidden = width_stride_output * (info->output_h - 1) + info->output_w * info->channels * stbir__type_size[type];\n    memcpy(overwrite_output_before_pre, &((unsigned char*)output_data)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE);\n    memcpy(overwrite_output_after_pre, &((unsigned char*)output_data)[begin_forbidden], OVERWRITE_ARRAY_SIZE);\n    memcpy(overwrite_tempmem_before_pre, &((unsigned char*)tempmem)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE);\n    memcpy(overwrite_tempmem_after_pre, &((unsigned char*)tempmem)[tempmem_size_in_bytes], OVERWRITE_ARRAY_SIZE);\n#endif\n\n    STBIR_ASSERT(info->channels >= 0);\n    STBIR_ASSERT(info->channels <= STBIR_MAX_CHANNELS);\n\n    if (info->channels < 0 || info->channels > STBIR_MAX_CHANNELS)\n        return 0;\n\n    STBIR_ASSERT(info->horizontal_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));\n    STBIR_ASSERT(info->vertical_filter < STBIR__ARRAY_SIZE(stbir__filter_info_table));\n\n    if (info->horizontal_filter >= STBIR__ARRAY_SIZE(stbir__filter_info_table))\n        return 0;\n    if (info->vertical_filter >= STBIR__ARRAY_SIZE(stbir__filter_info_table))\n        return 0;\n\n    if (alpha_channel < 0)\n        flags |= STBIR_FLAG_ALPHA_USES_COLORSPACE | STBIR_FLAG_ALPHA_PREMULTIPLIED;\n\n    if (!(flags&STBIR_FLAG_ALPHA_USES_COLORSPACE) || !(flags&STBIR_FLAG_ALPHA_PREMULTIPLIED))\n        STBIR_ASSERT(alpha_channel >= 0 && alpha_channel < info->channels);\n\n    if (alpha_channel >= info->channels)\n        return 0;\n\n    STBIR_ASSERT(tempmem);\n\n    if (!tempmem)\n        return 0;\n\n    STBIR_ASSERT(tempmem_size_in_bytes >= memory_required);\n\n    if (tempmem_size_in_bytes < memory_required)\n        return 0;\n\n    memset(tempmem, 0, tempmem_size_in_bytes);\n\n    info->input_data = input_data;\n    info->input_stride_bytes = width_stride_input;\n\n    info->output_data = output_data;\n    info->output_stride_bytes = width_stride_output;\n\n    info->alpha_channel = alpha_channel;\n    info->flags = flags;\n    info->type = type;\n    info->edge_horizontal = edge_horizontal;\n    info->edge_vertical = edge_vertical;\n    info->colorspace = colorspace;\n\n    info->horizontal_coefficient_width   = stbir__get_coefficient_width  (info->horizontal_filter, info->horizontal_scale);\n    info->vertical_coefficient_width     = stbir__get_coefficient_width  (info->vertical_filter  , info->vertical_scale  );\n    info->horizontal_filter_pixel_width  = stbir__get_filter_pixel_width (info->horizontal_filter, info->horizontal_scale);\n    info->vertical_filter_pixel_width    = stbir__get_filter_pixel_width (info->vertical_filter  , info->vertical_scale  );\n    info->horizontal_filter_pixel_margin = stbir__get_filter_pixel_margin(info->horizontal_filter, info->horizontal_scale);\n    info->vertical_filter_pixel_margin   = stbir__get_filter_pixel_margin(info->vertical_filter  , info->vertical_scale  );\n\n    info->ring_buffer_length_bytes = info->output_w * info->channels * sizeof(float);\n    info->decode_buffer_pixels = info->input_w + info->horizontal_filter_pixel_margin * 2;\n\n#define STBIR__NEXT_MEMPTR(current, newtype) (newtype*)(((unsigned char*)current) + current##_size)\n\n    info->horizontal_contributors = (stbir__contributors *) tempmem;\n    info->horizontal_coefficients = STBIR__NEXT_MEMPTR(info->horizontal_contributors, float);\n    info->vertical_contributors = STBIR__NEXT_MEMPTR(info->horizontal_coefficients, stbir__contributors);\n    info->vertical_coefficients = STBIR__NEXT_MEMPTR(info->vertical_contributors, float);\n    info->decode_buffer = STBIR__NEXT_MEMPTR(info->vertical_coefficients, float);\n\n    if (stbir__use_height_upsampling(info))\n    {\n        info->horizontal_buffer = NULL;\n        info->ring_buffer = STBIR__NEXT_MEMPTR(info->decode_buffer, float);\n        info->encode_buffer = STBIR__NEXT_MEMPTR(info->ring_buffer, float);\n\n        STBIR__DEBUG_ASSERT((size_t)STBIR__NEXT_MEMPTR(info->encode_buffer, unsigned char) == (size_t)tempmem + tempmem_size_in_bytes);\n    }\n    else\n    {\n        info->horizontal_buffer = STBIR__NEXT_MEMPTR(info->decode_buffer, float);\n        info->ring_buffer = STBIR__NEXT_MEMPTR(info->horizontal_buffer, float);\n        info->encode_buffer = NULL;\n\n        STBIR__DEBUG_ASSERT((size_t)STBIR__NEXT_MEMPTR(info->ring_buffer, unsigned char) == (size_t)tempmem + tempmem_size_in_bytes);\n    }\n\n#undef STBIR__NEXT_MEMPTR\n\n    // This signals that the ring buffer is empty\n    info->ring_buffer_begin_index = -1;\n\n    stbir__calculate_filters(info, info->horizontal_contributors, info->horizontal_coefficients, info->horizontal_filter, info->horizontal_scale, info->horizontal_shift, info->input_w, info->output_w);\n    stbir__calculate_filters(info, info->vertical_contributors, info->vertical_coefficients, info->vertical_filter, info->vertical_scale, info->vertical_shift, info->input_h, info->output_h);\n\n    STBIR_PROGRESS_REPORT(0);\n\n    if (stbir__use_height_upsampling(info))\n        stbir__buffer_loop_upsample(info);\n    else\n        stbir__buffer_loop_downsample(info);\n\n    STBIR_PROGRESS_REPORT(1);\n\n#ifdef STBIR_DEBUG_OVERWRITE_TEST\n    STBIR__DEBUG_ASSERT(memcmp(overwrite_output_before_pre, &((unsigned char*)output_data)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE) == 0);\n    STBIR__DEBUG_ASSERT(memcmp(overwrite_output_after_pre, &((unsigned char*)output_data)[begin_forbidden], OVERWRITE_ARRAY_SIZE) == 0);\n    STBIR__DEBUG_ASSERT(memcmp(overwrite_tempmem_before_pre, &((unsigned char*)tempmem)[-OVERWRITE_ARRAY_SIZE], OVERWRITE_ARRAY_SIZE) == 0);\n    STBIR__DEBUG_ASSERT(memcmp(overwrite_tempmem_after_pre, &((unsigned char*)tempmem)[tempmem_size_in_bytes], OVERWRITE_ARRAY_SIZE) == 0);\n#endif\n\n    return 1;\n}\n\n\nstatic int stbir__resize_arbitrary(\n    void *alloc_context,\n    const void* input_data, int input_w, int input_h, int input_stride_in_bytes,\n    void* output_data, int output_w, int output_h, int output_stride_in_bytes,\n    float s0, float t0, float s1, float t1, float *transform,\n    int channels, int alpha_channel, stbir_uint32 flags, stbir_datatype type,\n    stbir_filter h_filter, stbir_filter v_filter,\n    stbir_edge edge_horizontal, stbir_edge edge_vertical, stbir_colorspace colorspace)\n{\n    stbir__info info;\n    int result;\n    size_t memory_required;\n    void* extra_memory;\n\n    stbir__setup(&info, input_w, input_h, output_w, output_h, channels);\n    stbir__calculate_transform(&info, s0,t0,s1,t1,transform);\n    stbir__choose_filter(&info, h_filter, v_filter);\n    memory_required = stbir__calculate_memory(&info);\n    extra_memory = STBIR_MALLOC(memory_required, alloc_context);\n\n    if (!extra_memory)\n        return 0;\n\n    result = stbir__resize_allocated(&info, input_data, input_stride_in_bytes,\n                                            output_data, output_stride_in_bytes, \n                                            alpha_channel, flags, type,\n                                            edge_horizontal, edge_vertical,\n                                            colorspace, extra_memory, memory_required);\n\n    STBIR_FREE(extra_memory, alloc_context);\n\n    return result;\n}\n\nSTBIRDEF int stbir_resize_uint8(     const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                     int num_channels)\n{\n    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,-1,0, STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,\n        STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP, STBIR_COLORSPACE_LINEAR);\n}\n\nSTBIRDEF int stbir_resize_float(     const float *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                           float *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                     int num_channels)\n{\n    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,-1,0, STBIR_TYPE_FLOAT, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,\n        STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP, STBIR_COLORSPACE_LINEAR);\n}\n\nSTBIRDEF int stbir_resize_uint8_srgb(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                           unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                     int num_channels, int alpha_channel, int flags)\n{\n    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,\n        STBIR_EDGE_CLAMP, STBIR_EDGE_CLAMP, STBIR_COLORSPACE_SRGB);\n}\n\nSTBIRDEF int stbir_resize_uint8_srgb_edgemode(const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                                    unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                              int num_channels, int alpha_channel, int flags,\n                                              stbir_edge edge_wrap_mode)\n{\n    return stbir__resize_arbitrary(NULL, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT8, STBIR_FILTER_DEFAULT, STBIR_FILTER_DEFAULT,\n        edge_wrap_mode, edge_wrap_mode, STBIR_COLORSPACE_SRGB);\n}\n\nSTBIRDEF int stbir_resize_uint8_generic( const unsigned char *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                               unsigned char *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                         int num_channels, int alpha_channel, int flags,\n                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space, \n                                         void *alloc_context)\n{\n    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT8, filter, filter,\n        edge_wrap_mode, edge_wrap_mode, space);\n}\n\nSTBIRDEF int stbir_resize_uint16_generic(const stbir_uint16 *input_pixels  , int input_w , int input_h , int input_stride_in_bytes,\n                                               stbir_uint16 *output_pixels , int output_w, int output_h, int output_stride_in_bytes,\n                                         int num_channels, int alpha_channel, int flags,\n                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space, \n                                         void *alloc_context)\n{\n    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_UINT16, filter, filter,\n        edge_wrap_mode, edge_wrap_mode, space);\n}\n\n\nSTBIRDEF int stbir_resize_float_generic( const float *input_pixels         , int input_w , int input_h , int input_stride_in_bytes,\n                                               float *output_pixels        , int output_w, int output_h, int output_stride_in_bytes,\n                                         int num_channels, int alpha_channel, int flags,\n                                         stbir_edge edge_wrap_mode, stbir_filter filter, stbir_colorspace space, \n                                         void *alloc_context)\n{\n    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,alpha_channel,flags, STBIR_TYPE_FLOAT, filter, filter,\n        edge_wrap_mode, edge_wrap_mode, space);\n}\n\n\nSTBIRDEF int stbir_resize(         const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                   stbir_datatype datatype,\n                                   int num_channels, int alpha_channel, int flags,\n                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical, \n                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,\n                                   stbir_colorspace space, void *alloc_context)\n{\n    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,NULL,num_channels,alpha_channel,flags, datatype, filter_horizontal, filter_vertical,\n        edge_mode_horizontal, edge_mode_vertical, space);\n}\n\n\nSTBIRDEF int stbir_resize_subpixel(const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                   stbir_datatype datatype,\n                                   int num_channels, int alpha_channel, int flags,\n                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical, \n                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,\n                                   stbir_colorspace space, void *alloc_context,\n                                   float x_scale, float y_scale,\n                                   float x_offset, float y_offset)\n{\n    float transform[4];\n    transform[0] = x_scale;\n    transform[1] = y_scale;\n    transform[2] = x_offset;\n    transform[3] = y_offset;\n    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        0,0,1,1,transform,num_channels,alpha_channel,flags, datatype, filter_horizontal, filter_vertical,\n        edge_mode_horizontal, edge_mode_vertical, space);\n}\n\nSTBIRDEF int stbir_resize_region(  const void *input_pixels , int input_w , int input_h , int input_stride_in_bytes,\n                                         void *output_pixels, int output_w, int output_h, int output_stride_in_bytes,\n                                   stbir_datatype datatype,\n                                   int num_channels, int alpha_channel, int flags,\n                                   stbir_edge edge_mode_horizontal, stbir_edge edge_mode_vertical, \n                                   stbir_filter filter_horizontal,  stbir_filter filter_vertical,\n                                   stbir_colorspace space, void *alloc_context,\n                                   float s0, float t0, float s1, float t1)\n{\n    return stbir__resize_arbitrary(alloc_context, input_pixels, input_w, input_h, input_stride_in_bytes,\n        output_pixels, output_w, output_h, output_stride_in_bytes,\n        s0,t0,s1,t1,NULL,num_channels,alpha_channel,flags, datatype, filter_horizontal, filter_vertical,\n        edge_mode_horizontal, edge_mode_vertical, space);\n}\n\n#endif // STB_IMAGE_RESIZE_IMPLEMENTATION\n/* stb_image - v1.46 - public domain JPEG/PNG reader - http://nothings.org/stb_image.c\n   when you control the images you're loading\n                                     no warranty implied; use at your own risk\n\n   Do this:\n      #define STB_IMAGE_IMPLEMENTATION\n   before you include this file in *one* C or C++ file to create the implementation.\n\n   #define STBI_ASSERT(x) to avoid using assert.h.\n\n   QUICK NOTES:\n      Primarily of interest to game developers and other people who can\n          avoid problematic images and only need the trivial interface\n\n      JPEG baseline (no JPEG progressive)\n      PNG 8-bit-per-channel only\n\n      TGA (not sure what subset, if a subset)\n      BMP non-1bpp, non-RLE\n      PSD (composited view only, no extra channels)\n\n      GIF (*comp always reports as 4-channel)\n      HDR (radiance rgbE format)\n      PIC (Softimage PIC)\n\n      - decode from memory or through FILE (define STBI_NO_STDIO to remove code)\n      - decode from arbitrary I/O callbacks\n      - overridable dequantizing-IDCT, YCbCr-to-RGB conversion (define STBI_SIMD)\n\n   Latest revisions:\n      1.46 (2014-08-26) fix broken tRNS chunk in non-paletted PNG\n      1.45 (2014-08-16) workaround MSVC-ARM internal compiler error by wrapping malloc\n      1.44 (2014-08-07) warnings\n      1.43 (2014-07-15) fix MSVC-only bug in 1.42\n      1.42 (2014-07-09) no _CRT_SECURE_NO_WARNINGS; error-path fixes; STBI_ASSERT\n      1.41 (2014-06-25) fix search&replace that messed up comments/error messages\n      1.40 (2014-06-22) gcc warning\n      1.39 (2014-06-15) TGA optimization bugfix, multiple BMP fixes\n      1.38 (2014-06-06) suppress MSVC run-time warnings, fix accidental rename of 'skip'\n      1.37 (2014-06-04) remove duplicate typedef\n      1.36 (2014-06-03) converted to header file, allow reading incorrect iphoned-images without iphone flag\n      1.35 (2014-05-27) warnings, bugfixes, TGA optimization, etc\n\n   See end of file for full revision history.\n\n   TODO:\n      stbi_info support for BMP,PSD,HDR,PIC\n\n\n ============================    Contributors    =========================\n              \n Image formats                                Bug fixes & warning fixes\n    Sean Barrett (jpeg, png, bmp)                Marc LeBlanc\n    Nicolas Schulz (hdr, psd)                    Christpher Lloyd\n    Jonathan Dummer (tga)                        Dave Moore\n    Jean-Marc Lienher (gif)                      Won Chun\n    Tom Seddon (pic)                             the Horde3D community\n    Thatcher Ulrich (psd)                        Janez Zemva\n                                                 Jonathan Blow\n                                                 Laurent Gomila\n Extensions, features                            Aruelien Pocheville\n    Jetro Lauha (stbi_info)                      Ryamond Barbiero\n    James \"moose2000\" Brown (iPhone PNG)         David Woo\n    Ben \"Disch\" Wenger (io callbacks)            Roy Eltham\n    Martin \"SpartanJ\" Golini                     Luke Graham\n                                                 Thomas Ruf\n                                                 John Bartholomew\n Optimizations & bugfixes                        Ken Hamada\n    Fabian \"ryg\" Giesen                          Cort Stratton\n    Arseny Kapoulkine                            Blazej Dariusz Roszkowski\n                                                 Thibault Reuille\n                                                 Paul Du Bois\n                                                 Guillaume George\n                                                 Jerry Jansson\n  If your name should be here but                Hayaki Saito\n  isn't, let Sean know.                          Johan Duparc\n                                                 Ronny Chevalier\n                                                 Michal Cichon\n*/\n\n#ifndef STBI_INCLUDE_STB_IMAGE_H\n#define STBI_INCLUDE_STB_IMAGE_H\n\n// Limitations:\n//    - no jpeg progressive support\n//    - non-HDR formats support 8-bit samples only (jpeg, png)\n//    - no delayed line count (jpeg) -- IJG doesn't support either\n//    - no 1-bit BMP\n//    - GIF always returns *comp=4\n//\n// Basic usage (see HDR discussion below):\n//    int x,y,n;\n//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);\n//    // ... process data if not NULL ... \n//    // ... x = width, y = height, n = # 8-bit components per pixel ...\n//    // ... replace '0' with '1'..'4' to force that many components per pixel\n//    // ... but 'n' will always be the number that it would have been if you said 0\n//    stbi_image_freea(data)\n//\n// Standard parameters:\n//    int *x       -- outputs image width in pixels\n//    int *y       -- outputs image height in pixels\n//    int *comp    -- outputs # of image components in image file\n//    int req_comp -- if non-zero, # of image components requested in result\n//\n// The return value from an image loader is an 'unsigned char *' which points\n// to the pixel data. The pixel data consists of *y scanlines of *x pixels,\n// with each pixel consisting of N interleaved 8-bit components; the first\n// pixel pointed to is top-left-most in the image. There is no padding between\n// image scanlines or between pixels, regardless of format. The number of\n// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.\n// If req_comp is non-zero, *comp has the number of components that _would_\n// have been output otherwise. E.g. if you set req_comp to 4, you will always\n// get RGBA output, but you can check *comp to easily see if it's opaque.\n//\n// An output image with N components has the following components interleaved\n// in this order in each pixel:\n//\n//     N=#comp     components\n//       1           grey\n//       2           grey, alpha\n//       3           red, green, blue\n//       4           red, green, blue, alpha\n//\n// If image loading fails for any reason, the return value will be NULL,\n// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()\n// can be queried for an extremely brief, end-user unfriendly explanation\n// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid\n// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly\n// more user-friendly ones.\n//\n// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.\n//\n// ===========================================================================\n//\n// iPhone PNG support:\n//\n// By default we convert iphone-formatted PNGs back to RGB; nominally they\n// would silently load as BGR, except the existing code should have just\n// failed on such iPhone PNGs. But you can disable this conversion by\n// by calling stbi_convert_iphone_png_to_rgb(0), in which case\n// you will always just get the native iphone \"format\" through.\n//\n// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per\n// pixel to remove any premultiplied alpha *only* if the image file explicitly\n// says there's premultiplied data (currently only happens in iPhone images,\n// and only if iPhone convert-to-rgb processing is on).\n//\n// ===========================================================================\n//\n// HDR image support   (disable by defining STBI_NO_HDR)\n//\n// stb_image now supports loading HDR images in general, and currently\n// the Radiance .HDR file format, although the support is provided\n// generically. You can still load any file through the existing interface;\n// if you attempt to load an HDR file, it will be automatically remapped to\n// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;\n// both of these constants can be reconfigured through this interface:\n//\n//     stbi_hdr_to_ldr_gamma(2.2f);\n//     stbi_hdr_to_ldr_scale(1.0f);\n//\n// (note, do not use _inverse_ constants; stbi_image will invert them\n// appropriately).\n//\n// Additionally, there is a new, parallel interface for loading files as\n// (linear) floats to preserve the full dynamic range:\n//\n//    float *data = stbi_loadf(filename, &x, &y, &n, 0);\n// \n// If you load LDR images through this interface, those images will\n// be promoted to floating point values, run through the inverse of\n// constants corresponding to the above:\n//\n//     stbi_ldr_to_hdr_scale(1.0f);\n//     stbi_ldr_to_hdr_gamma(2.2f);\n//\n// Finally, given a filename (or an open file or memory block--see header\n// file for details) containing image data, you can query for the \"most\n// appropriate\" interface to use (that is, whether the image is HDR or\n// not), using:\n//\n//     stbi_is_hdr(char *filename);\n//\n// ===========================================================================\n//\n// I/O callbacks\n//\n// I/O callbacks allow you to read from arbitrary sources, like packaged\n// files or some other source. Data read from callbacks are processed\n// through a small internal buffer (currently 128 bytes) to try to reduce\n// overhead. \n//\n// The three functions you must define are \"read\" (reads some bytes of data),\n// \"skip\" (skips some bytes of data), \"eof\" (reports if the stream is at the end).\n\n\n#ifndef STBI_NO_STDIO\n#include <stdio.h>\n#endif // STBI_NO_STDIO\n\n#define STBI_VERSION 1\n\nenum\n{\n   STBI_default = 0, // only used for req_comp\n\n   STBI_grey       = 1,\n   STBI_grey_alpha = 2,\n   STBI_rgb        = 3,\n   STBI_rgb_alpha  = 4\n};\n\ntypedef unsigned char stbi_uc;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef STB_IMAGE_STATIC\n#define STBIDEF static\n#else\n#define STBIDEF extern\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// PRIMARY API - works on images of any type\n//\n\n//\n// load image by filename, open file, or memory buffer\n//\n\nSTBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF stbi_uc *stbi_load            (char const *filename,     int *x, int *y, int *comp, int req_comp);\nSTBIDEF stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);\n// for stbi_load_from_file, file pointer is left pointing immediately after image\n#endif\n\ntypedef struct\n{\n   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read \n   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative\n   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data\n} stbi_io_callbacks;\n\nSTBIDEF stbi_uc *stbi_load_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);\n\n#ifndef STBI_NO_HDR\n   STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);\n\n   #ifndef STBI_NO_STDIO\n   STBIDEF float *stbi_loadf            (char const *filename,   int *x, int *y, int *comp, int req_comp);\n   STBIDEF float *stbi_loadf_from_file  (FILE *f,                int *x, int *y, int *comp, int req_comp);\n   #endif\n   \n   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);\n\n   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);\n   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);\n\n   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);\n   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);\n#endif // STBI_NO_HDR\n\n// stbi_is_hdr is always defined\nSTBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);\nSTBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename);\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f);\n#endif // STBI_NO_STDIO\n\n\n// get a VERY brief reason for failure\n// NOT THREADSAFE\nSTBIDEF const char *stbi_failure_reason  (void); \n\n// free the loaded image -- this is just free()\nSTBIDEF void     stbi_image_free      (void *retval_from_stbi_load);\n\n// get image dimensions & components without fully decoding\nSTBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_info            (char const *filename,     int *x, int *y, int *comp);\nSTBIDEF int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);\n\n#endif\n\n\n\n// for image formats that explicitly notate that they have premultiplied alpha,\n// we just return the colors as stored in the file. set this flag to force\n// unpremultiplication. results are undefined if the unpremultiply overflow.\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);\n\n// indicate whether we should process iphone images back to canonical format,\n// or just pass them through \"as-is\"\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);\n\n\n// ZLIB client - used by PNG, available for other purposes\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);\nSTBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);\nSTBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);\n\n\n// define faster low-level operations (typically SIMD support)\n#ifdef STBI_SIMD\ntypedef void (*stbi_idct_8x8)(stbi_uc *out, int out_stride, short data[64], unsigned short *dequantize);\n// compute an integer IDCT on \"input\"\n//     input[x] = data[x] * dequantize[x]\n//     write results to 'out': 64 samples, each run of 8 spaced by 'out_stride'\n//                             CLAMP results to 0..255\ntypedef void (*stbi_YCbCr_to_RGB_run)(stbi_uc *output, stbi_uc const  *y, stbi_uc const *cb, stbi_uc const *cr, int count, int step);\n// compute a conversion from YCbCr to RGB\n//     'count' pixels\n//     write pixels to 'output'; each pixel is 'step' bytes (either 3 or 4; if 4, write '255' as 4th), order R,G,B\n//     y: Y input channel\n//     cb: Cb input channel; scale/biased to be 0..255\n//     cr: Cr input channel; scale/biased to be 0..255\n\nSTBIDEF void stbi_install_idct(stbi_idct_8x8 func);\nSTBIDEF void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func);\n#endif // STBI_SIMD\n\n\n#ifdef __cplusplus\n}\n#endif\n\n//\n//\n////   end header file   /////////////////////////////////////////////////////\n#endif // STBI_INCLUDE_STB_IMAGE_H\n\n#ifdef STB_IMAGE_IMPLEMENTATION\n\n#ifndef STBI_NO_HDR\n#include <math.h>  // ldexp\n#include <string.h> // strcmp, strtok\n#endif\n\n#ifndef STBI_NO_STDIO\n#include <stdio.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#ifndef STBI_ASSERT\n#include <assert.h>\n#define STBI_ASSERT(x) assert(x)\n#endif\n#include <stdarg.h>\n#include <stddef.h> // ptrdiff_t on osx\n\n#ifndef _MSC_VER\n   #ifdef __cplusplus\n   #define stbi_inline inline\n   #else\n   #define stbi_inline\n   #endif\n#else\n   #define stbi_inline __forceinline\n#endif\n\n\n#ifdef _MSC_VER\ntypedef unsigned short stbi__uint16;\ntypedef   signed short stbi__int16;\ntypedef unsigned int   stbi__uint32;\ntypedef   signed int   stbi__int32;\n#else\n#include <stdint.h>\ntypedef uint16_t stbi__uint16;\ntypedef int16_t  stbi__int16;\ntypedef uint32_t stbi__uint32;\ntypedef int32_t  stbi__int32;\n#endif\n\n// should produce compiler error if size is wrong\ntypedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];\n\n#ifdef _MSC_VER\n#define STBI_NOTUSED(v)  (void)(v)\n#else\n#define STBI_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#ifdef _MSC_VER\n#define STBI_HAS_LROTL\n#endif\n\n#ifdef STBI_HAS_LROTL\n   #define stbi_lrot(x,y)  _lrotl(x,y)\n#else\n   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))\n#endif\n\n///////////////////////////////////////////////\n//\n//  stbi__context struct and start_xxx functions\n\n// stbi__context structure is our basic context used by all images, so it\n// contains all the IO context, plus some basic image information\ntypedef struct\n{\n   stbi__uint32 img_x, img_y;\n   int img_n, img_out_n;\n   \n   stbi_io_callbacks io;\n   void *io_user_data;\n\n   int read_from_callbacks;\n   int buflen;\n   stbi_uc buffer_start[128];\n\n   stbi_uc *img_buffer, *img_buffer_end;\n   stbi_uc *img_buffer_original;\n} stbi__context;\n\n\nstatic void stbi__refill_buffer(stbi__context *s);\n\n// initialize a memory-decode context\nstatic void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)\n{\n   s->io.read = NULL;\n   s->read_from_callbacks = 0;\n   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;\n   s->img_buffer_end = (stbi_uc *) buffer+len;\n}\n\n// initialize a callback-based context\nstatic void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)\n{\n   s->io = *c;\n   s->io_user_data = user;\n   s->buflen = sizeof(s->buffer_start);\n   s->read_from_callbacks = 1;\n   s->img_buffer_original = s->buffer_start;\n   stbi__refill_buffer(s);\n}\n\n#ifndef STBI_NO_STDIO\n\nstatic int stbi__stdio_read(void *user, char *data, int size)\n{\n   return (int) fread(data,1,size,(FILE*) user);\n}\n\nstatic void stbi__stdio_skip(void *user, int n)\n{\n   fseek((FILE*) user, n, SEEK_CUR);\n}\n\nstatic int stbi__stdio_eof(void *user)\n{\n   return feof((FILE*) user);\n}\n\nstatic stbi_io_callbacks stbi__stdio_callbacks =\n{\n   stbi__stdio_read,\n   stbi__stdio_skip,\n   stbi__stdio_eof,\n};\n\nstatic void stbi__start_file(stbi__context *s, FILE *f)\n{\n   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);\n}\n\n//static void stop_file(stbi__context *s) { }\n\n#endif // !STBI_NO_STDIO\n\nstatic void stbi__rewind(stbi__context *s)\n{\n   // conceptually rewind SHOULD rewind to the beginning of the stream,\n   // but we just rewind to the beginning of the initial buffer, because\n   // we only use it after doing 'test', which only ever looks at at most 92 bytes\n   s->img_buffer = s->img_buffer_original;\n}\n\nstatic int      stbi__jpeg_test(stbi__context *s);\nstatic stbi_uc *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\nstatic int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__png_test(stbi__context *s);\nstatic stbi_uc *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\nstatic int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__bmp_test(stbi__context *s);\nstatic stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\nstatic int      stbi__tga_test(stbi__context *s);\nstatic stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\nstatic int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);\nstatic int      stbi__psd_test(stbi__context *s);\nstatic stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\n#ifndef STBI_NO_HDR\nstatic int      stbi__hdr_test(stbi__context *s);\nstatic float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\n#endif\nstatic int      stbi__pic_test(stbi__context *s);\nstatic stbi_uc *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\nstatic int      stbi__gif_test(stbi__context *s);\nstatic stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);\nstatic int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);\n\n\n// this is not threadsafe\nstatic const char *stbi__g_failure_reason;\n\nSTBIDEF const char *stbi_failure_reason(void)\n{\n   return stbi__g_failure_reason;\n}\n\nstatic int stbi__err(const char *str)\n{\n   stbi__g_failure_reason = str;\n   return 0;\n}\n\nstatic void *stbi__malloc(size_t size)\n{\n    return malloc(size);\n}\n\n// stbi__err - error\n// stbi__errpf - error returning pointer to float\n// stbi__errpuc - error returning pointer to unsigned char\n\n#ifdef STBI_NO_FAILURE_STRINGS\n   #define stbi__err(x,y)  0\n#elif defined(STBI_FAILURE_USERMSG)\n   #define stbi__err(x,y)  stbi__err(y)\n#else\n   #define stbi__err(x,y)  stbi__err(x)\n#endif\n\n#define stbi__errpf(x,y)   ((float *) (stbi__err(x,y)?NULL:NULL))\n#define stbi__errpuc(x,y)  ((unsigned char *) (stbi__err(x,y)?NULL:NULL))\n\nSTBIDEF void stbi_image_free(void *retval_from_stbi_load)\n{\n   free(retval_from_stbi_load);\n}\n\n#ifndef STBI_NO_HDR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);\n#endif\n\nstatic unsigned char *stbi_load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp);\n   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp);\n   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp);\n   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp);\n   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp);\n   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp);\n\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s)) {\n      float *hdr = stbi__hdr_load(s, x,y,comp,req_comp);\n      return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);\n   }\n   #endif\n\n   // test tga last because it's a crappy test!\n   if (stbi__tga_test(s))\n      return stbi__tga_load(s,x,y,comp,req_comp);\n   return stbi__errpuc(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\n#ifndef STBI_NO_STDIO\n\nFILE *stbi__fopen(char const *filename, char const *mode)\n{\n   FILE *f;\n#if defined(_MSC_VER) && _MSC_VER >= 1400\n   if (0 != fopen_s(&f, filename, mode))\n      f=0;\n#else\n   f = fopen(filename, mode);\n#endif\n   return f;\n}\n\n\nSTBIDEF unsigned char *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   unsigned char *result;\n   if (!f) return stbi__errpuc(\"can't fopen\", \"Unable to open file\");\n   result = stbi_load_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nSTBIDEF unsigned char *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *result;\n   stbi__context s;\n   stbi__start_file(&s,f);\n   result = stbi_load_main(&s,x,y,comp,req_comp);\n   if (result) {\n      // need to 'unget' all the characters in the IO buffer\n      fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);\n   }\n   return result;\n}\n#endif //!STBI_NO_STDIO\n\nSTBIDEF unsigned char *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi_load_main(&s,x,y,comp,req_comp);\n}\n\nunsigned char *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi_load_main(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_HDR\n\nfloat *stbi_loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   unsigned char *data;\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_test(s))\n      return stbi__hdr_load(s,x,y,comp,req_comp);\n   #endif\n   data = stbi_load_main(s, x, y, comp, req_comp);\n   if (data)\n      return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);\n   return stbi__errpf(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\nfloat *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi_loadf_main(&s,x,y,comp,req_comp);\n}\n\nfloat *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi_loadf_main(&s,x,y,comp,req_comp);\n}\n\n#ifndef STBI_NO_STDIO\nfloat *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)\n{\n   float *result;\n   FILE *f = stbi__fopen(filename, \"rb\");\n   if (!f) return stbi__errpf(\"can't fopen\", \"Unable to open file\");\n   result = stbi_loadf_from_file(f,x,y,comp,req_comp);\n   fclose(f);\n   return result;\n}\n\nfloat *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__context s;\n   stbi__start_file(&s,f);\n   return stbi_loadf_main(&s,x,y,comp,req_comp);\n}\n#endif // !STBI_NO_STDIO\n\n#endif // !STBI_NO_HDR\n\n// these is-hdr-or-not is defined independent of whether STBI_NO_HDR is\n// defined, for API simplicity; if STBI_NO_HDR is defined, it always\n// reports false!\n\nint stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__hdr_test(&s);\n   #else\n   STBI_NOTUSED(buffer);\n   STBI_NOTUSED(len);\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int      stbi_is_hdr          (char const *filename)\n{\n   FILE *f = stbi__fopen(filename, \"rb\");\n   int result=0;\n   if (f) {\n      result = stbi_is_hdr_from_file(f);\n      fclose(f);\n   }\n   return result;\n}\n\nSTBIDEF int      stbi_is_hdr_from_file(FILE *f)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_file(&s,f);\n   return stbi__hdr_test(&s);\n   #else\n   return 0;\n   #endif\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)\n{\n   #ifndef STBI_NO_HDR\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);\n   return stbi__hdr_test(&s);\n   #else\n   return 0;\n   #endif\n}\n\n#ifndef STBI_NO_HDR\nstatic float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;\nstatic float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;\n\nvoid   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }\nvoid   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }\n\nvoid   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }\nvoid   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }\n#endif\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Common code used by all image loaders\n//\n\nenum\n{\n   SCAN_load=0,\n   SCAN_type,\n   SCAN_header\n};\n\nstatic void stbi__refill_buffer(stbi__context *s)\n{\n   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);\n   if (n == 0) {\n      // at end of file, treat same as if from memory, but need to handle case\n      // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file\n      s->read_from_callbacks = 0;\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start+1;\n      *s->img_buffer = 0;\n   } else {\n      s->img_buffer = s->buffer_start;\n      s->img_buffer_end = s->buffer_start + n;\n   }\n}\n\nstbi_inline static stbi_uc stbi__get8(stbi__context *s)\n{\n   if (s->img_buffer < s->img_buffer_end)\n      return *s->img_buffer++;\n   if (s->read_from_callbacks) {\n      stbi__refill_buffer(s);\n      return *s->img_buffer++;\n   }\n   return 0;\n}\n\nstbi_inline static int stbi__at_eof(stbi__context *s)\n{\n   if (s->io.read) {\n      if (!(s->io.eof)(s->io_user_data)) return 0;\n      // if feof() is true, check if buffer = end\n      // special case: we've only got the special 0 character at the end\n      if (s->read_from_callbacks == 0) return 1;\n   }\n\n   return s->img_buffer >= s->img_buffer_end;   \n}\n\nstatic void stbi__skip(stbi__context *s, int n)\n{\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         s->img_buffer = s->img_buffer_end;\n         (s->io.skip)(s->io_user_data, n - blen);\n         return;\n      }\n   }\n   s->img_buffer += n;\n}\n\nstatic int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)\n{\n   if (s->io.read) {\n      int blen = (int) (s->img_buffer_end - s->img_buffer);\n      if (blen < n) {\n         int res, count;\n\n         memcpy(buffer, s->img_buffer, blen);\n         \n         count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);\n         res = (count == (n-blen));\n         s->img_buffer = s->img_buffer_end;\n         return res;\n      }\n   }\n\n   if (s->img_buffer+n <= s->img_buffer_end) {\n      memcpy(buffer, s->img_buffer, n);\n      s->img_buffer += n;\n      return 1;\n   } else\n      return 0;\n}\n\nstatic int stbi__get16be(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return (z << 8) + stbi__get8(s);\n}\n\nstatic stbi__uint32 stbi__get32be(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16be(s);\n   return (z << 16) + stbi__get16be(s);\n}\n\nstatic int stbi__get16le(stbi__context *s)\n{\n   int z = stbi__get8(s);\n   return z + (stbi__get8(s) << 8);\n}\n\nstatic stbi__uint32 stbi__get32le(stbi__context *s)\n{\n   stbi__uint32 z = stbi__get16le(s);\n   return z + (stbi__get16le(s) << 16);\n}\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  generic converter from built-in img_n to req_comp\n//    individual types do this automatically as much as possible (e.g. jpeg\n//    does all cases internally since it needs to colorspace convert anyway,\n//    and it never has alpha, so very few cases ). png can automatically\n//    interleave an alpha=255 channel, but falls back to this for other cases\n//\n//  assume data buffer is malloced, so malloc a new one and free that one\n//  only failure mode is malloc failing\n\nstatic stbi_uc stbi__compute_y(int r, int g, int b)\n{\n   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);\n}\n\nstatic unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)\n{\n   int i,j;\n   unsigned char *good;\n\n   if (req_comp == img_n) return data;\n   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);\n\n   good = (unsigned char *) stbi__malloc(req_comp * x * y);\n   if (good == NULL) {\n      free(data);\n      return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   }\n\n   for (j=0; j < (int) y; ++j) {\n      unsigned char *src  = data + j * x * img_n   ;\n      unsigned char *dest = good + j * x * req_comp;\n\n      #define COMBO(a,b)  ((a)*8+(b))\n      #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)\n      // convert source image with img_n components to one with req_comp components;\n      // avoid switch per pixel, so use switch per scanline and massive macros\n      switch (COMBO(img_n, req_comp)) {\n         CASE(1,2) dest[0]=src[0], dest[1]=255; break;\n         CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;\n         CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;\n         CASE(2,1) dest[0]=src[0]; break;\n         CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;\n         CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;\n         CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;\n         CASE(3,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;\n         CASE(3,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255; break;\n         CASE(4,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;\n         CASE(4,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;\n         CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;\n         default: STBI_ASSERT(0);\n      }\n      #undef CASE\n   }\n\n   free(data);\n   return good;\n}\n\n#ifndef STBI_NO_HDR\nstatic float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)\n{\n   int i,k,n;\n   float *output = (float *) stbi__malloc(x * y * comp * sizeof(float));\n   if (output == NULL) { free(data); return stbi__errpf(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);\n      }\n      if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;\n   }\n   free(data);\n   return output;\n}\n\n#define stbi__float2int(x)   ((int) (x))\nstatic stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)\n{\n   int i,k,n;\n   stbi_uc *output = (stbi_uc *) stbi__malloc(x * y * comp);\n   if (output == NULL) { free(data); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n   // compute number of non-alpha components\n   if (comp & 1) n = comp; else n = comp-1;\n   for (i=0; i < x*y; ++i) {\n      for (k=0; k < n; ++k) {\n         float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n      if (k < comp) {\n         float z = data[i*comp+k] * 255 + 0.5f;\n         if (z < 0) z = 0;\n         if (z > 255) z = 255;\n         output[i*comp + k] = (stbi_uc) stbi__float2int(z);\n      }\n   }\n   free(data);\n   return output;\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//  \"baseline\" JPEG/JFIF decoder (not actually fully baseline implementation)\n//\n//    simple implementation\n//      - channel subsampling of at most 2 in each dimension\n//      - doesn't support delayed output of y-dimension\n//      - simple interface (only one output format: 8-bit interleaved RGB)\n//      - doesn't try to recover corrupt jpegs\n//      - doesn't allow partial loading, loading multiple at once\n//      - still fast on x86 (copying globals into locals doesn't help x86)\n//      - allocates lots of intermediate memory (full size of all components)\n//        - non-interleaved case requires this anyway\n//        - allows good upsampling (see next)\n//    high-quality\n//      - upsampled channels are bilinearly interpolated, even across blocks\n//      - quality integer IDCT derived from IJG's 'slow'\n//    performance\n//      - fast huffman; reasonable integer IDCT\n//      - uses a lot of intermediate memory, could cache poorly\n//      - load http://nothings.org/remote/anemones.jpg 3 times on 2.8Ghz P4\n//          stb_jpeg:   1.34 seconds (MSVC6, default release build)\n//          stb_jpeg:   1.06 seconds (MSVC6, processor = Pentium Pro)\n//          IJL11.dll:  1.08 seconds (compiled by intel)\n//          IJG 1998:   0.98 seconds (MSVC6, makefile provided by IJG)\n//          IJG 1998:   0.95 seconds (MSVC6, makefile + proc=PPro)\n\n// huffman decoding acceleration\n#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache\n\ntypedef struct\n{\n   stbi_uc  fast[1 << FAST_BITS];\n   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win\n   stbi__uint16 code[256];\n   stbi_uc  values[256];\n   stbi_uc  size[257];\n   unsigned int maxcode[18];\n   int    delta[17];   // old 'firstsymbol' - old 'firstcode'\n} stbi__huffman;\n\ntypedef struct\n{\n   #ifdef STBI_SIMD\n   unsigned short dequant2[4][64];\n   #endif\n   stbi__context *s;\n   stbi__huffman huff_dc[4];\n   stbi__huffman huff_ac[4];\n   stbi_uc dequant[4][64];\n\n// sizes for components, interleaved MCUs\n   int img_h_max, img_v_max;\n   int img_mcu_x, img_mcu_y;\n   int img_mcu_w, img_mcu_h;\n\n// definition of jpeg image component\n   struct\n   {\n      int id;\n      int h,v;\n      int tq;\n      int hd,ha;\n      int dc_pred;\n\n      int x,y,w2,h2;\n      stbi_uc *data;\n      void *raw_data;\n      stbi_uc *linebuf;\n   } img_comp[4];\n\n   stbi__uint32         code_buffer; // jpeg entropy-coded buffer\n   int            code_bits;   // number of valid bits\n   unsigned char  marker;      // marker seen while filling entropy buffer\n   int            nomore;      // flag if we saw a marker so must stop\n\n   int scan_n, order[4];\n   int restart_interval, todo;\n} stbi__jpeg;\n\nstatic int stbi__build_huffman(stbi__huffman *h, int *count)\n{\n   int i,j,k=0,code;\n   // build size list for each symbol (from JPEG spec)\n   for (i=0; i < 16; ++i)\n      for (j=0; j < count[i]; ++j)\n         h->size[k++] = (stbi_uc) (i+1);\n   h->size[k] = 0;\n\n   // compute actual symbols (from jpeg spec)\n   code = 0;\n   k = 0;\n   for(j=1; j <= 16; ++j) {\n      // compute delta to add to code to compute symbol id\n      h->delta[j] = k - code;\n      if (h->size[k] == j) {\n         while (h->size[k] == j)\n            h->code[k++] = (stbi__uint16) (code++);\n         if (code-1 >= (1 << j)) return stbi__err(\"bad code lengths\",\"Corrupt JPEG\");\n      }\n      // compute largest code + 1 for this size, preshifted as needed later\n      h->maxcode[j] = code << (16-j);\n      code <<= 1;\n   }\n   h->maxcode[j] = 0xffffffff;\n\n   // build non-spec acceleration table; 255 is flag for not-accelerated\n   memset(h->fast, 255, 1 << FAST_BITS);\n   for (i=0; i < k; ++i) {\n      int s = h->size[i];\n      if (s <= FAST_BITS) {\n         int c = h->code[i] << (FAST_BITS-s);\n         int m = 1 << (FAST_BITS-s);\n         for (j=0; j < m; ++j) {\n            h->fast[c+j] = (stbi_uc) i;\n         }\n      }\n   }\n   return 1;\n}\n\nstatic void stbi__grow_buffer_unsafe(stbi__jpeg *j)\n{\n   do {\n      int b = j->nomore ? 0 : stbi__get8(j->s);\n      if (b == 0xff) {\n         int c = stbi__get8(j->s);\n         if (c != 0) {\n            j->marker = (unsigned char) c;\n            j->nomore = 1;\n            return;\n         }\n      }\n      j->code_buffer |= b << (24 - j->code_bits);\n      j->code_bits += 8;\n   } while (j->code_bits <= 24);\n}\n\n// (1 << n) - 1\nstatic stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};\n\n// decode a jpeg huffman value from the bitstream\nstbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)\n{\n   unsigned int temp;\n   int c,k;\n\n   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);\n\n   // look at the top FAST_BITS and determine what symbol ID it is,\n   // if the code is <= FAST_BITS\n   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);\n   k = h->fast[c];\n   if (k < 255) {\n      int s = h->size[k];\n      if (s > j->code_bits)\n         return -1;\n      j->code_buffer <<= s;\n      j->code_bits -= s;\n      return h->values[k];\n   }\n\n   // naive test is to shift the code_buffer down so k bits are\n   // valid, then test against maxcode. To speed this up, we've\n   // preshifted maxcode left so that it has (16-k) 0s at the\n   // end; in other words, regardless of the number of bits, it\n   // wants to be compared against something shifted to have 16;\n   // that way we don't need to shift inside the loop.\n   temp = j->code_buffer >> 16;\n   for (k=FAST_BITS+1 ; ; ++k)\n      if (temp < h->maxcode[k])\n         break;\n   if (k == 17) {\n      // error! code not found\n      j->code_bits -= 16;\n      return -1;\n   }\n\n   if (k > j->code_bits)\n      return -1;\n\n   // convert the huffman code to the symbol id\n   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];\n   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);\n\n   // convert the id to a symbol\n   j->code_bits -= k;\n   j->code_buffer <<= k;\n   return h->values[c];\n}\n\n// combined JPEG 'receive' and JPEG 'extend', since baseline\n// always extends everything it receives.\nstbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)\n{\n   unsigned int m = 1 << (n-1);\n   unsigned int k;\n   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);\n\n   #if 1\n   k = stbi_lrot(j->code_buffer, n);\n   j->code_buffer = k & ~stbi__bmask[n];\n   k &= stbi__bmask[n];\n   j->code_bits -= n;\n   #else\n   k = (j->code_buffer >> (32 - n)) & stbi__bmask[n];\n   j->code_bits -= n;\n   j->code_buffer <<= n;\n   #endif\n   // the following test is probably a random branch that won't\n   // predict well. I tried to table accelerate it but failed.\n   // maybe it's compiling as a conditional move?\n   if (k < m)\n      return (-1 << n) + k + 1;\n   else\n      return k;\n}\n\n// given a value that's at position X in the zigzag stream,\n// where does it appear in the 8x8 matrix coded as row-major?\nstatic stbi_uc stbi__jpeg_dezigzag[64+15] =\n{\n    0,  1,  8, 16,  9,  2,  3, 10,\n   17, 24, 32, 25, 18, 11,  4,  5,\n   12, 19, 26, 33, 40, 48, 41, 34,\n   27, 20, 13,  6,  7, 14, 21, 28,\n   35, 42, 49, 56, 57, 50, 43, 36,\n   29, 22, 15, 23, 30, 37, 44, 51,\n   58, 59, 52, 45, 38, 31, 39, 46,\n   53, 60, 61, 54, 47, 55, 62, 63,\n   // let corrupt input sample past end\n   63, 63, 63, 63, 63, 63, 63, 63,\n   63, 63, 63, 63, 63, 63, 63\n};\n\n// decode one 64-entry block--\nstatic int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, int b)\n{\n   int diff,dc,k;\n   int t = stbi__jpeg_huff_decode(j, hdc);\n   if (t < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n\n   // 0 all the ac values now so we can do it 32-bits at a time\n   memset(data,0,64*sizeof(data[0]));\n\n   diff = t ? stbi__extend_receive(j, t) : 0;\n   dc = j->img_comp[b].dc_pred + diff;\n   j->img_comp[b].dc_pred = dc;\n   data[0] = (short) dc;\n\n   // decode AC components, see JPEG spec\n   k = 1;\n   do {\n      int r,s;\n      int rs = stbi__jpeg_huff_decode(j, hac);\n      if (rs < 0) return stbi__err(\"bad huffman code\",\"Corrupt JPEG\");\n      s = rs & 15;\n      r = rs >> 4;\n      if (s == 0) {\n         if (rs != 0xf0) break; // end block\n         k += 16;\n      } else {\n         k += r;\n         // decode into unzigzag'd location\n         data[stbi__jpeg_dezigzag[k++]] = (short) stbi__extend_receive(j,s);\n      }\n   } while (k < 64);\n   return 1;\n}\n\n// take a -128..127 value and stbi__clamp it and convert to 0..255\nstbi_inline static stbi_uc stbi__clamp(int x)\n{\n   // trick to use a single test to catch both cases\n   if ((unsigned int) x > 255) {\n      if (x < 0) return 0;\n      if (x > 255) return 255;\n   }\n   return (stbi_uc) x;\n}\n\n#define stbi__f2f(x)  (int) (((x) * 4096 + 0.5))\n#define stbi__fsh(x)  ((x) << 12)\n\n// derived from jidctint -- DCT_ISLOW\n#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7)       \\\n   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \\\n   p2 = s2;                                    \\\n   p3 = s6;                                    \\\n   p1 = (p2+p3) * stbi__f2f(0.5411961f);             \\\n   t2 = p1 + p3*stbi__f2f(-1.847759065f);            \\\n   t3 = p1 + p2*stbi__f2f( 0.765366865f);            \\\n   p2 = s0;                                    \\\n   p3 = s4;                                    \\\n   t0 = stbi__fsh(p2+p3);                            \\\n   t1 = stbi__fsh(p2-p3);                            \\\n   x0 = t0+t3;                                 \\\n   x3 = t0-t3;                                 \\\n   x1 = t1+t2;                                 \\\n   x2 = t1-t2;                                 \\\n   t0 = s7;                                    \\\n   t1 = s5;                                    \\\n   t2 = s3;                                    \\\n   t3 = s1;                                    \\\n   p3 = t0+t2;                                 \\\n   p4 = t1+t3;                                 \\\n   p1 = t0+t3;                                 \\\n   p2 = t1+t2;                                 \\\n   p5 = (p3+p4)*stbi__f2f( 1.175875602f);            \\\n   t0 = t0*stbi__f2f( 0.298631336f);                 \\\n   t1 = t1*stbi__f2f( 2.053119869f);                 \\\n   t2 = t2*stbi__f2f( 3.072711026f);                 \\\n   t3 = t3*stbi__f2f( 1.501321110f);                 \\\n   p1 = p5 + p1*stbi__f2f(-0.899976223f);            \\\n   p2 = p5 + p2*stbi__f2f(-2.562915447f);            \\\n   p3 = p3*stbi__f2f(-1.961570560f);                 \\\n   p4 = p4*stbi__f2f(-0.390180644f);                 \\\n   t3 += p1+p4;                                \\\n   t2 += p2+p3;                                \\\n   t1 += p2+p4;                                \\\n   t0 += p1+p3;\n\n#ifdef STBI_SIMD\ntypedef unsigned short stbi_dequantize_t;\n#else\ntypedef stbi_uc stbi_dequantize_t;\n#endif\n\n// .344 seconds on 3*anemones.jpg\nstatic void stbi__idct_block(stbi_uc *out, int out_stride, short data[64], stbi_dequantize_t *dequantize)\n{\n   int i,val[64],*v=val;\n   stbi_dequantize_t *dq = dequantize;\n   stbi_uc *o;\n   short *d = data;\n\n   // columns\n   for (i=0; i < 8; ++i,++d,++dq, ++v) {\n      // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing\n      if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0\n           && d[40]==0 && d[48]==0 && d[56]==0) {\n         //    no shortcut                 0     seconds\n         //    (1|2|3|4|5|6|7)==0          0     seconds\n         //    all separate               -0.047 seconds\n         //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds\n         int dcterm = d[0] * dq[0] << 2;\n         v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;\n      } else {\n         STBI__IDCT_1D(d[ 0]*dq[ 0],d[ 8]*dq[ 8],d[16]*dq[16],d[24]*dq[24],\n                 d[32]*dq[32],d[40]*dq[40],d[48]*dq[48],d[56]*dq[56])\n         // constants scaled things up by 1<<12; let's bring them back\n         // down, but keep 2 extra bits of precision\n         x0 += 512; x1 += 512; x2 += 512; x3 += 512;\n         v[ 0] = (x0+t3) >> 10;\n         v[56] = (x0-t3) >> 10;\n         v[ 8] = (x1+t2) >> 10;\n         v[48] = (x1-t2) >> 10;\n         v[16] = (x2+t1) >> 10;\n         v[40] = (x2-t1) >> 10;\n         v[24] = (x3+t0) >> 10;\n         v[32] = (x3-t0) >> 10;\n      }\n   }\n\n   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {\n      // no fast case since the first 1D IDCT spread components out\n      STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])\n      // constants scaled things up by 1<<12, plus we had 1<<2 from first\n      // loop, plus horizontal and vertical each scale by sqrt(8) so together\n      // we've got an extra 1<<3, so 1<<17 total we need to remove.\n      // so we want to round that, which means adding 0.5 * 1<<17,\n      // aka 65536. Also, we'll end up with -128 to 127 that we want\n      // to encode as 0..255 by adding 128, so we'll add that before the shift\n      x0 += 65536 + (128<<17);\n      x1 += 65536 + (128<<17);\n      x2 += 65536 + (128<<17);\n      x3 += 65536 + (128<<17);\n      // tried computing the shifts into temps, or'ing the temps to see\n      // if any were out of range, but that was slower\n      o[0] = stbi__clamp((x0+t3) >> 17);\n      o[7] = stbi__clamp((x0-t3) >> 17);\n      o[1] = stbi__clamp((x1+t2) >> 17);\n      o[6] = stbi__clamp((x1-t2) >> 17);\n      o[2] = stbi__clamp((x2+t1) >> 17);\n      o[5] = stbi__clamp((x2-t1) >> 17);\n      o[3] = stbi__clamp((x3+t0) >> 17);\n      o[4] = stbi__clamp((x3-t0) >> 17);\n   }\n}\n\n#ifdef STBI_SIMD\nstatic stbi_idct_8x8 stbi__idct_installed = stbi__idct_block;\n\nSTBIDEF void stbi_install_idct(stbi_idct_8x8 func)\n{\n   stbi__idct_installed = func;\n}\n#endif\n\n#define STBI__MARKER_none  0xff\n// if there's a pending marker from the entropy stream, return that\n// otherwise, fetch from the stream and get a marker. if there's no\n// marker, return 0xff, which is never a valid marker value\nstatic stbi_uc stbi__get_marker(stbi__jpeg *j)\n{\n   stbi_uc x;\n   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }\n   x = stbi__get8(j->s);\n   if (x != 0xff) return STBI__MARKER_none;\n   while (x == 0xff)\n      x = stbi__get8(j->s);\n   return x;\n}\n\n// in each scan, we'll have scan_n components, and the order\n// of the components is specified by order[]\n#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)\n\n// after a restart interval, stbi__jpeg_reset the entropy decoder and\n// the dc prediction\nstatic void stbi__jpeg_reset(stbi__jpeg *j)\n{\n   j->code_bits = 0;\n   j->code_buffer = 0;\n   j->nomore = 0;\n   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;\n   j->marker = STBI__MARKER_none;\n   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;\n   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,\n   // since we don't even allow 1<<30 pixels\n}\n\nstatic int stbi__parse_entropy_coded_data(stbi__jpeg *z)\n{\n   stbi__jpeg_reset(z);\n   if (z->scan_n == 1) {\n      int i,j;\n      #ifdef STBI_SIMD\n      __declspec(align(16))\n      #endif\n      short data[64];\n      int n = z->order[0];\n      // non-interleaved data, we just need to process one block at a time,\n      // in trivial scanline order\n      // number of blocks to do just depends on how many actual \"pixels\" this\n      // component has, independent of interleaved MCU blocking and such\n      int w = (z->img_comp[n].x+7) >> 3;\n      int h = (z->img_comp[n].y+7) >> 3;\n      for (j=0; j < h; ++j) {\n         for (i=0; i < w; ++i) {\n            if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;\n            #ifdef STBI_SIMD\n            stbi__idct_installed(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);\n            #else\n            stbi__idct_block(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);\n            #endif\n            // every data block is an MCU, so countdown the restart interval\n            if (--z->todo <= 0) {\n               if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n               // if it's NOT a restart, then just bail, so we get corrupt data\n               // rather than no data\n               if (!STBI__RESTART(z->marker)) return 1;\n               stbi__jpeg_reset(z);\n            }\n         }\n      }\n   } else { // interleaved!\n      int i,j,k,x,y;\n      short data[64];\n      for (j=0; j < z->img_mcu_y; ++j) {\n         for (i=0; i < z->img_mcu_x; ++i) {\n            // scan an interleaved mcu... process scan_n components in order\n            for (k=0; k < z->scan_n; ++k) {\n               int n = z->order[k];\n               // scan out an mcu's worth of this component; that's just determined\n               // by the basic H and V specified for the component\n               for (y=0; y < z->img_comp[n].v; ++y) {\n                  for (x=0; x < z->img_comp[n].h; ++x) {\n                     int x2 = (i*z->img_comp[n].h + x)*8;\n                     int y2 = (j*z->img_comp[n].v + y)*8;\n                     if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+z->img_comp[n].ha, n)) return 0;\n                     #ifdef STBI_SIMD\n                     stbi__idct_installed(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant2[z->img_comp[n].tq]);\n                     #else\n                     stbi__idct_block(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data, z->dequant[z->img_comp[n].tq]);\n                     #endif\n                  }\n               }\n            }\n            // after all interleaved components, that's an interleaved MCU,\n            // so now count down the restart interval\n            if (--z->todo <= 0) {\n               if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);\n               // if it's NOT a restart, then just bail, so we get corrupt data\n               // rather than no data\n               if (!STBI__RESTART(z->marker)) return 1;\n               stbi__jpeg_reset(z);\n            }\n         }\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__process_marker(stbi__jpeg *z, int m)\n{\n   int L;\n   switch (m) {\n      case STBI__MARKER_none: // no marker found\n         return stbi__err(\"expected marker\",\"Corrupt JPEG\");\n\n      case 0xC2: // stbi__SOF - progressive\n         return stbi__err(\"progressive jpeg\",\"JPEG format not supported (progressive)\");\n\n      case 0xDD: // DRI - specify restart interval\n         if (stbi__get16be(z->s) != 4) return stbi__err(\"bad DRI len\",\"Corrupt JPEG\");\n         z->restart_interval = stbi__get16be(z->s);\n         return 1;\n\n      case 0xDB: // DQT - define quantization table\n         L = stbi__get16be(z->s)-2;\n         while (L > 0) {\n            int q = stbi__get8(z->s);\n            int p = q >> 4;\n            int t = q & 15,i;\n            if (p != 0) return stbi__err(\"bad DQT type\",\"Corrupt JPEG\");\n            if (t > 3) return stbi__err(\"bad DQT table\",\"Corrupt JPEG\");\n            for (i=0; i < 64; ++i)\n               z->dequant[t][stbi__jpeg_dezigzag[i]] = stbi__get8(z->s);\n            #ifdef STBI_SIMD\n            for (i=0; i < 64; ++i)\n               z->dequant2[t][i] = z->dequant[t][i];\n            #endif\n            L -= 65;\n         }\n         return L==0;\n\n      case 0xC4: // DHT - define huffman table\n         L = stbi__get16be(z->s)-2;\n         while (L > 0) {\n            stbi_uc *v;\n            int sizes[16],i,n=0;\n            int q = stbi__get8(z->s);\n            int tc = q >> 4;\n            int th = q & 15;\n            if (tc > 1 || th > 3) return stbi__err(\"bad DHT header\",\"Corrupt JPEG\");\n            for (i=0; i < 16; ++i) {\n               sizes[i] = stbi__get8(z->s);\n               n += sizes[i];\n            }\n            L -= 17;\n            if (tc == 0) {\n               if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;\n               v = z->huff_dc[th].values;\n            } else {\n               if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;\n               v = z->huff_ac[th].values;\n            }\n            for (i=0; i < n; ++i)\n               v[i] = stbi__get8(z->s);\n            L -= n;\n         }\n         return L==0;\n   }\n   // check for comment block or APP blocks\n   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {\n      stbi__skip(z->s, stbi__get16be(z->s)-2);\n      return 1;\n   }\n   return 0;\n}\n\n// after we see stbi__SOS\nstatic int stbi__process_scan_header(stbi__jpeg *z)\n{\n   int i;\n   int Ls = stbi__get16be(z->s);\n   z->scan_n = stbi__get8(z->s);\n   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err(\"bad stbi__SOS component count\",\"Corrupt JPEG\");\n   if (Ls != 6+2*z->scan_n) return stbi__err(\"bad stbi__SOS len\",\"Corrupt JPEG\");\n   for (i=0; i < z->scan_n; ++i) {\n      int id = stbi__get8(z->s), which;\n      int q = stbi__get8(z->s);\n      for (which = 0; which < z->s->img_n; ++which)\n         if (z->img_comp[which].id == id)\n            break;\n      if (which == z->s->img_n) return 0;\n      z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err(\"bad DC huff\",\"Corrupt JPEG\");\n      z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err(\"bad AC huff\",\"Corrupt JPEG\");\n      z->order[i] = which;\n   }\n   if (stbi__get8(z->s) != 0) return stbi__err(\"bad stbi__SOS\",\"Corrupt JPEG\");\n   stbi__get8(z->s); // should be 63, but might be 0\n   if (stbi__get8(z->s) != 0) return stbi__err(\"bad stbi__SOS\",\"Corrupt JPEG\");\n\n   return 1;\n}\n\nstatic int stbi__process_frame_header(stbi__jpeg *z, int scan)\n{\n   stbi__context *s = z->s;\n   int Lf,p,i,q, h_max=1,v_max=1,c;\n   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(\"bad stbi__SOF len\",\"Corrupt JPEG\"); // JPEG\n   p  = stbi__get8(s);          if (p != 8) return stbi__err(\"only 8-bit\",\"JPEG format not supported: 8-bit only\"); // JPEG baseline\n   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(\"no header height\", \"JPEG format not supported: delayed height\"); // Legal, but we don't handle it--but neither does IJG\n   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(\"0 width\",\"Corrupt JPEG\"); // JPEG requires\n   c = stbi__get8(s);\n   if (c != 3 && c != 1) return stbi__err(\"bad component count\",\"Corrupt JPEG\");    // JFIF requires\n   s->img_n = c;\n   for (i=0; i < c; ++i) {\n      z->img_comp[i].data = NULL;\n      z->img_comp[i].linebuf = NULL;\n   }\n\n   if (Lf != 8+3*s->img_n) return stbi__err(\"bad stbi__SOF len\",\"Corrupt JPEG\");\n\n   for (i=0; i < s->img_n; ++i) {\n      z->img_comp[i].id = stbi__get8(s);\n      if (z->img_comp[i].id != i+1)   // JFIF requires\n         if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!\n            return stbi__err(\"bad component ID\",\"Corrupt JPEG\");\n      q = stbi__get8(s);\n      z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(\"bad H\",\"Corrupt JPEG\");\n      z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(\"bad V\",\"Corrupt JPEG\");\n      z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(\"bad TQ\",\"Corrupt JPEG\");\n   }\n\n   if (scan != SCAN_load) return 1;\n\n   if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\n\n   for (i=0; i < s->img_n; ++i) {\n      if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;\n      if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;\n   }\n\n   // compute interleaved mcu info\n   z->img_h_max = h_max;\n   z->img_v_max = v_max;\n   z->img_mcu_w = h_max * 8;\n   z->img_mcu_h = v_max * 8;\n   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;\n   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;\n\n   for (i=0; i < s->img_n; ++i) {\n      // number of effective pixels (e.g. for non-interleaved MCU)\n      z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;\n      z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;\n      // to simplify generation, we'll allocate enough memory to decode\n      // the bogus oversized data from using interleaved MCUs and their\n      // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't\n      // discard the extra data until colorspace conversion\n      z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;\n      z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;\n      z->img_comp[i].raw_data = stbi__malloc(z->img_comp[i].w2 * z->img_comp[i].h2+15);\n      if (z->img_comp[i].raw_data == NULL) {\n         for(--i; i >= 0; --i) {\n            free(z->img_comp[i].raw_data);\n            z->img_comp[i].data = NULL;\n         }\n         return stbi__err(\"outofmem\", \"Out of memory\");\n      }\n      // align blocks for installable-idct using mmx/sse\n      z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);\n      z->img_comp[i].linebuf = NULL;\n   }\n\n   return 1;\n}\n\n// use comparisons since in some cases we handle more than one case (e.g. stbi__SOF)\n#define stbi__DNL(x)         ((x) == 0xdc)\n#define stbi__SOI(x)         ((x) == 0xd8)\n#define stbi__EOI(x)         ((x) == 0xd9)\n#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1)\n#define stbi__SOS(x)         ((x) == 0xda)\n\nstatic int decode_jpeg_header(stbi__jpeg *z, int scan)\n{\n   int m;\n   z->marker = STBI__MARKER_none; // initialize cached marker to empty\n   m = stbi__get_marker(z);\n   if (!stbi__SOI(m)) return stbi__err(\"no stbi__SOI\",\"Corrupt JPEG\");\n   if (scan == SCAN_type) return 1;\n   m = stbi__get_marker(z);\n   while (!stbi__SOF(m)) {\n      if (!stbi__process_marker(z,m)) return 0;\n      m = stbi__get_marker(z);\n      while (m == STBI__MARKER_none) {\n         // some files have extra padding after their blocks, so ok, we'll scan\n         if (stbi__at_eof(z->s)) return stbi__err(\"no stbi__SOF\", \"Corrupt JPEG\");\n         m = stbi__get_marker(z);\n      }\n   }\n   if (!stbi__process_frame_header(z, scan)) return 0;\n   return 1;\n}\n\nstatic int decode_jpeg_image(stbi__jpeg *j)\n{\n   int m;\n   j->restart_interval = 0;\n   if (!decode_jpeg_header(j, SCAN_load)) return 0;\n   m = stbi__get_marker(j);\n   while (!stbi__EOI(m)) {\n      if (stbi__SOS(m)) {\n         if (!stbi__process_scan_header(j)) return 0;\n         if (!stbi__parse_entropy_coded_data(j)) return 0;\n         if (j->marker == STBI__MARKER_none ) {\n            // handle 0s at the end of image data from IP Kamera 9060\n            while (!stbi__at_eof(j->s)) {\n               int x = stbi__get8(j->s);\n               if (x == 255) {\n                  j->marker = stbi__get8(j->s);\n                  break;\n               } else if (x != 0) {\n                  return 0;\n               }\n            }\n            // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0\n         }\n      } else {\n         if (!stbi__process_marker(j, m)) return 0;\n      }\n      m = stbi__get_marker(j);\n   }\n   return 1;\n}\n\n// static jfif-centered resampling (across block boundaries)\n\ntypedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,\n                                    int w, int hs);\n\n#define stbi__div4(x) ((stbi_uc) ((x) >> 2))\n\nstatic stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   STBI_NOTUSED(out);\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(w);\n   STBI_NOTUSED(hs);\n   return in_near;\n}\n\nstatic stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples vertically for every one in input\n   int i;\n   STBI_NOTUSED(hs);\n   for (i=0; i < w; ++i)\n      out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);\n   return out;\n}\n\nstatic stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate two samples horizontally for every one in input\n   int i;\n   stbi_uc *input = in_near;\n\n   if (w == 1) {\n      // if only one sample, can't do any interpolation\n      out[0] = out[1] = input[0];\n      return out;\n   }\n\n   out[0] = input[0];\n   out[1] = stbi__div4(input[0]*3 + input[1] + 2);\n   for (i=1; i < w-1; ++i) {\n      int n = 3*input[i]+2;\n      out[i*2+0] = stbi__div4(n+input[i-1]);\n      out[i*2+1] = stbi__div4(n+input[i+1]);\n   }\n   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);\n   out[i*2+1] = input[w-1];\n\n   STBI_NOTUSED(in_far);\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\n#define stbi__div16(x) ((stbi_uc) ((x) >> 4))\n\nstatic stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // need to generate 2x2 samples for every one in input\n   int i,t0,t1;\n   if (w == 1) {\n      out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);\n      return out;\n   }\n\n   t1 = 3*in_near[0] + in_far[0];\n   out[0] = stbi__div4(t1+2);\n   for (i=1; i < w; ++i) {\n      t0 = t1;\n      t1 = 3*in_near[i]+in_far[i];\n      out[i*2-1] = stbi__div16(3*t0 + t1 + 8);\n      out[i*2  ] = stbi__div16(3*t1 + t0 + 8);\n   }\n   out[w*2-1] = stbi__div4(t1+2);\n\n   STBI_NOTUSED(hs);\n\n   return out;\n}\n\nstatic stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)\n{\n   // resample with nearest-neighbor\n   int i,j;\n   STBI_NOTUSED(in_far);\n   for (i=0; i < w; ++i)\n      for (j=0; j < hs; ++j)\n         out[i*hs+j] = in_near[i];\n   return out;\n}\n\n#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))\n\n// 0.38 seconds on 3*anemones.jpg   (0.25 with processor = Pro)\n// VC6 without processor=Pro is generating multiple LEAs per multiply!\nstatic void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)\n{\n   int i;\n   for (i=0; i < count; ++i) {\n      int y_fixed = (y[i] << 16) + 32768; // rounding\n      int r,g,b;\n      int cr = pcr[i] - 128;\n      int cb = pcb[i] - 128;\n      r = y_fixed + cr*float2fixed(1.40200f);\n      g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);\n      b = y_fixed                            + cb*float2fixed(1.77200f);\n      r >>= 16;\n      g >>= 16;\n      b >>= 16;\n      if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }\n      if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }\n      if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }\n      out[0] = (stbi_uc)r;\n      out[1] = (stbi_uc)g;\n      out[2] = (stbi_uc)b;\n      out[3] = 255;\n      out += step;\n   }\n}\n\n#ifdef STBI_SIMD\nstatic stbi_YCbCr_to_RGB_run stbi__YCbCr_installed = stbi__YCbCr_to_RGB_row;\n\nSTBIDEF void stbi_install_YCbCr_to_RGB(stbi_YCbCr_to_RGB_run func)\n{\n   stbi__YCbCr_installed = func;\n}\n#endif\n\n\n// clean up the temporary component buffers\nstatic void stbi__cleanup_jpeg(stbi__jpeg *j)\n{\n   int i;\n   for (i=0; i < j->s->img_n; ++i) {\n      if (j->img_comp[i].raw_data) {\n         free(j->img_comp[i].raw_data);\n         j->img_comp[i].raw_data = NULL;\n         j->img_comp[i].data = NULL;\n      }\n      if (j->img_comp[i].linebuf) {\n         free(j->img_comp[i].linebuf);\n         j->img_comp[i].linebuf = NULL;\n      }\n   }\n}\n\ntypedef struct\n{\n   resample_row_func resample;\n   stbi_uc *line0,*line1;\n   int hs,vs;   // expansion factor in each axis\n   int w_lores; // horizontal pixels pre-expansion \n   int ystep;   // how far through vertical expansion we are\n   int ypos;    // which pre-expansion row we're on\n} stbi__resample;\n\nstatic stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)\n{\n   int n, decode_n;\n   z->s->img_n = 0; // make stbi__cleanup_jpeg safe\n\n   // validate req_comp\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n\n   // load a jpeg image from whichever source\n   if (!decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }\n\n   // determine actual number of components to generate\n   n = req_comp ? req_comp : z->s->img_n;\n\n   if (z->s->img_n == 3 && n < 3)\n      decode_n = 1;\n   else\n      decode_n = z->s->img_n;\n\n   // resample and color-convert\n   {\n      int k;\n      unsigned int i,j;\n      stbi_uc *output;\n      stbi_uc *coutput[4];\n\n      stbi__resample res_comp[4];\n\n      for (k=0; k < decode_n; ++k) {\n         stbi__resample *r = &res_comp[k];\n\n         // allocate line buffer big enough for upsampling off the edges\n         // with upsample factor of 4\n         z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);\n         if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n         r->hs      = z->img_h_max / z->img_comp[k].h;\n         r->vs      = z->img_v_max / z->img_comp[k].v;\n         r->ystep   = r->vs >> 1;\n         r->w_lores = (z->s->img_x + r->hs-1) / r->hs;\n         r->ypos    = 0;\n         r->line0   = r->line1 = z->img_comp[k].data;\n\n         if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;\n         else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;\n         else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;\n         else if (r->hs == 2 && r->vs == 2) r->resample = stbi__resample_row_hv_2;\n         else                               r->resample = stbi__resample_row_generic;\n      }\n\n      // can't error after this so, this is safe\n      output = (stbi_uc *) stbi__malloc(n * z->s->img_x * z->s->img_y + 1);\n      if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc(\"outofmem\", \"Out of memory\"); }\n\n      // now go ahead and resample\n      for (j=0; j < z->s->img_y; ++j) {\n         stbi_uc *out = output + n * z->s->img_x * j;\n         for (k=0; k < decode_n; ++k) {\n            stbi__resample *r = &res_comp[k];\n            int y_bot = r->ystep >= (r->vs >> 1);\n            coutput[k] = r->resample(z->img_comp[k].linebuf,\n                                     y_bot ? r->line1 : r->line0,\n                                     y_bot ? r->line0 : r->line1,\n                                     r->w_lores, r->hs);\n            if (++r->ystep >= r->vs) {\n               r->ystep = 0;\n               r->line0 = r->line1;\n               if (++r->ypos < z->img_comp[k].y)\n                  r->line1 += z->img_comp[k].w2;\n            }\n         }\n         if (n >= 3) {\n            stbi_uc *y = coutput[0];\n            if (z->s->img_n == 3) {\n               #ifdef STBI_SIMD\n               stbi__YCbCr_installed(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               #else\n               stbi__YCbCr_to_RGB_row(out, y, coutput[1], coutput[2], z->s->img_x, n);\n               #endif\n            } else\n               for (i=0; i < z->s->img_x; ++i) {\n                  out[0] = out[1] = out[2] = y[i];\n                  out[3] = 255; // not used if n==3\n                  out += n;\n               }\n         } else {\n            stbi_uc *y = coutput[0];\n            if (n == 1)\n               for (i=0; i < z->s->img_x; ++i) out[i] = y[i];\n            else\n               for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;\n         }\n      }\n      stbi__cleanup_jpeg(z);\n      *out_x = z->s->img_x;\n      *out_y = z->s->img_y;\n      if (comp) *comp  = z->s->img_n; // report original components, not output\n      return output;\n   }\n}\n\nstatic unsigned char *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__jpeg j;\n   j.s = s;\n   return load_jpeg_image(&j, x,y,comp,req_comp);\n}\n\nstatic int stbi__jpeg_test(stbi__context *s)\n{\n   int r;\n   stbi__jpeg j;\n   j.s = s;\n   r = decode_jpeg_header(&j, SCAN_type);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)\n{\n   if (!decode_jpeg_header(j, SCAN_header)) {\n      stbi__rewind( j->s );\n      return 0;\n   }\n   if (x) *x = j->s->img_x;\n   if (y) *y = j->s->img_y;\n   if (comp) *comp = j->s->img_n;\n   return 1;\n}\n\nstatic int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__jpeg j;\n   j.s = s;\n   return stbi__jpeg_info_raw(&j, x, y, comp);\n}\n\n// public domain zlib decode    v0.2  Sean Barrett 2006-11-18\n//    simple implementation\n//      - all input must be provided in an upfront buffer\n//      - all output is written to a single output buffer (can malloc/realloc)\n//    performance\n//      - fast huffman\n\n// fast-way is faster to check than jpeg huffman, but slow way is slower\n#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables\n#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)\n\n// zlib-style huffman encoding\n// (jpegs packs from left, zlib from right, so can't share code)\ntypedef struct\n{\n   stbi__uint16 fast[1 << STBI__ZFAST_BITS];\n   stbi__uint16 firstcode[16];\n   int maxcode[17];\n   stbi__uint16 firstsymbol[16];\n   stbi_uc  size[288];\n   stbi__uint16 value[288]; \n} stbi__zhuffman;\n\nstbi_inline static int stbi__bitreverse16(int n)\n{\n  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);\n  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);\n  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);\n  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);\n  return n;\n}\n\nstbi_inline static int stbi__bit_reverse(int v, int bits)\n{\n   STBI_ASSERT(bits <= 16);\n   // to bit reverse n bits, reverse 16 and shift\n   // e.g. 11 bits, bit reverse and shift away 5\n   return stbi__bitreverse16(v) >> (16-bits);\n}\n\nstatic int stbi__zbuild_huffman(stbi__zhuffman *z, stbi_uc *sizelist, int num)\n{\n   int i,k=0;\n   int code, next_code[16], sizes[17];\n\n   // DEFLATE spec for generating codes\n   memset(sizes, 0, sizeof(sizes));\n   memset(z->fast, 255, sizeof(z->fast));\n   for (i=0; i < num; ++i) \n      ++sizes[sizelist[i]];\n   sizes[0] = 0;\n   for (i=1; i < 16; ++i)\n      STBI_ASSERT(sizes[i] <= (1 << i));\n   code = 0;\n   for (i=1; i < 16; ++i) {\n      next_code[i] = code;\n      z->firstcode[i] = (stbi__uint16) code;\n      z->firstsymbol[i] = (stbi__uint16) k;\n      code = (code + sizes[i]);\n      if (sizes[i])\n         if (code-1 >= (1 << i)) return stbi__err(\"bad codelengths\",\"Corrupt JPEG\");\n      z->maxcode[i] = code << (16-i); // preshift for inner loop\n      code <<= 1;\n      k += sizes[i];\n   }\n   z->maxcode[16] = 0x10000; // sentinel\n   for (i=0; i < num; ++i) {\n      int s = sizelist[i];\n      if (s) {\n         int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];\n         z->size [c] = (stbi_uc     ) s;\n         z->value[c] = (stbi__uint16) i;\n         if (s <= STBI__ZFAST_BITS) {\n            int k = stbi__bit_reverse(next_code[s],s);\n            while (k < (1 << STBI__ZFAST_BITS)) {\n               z->fast[k] = (stbi__uint16) c;\n               k += (1 << s);\n            }\n         }\n         ++next_code[s];\n      }\n   }\n   return 1;\n}\n\n// zlib-from-memory implementation for PNG reading\n//    because PNG allows splitting the zlib stream arbitrarily,\n//    and it's annoying structurally to have PNG call ZLIB call PNG,\n//    we require PNG read all the IDATs and combine them into a single\n//    memory buffer\n\ntypedef struct\n{\n   stbi_uc *zbuffer, *zbuffer_end;\n   int num_bits;\n   stbi__uint32 code_buffer;\n\n   char *zout;\n   char *zout_start;\n   char *zout_end;\n   int   z_expandable;\n\n   stbi__zhuffman z_length, z_distance;\n} stbi__zbuf;\n\nstbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)\n{\n   if (z->zbuffer >= z->zbuffer_end) return 0;\n   return *z->zbuffer++;\n}\n\nstatic void stbi__fill_bits(stbi__zbuf *z)\n{\n   do {\n      STBI_ASSERT(z->code_buffer < (1U << z->num_bits));\n      z->code_buffer |= stbi__zget8(z) << z->num_bits;\n      z->num_bits += 8;\n   } while (z->num_bits <= 24);\n}\n\nstbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)\n{\n   unsigned int k;\n   if (z->num_bits < n) stbi__fill_bits(z);\n   k = z->code_buffer & ((1 << n) - 1);\n   z->code_buffer >>= n;\n   z->num_bits -= n;\n   return k;   \n}\n\nstbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)\n{\n   int b,s,k;\n   if (a->num_bits < 16) stbi__fill_bits(a);\n   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];\n   if (b < 0xffff) {\n      s = z->size[b];\n      a->code_buffer >>= s;\n      a->num_bits -= s;\n      return z->value[b];\n   }\n\n   // not resolved by fast table, so compute it the slow way\n   // use jpeg approach, which requires MSbits at top\n   k = stbi__bit_reverse(a->code_buffer, 16);\n   for (s=STBI__ZFAST_BITS+1; ; ++s)\n      if (k < z->maxcode[s])\n         break;\n   if (s == 16) return -1; // invalid code!\n   // code size is s, so:\n   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];\n   STBI_ASSERT(z->size[b] == s);\n   a->code_buffer >>= s;\n   a->num_bits -= s;\n   return z->value[b];\n}\n\nstatic int stbi__zexpand(stbi__zbuf *z, int n)  // need to make room for n bytes\n{\n   char *q;\n   int cur, limit;\n   if (!z->z_expandable) return stbi__err(\"output buffer limit\",\"Corrupt PNG\");\n   cur   = (int) (z->zout     - z->zout_start);\n   limit = (int) (z->zout_end - z->zout_start);\n   while (cur + n > limit)\n      limit *= 2;\n   q = (char *) realloc(z->zout_start, limit);\n   if (q == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n   z->zout_start = q;\n   z->zout       = q + cur;\n   z->zout_end   = q + limit;\n   return 1;\n}\n\nstatic int stbi__zlength_base[31] = {\n   3,4,5,6,7,8,9,10,11,13,\n   15,17,19,23,27,31,35,43,51,59,\n   67,83,99,115,131,163,195,227,258,0,0 };\n\nstatic int stbi__zlength_extra[31]= \n{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\n\nstatic int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,\n257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\n\nstatic int stbi__zdist_extra[32] =\n{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n\nstatic int stbi__parse_huffman_block(stbi__zbuf *a)\n{\n   for(;;) {\n      int z = stbi__zhuffman_decode(a, &a->z_length);\n      if (z < 256) {\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\"); // error in huffman codes\n         if (a->zout >= a->zout_end) if (!stbi__zexpand(a, 1)) return 0;\n         *a->zout++ = (char) z;\n      } else {\n         stbi_uc *p;\n         int len,dist;\n         if (z == 256) return 1;\n         z -= 257;\n         len = stbi__zlength_base[z];\n         if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);\n         z = stbi__zhuffman_decode(a, &a->z_distance);\n         if (z < 0) return stbi__err(\"bad huffman code\",\"Corrupt PNG\");\n         dist = stbi__zdist_base[z];\n         if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);\n         if (a->zout - a->zout_start < dist) return stbi__err(\"bad dist\",\"Corrupt PNG\");\n         if (a->zout + len > a->zout_end) if (!stbi__zexpand(a, len)) return 0;\n         p = (stbi_uc *) (a->zout - dist);\n         while (len--)\n            *a->zout++ = *p++;\n      }\n   }\n}\n\nstatic int stbi__compute_huffman_codes(stbi__zbuf *a)\n{\n   static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\n   stbi__zhuffman z_codelength;\n   stbi_uc lencodes[286+32+137];//padding for maximum single op\n   stbi_uc codelength_sizes[19];\n   int i,n;\n\n   int hlit  = stbi__zreceive(a,5) + 257;\n   int hdist = stbi__zreceive(a,5) + 1;\n   int hclen = stbi__zreceive(a,4) + 4;\n\n   memset(codelength_sizes, 0, sizeof(codelength_sizes));\n   for (i=0; i < hclen; ++i) {\n      int s = stbi__zreceive(a,3);\n      codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;\n   }\n   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;\n\n   n = 0;\n   while (n < hlit + hdist) {\n      int c = stbi__zhuffman_decode(a, &z_codelength);\n      STBI_ASSERT(c >= 0 && c < 19);\n      if (c < 16)\n         lencodes[n++] = (stbi_uc) c;\n      else if (c == 16) {\n         c = stbi__zreceive(a,2)+3;\n         memset(lencodes+n, lencodes[n-1], c);\n         n += c;\n      } else if (c == 17) {\n         c = stbi__zreceive(a,3)+3;\n         memset(lencodes+n, 0, c);\n         n += c;\n      } else {\n         STBI_ASSERT(c == 18);\n         c = stbi__zreceive(a,7)+11;\n         memset(lencodes+n, 0, c);\n         n += c;\n      }\n   }\n   if (n != hlit+hdist) return stbi__err(\"bad codelengths\",\"Corrupt PNG\");\n   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;\n   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;\n   return 1;\n}\n\nstatic int stbi__parse_uncomperssed_block(stbi__zbuf *a)\n{\n   stbi_uc header[4];\n   int len,nlen,k;\n   if (a->num_bits & 7)\n      stbi__zreceive(a, a->num_bits & 7); // discard\n   // drain the bit-packed data into header\n   k = 0;\n   while (a->num_bits > 0) {\n      header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check\n      a->code_buffer >>= 8;\n      a->num_bits -= 8;\n   }\n   STBI_ASSERT(a->num_bits == 0);\n   // now fill header the normal way\n   while (k < 4)\n      header[k++] = stbi__zget8(a);\n   len  = header[1] * 256 + header[0];\n   nlen = header[3] * 256 + header[2];\n   if (nlen != (len ^ 0xffff)) return stbi__err(\"zlib corrupt\",\"Corrupt PNG\");\n   if (a->zbuffer + len > a->zbuffer_end) return stbi__err(\"read past buffer\",\"Corrupt PNG\");\n   if (a->zout + len > a->zout_end)\n      if (!stbi__zexpand(a, len)) return 0;\n   memcpy(a->zout, a->zbuffer, len);\n   a->zbuffer += len;\n   a->zout += len;\n   return 1;\n}\n\nstatic int stbi__parse_zlib_header(stbi__zbuf *a)\n{\n   int cmf   = stbi__zget8(a);\n   int cm    = cmf & 15;\n   /* int cinfo = cmf >> 4; */\n   int flg   = stbi__zget8(a);\n   if ((cmf*256+flg) % 31 != 0) return stbi__err(\"bad zlib header\",\"Corrupt PNG\"); // zlib spec\n   if (flg & 32) return stbi__err(\"no preset dict\",\"Corrupt PNG\"); // preset dictionary not allowed in png\n   if (cm != 8) return stbi__err(\"bad compression\",\"Corrupt PNG\"); // DEFLATE required for png\n   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output\n   return 1;\n}\n\n// @TODO: should statically initialize these for optimal thread safety\nstatic stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];\nstatic void stbi__init_zdefaults(void)\n{\n   int i;   // use <= to match clearly with spec\n   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;\n   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;\n   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;\n   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;\n\n   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;\n}\n\nstatic int stbi__parse_zlib(stbi__zbuf *a, int parse_header)\n{\n   int final, type;\n   if (parse_header)\n      if (!stbi__parse_zlib_header(a)) return 0;\n   a->num_bits = 0;\n   a->code_buffer = 0;\n   do {\n      final = stbi__zreceive(a,1);\n      type = stbi__zreceive(a,2);\n      if (type == 0) {\n         if (!stbi__parse_uncomperssed_block(a)) return 0;\n      } else if (type == 3) {\n         return 0;\n      } else {\n         if (type == 1) {\n            // use fixed code lengths\n            if (!stbi__zdefault_distance[31]) stbi__init_zdefaults();\n            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;\n            if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;\n         } else {\n            if (!stbi__compute_huffman_codes(a)) return 0;\n         }\n         if (!stbi__parse_huffman_block(a)) return 0;\n      }\n   } while (!final);\n   return 1;\n}\n\nstatic int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)\n{\n   a->zout_start = obuf;\n   a->zout       = obuf;\n   a->zout_end   = obuf + olen;\n   a->z_expandable = exp;\n\n   return stbi__parse_zlib(a, parse_header);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      free(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)\n{\n   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);\n}\n\nSTBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(initial_size);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer + len;\n   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      free(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n\nSTBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)\n{\n   stbi__zbuf a;\n   char *p = (char *) stbi__malloc(16384);\n   if (p == NULL) return NULL;\n   a.zbuffer = (stbi_uc *) buffer;\n   a.zbuffer_end = (stbi_uc *) buffer+len;\n   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {\n      if (outlen) *outlen = (int) (a.zout - a.zout_start);\n      return a.zout_start;\n   } else {\n      free(a.zout_start);\n      return NULL;\n   }\n}\n\nSTBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)\n{\n   stbi__zbuf a;\n   a.zbuffer = (stbi_uc *) ibuffer;\n   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;\n   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))\n      return (int) (a.zout - a.zout_start);\n   else\n      return -1;\n}\n\n// public domain \"baseline\" PNG decoder   v0.10  Sean Barrett 2006-11-18\n//    simple implementation\n//      - only 8-bit samples\n//      - no CRC checking\n//      - allocates lots of intermediate memory\n//        - avoids problem of streaming data between subsystems\n//        - avoids explicit window management\n//    performance\n//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding\n\n\ntypedef struct\n{\n   stbi__uint32 length;\n   stbi__uint32 type;\n} stbi__pngchunk;\n\n#define PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))\n\nstatic stbi__pngchunk stbi__get_chunk_header(stbi__context *s)\n{\n   stbi__pngchunk c;\n   c.length = stbi__get32be(s);\n   c.type   = stbi__get32be(s);\n   return c;\n}\n\nstatic int stbi__check_png_header(stbi__context *s)\n{\n   static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };\n   int i;\n   for (i=0; i < 8; ++i)\n      if (stbi__get8(s) != png_sig[i]) return stbi__err(\"bad png sig\",\"Not a PNG\");\n   return 1;\n}\n\ntypedef struct\n{\n   stbi__context *s;\n   stbi_uc *idata, *expanded, *out;\n} stbi__png;\n\n\nenum {\n   STBI__F_none=0, STBI__F_sub=1, STBI__F_up=2, STBI__F_avg=3, STBI__F_paeth=4,\n   STBI__F_avg_first, STBI__F_paeth_first\n};\n\nstatic stbi_uc first_row_filter[5] =\n{\n   STBI__F_none, STBI__F_sub, STBI__F_none, STBI__F_avg_first, STBI__F_paeth_first\n};\n\nstatic int stbi__paeth(int a, int b, int c)\n{\n   int p = a + b - c;\n   int pa = abs(p-a);\n   int pb = abs(p-b);\n   int pc = abs(p-c);\n   if (pa <= pb && pa <= pc) return a;\n   if (pb <= pc) return b;\n   return c;\n}\n\n#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings\n\n// create the png data from post-deflated data\nstatic int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y)\n{\n   stbi__context *s = a->s;\n   stbi__uint32 i,j,stride = x*out_n;\n   int k;\n   int img_n = s->img_n; // copy it into a local for later\n   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);\n   a->out = (stbi_uc *) stbi__malloc(x * y * out_n);\n   if (!a->out) return stbi__err(\"outofmem\", \"Out of memory\");\n   if (s->img_x == x && s->img_y == y) {\n      if (raw_len != (img_n * x + 1) * y) return stbi__err(\"not enough pixels\",\"Corrupt PNG\");\n   } else { // interlaced:\n      if (raw_len < (img_n * x + 1) * y) return stbi__err(\"not enough pixels\",\"Corrupt PNG\");\n   }\n   for (j=0; j < y; ++j) {\n      stbi_uc *cur = a->out + stride*j;\n      stbi_uc *prior = cur - stride;\n      int filter = *raw++;\n      if (filter > 4) return stbi__err(\"invalid filter\",\"Corrupt PNG\");\n      // if first row, use special filter that doesn't sample previous row\n      if (j == 0) filter = first_row_filter[filter];\n      // handle first pixel explicitly\n      for (k=0; k < img_n; ++k) {\n         switch (filter) {\n            case STBI__F_none       : cur[k] = raw[k]; break;\n            case STBI__F_sub        : cur[k] = raw[k]; break;\n            case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\n            case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;\n            case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;\n            case STBI__F_avg_first  : cur[k] = raw[k]; break;\n            case STBI__F_paeth_first: cur[k] = raw[k]; break;\n         }\n      }\n      if (img_n != out_n) cur[img_n] = 255;\n      raw += img_n;\n      cur += out_n;\n      prior += out_n;\n      // this is a little gross, so that we don't switch per-pixel or per-component\n      if (img_n == out_n) {\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, raw+=img_n,cur+=img_n,prior+=img_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch (filter) {\n            CASE(STBI__F_none)         cur[k] = raw[k]; break;\n            CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-img_n]); break;\n            CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\n            CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-img_n])>>1)); break;\n            CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-img_n],prior[k],prior[k-img_n])); break;\n            CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k-img_n] >> 1)); break;\n            CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-img_n],0,0)); break;\n         }\n         #undef CASE\n      } else {\n         STBI_ASSERT(img_n+1 == out_n);\n         #define CASE(f) \\\n             case f:     \\\n                for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \\\n                   for (k=0; k < img_n; ++k)\n         switch (filter) {\n            CASE(STBI__F_none)         cur[k] = raw[k]; break;\n            CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-out_n]); break;\n            CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;\n            CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-out_n])>>1)); break;\n            CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;\n            CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k-out_n] >> 1)); break;\n            CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-out_n],0,0)); break;\n         }\n         #undef CASE\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__create_png_image(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, int interlaced)\n{\n   stbi_uc *final;\n   int p;\n   if (!interlaced)\n      return stbi__create_png_image_raw(a, raw, raw_len, out_n, a->s->img_x, a->s->img_y);\n\n   // de-interlacing\n   final = (stbi_uc *) stbi__malloc(a->s->img_x * a->s->img_y * out_n);\n   for (p=0; p < 7; ++p) {\n      int xorig[] = { 0,4,0,2,0,1,0 };\n      int yorig[] = { 0,0,4,0,2,0,1 };\n      int xspc[]  = { 8,8,4,4,2,2,1 };\n      int yspc[]  = { 8,8,8,4,4,2,2 };\n      int i,j,x,y;\n      // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1\n      x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];\n      y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];\n      if (x && y) {\n         if (!stbi__create_png_image_raw(a, raw, raw_len, out_n, x, y)) {\n            free(final);\n            return 0;\n         }\n         for (j=0; j < y; ++j)\n            for (i=0; i < x; ++i)\n               memcpy(final + (j*yspc[p]+yorig[p])*a->s->img_x*out_n + (i*xspc[p]+xorig[p])*out_n,\n                      a->out + (j*x+i)*out_n, out_n);\n         free(a->out);\n         raw += (x*out_n+1)*y;\n         raw_len -= (x*out_n+1)*y;\n      }\n   }\n   a->out = final;\n\n   return 1;\n}\n\nstatic int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   // compute color-based transparency, assuming we've\n   // already got 255 as the alpha value in the output\n   STBI_ASSERT(out_n == 2 || out_n == 4);\n\n   if (out_n == 2) {\n      for (i=0; i < pixel_count; ++i) {\n         p[1] = (p[0] == tc[0] ? 0 : 255);\n         p += 2;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])\n            p[3] = 0;\n         p += 4;\n      }\n   }\n   return 1;\n}\n\nstatic int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)\n{\n   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;\n   stbi_uc *p, *temp_out, *orig = a->out;\n\n   p = (stbi_uc *) stbi__malloc(pixel_count * pal_img_n);\n   if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n\n   // between here and free(out) below, exitting would leak\n   temp_out = p;\n\n   if (pal_img_n == 3) {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p += 3;\n      }\n   } else {\n      for (i=0; i < pixel_count; ++i) {\n         int n = orig[i]*4;\n         p[0] = palette[n  ];\n         p[1] = palette[n+1];\n         p[2] = palette[n+2];\n         p[3] = palette[n+3];\n         p += 4;\n      }\n   }\n   free(a->out);\n   a->out = temp_out;\n\n   STBI_NOTUSED(len);\n\n   return 1;\n}\n\nstatic int stbi__unpremultiply_on_load = 0;\nstatic int stbi__de_iphone_flag = 0;\n\nSTBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)\n{\n   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;\n}\n\nSTBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)\n{\n   stbi__de_iphone_flag = flag_true_if_should_convert;\n}\n\nstatic void stbi__de_iphone(stbi__png *z)\n{\n   stbi__context *s = z->s;\n   stbi__uint32 i, pixel_count = s->img_x * s->img_y;\n   stbi_uc *p = z->out;\n\n   if (s->img_out_n == 3) {  // convert bgr to rgb\n      for (i=0; i < pixel_count; ++i) {\n         stbi_uc t = p[0];\n         p[0] = p[2];\n         p[2] = t;\n         p += 3;\n      }\n   } else {\n      STBI_ASSERT(s->img_out_n == 4);\n      if (stbi__unpremultiply_on_load) {\n         // convert bgr to rgb and unpremultiply\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc a = p[3];\n            stbi_uc t = p[0];\n            if (a) {\n               p[0] = p[2] * 255 / a;\n               p[1] = p[1] * 255 / a;\n               p[2] =  t   * 255 / a;\n            } else {\n               p[0] = p[2];\n               p[2] = t;\n            } \n            p += 4;\n         }\n      } else {\n         // convert bgr to rgb\n         for (i=0; i < pixel_count; ++i) {\n            stbi_uc t = p[0];\n            p[0] = p[2];\n            p[2] = t;\n            p += 4;\n         }\n      }\n   }\n}\n\nstatic int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)\n{\n   stbi_uc palette[1024], pal_img_n=0;\n   stbi_uc has_trans=0, tc[3];\n   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;\n   int first=1,k,interlace=0, is_iphone=0;\n   stbi__context *s = z->s;\n\n   z->expanded = NULL;\n   z->idata = NULL;\n   z->out = NULL;\n\n   if (!stbi__check_png_header(s)) return 0;\n\n   if (scan == SCAN_type) return 1;\n\n   for (;;) {\n      stbi__pngchunk c = stbi__get_chunk_header(s);\n      switch (c.type) {\n         case PNG_TYPE('C','g','B','I'):\n            is_iphone = 1;\n            stbi__skip(s, c.length);\n            break;\n         case PNG_TYPE('I','H','D','R'): {\n            int depth,color,comp,filter;\n            if (!first) return stbi__err(\"multiple IHDR\",\"Corrupt PNG\");\n            first = 0;\n            if (c.length != 13) return stbi__err(\"bad IHDR len\",\"Corrupt PNG\");\n            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err(\"too large\",\"Very large image (corrupt?)\");\n            depth = stbi__get8(s);  if (depth != 8)        return stbi__err(\"8bit only\",\"PNG not supported: 8-bit only\");\n            color = stbi__get8(s);  if (color > 6)         return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err(\"bad ctype\",\"Corrupt PNG\");\n            comp  = stbi__get8(s);  if (comp) return stbi__err(\"bad comp method\",\"Corrupt PNG\");\n            filter= stbi__get8(s);  if (filter) return stbi__err(\"bad filter method\",\"Corrupt PNG\");\n            interlace = stbi__get8(s); if (interlace>1) return stbi__err(\"bad interlace method\",\"Corrupt PNG\");\n            if (!s->img_x || !s->img_y) return stbi__err(\"0-pixel image\",\"Corrupt PNG\");\n            if (!pal_img_n) {\n               s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);\n               if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err(\"too large\", \"Image too large to decode\");\n               if (scan == SCAN_header) return 1;\n            } else {\n               // if paletted, then pal_n is our final components, and\n               // img_n is # components to decompress/filter.\n               s->img_n = 1;\n               if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err(\"too large\",\"Corrupt PNG\");\n               // if SCAN_header, have to scan to see if we have a tRNS\n            }\n            break;\n         }\n\n         case PNG_TYPE('P','L','T','E'):  {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (c.length > 256*3) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            pal_len = c.length / 3;\n            if (pal_len * 3 != c.length) return stbi__err(\"invalid PLTE\",\"Corrupt PNG\");\n            for (i=0; i < pal_len; ++i) {\n               palette[i*4+0] = stbi__get8(s);\n               palette[i*4+1] = stbi__get8(s);\n               palette[i*4+2] = stbi__get8(s);\n               palette[i*4+3] = 255;\n            }\n            break;\n         }\n\n         case PNG_TYPE('t','R','N','S'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (z->idata) return stbi__err(\"tRNS after IDAT\",\"Corrupt PNG\");\n            if (pal_img_n) {\n               if (scan == SCAN_header) { s->img_n = 4; return 1; }\n               if (pal_len == 0) return stbi__err(\"tRNS before PLTE\",\"Corrupt PNG\");\n               if (c.length > pal_len) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               pal_img_n = 4;\n               for (i=0; i < c.length; ++i)\n                  palette[i*4+3] = stbi__get8(s);\n            } else {\n               if (!(s->img_n & 1)) return stbi__err(\"tRNS with alpha\",\"Corrupt PNG\");\n               if (c.length != (stbi__uint32) s->img_n*2) return stbi__err(\"bad tRNS len\",\"Corrupt PNG\");\n               has_trans = 1;\n               for (k=0; k < s->img_n; ++k)\n                  tc[k] = (stbi_uc) (stbi__get16be(s) & 255); // non 8-bit images will be larger\n            }\n            break;\n         }\n\n         case PNG_TYPE('I','D','A','T'): {\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (pal_img_n && !pal_len) return stbi__err(\"no PLTE\",\"Corrupt PNG\");\n            if (scan == SCAN_header) { s->img_n = pal_img_n; return 1; }\n            if (ioff + c.length > idata_limit) {\n               stbi_uc *p;\n               if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;\n               while (ioff + c.length > idata_limit)\n                  idata_limit *= 2;\n               p = (stbi_uc *) realloc(z->idata, idata_limit); if (p == NULL) return stbi__err(\"outofmem\", \"Out of memory\");\n               z->idata = p;\n            }\n            if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err(\"outofdata\",\"Corrupt PNG\");\n            ioff += c.length;\n            break;\n         }\n\n         case PNG_TYPE('I','E','N','D'): {\n            stbi__uint32 raw_len;\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if (scan != SCAN_load) return 1;\n            if (z->idata == NULL) return stbi__err(\"no IDAT\",\"Corrupt PNG\");\n            z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, 16384, (int *) &raw_len, !is_iphone);\n            if (z->expanded == NULL) return 0; // zlib should set error\n            free(z->idata); z->idata = NULL;\n            if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)\n               s->img_out_n = s->img_n+1;\n            else\n               s->img_out_n = s->img_n;\n            if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, interlace)) return 0;\n            if (has_trans)\n               if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;\n            if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)\n               stbi__de_iphone(z);\n            if (pal_img_n) {\n               // pal_img_n == 3 or 4\n               s->img_n = pal_img_n; // record the actual colors we had\n               s->img_out_n = pal_img_n;\n               if (req_comp >= 3) s->img_out_n = req_comp;\n               if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))\n                  return 0;\n            }\n            free(z->expanded); z->expanded = NULL;\n            return 1;\n         }\n\n         default:\n            // if critical, fail\n            if (first) return stbi__err(\"first not IHDR\", \"Corrupt PNG\");\n            if ((c.type & (1 << 29)) == 0) {\n               #ifndef STBI_NO_FAILURE_STRINGS\n               // not threadsafe\n               static char invalid_chunk[] = \"XXXX PNG chunk not known\";\n               invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);\n               invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);\n               invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);\n               invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);\n               #endif\n               return stbi__err(invalid_chunk, \"PNG not supported: unknown PNG chunk type\");\n            }\n            stbi__skip(s, c.length);\n            break;\n      }\n      // end of PNG chunk, read and skip CRC\n      stbi__get32be(s);\n   }\n}\n\nstatic unsigned char *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp)\n{\n   unsigned char *result=NULL;\n   if (req_comp < 0 || req_comp > 4) return stbi__errpuc(\"bad req_comp\", \"Internal error\");\n   if (stbi__parse_png_file(p, SCAN_load, req_comp)) {\n      result = p->out;\n      p->out = NULL;\n      if (req_comp && req_comp != p->s->img_out_n) {\n         result = stbi__convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);\n         p->s->img_out_n = req_comp;\n         if (result == NULL) return result;\n      }\n      *x = p->s->img_x;\n      *y = p->s->img_y;\n      if (n) *n = p->s->img_out_n;\n   }\n   free(p->out);      p->out      = NULL;\n   free(p->expanded); p->expanded = NULL;\n   free(p->idata);    p->idata    = NULL;\n\n   return result;\n}\n\nstatic unsigned char *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__do_png(&p, x,y,comp,req_comp);\n}\n\nstatic int stbi__png_test(stbi__context *s)\n{\n   int r;\n   r = stbi__check_png_header(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)\n{\n   if (!stbi__parse_png_file(p, SCAN_header, 0)) {\n      stbi__rewind( p->s );\n      return 0;\n   }\n   if (x) *x = p->s->img_x;\n   if (y) *y = p->s->img_y;\n   if (comp) *comp = p->s->img_n;\n   return 1;\n}\n\nstatic int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__png p;\n   p.s = s;\n   return stbi__png_info_raw(&p, x, y, comp);\n}\n\n// Microsoft/Windows BMP image\nstatic int stbi__bmp_test_raw(stbi__context *s)\n{\n   int r;\n   int sz;\n   if (stbi__get8(s) != 'B') return 0;\n   if (stbi__get8(s) != 'M') return 0;\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   stbi__get32le(s); // discard data offset\n   sz = stbi__get32le(s);\n   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);\n   return r;\n}\n\nstatic int stbi__bmp_test(stbi__context *s)\n{\n   int r = stbi__bmp_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\n\n// returns 0..31 for the highest set bit\nstatic int stbi__high_bit(unsigned int z)\n{\n   int n=0;\n   if (z == 0) return -1;\n   if (z >= 0x10000) n += 16, z >>= 16;\n   if (z >= 0x00100) n +=  8, z >>=  8;\n   if (z >= 0x00010) n +=  4, z >>=  4;\n   if (z >= 0x00004) n +=  2, z >>=  2;\n   if (z >= 0x00002) n +=  1, z >>=  1;\n   return n;\n}\n\nstatic int stbi__bitcount(unsigned int a)\n{\n   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2\n   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4\n   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits\n   a = (a + (a >> 8)); // max 16 per 8 bits\n   a = (a + (a >> 16)); // max 32 per 8 bits\n   return a & 0xff;\n}\n\nstatic int stbi__shiftsigned(int v, int shift, int bits)\n{\n   int result;\n   int z=0;\n\n   if (shift < 0) v <<= -shift;\n   else v >>= shift;\n   result = v;\n\n   z = bits;\n   while (z < 8) {\n      result += v >> z;\n      z += bits;\n   }\n   return result;\n}\n\nstatic stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi_uc *out;\n   unsigned int mr=0,mg=0,mb=0,ma=0, fake_a=0;\n   stbi_uc pal[256][4];\n   int psize=0,i,j,compress=0,width;\n   int bpp, flip_vertically, pad, target, offset, hsz;\n   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc(\"not BMP\", \"Corrupt BMP\");\n   stbi__get32le(s); // discard filesize\n   stbi__get16le(s); // discard reserved\n   stbi__get16le(s); // discard reserved\n   offset = stbi__get32le(s);\n   hsz = stbi__get32le(s);\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc(\"unknown BMP\", \"BMP type not supported: unknown\");\n   if (hsz == 12) {\n      s->img_x = stbi__get16le(s);\n      s->img_y = stbi__get16le(s);\n   } else {\n      s->img_x = stbi__get32le(s);\n      s->img_y = stbi__get32le(s);\n   }\n   if (stbi__get16le(s) != 1) return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n   bpp = stbi__get16le(s);\n   if (bpp == 1) return stbi__errpuc(\"monochrome\", \"BMP type not supported: 1-bit\");\n   flip_vertically = ((int) s->img_y) > 0;\n   s->img_y = abs((int) s->img_y);\n   if (hsz == 12) {\n      if (bpp < 24)\n         psize = (offset - 14 - 24) / 3;\n   } else {\n      compress = stbi__get32le(s);\n      if (compress == 1 || compress == 2) return stbi__errpuc(\"BMP RLE\", \"BMP type not supported: RLE\");\n      stbi__get32le(s); // discard sizeof\n      stbi__get32le(s); // discard hres\n      stbi__get32le(s); // discard vres\n      stbi__get32le(s); // discard colorsused\n      stbi__get32le(s); // discard max important\n      if (hsz == 40 || hsz == 56) {\n         if (hsz == 56) {\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n            stbi__get32le(s);\n         }\n         if (bpp == 16 || bpp == 32) {\n            mr = mg = mb = 0;\n            if (compress == 0) {\n               if (bpp == 32) {\n                  mr = 0xffu << 16;\n                  mg = 0xffu <<  8;\n                  mb = 0xffu <<  0;\n                  ma = 0xffu << 24;\n                  fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255\n                  STBI_NOTUSED(fake_a);\n               } else {\n                  mr = 31u << 10;\n                  mg = 31u <<  5;\n                  mb = 31u <<  0;\n               }\n            } else if (compress == 3) {\n               mr = stbi__get32le(s);\n               mg = stbi__get32le(s);\n               mb = stbi__get32le(s);\n               // not documented, but generated by photoshop and handled by mspaint\n               if (mr == mg && mg == mb) {\n                  // ?!?!?\n                  return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n               }\n            } else\n               return stbi__errpuc(\"bad BMP\", \"bad BMP\");\n         }\n      } else {\n         STBI_ASSERT(hsz == 108 || hsz == 124);\n         mr = stbi__get32le(s);\n         mg = stbi__get32le(s);\n         mb = stbi__get32le(s);\n         ma = stbi__get32le(s);\n         stbi__get32le(s); // discard color space\n         for (i=0; i < 12; ++i)\n            stbi__get32le(s); // discard color space parameters\n         if (hsz == 124) {\n            stbi__get32le(s); // discard rendering intent\n            stbi__get32le(s); // discard offset of profile data\n            stbi__get32le(s); // discard size of profile data\n            stbi__get32le(s); // discard reserved\n         }\n      }\n      if (bpp < 16)\n         psize = (offset - 14 - hsz) >> 2;\n   }\n   s->img_n = ma ? 4 : 3;\n   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4\n      target = req_comp;\n   else\n      target = s->img_n; // if they want monochrome, we'll post-convert\n   out = (stbi_uc *) stbi__malloc(target * s->img_x * s->img_y);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (bpp < 16) {\n      int z=0;\n      if (psize == 0 || psize > 256) { free(out); return stbi__errpuc(\"invalid\", \"Corrupt BMP\"); }\n      for (i=0; i < psize; ++i) {\n         pal[i][2] = stbi__get8(s);\n         pal[i][1] = stbi__get8(s);\n         pal[i][0] = stbi__get8(s);\n         if (hsz != 12) stbi__get8(s);\n         pal[i][3] = 255;\n      }\n      stbi__skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));\n      if (bpp == 4) width = (s->img_x + 1) >> 1;\n      else if (bpp == 8) width = s->img_x;\n      else { free(out); return stbi__errpuc(\"bad bpp\", \"Corrupt BMP\"); }\n      pad = (-width)&3;\n      for (j=0; j < (int) s->img_y; ++j) {\n         for (i=0; i < (int) s->img_x; i += 2) {\n            int v=stbi__get8(s),v2=0;\n            if (bpp == 4) {\n               v2 = v & 15;\n               v >>= 4;\n            }\n            out[z++] = pal[v][0];\n            out[z++] = pal[v][1];\n            out[z++] = pal[v][2];\n            if (target == 4) out[z++] = 255;\n            if (i+1 == (int) s->img_x) break;\n            v = (bpp == 8) ? stbi__get8(s) : v2;\n            out[z++] = pal[v][0];\n            out[z++] = pal[v][1];\n            out[z++] = pal[v][2];\n            if (target == 4) out[z++] = 255;\n         }\n         stbi__skip(s, pad);\n      }\n   } else {\n      int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;\n      int z = 0;\n      int easy=0;\n      stbi__skip(s, offset - 14 - hsz);\n      if (bpp == 24) width = 3 * s->img_x;\n      else if (bpp == 16) width = 2*s->img_x;\n      else /* bpp = 32 and pad = 0 */ width=0;\n      pad = (-width) & 3;\n      if (bpp == 24) {\n         easy = 1;\n      } else if (bpp == 32) {\n         if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)\n            easy = 2;\n      }\n      if (!easy) {\n         if (!mr || !mg || !mb) { free(out); return stbi__errpuc(\"bad masks\", \"Corrupt BMP\"); }\n         // right shift amt to put high bit in position #7\n         rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);\n         gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);\n         bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);\n         ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);\n      }\n      for (j=0; j < (int) s->img_y; ++j) {\n         if (easy) {\n            for (i=0; i < (int) s->img_x; ++i) {\n               unsigned char a;\n               out[z+2] = stbi__get8(s);\n               out[z+1] = stbi__get8(s);\n               out[z+0] = stbi__get8(s);\n               z += 3;\n               a = (easy == 2 ? stbi__get8(s) : 255);\n               if (target == 4) out[z++] = a;\n            }\n         } else {\n            for (i=0; i < (int) s->img_x; ++i) {\n               stbi__uint32 v = (stbi__uint32) (bpp == 16 ? stbi__get16le(s) : stbi__get32le(s));\n               int a;\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));\n               out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));\n               a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);\n               if (target == 4) out[z++] = STBI__BYTECAST(a); \n            }\n         }\n         stbi__skip(s, pad);\n      }\n   }\n   if (flip_vertically) {\n      stbi_uc t;\n      for (j=0; j < (int) s->img_y>>1; ++j) {\n         stbi_uc *p1 = out +      j     *s->img_x*target;\n         stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;\n         for (i=0; i < (int) s->img_x*target; ++i) {\n            t = p1[i], p1[i] = p2[i], p2[i] = t;\n         }\n      }\n   }\n\n   if (req_comp && req_comp != target) {\n      out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n   return out;\n}\n\n// Targa Truevision - TGA\n// by Jonathan Dummer\n\nstatic int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)\n{\n    int tga_w, tga_h, tga_comp;\n    int sz;\n    stbi__get8(s);                   // discard Offset\n    sz = stbi__get8(s);              // color type\n    if( sz > 1 ) {\n        stbi__rewind(s);\n        return 0;      // only RGB or indexed allowed\n    }\n    sz = stbi__get8(s);              // image type\n    // only RGB or grey allowed, +/- RLE\n    if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;\n    stbi__skip(s,9);\n    tga_w = stbi__get16le(s);\n    if( tga_w < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test width\n    }\n    tga_h = stbi__get16le(s);\n    if( tga_h < 1 ) {\n        stbi__rewind(s);\n        return 0;   // test height\n    }\n    sz = stbi__get8(s);               // bits per pixel\n    // only RGB or RGBA or grey allowed\n    if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {\n        stbi__rewind(s);\n        return 0;\n    }\n    tga_comp = sz;\n    if (x) *x = tga_w;\n    if (y) *y = tga_h;\n    if (comp) *comp = tga_comp / 8;\n    return 1;                   // seems to have passed everything\n}\n\nstatic int stbi__tga_test(stbi__context *s)\n{\n   int res;\n   int sz;\n   stbi__get8(s);      //   discard Offset\n   sz = stbi__get8(s);   //   color type\n   if ( sz > 1 ) return 0;   //   only RGB or indexed allowed\n   sz = stbi__get8(s);   //   image type\n   if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE\n   stbi__get16be(s);      //   discard palette start\n   stbi__get16be(s);      //   discard palette length\n   stbi__get8(s);         //   discard bits per palette color entry\n   stbi__get16be(s);      //   discard x origin\n   stbi__get16be(s);      //   discard y origin\n   if ( stbi__get16be(s) < 1 ) return 0;      //   test width\n   if ( stbi__get16be(s) < 1 ) return 0;      //   test height\n   sz = stbi__get8(s);   //   bits per pixel\n   if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) )\n      res = 0;\n   else\n      res = 1;\n   stbi__rewind(s);\n   return res;\n}\n\nstatic stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   //   read in the TGA header stuff\n   int tga_offset = stbi__get8(s);\n   int tga_indexed = stbi__get8(s);\n   int tga_image_type = stbi__get8(s);\n   int tga_is_RLE = 0;\n   int tga_palette_start = stbi__get16le(s);\n   int tga_palette_len = stbi__get16le(s);\n   int tga_palette_bits = stbi__get8(s);\n   int tga_x_origin = stbi__get16le(s);\n   int tga_y_origin = stbi__get16le(s);\n   int tga_width = stbi__get16le(s);\n   int tga_height = stbi__get16le(s);\n   int tga_bits_per_pixel = stbi__get8(s);\n   int tga_comp = tga_bits_per_pixel / 8;\n   int tga_inverted = stbi__get8(s);\n   //   image data\n   unsigned char *tga_data;\n   unsigned char *tga_palette = NULL;\n   int i, j;\n   unsigned char raw_data[4];\n   int RLE_count = 0;\n   int RLE_repeating = 0;\n   int read_next_pixel = 1;\n\n   //   do a tiny bit of precessing\n   if ( tga_image_type >= 8 )\n   {\n      tga_image_type -= 8;\n      tga_is_RLE = 1;\n   }\n   /* int tga_alpha_bits = tga_inverted & 15; */\n   tga_inverted = 1 - ((tga_inverted >> 5) & 1);\n\n   //   error check\n   if ( //(tga_indexed) ||\n      (tga_width < 1) || (tga_height < 1) ||\n      (tga_image_type < 1) || (tga_image_type > 3) ||\n      ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&\n      (tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))\n      )\n   {\n      return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA\n   }\n\n   //   If I'm paletted, then I'll use the number of bits from the palette\n   if ( tga_indexed )\n   {\n      tga_comp = tga_palette_bits / 8;\n   }\n\n   //   tga info\n   *x = tga_width;\n   *y = tga_height;\n   if (comp) *comp = tga_comp;\n\n   tga_data = (unsigned char*)stbi__malloc( tga_width * tga_height * tga_comp );\n   if (!tga_data) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n\n   // skip to the data's starting position (offset usually = 0)\n   stbi__skip(s, tga_offset );\n\n   if ( !tga_indexed && !tga_is_RLE) {\n      for (i=0; i < tga_height; ++i) {\n         int y = tga_inverted ? tga_height -i - 1 : i;\n         stbi_uc *tga_row = tga_data + y*tga_width*tga_comp;\n         stbi__getn(s, tga_row, tga_width * tga_comp);\n      }\n   } else  {\n      //   do I need to load a palette?\n      if ( tga_indexed)\n      {\n         //   any data to skip? (offset usually = 0)\n         stbi__skip(s, tga_palette_start );\n         //   load the palette\n         tga_palette = (unsigned char*)stbi__malloc( tga_palette_len * tga_palette_bits / 8 );\n         if (!tga_palette) {\n            free(tga_data);\n            return stbi__errpuc(\"outofmem\", \"Out of memory\");\n         }\n         if (!stbi__getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8 )) {\n            free(tga_data);\n            free(tga_palette);\n            return stbi__errpuc(\"bad palette\", \"Corrupt TGA\");\n         }\n      }\n      //   load the data\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?\n         if ( tga_is_RLE )\n         {\n            if ( RLE_count == 0 )\n            {\n               //   yep, get the next byte as a RLE command\n               int RLE_cmd = stbi__get8(s);\n               RLE_count = 1 + (RLE_cmd & 127);\n               RLE_repeating = RLE_cmd >> 7;\n               read_next_pixel = 1;\n            } else if ( !RLE_repeating )\n            {\n               read_next_pixel = 1;\n            }\n         } else\n         {\n            read_next_pixel = 1;\n         }\n         //   OK, if I need to read a pixel, do it now\n         if ( read_next_pixel )\n         {\n            //   load however much data we did have\n            if ( tga_indexed )\n            {\n               //   read in 1 byte, then perform the lookup\n               int pal_idx = stbi__get8(s);\n               if ( pal_idx >= tga_palette_len )\n               {\n                  //   invalid index\n                  pal_idx = 0;\n               }\n               pal_idx *= tga_bits_per_pixel / 8;\n               for (j = 0; j*8 < tga_bits_per_pixel; ++j)\n               {\n                  raw_data[j] = tga_palette[pal_idx+j];\n               }\n            } else\n            {\n               //   read in the data raw\n               for (j = 0; j*8 < tga_bits_per_pixel; ++j)\n               {\n                  raw_data[j] = stbi__get8(s);\n               }\n            }\n            //   clear the reading flag for the next pixel\n            read_next_pixel = 0;\n         } // end of reading a pixel\n\n         // copy data\n         for (j = 0; j < tga_comp; ++j)\n           tga_data[i*tga_comp+j] = raw_data[j];\n\n         //   in case we're in RLE mode, keep counting down\n         --RLE_count;\n      }\n      //   do I need to invert the image?\n      if ( tga_inverted )\n      {\n         for (j = 0; j*2 < tga_height; ++j)\n         {\n            int index1 = j * tga_width * tga_comp;\n            int index2 = (tga_height - 1 - j) * tga_width * tga_comp;\n            for (i = tga_width * tga_comp; i > 0; --i)\n            {\n               unsigned char temp = tga_data[index1];\n               tga_data[index1] = tga_data[index2];\n               tga_data[index2] = temp;\n               ++index1;\n               ++index2;\n            }\n         }\n      }\n      //   clear my palette, if I had one\n      if ( tga_palette != NULL )\n      {\n         free( tga_palette );\n      }\n   }\n\n   // swap RGB\n   if (tga_comp >= 3)\n   {\n      unsigned char* tga_pixel = tga_data;\n      for (i=0; i < tga_width * tga_height; ++i)\n      {\n         unsigned char temp = tga_pixel[0];\n         tga_pixel[0] = tga_pixel[2];\n         tga_pixel[2] = temp;\n         tga_pixel += tga_comp;\n      }\n   }\n\n   // convert to target component count\n   if (req_comp && req_comp != tga_comp)\n      tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);\n\n   //   the things I do to get rid of an error message, and yet keep\n   //   Microsoft's C compilers happy... [8^(\n   tga_palette_start = tga_palette_len = tga_palette_bits =\n         tga_x_origin = tga_y_origin = 0;\n   //   OK, done\n   return tga_data;\n}\n\n// *************************************************************************************************\n// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB\n\nstatic int stbi__psd_test(stbi__context *s)\n{\n   int r = (stbi__get32be(s) == 0x38425053);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   int   pixelCount;\n   int channelCount, compression;\n   int channel, i, count, len;\n   int w,h;\n   stbi_uc *out;\n\n   // Check identifier\n   if (stbi__get32be(s) != 0x38425053)   // \"8BPS\"\n      return stbi__errpuc(\"not PSD\", \"Corrupt PSD image\");\n\n   // Check file type version.\n   if (stbi__get16be(s) != 1)\n      return stbi__errpuc(\"wrong version\", \"Unsupported version of PSD image\");\n\n   // Skip 6 reserved bytes.\n   stbi__skip(s, 6 );\n\n   // Read the number of channels (R, G, B, A, etc).\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16)\n      return stbi__errpuc(\"wrong channel count\", \"Unsupported number of channels in PSD image\");\n\n   // Read the rows and columns of the image.\n   h = stbi__get32be(s);\n   w = stbi__get32be(s);\n   \n   // Make sure the depth is 8 bits.\n   if (stbi__get16be(s) != 8)\n      return stbi__errpuc(\"unsupported bit depth\", \"PSD bit depth is not 8 bit\");\n\n   // Make sure the color mode is RGB.\n   // Valid options are:\n   //   0: Bitmap\n   //   1: Grayscale\n   //   2: Indexed color\n   //   3: RGB color\n   //   4: CMYK color\n   //   7: Multichannel\n   //   8: Duotone\n   //   9: Lab color\n   if (stbi__get16be(s) != 3)\n      return stbi__errpuc(\"wrong color format\", \"PSD is not in RGB color format\");\n\n   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)\n   stbi__skip(s,stbi__get32be(s) );\n\n   // Skip the image resources.  (resolution, pen tool paths, etc)\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Skip the reserved data.\n   stbi__skip(s, stbi__get32be(s) );\n\n   // Find out if the data is compressed.\n   // Known values:\n   //   0: no compression\n   //   1: RLE compressed\n   compression = stbi__get16be(s);\n   if (compression > 1)\n      return stbi__errpuc(\"bad compression\", \"PSD has an unknown compression format\");\n\n   // Create the destination image.\n   out = (stbi_uc *) stbi__malloc(4 * w*h);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   pixelCount = w*h;\n\n   // Initialize the data to zero.\n   //memset( out, 0, pixelCount * 4 );\n   \n   // Finally, the image data.\n   if (compression) {\n      // RLE as used by .PSD and .TIFF\n      // Loop until you get the number of unpacked bytes you are expecting:\n      //     Read the next source byte into n.\n      //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.\n      //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.\n      //     Else if n is 128, noop.\n      // Endloop\n\n      // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,\n      // which we're going to just skip.\n      stbi__skip(s, h * channelCount * 2 );\n\n      // Read the RLE data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         stbi_uc *p;\n         \n         p = out+channel;\n         if (channel >= channelCount) {\n            // Fill this channel with default data.\n            for (i = 0; i < pixelCount; i++) *p = (channel == 3 ? 255 : 0), p += 4;\n         } else {\n            // Read the RLE data.\n            count = 0;\n            while (count < pixelCount) {\n               len = stbi__get8(s);\n               if (len == 128) {\n                  // No-op.\n               } else if (len < 128) {\n                  // Copy next len+1 bytes literally.\n                  len++;\n                  count += len;\n                  while (len) {\n                     *p = stbi__get8(s);\n                     p += 4;\n                     len--;\n                  }\n               } else if (len > 128) {\n                  stbi_uc   val;\n                  // Next -len+1 bytes in the dest are replicated from next source byte.\n                  // (Interpret len as a negative 8-bit int.)\n                  len ^= 0x0FF;\n                  len += 2;\n                  val = stbi__get8(s);\n                  count += len;\n                  while (len) {\n                     *p = val;\n                     p += 4;\n                     len--;\n                  }\n               }\n            }\n         }\n      }\n      \n   } else {\n      // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)\n      // where each channel consists of an 8-bit value for each pixel in the image.\n      \n      // Read the data by channel.\n      for (channel = 0; channel < 4; channel++) {\n         stbi_uc *p;\n         \n         p = out + channel;\n         if (channel > channelCount) {\n            // Fill this channel with default data.\n            for (i = 0; i < pixelCount; i++) *p = channel == 3 ? 255 : 0, p += 4;\n         } else {\n            // Read the data.\n            for (i = 0; i < pixelCount; i++)\n               *p = stbi__get8(s), p += 4;\n         }\n      }\n   }\n\n   if (req_comp && req_comp != 4) {\n      out = stbi__convert_format(out, 4, req_comp, w, h);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n\n   if (comp) *comp = channelCount;\n   *y = h;\n   *x = w;\n   \n   return out;\n}\n\n// *************************************************************************************************\n// Softimage PIC loader\n// by Tom Seddon\n//\n// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format\n// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/\n\nstatic int stbi__pic_is4(stbi__context *s,const char *str)\n{\n   int i;\n   for (i=0; i<4; ++i)\n      if (stbi__get8(s) != (stbi_uc)str[i])\n         return 0;\n\n   return 1;\n}\n\nstatic int stbi__pic_test_core(stbi__context *s)\n{\n   int i;\n\n   if (!stbi__pic_is4(s,\"\\x53\\x80\\xF6\\x34\"))\n      return 0;\n\n   for(i=0;i<84;++i)\n      stbi__get8(s);\n\n   if (!stbi__pic_is4(s,\"PICT\"))\n      return 0;\n\n   return 1;\n}\n\ntypedef struct\n{\n   stbi_uc size,type,channel;\n} stbi__pic_packet;\n\nstatic stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)\n{\n   int mask=0x80, i;\n\n   for (i=0; i<4; ++i, mask>>=1) {\n      if (channel & mask) {\n         if (stbi__at_eof(s)) return stbi__errpuc(\"bad file\",\"PIC file too short\");\n         dest[i]=stbi__get8(s);\n      }\n   }\n\n   return dest;\n}\n\nstatic void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)\n{\n   int mask=0x80,i;\n\n   for (i=0;i<4; ++i, mask>>=1)\n      if (channel&mask)\n         dest[i]=src[i];\n}\n\nstatic stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)\n{\n   int act_comp=0,num_packets=0,y,chained;\n   stbi__pic_packet packets[10];\n\n   // this will (should...) cater for even some bizarre stuff like having data\n    // for the same channel in multiple packets.\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return stbi__errpuc(\"bad format\",\"too many packets\");\n\n      packet = &packets[num_packets++];\n\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s))          return stbi__errpuc(\"bad file\",\"file too short (reading packets)\");\n      if (packet->size != 8)  return stbi__errpuc(\"bad format\",\"packet isn't 8bpp\");\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?\n\n   for(y=0; y<height; ++y) {\n      int packet_idx;\n\n      for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {\n         stbi__pic_packet *packet = &packets[packet_idx];\n         stbi_uc *dest = result+y*width*4;\n\n         switch (packet->type) {\n            default:\n               return stbi__errpuc(\"bad format\",\"packet has bad compression type\");\n\n            case 0: {//uncompressed\n               int x;\n\n               for(x=0;x<width;++x, dest+=4)\n                  if (!stbi__readval(s,packet->channel,dest))\n                     return 0;\n               break;\n            }\n\n            case 1://Pure RLE\n               {\n                  int left=width, i;\n\n                  while (left>0) {\n                     stbi_uc count,value[4];\n\n                     count=stbi__get8(s);\n                     if (stbi__at_eof(s))   return stbi__errpuc(\"bad file\",\"file too short (pure read count)\");\n\n                     if (count > left)\n                        count = (stbi_uc) left;\n\n                     if (!stbi__readval(s,packet->channel,value))  return 0;\n\n                     for(i=0; i<count; ++i,dest+=4)\n                        stbi__copyval(packet->channel,dest,value);\n                     left -= count;\n                  }\n               }\n               break;\n\n            case 2: {//Mixed RLE\n               int left=width;\n               while (left>0) {\n                  int count = stbi__get8(s), i;\n                  if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (mixed read count)\");\n\n                  if (count >= 128) { // Repeated\n                     stbi_uc value[4];\n                     int i;\n\n                     if (count==128)\n                        count = stbi__get16be(s);\n                     else\n                        count -= 127;\n                     if (count > left)\n                        return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     if (!stbi__readval(s,packet->channel,value))\n                        return 0;\n\n                     for(i=0;i<count;++i, dest += 4)\n                        stbi__copyval(packet->channel,dest,value);\n                  } else { // Raw\n                     ++count;\n                     if (count>left) return stbi__errpuc(\"bad file\",\"scanline overrun\");\n\n                     for(i=0;i<count;++i, dest+=4)\n                        if (!stbi__readval(s,packet->channel,dest))\n                           return 0;\n                  }\n                  left-=count;\n               }\n               break;\n            }\n         }\n      }\n   }\n\n   return result;\n}\n\nstatic stbi_uc *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp)\n{\n   stbi_uc *result;\n   int i, x,y;\n\n   for (i=0; i<92; ++i)\n      stbi__get8(s);\n\n   x = stbi__get16be(s);\n   y = stbi__get16be(s);\n   if (stbi__at_eof(s))  return stbi__errpuc(\"bad file\",\"file too short (pic header)\");\n   if ((1 << 28) / x < y) return stbi__errpuc(\"too large\", \"Image too large to decode\");\n\n   stbi__get32be(s); //skip `ratio'\n   stbi__get16be(s); //skip `fields'\n   stbi__get16be(s); //skip `pad'\n\n   // intermediate buffer is RGBA\n   result = (stbi_uc *) stbi__malloc(x*y*4);\n   memset(result, 0xff, x*y*4);\n\n   if (!stbi__pic_load_core(s,x,y,comp, result)) {\n      free(result);\n      result=0;\n   }\n   *px = x;\n   *py = y;\n   if (req_comp == 0) req_comp = *comp;\n   result=stbi__convert_format(result,4,req_comp,x,y);\n\n   return result;\n}\n\nstatic int stbi__pic_test(stbi__context *s)\n{\n   int r = stbi__pic_test_core(s);\n   stbi__rewind(s);\n   return r;\n}\n\n// *************************************************************************************************\n// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb\ntypedef struct \n{\n   stbi__int16 prefix;\n   stbi_uc first;\n   stbi_uc suffix;\n} stbi__gif_lzw;\n\ntypedef struct\n{\n   int w,h;\n   stbi_uc *out;                 // output buffer (always 4 components)\n   int flags, bgindex, ratio, transparent, eflags;\n   stbi_uc  pal[256][4];\n   stbi_uc lpal[256][4];\n   stbi__gif_lzw codes[4096];\n   stbi_uc *color_table;\n   int parse, step;\n   int lflags;\n   int start_x, start_y;\n   int max_x, max_y;\n   int cur_x, cur_y;\n   int line_size;\n} stbi__gif;\n\nstatic int stbi__gif_test_raw(stbi__context *s)\n{\n   int sz;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;\n   sz = stbi__get8(s);\n   if (sz != '9' && sz != '7') return 0;\n   if (stbi__get8(s) != 'a') return 0;\n   return 1;\n}\n\nstatic int stbi__gif_test(stbi__context *s)\n{\n   int r = stbi__gif_test_raw(s);\n   stbi__rewind(s);\n   return r;\n}\n\nstatic void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)\n{\n   int i;\n   for (i=0; i < num_entries; ++i) {\n      pal[i][2] = stbi__get8(s);\n      pal[i][1] = stbi__get8(s);\n      pal[i][0] = stbi__get8(s);\n      pal[i][3] = transp ? 0 : 255;\n   }   \n}\n\nstatic int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)\n{\n   stbi_uc version;\n   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')\n      return stbi__err(\"not GIF\", \"Corrupt GIF\");\n\n   version = stbi__get8(s);\n   if (version != '7' && version != '9')    return stbi__err(\"not GIF\", \"Corrupt GIF\");\n   if (stbi__get8(s) != 'a')                      return stbi__err(\"not GIF\", \"Corrupt GIF\");\n \n   stbi__g_failure_reason = \"\";\n   g->w = stbi__get16le(s);\n   g->h = stbi__get16le(s);\n   g->flags = stbi__get8(s);\n   g->bgindex = stbi__get8(s);\n   g->ratio = stbi__get8(s);\n   g->transparent = -1;\n\n   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments\n\n   if (is_info) return 1;\n\n   if (g->flags & 0x80)\n      stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);\n\n   return 1;\n}\n\nstatic int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)\n{\n   stbi__gif g;   \n   if (!stbi__gif_header(s, &g, comp, 1)) {\n      stbi__rewind( s );\n      return 0;\n   }\n   if (x) *x = g.w;\n   if (y) *y = g.h;\n   return 1;\n}\n\nstatic void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)\n{\n   stbi_uc *p, *c;\n\n   // recurse to decode the prefixes, since the linked-list is backwards,\n   // and working backwards through an interleaved image would be nasty\n   if (g->codes[code].prefix >= 0)\n      stbi__out_gif_code(g, g->codes[code].prefix);\n\n   if (g->cur_y >= g->max_y) return;\n  \n   p = &g->out[g->cur_x + g->cur_y];\n   c = &g->color_table[g->codes[code].suffix * 4];\n\n   if (c[3] >= 128) {\n      p[0] = c[2];\n      p[1] = c[1];\n      p[2] = c[0];\n      p[3] = c[3];\n   }\n   g->cur_x += 4;\n\n   if (g->cur_x >= g->max_x) {\n      g->cur_x = g->start_x;\n      g->cur_y += g->step;\n\n      while (g->cur_y >= g->max_y && g->parse > 0) {\n         g->step = (1 << g->parse) * g->line_size;\n         g->cur_y = g->start_y + (g->step >> 1);\n         --g->parse;\n      }\n   }\n}\n\nstatic stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)\n{\n   stbi_uc lzw_cs;\n   stbi__int32 len, code;\n   stbi__uint32 first;\n   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;\n   stbi__gif_lzw *p;\n\n   lzw_cs = stbi__get8(s);\n   clear = 1 << lzw_cs;\n   first = 1;\n   codesize = lzw_cs + 1;\n   codemask = (1 << codesize) - 1;\n   bits = 0;\n   valid_bits = 0;\n   for (code = 0; code < clear; code++) {\n      g->codes[code].prefix = -1;\n      g->codes[code].first = (stbi_uc) code;\n      g->codes[code].suffix = (stbi_uc) code;\n   }\n\n   // support no starting clear code\n   avail = clear+2;\n   oldcode = -1;\n\n   len = 0;\n   for(;;) {\n      if (valid_bits < codesize) {\n         if (len == 0) {\n            len = stbi__get8(s); // start new block\n            if (len == 0) \n               return g->out;\n         }\n         --len;\n         bits |= (stbi__int32) stbi__get8(s) << valid_bits;\n         valid_bits += 8;\n      } else {\n         stbi__int32 code = bits & codemask;\n         bits >>= codesize;\n         valid_bits -= codesize;\n         // @OPTIMIZE: is there some way we can accelerate the non-clear path?\n         if (code == clear) {  // clear code\n            codesize = lzw_cs + 1;\n            codemask = (1 << codesize) - 1;\n            avail = clear + 2;\n            oldcode = -1;\n            first = 0;\n         } else if (code == clear + 1) { // end of stream code\n            stbi__skip(s, len);\n            while ((len = stbi__get8(s)) > 0)\n               stbi__skip(s,len);\n            return g->out;\n         } else if (code <= avail) {\n            if (first) return stbi__errpuc(\"no clear code\", \"Corrupt GIF\");\n\n            if (oldcode >= 0) {\n               p = &g->codes[avail++];\n               if (avail > 4096)        return stbi__errpuc(\"too many codes\", \"Corrupt GIF\");\n               p->prefix = (stbi__int16) oldcode;\n               p->first = g->codes[oldcode].first;\n               p->suffix = (code == avail) ? p->first : g->codes[code].first;\n            } else if (code == avail)\n               return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n\n            stbi__out_gif_code(g, (stbi__uint16) code);\n\n            if ((avail & codemask) == 0 && avail <= 0x0FFF) {\n               codesize++;\n               codemask = (1 << codesize) - 1;\n            }\n\n            oldcode = code;\n         } else {\n            return stbi__errpuc(\"illegal code in raster\", \"Corrupt GIF\");\n         }\n      } \n   }\n}\n\nstatic void stbi__fill_gif_background(stbi__gif *g)\n{\n   int i;\n   stbi_uc *c = g->pal[g->bgindex];\n   // @OPTIMIZE: write a dword at a time\n   for (i = 0; i < g->w * g->h * 4; i += 4) {\n      stbi_uc *p  = &g->out[i];\n      p[0] = c[2];\n      p[1] = c[1];\n      p[2] = c[0];\n      p[3] = c[3];\n   }\n}\n\n// this function is designed to support animated gifs, although stb_image doesn't support it\nstatic stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)\n{\n   int i;\n   stbi_uc *old_out = 0;\n\n   if (g->out == 0) {\n      if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header\n      g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);\n      if (g->out == 0)                      return stbi__errpuc(\"outofmem\", \"Out of memory\");\n      stbi__fill_gif_background(g);\n   } else {\n      // animated-gif-only path\n      if (((g->eflags & 0x1C) >> 2) == 3) {\n         old_out = g->out;\n         g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);\n         if (g->out == 0)                   return stbi__errpuc(\"outofmem\", \"Out of memory\");\n         memcpy(g->out, old_out, g->w*g->h*4);\n      }\n   }\n    \n   for (;;) {\n      switch (stbi__get8(s)) {\n         case 0x2C: /* Image Descriptor */\n         {\n            stbi__int32 x, y, w, h;\n            stbi_uc *o;\n\n            x = stbi__get16le(s);\n            y = stbi__get16le(s);\n            w = stbi__get16le(s);\n            h = stbi__get16le(s);\n            if (((x + w) > (g->w)) || ((y + h) > (g->h)))\n               return stbi__errpuc(\"bad Image Descriptor\", \"Corrupt GIF\");\n\n            g->line_size = g->w * 4;\n            g->start_x = x * 4;\n            g->start_y = y * g->line_size;\n            g->max_x   = g->start_x + w * 4;\n            g->max_y   = g->start_y + h * g->line_size;\n            g->cur_x   = g->start_x;\n            g->cur_y   = g->start_y;\n\n            g->lflags = stbi__get8(s);\n\n            if (g->lflags & 0x40) {\n               g->step = 8 * g->line_size; // first interlaced spacing\n               g->parse = 3;\n            } else {\n               g->step = g->line_size;\n               g->parse = 0;\n            }\n\n            if (g->lflags & 0x80) {\n               stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);\n               g->color_table = (stbi_uc *) g->lpal;       \n            } else if (g->flags & 0x80) {\n               for (i=0; i < 256; ++i)  // @OPTIMIZE: stbi__jpeg_reset only the previous transparent\n                  g->pal[i][3] = 255; \n               if (g->transparent >= 0 && (g->eflags & 0x01))\n                  g->pal[g->transparent][3] = 0;\n               g->color_table = (stbi_uc *) g->pal;\n            } else\n               return stbi__errpuc(\"missing color table\", \"Corrupt GIF\");\n   \n            o = stbi__process_gif_raster(s, g);\n            if (o == NULL) return NULL;\n\n            if (req_comp && req_comp != 4)\n               o = stbi__convert_format(o, 4, req_comp, g->w, g->h);\n            return o;\n         }\n\n         case 0x21: // Comment Extension.\n         {\n            int len;\n            if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.\n               len = stbi__get8(s);\n               if (len == 4) {\n                  g->eflags = stbi__get8(s);\n                  stbi__get16le(s); // delay\n                  g->transparent = stbi__get8(s);\n               } else {\n                  stbi__skip(s, len);\n                  break;\n               }\n            }\n            while ((len = stbi__get8(s)) != 0)\n               stbi__skip(s, len);\n            break;\n         }\n\n         case 0x3B: // gif stream termination code\n            return (stbi_uc *) s; // using '1' causes warning on some compilers\n\n         default:\n            return stbi__errpuc(\"unknown code\", \"Corrupt GIF\");\n      }\n   }\n}\n\nstatic stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   stbi_uc *u = 0;\n   stbi__gif g;\n   memset(&g, 0, sizeof(g));\n\n   u = stbi__gif_load_next(s, &g, comp, req_comp);\n   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker\n   if (u) {\n      *x = g.w;\n      *y = g.h;\n   }\n\n   return u;\n}\n\nstatic int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   return stbi__gif_info_raw(s,x,y,comp);\n}\n\n\n// *************************************************************************************************\n// Radiance RGBE HDR loader\n// originally by Nicolas Schulz\n#ifndef STBI_NO_HDR\nstatic int stbi__hdr_test_core(stbi__context *s)\n{\n   const char *signature = \"#?RADIANCE\\n\";\n   int i;\n   for (i=0; signature[i]; ++i)\n      if (stbi__get8(s) != signature[i])\n         return 0;\n   return 1;\n}\n\nstatic int stbi__hdr_test(stbi__context* s)\n{\n   int r = stbi__hdr_test_core(s);\n   stbi__rewind(s);\n   return r;\n}\n\n#define STBI__HDR_BUFLEN  1024\nstatic char *stbi__hdr_gettoken(stbi__context *z, char *buffer)\n{\n   int len=0;\n   char c = '\\0';\n\n   c = (char) stbi__get8(z);\n\n   while (!stbi__at_eof(z) && c != '\\n') {\n      buffer[len++] = c;\n      if (len == STBI__HDR_BUFLEN-1) {\n         // flush to end of line\n         while (!stbi__at_eof(z) && stbi__get8(z) != '\\n')\n            ;\n         break;\n      }\n      c = (char) stbi__get8(z);\n   }\n\n   buffer[len] = 0;\n   return buffer;\n}\n\nstatic void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)\n{\n   if ( input[3] != 0 ) {\n      float f1;\n      // Exponent\n      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));\n      if (req_comp <= 2)\n         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;\n      else {\n         output[0] = input[0] * f1;\n         output[1] = input[1] * f1;\n         output[2] = input[2] * f1;\n      }\n      if (req_comp == 2) output[1] = 1;\n      if (req_comp == 4) output[3] = 1;\n   } else {\n      switch (req_comp) {\n         case 4: output[3] = 1; /* fallthrough */\n         case 3: output[0] = output[1] = output[2] = 0;\n                 break;\n         case 2: output[1] = 1; /* fallthrough */\n         case 1: output[0] = 0;\n                 break;\n      }\n   }\n}\n\nstatic float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n\n\n   // Check identifier\n   if (strcmp(stbi__hdr_gettoken(s,buffer), \"#?RADIANCE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n   \n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   // Read data\n   hdr_data = (float *) stbi__malloc(height * width * req_comp * sizeof(float));\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            free(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { free(hdr_data); free(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) scanline = (stbi_uc *) stbi__malloc(width * 4);\n            \n         for (k = 0; k < 4; ++k) {\n            i = 0;\n            while (i < width) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      free(scanline);\n   }\n\n   return hdr_data;\n}\n\nstatic int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n\n   if (strcmp(stbi__hdr_gettoken(s,buffer), \"#?RADIANCE\") != 0) {\n       stbi__rewind( s );\n       return 0;\n   }\n\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *y = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3)) {\n       stbi__rewind( s );\n       return 0;\n   }\n   token += 3;\n   *x = (int) strtol(token, NULL, 10);\n   *comp = 3;\n   return 1;\n}\n#endif // STBI_NO_HDR\n\nstatic int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int hsz;\n   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s,12);\n   hsz = stbi__get32le(s);\n   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (hsz == 12) {\n      *x = stbi__get16le(s);\n      *y = stbi__get16le(s);\n   } else {\n      *x = stbi__get32le(s);\n      *y = stbi__get32le(s);\n   }\n   if (stbi__get16le(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *comp = stbi__get16le(s) / 8;\n   return 1;\n}\n\nstatic int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int channelCount;\n   if (stbi__get32be(s) != 0x38425053) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 1) {\n       stbi__rewind( s );\n       return 0;\n   }\n   stbi__skip(s, 6);\n   channelCount = stbi__get16be(s);\n   if (channelCount < 0 || channelCount > 16) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *y = stbi__get32be(s);\n   *x = stbi__get32be(s);\n   if (stbi__get16be(s) != 8) {\n       stbi__rewind( s );\n       return 0;\n   }\n   if (stbi__get16be(s) != 3) {\n       stbi__rewind( s );\n       return 0;\n   }\n   *comp = 4;\n   return 1;\n}\n\nstatic int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)\n{\n   int act_comp=0,num_packets=0,chained;\n   stbi__pic_packet packets[10];\n\n   stbi__skip(s, 92);\n\n   *x = stbi__get16be(s);\n   *y = stbi__get16be(s);\n   if (stbi__at_eof(s))  return 0;\n   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {\n       stbi__rewind( s );\n       return 0;\n   }\n\n   stbi__skip(s, 8);\n\n   do {\n      stbi__pic_packet *packet;\n\n      if (num_packets==sizeof(packets)/sizeof(packets[0]))\n         return 0;\n\n      packet = &packets[num_packets++];\n      chained = stbi__get8(s);\n      packet->size    = stbi__get8(s);\n      packet->type    = stbi__get8(s);\n      packet->channel = stbi__get8(s);\n      act_comp |= packet->channel;\n\n      if (stbi__at_eof(s)) {\n          stbi__rewind( s );\n          return 0;\n      }\n      if (packet->size != 8) {\n          stbi__rewind( s );\n          return 0;\n      }\n   } while (chained);\n\n   *comp = (act_comp & 0x10 ? 4 : 3);\n\n   return 1;\n}\n\nstatic int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)\n{\n   if (stbi__jpeg_info(s, x, y, comp))\n       return 1;\n   if (stbi__png_info(s, x, y, comp))\n       return 1;\n   if (stbi__gif_info(s, x, y, comp))\n       return 1;\n   if (stbi__bmp_info(s, x, y, comp))\n       return 1;\n   if (stbi__psd_info(s, x, y, comp))\n       return 1;\n   if (stbi__pic_info(s, x, y, comp))\n       return 1;\n   #ifndef STBI_NO_HDR\n   if (stbi__hdr_info(s, x, y, comp))\n       return 1;\n   #endif\n   // test tga last because it's a crappy test!\n   if (stbi__tga_info(s, x, y, comp))\n       return 1;\n   return stbi__err(\"unknown image type\", \"Image not of any known type, or corrupt\");\n}\n\n#ifndef STBI_NO_STDIO\nSTBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)\n{\n    FILE *f = stbi__fopen(filename, \"rb\");\n    int result;\n    if (!f) return stbi__err(\"can't fopen\", \"Unable to open file\");\n    result = stbi_info_from_file(f, x, y, comp);\n    fclose(f);\n    return result;\n}\n\nSTBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)\n{\n   int r;\n   stbi__context s;\n   long pos = ftell(f);\n   stbi__start_file(&s, f);\n   r = stbi__info_main(&s,x,y,comp);\n   fseek(f,pos,SEEK_SET);\n   return r;\n}\n#endif // !STBI_NO_STDIO\n\nSTBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_mem(&s,buffer,len);\n   return stbi__info_main(&s,x,y,comp);\n}\n\nSTBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)\n{\n   stbi__context s;\n   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);\n   return stbi__info_main(&s,x,y,comp);\n}\n\n#endif // STB_IMAGE_IMPLEMENTATION\n\n/*\n   revision history:\n      1.46 (2014-08-26)\n             fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG\n      1.45 (2014-08-16)\n             fix MSVC-ARM internal compiler error by wrapping malloc\n      1.44 (2014-08-07)\n\t\t       various warning fixes from Ronny Chevalier\n      1.43 (2014-07-15)\n             fix MSVC-only compiler problem in code changed in 1.42\n      1.42 (2014-07-09)\n             don't define _CRT_SECURE_NO_WARNINGS (affects user code)\n             fixes to stbi__cleanup_jpeg path\n             added STBI_ASSERT to avoid requiring assert.h\n      1.41 (2014-06-25)\n             fix search&replace from 1.36 that messed up comments/error messages\n      1.40 (2014-06-22)\n             fix gcc struct-initialization warning\n      1.39 (2014-06-15)\n             fix to TGA optimization when req_comp != number of components in TGA;\n             fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)\n             add support for BMP version 5 (more ignored fields)\n      1.38 (2014-06-06)\n             suppress MSVC warnings on integer casts truncating values\n             fix accidental rename of 'skip' field of I/O\n      1.37 (2014-06-04)\n             remove duplicate typedef\n      1.36 (2014-06-03)\n             convert to header file single-file library\n             if de-iphone isn't set, load iphone images color-swapped instead of returning NULL\n      1.35 (2014-05-27)\n             various warnings\n             fix broken STBI_SIMD path\n             fix bug where stbi_load_from_file no longer left file pointer in correct place\n             fix broken non-easy path for 32-bit BMP (possibly never used)\n             TGA optimization by Arseny Kapoulkine\n      1.34 (unknown)\n             use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case\n      1.33 (2011-07-14)\n             make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements\n      1.32 (2011-07-13)\n             support for \"info\" function for all supported filetypes (SpartanJ)\n      1.31 (2011-06-20)\n             a few more leak fixes, bug in PNG handling (SpartanJ)\n      1.30 (2011-06-11)\n             added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)\n             removed deprecated format-specific test/load functions\n             removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway\n             error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)\n             fix inefficiency in decoding 32-bit BMP (David Woo)\n      1.29 (2010-08-16)\n             various warning fixes from Aurelien Pocheville \n      1.28 (2010-08-01)\n             fix bug in GIF palette transparency (SpartanJ)\n      1.27 (2010-08-01)\n             cast-to-stbi_uc to fix warnings\n      1.26 (2010-07-24)\n             fix bug in file buffering for PNG reported by SpartanJ\n      1.25 (2010-07-17)\n             refix trans_data warning (Won Chun)\n      1.24 (2010-07-12)\n             perf improvements reading from files on platforms with lock-heavy fgetc()\n             minor perf improvements for jpeg\n             deprecated type-specific functions so we'll get feedback if they're needed\n             attempt to fix trans_data warning (Won Chun)\n      1.23   fixed bug in iPhone support\n      1.22 (2010-07-10)\n             removed image *writing* support\n             stbi_info support from Jetro Lauha\n             GIF support from Jean-Marc Lienher\n             iPhone PNG-extensions from James Brown\n             warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)\n      1.21   fix use of 'stbi_uc' in header (reported by jon blow)\n      1.20   added support for Softimage PIC, by Tom Seddon\n      1.19   bug in interlaced PNG corruption check (found by ryg)\n      1.18 2008-08-02\n             fix a threading bug (local mutable static)\n      1.17   support interlaced PNG\n      1.16   major bugfix - stbi__convert_format converted one too many pixels\n      1.15   initialize some fields for thread safety\n      1.14   fix threadsafe conversion bug\n             header-file-only version (#define STBI_HEADER_FILE_ONLY before including)\n      1.13   threadsafe\n      1.12   const qualifiers in the API\n      1.11   Support installable IDCT, colorspace conversion routines\n      1.10   Fixes for 64-bit (don't use \"unsigned long\")\n             optimized upsampling by Fabian \"ryg\" Giesen\n      1.09   Fix format-conversion for PSD code (bad global variables!)\n      1.08   Thatcher Ulrich's PSD code integrated by Nicolas Schulz\n      1.07   attempt to fix C++ warning/errors again\n      1.06   attempt to fix C++ warning/errors again\n      1.05   fix TGA loading to return correct *comp and use good luminance calc\n      1.04   default float alpha is 1, not 255; use 'void *' for stbi_image_free\n      1.03   bugfixes to STBI_NO_STDIO, STBI_NO_HDR\n      1.02   support for (subset of) HDR files, float interface for preferred access to them\n      1.01   fix bug: possible bug in handling right-side up bmps... not sure\n             fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all\n      1.00   interface to zlib that skips zlib header\n      0.99   correct handling of alpha in palette\n      0.98   TGA loader by lonesock; dynamically add loaders (untested)\n      0.97   jpeg errors on too large a file; also catch another malloc failure\n      0.96   fix detection of invalid v value - particleman@mollyrocket forum\n      0.95   during header scan, seek to markers in case of padding\n      0.94   STBI_NO_STDIO to disable stdio usage; rename all #defines the same\n      0.93   handle jpegtran output; verbose errors\n      0.92   read 4,8,16,24,32-bit BMP files of several formats\n      0.91   output 24-bit Windows 3.0 BMP files\n      0.90   fix a few more warnings; bump version number to approach 1.0\n      0.61   bugfixes due to Marc LeBlanc, Christopher Lloyd\n      0.60   fix compiling as c++\n      0.59   fix warnings: merge Dave Moore's -Wall fixes\n      0.58   fix bug: zlib uncompressed mode len/nlen was wrong endian\n      0.57   fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available\n      0.56   fix bug: zlib uncompressed mode len vs. nlen\n      0.55   fix bug: restart_interval not initialized to 0\n      0.54   allow NULL for 'int *comp'\n      0.53   fix bug in png 3->4; speedup png decoding\n      0.52   png handles req_comp=3,4 directly; minor cleanup; jpeg comments\n      0.51   obey req_comp requests, 1-component jpegs return as 1-component,\n             on 'test' only check type, not whether we support this variant\n      0.50   first released version\n*/\n#pragma GCC diagnostic pop\n\nheman_image* hut_read_image(const char* filename, int nbands)\n{\n    int width = 0, height = 0;\n    stbi_uc* bytes;\n    heman_image* retval;\n    int bands_in_file;\n    bytes = stbi_load(filename, &width, &height, &bands_in_file, nbands);\n    assert(bytes);\n    printf(\"%4d x %4d x %d :: %s\\n\", width, height, nbands, filename);\n    retval = heman_import_u8(width, height, nbands, bytes, 0, 1);\n    stbi_image_free(bytes);\n    return retval;\n}\n\nvoid hut_write_image(const char* filename, heman_image* img, float minv, float maxv)\n{\n    printf(\"Writing to \\\"%s\\\".\\n\", filename);\n    int width, height, ncomp;\n    heman_image_info(img, &width, &height, &ncomp);\n    unsigned char* bytes = (unsigned char*) malloc(width * height * ncomp);\n    heman_export_u8(img, minv, maxv, bytes);\n    stbi_write_png(filename, width, height, ncomp, bytes, width * ncomp);\n    free(bytes);\n}\n\nvoid hut_write_image_scaled(const char* filename, heman_image* img, int dwidth, int dheight)\n{\n    printf(\"Writing to \\\"%s\\\".\\n\", filename);\n    int width, height, ncomp;\n    heman_image_info(img, &width, &height, &ncomp);\n    unsigned char* bytes = (unsigned char*) malloc(width * height * ncomp);\n    heman_export_u8(img, 0, 1, bytes);\n    unsigned char* resized = (unsigned char*) malloc(dwidth * dheight * 3);\n    stbir_resize_uint8(bytes, width, height, 0, resized, dwidth, dheight, 0, 3);\n    stbi_write_png(filename, dwidth, dheight, ncomp, resized, dwidth * ncomp);\n    free(resized);\n    free(bytes);\n}\n\n#ifdef __APPLE__\ndouble omp_get_wtime() { return 1; }\nint omp_get_max_threads() { return 1; }\n#else\n#include <omp.h>\n#endif\n\nstatic const int SIZE = 512;\n\n#define COUNT(a) (sizeof(a) / sizeof(a[0]))\n#define OUTFOLDER \"./\"\n\n// Create a reasonable ocean-to-land color gradient.\nint cp_locations[] = {\n    000,  // Dark Blue\n    126,  // Light Blue\n    127,  // Yellow\n    128,  // Dark Green\n    160,  // Brown\n    200,  // White\n    255,  // White\n};\n\nheman_color cp_colors[] = {\n    0x001070,  // Dark Blue\n    0x2C5A7C,  // Light Blue\n    0xE0F0A0,  // Yellow\n    0x5D943C,  // Dark Green\n    0x606011,  // Brown\n    0xFFFFFF,  // White\n    0xFFFFFF,  // White\n};\n\n\n\n\n\n\n\n\n\n\n\n]"
}