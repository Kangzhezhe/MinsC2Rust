{
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/buffer.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/buffer.c",
    "parse_success": true,
    "functions": [
      {
        "name": "buffer_new",
        "type": "definition",
        "return_type": "buffer_t",
        "parameters": [],
        "is_static": false,
        "start_line": 29,
        "end_line": 32,
        "start_byte": 495,
        "end_byte": 574,
        "signature": "buffer_t *\nbuffer_new()",
        "full_definition": "buffer_t *\nbuffer_new() {\n  return buffer_new_with_size(BUFFER_DEFAULT_SIZE);\n}",
        "definition_length": 79,
        "comment": "* Allocate a new buffer with BUFFER_DEFAULT_SIZE."
      },
      {
        "name": "buffer_new_with_size",
        "type": "definition",
        "return_type": "buffer_t",
        "parameters": [
          "size_t n"
        ],
        "is_static": false,
        "start_line": 38,
        "end_line": 45,
        "start_byte": 625,
        "end_byte": 820,
        "signature": "buffer_t *\nbuffer_new_with_size(size_t n)",
        "full_definition": "buffer_t *\nbuffer_new_with_size(size_t n) {\n  buffer_t *self = malloc(sizeof(buffer_t));\n  if (!self) return NULL;\n  self->len = n;\n  self->data = self->alloc = calloc(n + 1, 1);\n  return self;\n}",
        "definition_length": 195,
        "comment": "* Allocate a new buffer with `n` bytes."
      },
      {
        "name": "buffer_new_with_string",
        "type": "definition",
        "return_type": "buffer_t",
        "parameters": [
          "char *str"
        ],
        "is_static": false,
        "start_line": 51,
        "end_line": 54,
        "start_byte": 867,
        "end_byte": 973,
        "signature": "buffer_t *\nbuffer_new_with_string(char *str)",
        "full_definition": "buffer_t *\nbuffer_new_with_string(char *str) {\n  return buffer_new_with_string_length(str, strlen(str));\n}",
        "definition_length": 106,
        "comment": "* Allocate a new buffer with `str`."
      },
      {
        "name": "buffer_new_with_string_length",
        "type": "definition",
        "return_type": "buffer_t",
        "parameters": [
          "char *str",
          "size_t len"
        ],
        "is_static": false,
        "start_line": 60,
        "end_line": 67,
        "start_byte": 1030,
        "end_byte": 1236,
        "signature": "buffer_t *\nbuffer_new_with_string_length(char *str, size_t len)",
        "full_definition": "buffer_t *\nbuffer_new_with_string_length(char *str, size_t len) {\n  buffer_t *self = malloc(sizeof(buffer_t));\n  if (!self) return NULL;\n  self->len = len;\n  self->data = self->alloc = str;\n  return self;\n}",
        "definition_length": 206,
        "comment": "* Allocate a new buffer with `str` and `len`."
      },
      {
        "name": "buffer_new_with_copy",
        "type": "definition",
        "return_type": "buffer_t",
        "parameters": [
          "char *str"
        ],
        "is_static": false,
        "start_line": 73,
        "end_line": 81,
        "start_byte": 1293,
        "end_byte": 1515,
        "signature": "buffer_t *\nbuffer_new_with_copy(char *str)",
        "full_definition": "buffer_t *\nbuffer_new_with_copy(char *str) {\n  size_t len = strlen(str);\n  buffer_t *self = buffer_new_with_size(len);\n  if (!self) return NULL;\n  memcpy(self->alloc, str, len);\n  self->data = self->alloc;\n  return self;\n}",
        "definition_length": 222,
        "comment": "* Allocate a new buffer with a copy of `str`."
      },
      {
        "name": "buffer_compact",
        "type": "definition",
        "return_type": "ssize_t",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 88,
        "end_line": 99,
        "start_byte": 1592,
        "end_byte": 1879,
        "signature": "ssize_t\nbuffer_compact(buffer_t *self)",
        "full_definition": "ssize_t\nbuffer_compact(buffer_t *self) {\n  size_t len = buffer_length(self);\n  size_t rem = self->len - len;\n  char *buf = calloc(len + 1, 1);\n  if (!buf) return -1;\n  memcpy(buf, self->data, len);\n  free(self->alloc);\n  self->len = len;\n  self->data = self->alloc = buf;\n  return rem;\n}",
        "definition_length": 287,
        "comment": "* Deallocate excess memory, the number\n * of bytes removed or -1."
      },
      {
        "name": "buffer_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 105,
        "end_line": 109,
        "start_byte": 1909,
        "end_byte": 1980,
        "signature": "void\nbuffer_free(buffer_t *self)",
        "full_definition": "void\nbuffer_free(buffer_t *self) {\n  free(self->alloc);\n  free(self);\n}",
        "definition_length": 71,
        "comment": "* Free the buffer."
      },
      {
        "name": "buffer_size",
        "type": "definition",
        "return_type": "size_t",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 115,
        "end_line": 118,
        "start_byte": 2013,
        "end_byte": 2071,
        "signature": "size_t\nbuffer_size(buffer_t *self)",
        "full_definition": "size_t\nbuffer_size(buffer_t *self) {\n  return self->len;\n}",
        "definition_length": 58,
        "comment": "* Return buffer size."
      },
      {
        "name": "buffer_length",
        "type": "definition",
        "return_type": "size_t",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 124,
        "end_line": 127,
        "start_byte": 2106,
        "end_byte": 2175,
        "signature": "size_t\nbuffer_length(buffer_t *self)",
        "full_definition": "size_t\nbuffer_length(buffer_t *self) {\n  return strlen(self->data);\n}",
        "definition_length": 69,
        "comment": "* Return string length."
      },
      {
        "name": "buffer_resize",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "size_t n"
        ],
        "is_static": false,
        "start_line": 133,
        "end_line": 141,
        "start_byte": 2214,
        "end_byte": 2440,
        "signature": "int\nbuffer_resize(buffer_t *self, size_t n)",
        "full_definition": "int\nbuffer_resize(buffer_t *self, size_t n) {\n  n = nearest_multiple_of(1024, n);\n  self->len = n;\n  self->alloc = self->data = realloc(self->alloc, n + 1);\n  if (!self->alloc) return -1;\n  self->alloc[n] = '\\0';\n  return 0;\n}",
        "definition_length": 226,
        "comment": "* Resize to hold `n` bytes."
      },
      {
        "name": "buffer_appendf",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "const char *format"
        ],
        "is_static": false,
        "start_line": 147,
        "end_line": 179,
        "start_byte": 2507,
        "end_byte": 3250,
        "signature": "int buffer_appendf(buffer_t *self, const char *format, ...)",
        "full_definition": "int buffer_appendf(buffer_t *self, const char *format, ...) {\n  va_list ap;\n  va_list tmpa;\n  char *dst = NULL;\n  int length = 0;\n  int required = 0;\n  int bytes = 0;\n\n  va_start(ap, format);\n\n  length = buffer_length(self);\n\n  // First, we compute how many bytes are needed\n  // for the formatted string and allocate that\n  // much more space in the buffer.\n  va_copy(tmpa, ap);\n  required = vsnprintf(NULL, 0, format, tmpa);\n  va_end(tmpa);\n  if (-1 == buffer_resize(self, length + required)) {\n    va_end(ap);\n    return -1;\n  }\n\n  // Next format the string into the space that we\n  // have made room for.\n  dst = self->data + length;\n  bytes = vsnprintf(dst, 1 + required, format, ap);\n  va_end(ap);\n\n  return bytes < 0\n    ? -1\n    : 0;\n}",
        "definition_length": 743,
        "comment": "* Append a printf-style formatted string to the buffer."
      },
      {
        "name": "buffer_append",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "const char *str"
        ],
        "is_static": false,
        "start_line": 185,
        "end_line": 188,
        "start_byte": 3326,
        "end_byte": 3430,
        "signature": "int\nbuffer_append(buffer_t *self, const char *str)",
        "full_definition": "int\nbuffer_append(buffer_t *self, const char *str) {\n  return buffer_append_n(self, str, strlen(str));\n}",
        "definition_length": 104,
        "comment": "* Append `str` to `self` and return 0 on success, -1 on failure."
      },
      {
        "name": "buffer_append_n",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "const char *str",
          "size_t len"
        ],
        "is_static": false,
        "start_line": 194,
        "end_line": 211,
        "start_byte": 3535,
        "end_byte": 3897,
        "signature": "int\nbuffer_append_n(buffer_t *self, const char *str, size_t len)",
        "full_definition": "int\nbuffer_append_n(buffer_t *self, const char *str, size_t len) {\n  size_t prev = strlen(self->data);\n  size_t needed = len + prev;\n\n  // enough space\n  if (self->len > needed) {\n    strncat(self->data, str, len);\n    return 0;\n  }\n\n  // resize\n  int ret = buffer_resize(self, needed);\n  if (-1 == ret) return -1;\n  strncat(self->data, str, len);\n\n  return 0;\n}",
        "definition_length": 362,
        "comment": "* Append the first `len` bytes from `str` to `self` and\n * return 0 on success, -1 on failure."
      },
      {
        "name": "buffer_prepend",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "char *str"
        ],
        "is_static": false,
        "start_line": 217,
        "end_line": 236,
        "start_byte": 3974,
        "end_byte": 4370,
        "signature": "int\nbuffer_prepend(buffer_t *self, char *str)",
        "full_definition": "int\nbuffer_prepend(buffer_t *self, char *str) {\n  size_t len = strlen(str);\n  size_t prev = strlen(self->data);\n  size_t needed = len + prev;\n\n  // enough space\n  if (self->len > needed) goto move;\n\n  // resize\n  int ret = buffer_resize(self, needed);\n  if (-1 == ret) return -1;\n\n  // move\n  move:\n  memmove(self->data + len, self->data, prev + 1);\n  memcpy(self->data, str, len);\n\n  return 0;\n}",
        "definition_length": 396,
        "comment": "* Prepend `str` to `self` and return 0 on success, -1 on failure."
      },
      {
        "name": "buffer_slice",
        "type": "definition",
        "return_type": "buffer_t",
        "parameters": [
          "buffer_t *buf",
          "size_t from",
          "ssize_t to"
        ],
        "is_static": false,
        "start_line": 243,
        "end_line": 260,
        "start_byte": 4464,
        "end_byte": 4830,
        "signature": "buffer_t *\nbuffer_slice(buffer_t *buf, size_t from, ssize_t to)",
        "full_definition": "buffer_t *\nbuffer_slice(buffer_t *buf, size_t from, ssize_t to) {\n  size_t len = strlen(buf->data);\n\n  // bad range\n  if (to < from) return NULL;\n\n  // relative to end\n  if (to < 0) to = len - ~to;\n\n  // cap end\n  if (to > len) to = len;\n\n  size_t n = to - from;\n  buffer_t *self = buffer_new_with_size(n);\n  memcpy(self->data, buf->data + from, n);\n  return self;\n}",
        "definition_length": 366,
        "comment": "* Return a new buffer based on the `from..to` slice of `buf`,\n * or NULL on error."
      },
      {
        "name": "buffer_equals",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "buffer_t *other"
        ],
        "is_static": false,
        "start_line": 266,
        "end_line": 269,
        "start_byte": 4892,
        "end_byte": 4993,
        "signature": "int\nbuffer_equals(buffer_t *self, buffer_t *other)",
        "full_definition": "int\nbuffer_equals(buffer_t *self, buffer_t *other) {\n  return 0 == strcmp(self->data, other->data);\n}",
        "definition_length": 101,
        "comment": "* Return 1 if the buffers contain equivalent data."
      },
      {
        "name": "buffer_indexof",
        "type": "definition",
        "return_type": "ssize_t",
        "parameters": [
          "buffer_t *self",
          "char *str"
        ],
        "is_static": false,
        "start_line": 275,
        "end_line": 280,
        "start_byte": 5065,
        "end_byte": 5207,
        "signature": "ssize_t\nbuffer_indexof(buffer_t *self, char *str)",
        "full_definition": "ssize_t\nbuffer_indexof(buffer_t *self, char *str) {\n  char *sub = strstr(self->data, str);\n  if (!sub) return -1;\n  return sub - self->data;\n}",
        "definition_length": 142,
        "comment": "* Return the index of the substring `str`, or -1 on failure."
      },
      {
        "name": "buffer_trim_left",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 286,
        "end_line": 292,
        "start_byte": 5245,
        "end_byte": 5361,
        "signature": "void\nbuffer_trim_left(buffer_t *self)",
        "full_definition": "void\nbuffer_trim_left(buffer_t *self) {\n  int c;\n  while ((c = *self->data) && isspace(c)) {\n    ++self->data;\n  }\n}",
        "definition_length": 116,
        "comment": "* Trim leading whitespace."
      },
      {
        "name": "buffer_trim_right",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 298,
        "end_line": 305,
        "start_byte": 5400,
        "end_byte": 5564,
        "signature": "void\nbuffer_trim_right(buffer_t *self)",
        "full_definition": "void\nbuffer_trim_right(buffer_t *self) {\n  int c;\n  size_t i = buffer_length(self) - 1;\n  while ((c = self->data[i]) && isspace(c)) {\n    self->data[i--] = 0;\n  }\n}",
        "definition_length": 164,
        "comment": "* Trim trailing whitespace."
      },
      {
        "name": "buffer_trim",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 311,
        "end_line": 315,
        "start_byte": 5615,
        "end_byte": 5704,
        "signature": "void\nbuffer_trim(buffer_t *self)",
        "full_definition": "void\nbuffer_trim(buffer_t *self) {\n  buffer_trim_left(self);\n  buffer_trim_right(self);\n}",
        "definition_length": 89,
        "comment": "* Trim trailing and leading whitespace."
      },
      {
        "name": "buffer_fill",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "buffer_t *self",
          "int c"
        ],
        "is_static": false,
        "start_line": 321,
        "end_line": 324,
        "start_byte": 5743,
        "end_byte": 5822,
        "signature": "void\nbuffer_fill(buffer_t *self, int c)",
        "full_definition": "void\nbuffer_fill(buffer_t *self, int c) {\n  memset(self->data, c, self->len);\n}",
        "definition_length": 79,
        "comment": "* Fill the buffer with `c`."
      },
      {
        "name": "buffer_clear",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 330,
        "end_line": 333,
        "start_byte": 5859,
        "end_byte": 5920,
        "signature": "void\nbuffer_clear(buffer_t *self)",
        "full_definition": "void\nbuffer_clear(buffer_t *self) {\n  buffer_fill(self, 0);\n}",
        "definition_length": 61,
        "comment": "* Fill the buffer with 0."
      },
      {
        "name": "buffer_print",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "is_static": false,
        "start_line": 339,
        "end_line": 353,
        "start_byte": 5965,
        "end_byte": 6194,
        "signature": "void\nbuffer_print(buffer_t *self)",
        "full_definition": "void\nbuffer_print(buffer_t *self) {\n  int i;\n  size_t len = self->len;\n\n  printf(\"\\n \");\n\n  // hex\n  for (i = 0; i < len; ++i) {\n    printf(\" %02x\", self->alloc[i]);\n    if ((i + 1) % 8 == 0) printf(\"\\n \");\n  }\n\n  printf(\"\\n\");\n}",
        "definition_length": 229,
        "comment": "* Print a hex dump of the buffer."
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <string.h>",
        "line": 7,
        "start_line": 7,
        "end_line": 8,
        "start_byte": 80,
        "end_byte": 100
      },
      {
        "text": "#include <stdio.h>",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 100,
        "end_byte": 119
      },
      {
        "text": "#include <stdarg.h>",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 119,
        "end_byte": 139
      },
      {
        "text": "#include <stdlib.h>",
        "line": 10,
        "start_line": 10,
        "end_line": 11,
        "start_byte": 139,
        "end_byte": 159
      },
      {
        "text": "#include <ctype.h>",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 159,
        "end_byte": 178
      },
      {
        "text": "#include <sys/types.h>",
        "line": 12,
        "start_line": 12,
        "end_line": 13,
        "start_byte": 178,
        "end_byte": 201
      },
      {
        "text": "#include \"buffer.h\"",
        "line": 13,
        "start_line": 13,
        "end_line": 14,
        "start_byte": 201,
        "end_byte": 221
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [
      {
        "text": "#define nearest_multiple_of(a, b) \\\n  (((b) + ((a) - 1)) & ~((a) - 1))",
        "name": "nearest_multiple_of",
        "line": 22,
        "start_line": 22,
        "end_line": 24,
        "start_byte": 364,
        "end_byte": 435,
        "comment": "* Compute the nearest multiple of `a` from `b`."
      }
    ],
    "enums": [],
    "total_nodes": 1817,
    "file_size": 6195
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/ht.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/ht.c",
    "parse_success": true,
    "functions": [
      {
        "name": "ht_create",
        "type": "definition",
        "return_type": "ht",
        "parameters": [
          "void"
        ],
        "is_static": false,
        "start_line": 25,
        "end_line": 41,
        "start_byte": 576,
        "end_byte": 1049,
        "signature": "ht* ht_create(void)",
        "full_definition": "ht* ht_create(void) {\n    // Allocate space for hash table struct.\n    ht* table = malloc(sizeof(ht));\n    if (table == NULL) {\n        return NULL;\n    }\n    table->length = 0;\n    table->capacity = INITIAL_CAPACITY;\n\n    // Allocate (zero'd) space for entry buckets.\n    table->entries = calloc(table->capacity, sizeof(ht_entry));\n    if (table->entries == NULL) {\n        free(table); // error, free table before we return!\n        return NULL;\n    }\n    return table;\n}",
        "definition_length": 473,
        "comment": ""
      },
      {
        "name": "ht_destroy",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "ht* table"
        ],
        "is_static": false,
        "start_line": 43,
        "end_line": 52,
        "start_byte": 1051,
        "end_byte": 1309,
        "signature": "void ht_destroy(ht* table)",
        "full_definition": "void ht_destroy(ht* table) {\n    // First free allocated keys.\n    for (size_t i = 0; i < table->capacity; i++) {\n        free((void*)table->entries[i].key);\n    }\n\n    // Then free entries array and table itself.\n    free(table->entries);\n    free(table);\n}",
        "definition_length": 258,
        "comment": ""
      },
      {
        "name": "hash_key",
        "type": "definition",
        "return_type": "64_t has",
        "parameters": [
          "t char* key) {"
        ],
        "is_static": false,
        "start_line": 59,
        "end_line": 66,
        "start_byte": 1522,
        "end_byte": 1741,
        "signature": "static uint64_t hash_key(const char* key)",
        "full_definition": "static uint64_t hash_key(const char* key) {\n    uint64_t hash = FNV_OFFSET;\n    for (const char* p = key; *p; p++) {\n        hash ^= (uint64_t)(unsigned char)(*p);\n        hash *= FNV_PRIME;\n    }\n    return hash;\n}\n\nvo",
        "definition_length": 219,
        "comment": "Return 64-bit FNV-1a hash for key (NUL-terminated). See description: https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function\nsta"
      },
      {
        "name": "ht_get",
        "type": "definition",
        "return_type": "* ht",
        "parameters": [
          "table, co",
          "t char* key) {"
        ],
        "is_static": false,
        "start_line": 68,
        "end_line": 87,
        "start_byte": 1739,
        "end_byte": 2440,
        "signature": "void* ht_get(ht* table, const char* key)",
        "full_definition": "void* ht_get(ht* table, const char* key) {\n    // AND hash with capacity-1 to ensure it's within entries array.\n    uint64_t hash = hash_key(key);\n    size_t index = (size_t)(hash & (uint64_t)(table->capacity - 1));\n\n    // Loop till we find an empty entry.\n    while (table->entries[index].key != NULL) {\n        if (strcmp(key, table->entries[index].key) == 0) {\n            // Found key, return value.\n            return table->entries[index].value;\n        }\n        // Key wasn't in this slot, move to next (linear probing).\n        index++;\n        if (index >= table->capacity) {\n            // At end of entries array, wrap around.\n            index = 0;\n        }\n    }\n    return NULL;\n}\n\n//",
        "definition_length": 701,
        "comment": ""
      },
      {
        "name": "ht_set_entry",
        "type": "definition",
        "return_type": "* ht",
        "parameters": [
          "ntry* entries, si",
          "_t capacity,",
          "t char* key, vo",
          "* value, si",
          "_t* plength) {"
        ],
        "is_static": false,
        "start_line": 90,
        "end_line": 122,
        "start_byte": 2502,
        "end_byte": 3590,
        "signature": "static const char* ht_set_entry(ht_entry* entries, size_t capacity,\n        const char* key, void* value, size_t* plength)",
        "full_definition": "static const char* ht_set_entry(ht_entry* entries, size_t capacity,\n        const char* key, void* value, size_t* plength) {\n    // AND hash with capacity-1 to ensure it's within entries array.\n    uint64_t hash = hash_key(key);\n    size_t index = (size_t)(hash & (uint64_t)(capacity - 1));\n\n    // Loop till we find an empty entry.\n    while (entries[index].key != NULL) {\n        if (strcmp(key, entries[index].key) == 0) {\n            // Found key (it already exists), update value.\n            entries[index].value = value;\n            return entries[index].key;\n        }\n        // Key wasn't in this slot, move to next (linear probing).\n        index++;\n        if (index >= capacity) {\n            // At end of entries array, wrap around.\n            index = 0;\n        }\n    }\n\n    // Didn't find key, allocate+copy if needed, then insert it.\n    if (plength != NULL) {\n        key = strdup(key);\n        if (key == NULL) {\n            return NULL;\n        }\n        (*plength)++;\n    }\n    entries[index].key = (char*)key;\n    entries[index].value = value;\n    return key;\n}\n\n//",
        "definition_length": 1088,
        "comment": "nternal function to set an entry (without expanding table).\nsta"
      },
      {
        "name": "ht_expand",
        "type": "definition",
        "return_type": "ht_",
        "parameters": [
          "table) {"
        ],
        "is_static": false,
        "start_line": 126,
        "end_line": 151,
        "start_byte": 3687,
        "end_byte": 4549,
        "signature": "static bool ht_expand(ht* table)",
        "full_definition": "static bool ht_expand(ht* table) {\n    // Allocate new entries array.\n    size_t new_capacity = table->capacity * 2;\n    if (new_capacity < table->capacity) {\n        return false;  // overflow (capacity would be too big)\n    }\n    ht_entry* new_entries = calloc(new_capacity, sizeof(ht_entry));\n    if (new_entries == NULL) {\n        return false;\n    }\n\n    // Iterate entries, move all non-empty ones to new table's entries.\n    for (size_t i = 0; i < table->capacity; i++) {\n        ht_entry entry = table->entries[i];\n        if (entry.key != NULL) {\n            ht_set_entry(new_entries, new_capacity, entry.key,\n                         entry.value, NULL);\n        }\n    }\n\n    // Free old entries array and update this table's details.\n    free(table->entries);\n    table->entries = new_entries;\n    table->capacity = new_capacity;\n    return true;\n}\n\nco",
        "definition_length": 862,
        "comment": "xpand hash table to twice its current size. Return true on success,\n// alse if out of memory.\nsta"
      },
      {
        "name": "ht_set",
        "type": "definition",
        "return_type": "* ht",
        "parameters": [
          "table, co",
          "t char* key, vo",
          "* value) {"
        ],
        "is_static": false,
        "start_line": 153,
        "end_line": 169,
        "start_byte": 4547,
        "end_byte": 5029,
        "signature": "const char* ht_set(ht* table, const char* key, void* value)",
        "full_definition": "const char* ht_set(ht* table, const char* key, void* value) {\n    assert(value != NULL);\n    if (value == NULL) {\n        return NULL;\n    }\n\n    // If length will exceed half of current capacity, expand it.\n    if (table->length >= table->capacity / 2) {\n        if (!ht_expand(table)) {\n            return NULL;\n        }\n    }\n\n    // Set entry and update length.\n    return ht_set_entry(table->entries, table->capacity, key, value,\n                        &table->length);\n}\n\nsi",
        "definition_length": 482,
        "comment": ""
      },
      {
        "name": "ht_length",
        "type": "definition",
        "return_type": "_t ht_",
        "parameters": [
          "table) {"
        ],
        "is_static": false,
        "start_line": 171,
        "end_line": 173,
        "start_byte": 5027,
        "end_byte": 5088,
        "signature": "size_t ht_length(ht* table)",
        "full_definition": "size_t ht_length(ht* table) {\n    return table->length;\n}\n\nht",
        "definition_length": 61,
        "comment": ""
      },
      {
        "name": "ht_iterator",
        "type": "definition",
        "return_type": "ht_",
        "parameters": [
          "table) {"
        ],
        "is_static": false,
        "start_line": 175,
        "end_line": 180,
        "start_byte": 5086,
        "end_byte": 5189,
        "signature": "hti ht_iterator(ht* table)",
        "full_definition": "hti ht_iterator(ht* table) {\n    hti it;\n    it._table = table;\n    it._index = 0;\n    return it;\n}\n\nbo",
        "definition_length": 103,
        "comment": ""
      },
      {
        "name": "ht_next",
        "type": "definition",
        "return_type": "ht_",
        "parameters": [
          "it) {"
        ],
        "is_static": false,
        "start_line": 182,
        "end_line": 197,
        "start_byte": 5187,
        "end_byte": 5684,
        "signature": "bool ht_next(hti* it)",
        "full_definition": "bool ht_next(hti* it) {\n    // Loop till we've hit end of entries array.\n    ht* table = it->_table;\n    while (it->_index < table->capacity) {\n        size_t i = it->_index;\n        it->_index++;\n        if (table->entries[i].key != NULL) {\n            // Found next non-empty item, update iterator key and value.\n            ht_entry entry = table->entries[i];\n            it->key = entry.key;\n            it->value = entry.value;\n            return true;\n        }\n    }\n    return false;\n}\n",
        "definition_length": 494,
        "comment": ""
      }
    ],
    "structs": [
      {
        "name": "ht",
        "start_line": 17,
        "end_line": 21,
        "start_byte": 365,
        "end_byte": 523,
        "full_definition": "struct ht {\n    ht_entry* entries;  // hash slots\n    size_t capacity;    // size of _entries array\n    size_t length;      // number of items in hash table\n}",
        "fields": [
          {
            "text": "ht_entry* entries;",
            "line": 18,
            "start_line": 18,
            "end_line": 18,
            "start_byte": 381,
            "end_byte": 399
          },
          {
            "text": "size_t capacity;",
            "line": 19,
            "start_line": 19,
            "end_line": 19,
            "start_byte": 419,
            "end_byte": 435
          },
          {
            "text": "size_t length;",
            "line": 20,
            "start_line": 20,
            "end_line": 20,
            "start_byte": 469,
            "end_byte": 483
          }
        ],
        "definition_length": 158,
        "comment": "Hash table structure: create with ht_create, free with ht_destroy."
      }
    ],
    "includes": [
      {
        "text": "#include \"ht.h\"",
        "line": 3,
        "start_line": 3,
        "end_line": 4,
        "start_byte": 40,
        "end_byte": 56
      },
      {
        "text": "#include <assert.h>",
        "line": 5,
        "start_line": 5,
        "end_line": 6,
        "start_byte": 57,
        "end_byte": 77
      },
      {
        "text": "#include <stdint.h>",
        "line": 6,
        "start_line": 6,
        "end_line": 7,
        "start_byte": 77,
        "end_byte": 97
      },
      {
        "text": "#include <stdlib.h>",
        "line": 7,
        "start_line": 7,
        "end_line": 8,
        "start_byte": 97,
        "end_byte": 117
      },
      {
        "text": "#include <string.h>",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 117,
        "end_byte": 137
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef struct {\n    const char* key;  // key is NULL if this slot is empty\n    void* value;\n} ht_entry;",
        "name": "ht_entry",
        "line": 11,
        "start_line": 11,
        "end_line": 14,
        "start_byte": 189,
        "end_byte": 293,
        "comment": "Hash table entry (slot may be filled or empty)."
      }
    ],
    "macros": [
      {
        "text": "#define INITIAL_CAPACITY 16  // must not be zero",
        "name": "INITIAL_CAPACITY",
        "line": 23,
        "start_line": 23,
        "end_line": 24,
        "start_byte": 526,
        "end_byte": 575,
        "comment": "number of items in hash table"
      },
      {
        "text": "#define FNV_OFFSET 14695981039346656037UL",
        "name": "FNV_OFFSET",
        "line": 54,
        "start_line": 54,
        "end_line": 55,
        "start_byte": 1311,
        "end_byte": 1353,
        "comment": ""
      },
      {
        "text": "#define FNV_PRIME 1099511628211UL",
        "name": "FNV_PRIME",
        "line": 55,
        "start_line": 55,
        "end_line": 56,
        "start_byte": 1353,
        "end_byte": 1387,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 1365,
    "file_size": 5681
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/binn.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/binn.c",
    "parse_success": true,
    "functions": [
      {
        "name": "copy_be16",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "u16 *pdest",
          "u16 *psource"
        ],
        "is_static": false,
        "start_line": 68,
        "end_line": 88,
        "start_byte": 2015,
        "end_byte": 2647,
        "signature": "BINN_PRIVATE void copy_be16(u16 *pdest, u16 *psource)",
        "full_definition": "BINN_PRIVATE void copy_be16(u16 *pdest, u16 *psource) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  dest[0] = source[1];\n  dest[1] = source[0];\n#else // if BYTE_ORDER == BIG_ENDIAN\n#ifdef BINN_ONLY_ALIGNED_ACCESS\n  if ((uintptr_t)psource % 2 == 0){  // address aligned to 16 bit\n    *pdest = *psource;\n  } else {\n    unsigned char *source = (unsigned char *) psource;\n    unsigned char *dest = (unsigned char *) pdest;\n    dest[0] = source[0];  // indexes are the same\n    dest[1] = source[1];\n  }\n#else\n  *pdest = *psource;\n#endif\n#endif\n}",
        "definition_length": 632,
        "comment": ""
      },
      {
        "name": "copy_be32",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "u32 *pdest",
          "u32 *psource"
        ],
        "is_static": false,
        "start_line": 90,
        "end_line": 114,
        "start_byte": 2649,
        "end_byte": 3377,
        "signature": "BINN_PRIVATE void copy_be32(u32 *pdest, u32 *psource)",
        "full_definition": "BINN_PRIVATE void copy_be32(u32 *pdest, u32 *psource) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  dest[0] = source[3];\n  dest[1] = source[2];\n  dest[2] = source[1];\n  dest[3] = source[0];\n#else // if BYTE_ORDER == BIG_ENDIAN\n#ifdef BINN_ONLY_ALIGNED_ACCESS\n  if ((uintptr_t)psource % 4 == 0){  // address aligned to 32 bit\n    *pdest = *psource;\n  } else {\n    unsigned char *source = (unsigned char *) psource;\n    unsigned char *dest = (unsigned char *) pdest;\n    dest[0] = source[0];  // indexes are the same\n    dest[1] = source[1];\n    dest[2] = source[2];\n    dest[3] = source[3];\n  }\n#else\n  *pdest = *psource;\n#endif\n#endif\n}",
        "definition_length": 728,
        "comment": ""
      },
      {
        "name": "copy_be64",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "u64 *pdest",
          "u64 *psource"
        ],
        "is_static": false,
        "start_line": 116,
        "end_line": 140,
        "start_byte": 3379,
        "end_byte": 4053,
        "signature": "BINN_PRIVATE void copy_be64(u64 *pdest, u64 *psource)",
        "full_definition": "BINN_PRIVATE void copy_be64(u64 *pdest, u64 *psource) {\n#if BYTE_ORDER == LITTLE_ENDIAN\n  unsigned char *source = (unsigned char *) psource;\n  unsigned char *dest = (unsigned char *) pdest;\n  int i;\n  for (i=0; i < 8; i++) {\n    dest[i] = source[7-i];\n  }\n#else // if BYTE_ORDER == BIG_ENDIAN\n#ifdef BINN_ONLY_ALIGNED_ACCESS\n  if ((uintptr_t)psource % 8 == 0){  // address aligned to 64 bit\n    *pdest = *psource;\n  } else {\n    unsigned char *source = (unsigned char *) psource;\n    unsigned char *dest = (unsigned char *) pdest;\n    int i;\n    for (i=0; i < 8; i++) {\n      dest[i] = source[i];  // indexes are the same\n    }\n  }\n#else\n  *pdest = *psource;\n#endif\n#endif\n}",
        "definition_length": 674,
        "comment": ""
      },
      {
        "name": "IsValidBinnHeader",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *pbuf",
          "int *ptype",
          "int *pcount",
          "int *psize",
          "int *pheadersize"
        ],
        "start_line": 149,
        "end_line": 149,
        "start_byte": 4215,
        "end_byte": 4324,
        "full_declaration": "BINN_PRIVATE BOOL IsValidBinnHeader(const void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize);",
        "declaration_length": 109,
        "comment": ""
      },
      {
        "name": "binn_version",
        "type": "definition",
        "return_type": "char",
        "parameters": [],
        "is_static": false,
        "start_line": 153,
        "end_line": 155,
        "start_byte": 4405,
        "end_byte": 4462,
        "signature": "char * APIENTRY binn_version()",
        "full_definition": "char * APIENTRY binn_version() {\n  return BINN_VERSION;\n}",
        "definition_length": 57,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_set_alloc_functions",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "void* (*new_malloc)(size_t)",
          "void* (*new_realloc)(void*,size_t)",
          "void (*new_free)(void*)"
        ],
        "is_static": false,
        "start_line": 159,
        "end_line": 165,
        "start_byte": 4543,
        "end_byte": 4753,
        "signature": "void APIENTRY binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*))",
        "full_definition": "void APIENTRY binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*)) {\n\n  malloc_fn = new_malloc;\n  realloc_fn = new_realloc;\n  free_fn = new_free;\n\n}",
        "definition_length": 210,
        "comment": "*************************************************************************"
      },
      {
        "name": "check_alloc_functions",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [],
        "is_static": false,
        "start_line": 169,
        "end_line": 175,
        "start_byte": 4834,
        "end_byte": 5007,
        "signature": "BINN_PRIVATE void check_alloc_functions()",
        "full_definition": "BINN_PRIVATE void check_alloc_functions() {\n\n  if (malloc_fn == 0) malloc_fn = &malloc;\n  if (realloc_fn == 0) realloc_fn = &realloc;\n  if (free_fn == 0) free_fn = &free;\n\n}",
        "definition_length": 173,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_malloc",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int size"
        ],
        "is_static": false,
        "start_line": 179,
        "end_line": 182,
        "start_byte": 5088,
        "end_byte": 5186,
        "signature": "BINN_PRIVATE void * binn_malloc(int size)",
        "full_definition": "BINN_PRIVATE void * binn_malloc(int size) {\n  check_alloc_functions();\n  return malloc_fn(size);\n}",
        "definition_length": 98,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_memdup",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *src",
          "int size"
        ],
        "is_static": false,
        "start_line": 186,
        "end_line": 195,
        "start_byte": 5267,
        "end_byte": 5493,
        "signature": "BINN_PRIVATE void * binn_memdup(const void *src, int size)",
        "full_definition": "BINN_PRIVATE void * binn_memdup(const void *src, int size) {\n  void *dest;\n\n  if (src == NULL || size <= 0) return NULL;\n  dest = binn_malloc(size);\n  if (dest == NULL) return NULL;\n  memcpy(dest, src, size);\n  return dest;\n\n}",
        "definition_length": 226,
        "comment": "*************************************************************************"
      },
      {
        "name": "strlen2",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "char *str"
        ],
        "is_static": false,
        "start_line": 199,
        "end_line": 204,
        "start_byte": 5574,
        "end_byte": 5669,
        "signature": "BINN_PRIVATE size_t strlen2(char *str)",
        "full_definition": "BINN_PRIVATE size_t strlen2(char *str) {\n\n  if (str == NULL) return 0;\n  return strlen(str);\n\n}",
        "definition_length": 95,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_create_type",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "int storage_type",
          "int data_type_index"
        ],
        "is_static": false,
        "start_line": 208,
        "end_line": 220,
        "start_byte": 5750,
        "end_byte": 6214,
        "signature": "int APIENTRY binn_create_type(int storage_type, int data_type_index)",
        "full_definition": "int APIENTRY binn_create_type(int storage_type, int data_type_index) {\n  if (data_type_index < 0) return -1;\n  if (storage_type < BINN_STORAGE_MIN || storage_type > BINN_STORAGE_MAX) return -1;\n  if (data_type_index < 16)\n    return storage_type | data_type_index;\n  else if (data_type_index < 4096) {\n    storage_type |= BINN_STORAGE_HAS_MORE;\n    storage_type <<= 8;\n    data_type_index >>= 4;\n    return storage_type | data_type_index;\n  } else\n    return -1;\n}",
        "definition_length": 464,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_get_type_info",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "int long_type",
          "int *pstorage_type",
          "int *pextra_type"
        ],
        "is_static": false,
        "start_line": 224,
        "end_line": 257,
        "start_byte": 6295,
        "end_byte": 7167,
        "signature": "BOOL APIENTRY binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type)",
        "full_definition": "BOOL APIENTRY binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type) {\n  int storage_type, extra_type;\n  BOOL retval=TRUE;\n\nagain:\n\n  if (long_type < 0) {\n    goto loc_invalid;\n  } else if (long_type <= 0xff) {\n    storage_type = long_type & BINN_STORAGE_MASK;\n    extra_type = long_type & BINN_TYPE_MASK;\n  } else if (long_type <= 0xffff) {\n    storage_type = long_type & BINN_STORAGE_MASK16;\n    storage_type >>= 8;\n    extra_type = long_type & BINN_TYPE_MASK16;\n    extra_type >>= 4;\n  } else if (long_type & BINN_STORAGE_VIRTUAL) {\n    //storage_type = BINN_STORAGE_VIRTUAL;\n    //extra_type = xxx;\n    long_type &= 0xffff;\n    goto again;\n  } else {\nloc_invalid:\n    storage_type = -1;\n    extra_type = -1;\n    retval = FALSE;\n  }\n\n  if (pstorage_type) *pstorage_type = storage_type;\n  if (pextra_type) *pextra_type = extra_type;\n\n  return retval;\n\n}",
        "definition_length": 872,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_create",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *item",
          "int type",
          "int size",
          "void *pointer"
        ],
        "is_static": false,
        "start_line": 261,
        "end_line": 306,
        "start_byte": 7248,
        "end_byte": 8269,
        "signature": "BOOL APIENTRY binn_create(binn *item, int type, int size, void *pointer)",
        "full_definition": "BOOL APIENTRY binn_create(binn *item, int type, int size, void *pointer) {\n  BOOL retval=FALSE;\n\n  switch (type) {\n    case BINN_LIST:\n    case BINN_MAP:\n    case BINN_OBJECT:\n      break;\n    default:\n      goto loc_exit;\n  }\n\n  if (item == NULL || size < 0) goto loc_exit;\n  if (size < MIN_BINN_SIZE) {\n    if (pointer) goto loc_exit;\n    else size = 0;\n  }\n\n  memset(item, 0, sizeof(binn));\n\n  if (pointer) {\n    item->pre_allocated = TRUE;\n  } else {\n    item->pre_allocated = FALSE;\n    if (size == 0) size = CHUNK_SIZE;\n    pointer = binn_malloc(size);\n    if (pointer == 0) return INVALID_BINN;\n  }\n\n  item->pbuf = pointer;\n  item->alloc_size = size;\n\n  item->header = BINN_MAGIC;\n  //item->allocated = FALSE;   -- already zeroed\n  item->writable = TRUE;\n  item->used_size = MAX_BINN_HEADER;  // save space for the header\n  item->type = type;\n  //item->count = 0;           -- already zeroed\n  item->dirty = TRUE;          // the header is not written to the buffer\n\n  retval = TRUE;\n\nloc_exit:\n  return retval;\n\n}",
        "definition_length": 1021,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_create_list",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *list"
        ],
        "is_static": false,
        "start_line": 327,
        "end_line": 331,
        "start_byte": 8704,
        "end_byte": 8800,
        "signature": "BOOL APIENTRY binn_create_list(binn *list)",
        "full_definition": "BOOL APIENTRY binn_create_list(binn *list) {\n\n  return binn_create(list, BINN_LIST, 0, NULL);\n\n}",
        "definition_length": 96,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_create_map",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *map"
        ],
        "is_static": false,
        "start_line": 335,
        "end_line": 339,
        "start_byte": 8891,
        "end_byte": 8983,
        "signature": "BOOL APIENTRY binn_create_map(binn *map)",
        "full_definition": "BOOL APIENTRY binn_create_map(binn *map) {\n\n  return binn_create(map, BINN_MAP, 0, NULL);\n\n}",
        "definition_length": 92,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_create_object",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *object"
        ],
        "is_static": false,
        "start_line": 343,
        "end_line": 347,
        "start_byte": 9074,
        "end_byte": 9178,
        "signature": "BOOL APIENTRY binn_create_object(binn *object)",
        "full_definition": "BOOL APIENTRY binn_create_object(binn *object) {\n\n  return binn_create(object, BINN_OBJECT, 0, NULL);\n\n}",
        "definition_length": 104,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_load",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *data",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 392,
        "end_line": 404,
        "start_byte": 10450,
        "end_byte": 10842,
        "signature": "BOOL APIENTRY binn_load(const void *data, binn *value)",
        "full_definition": "BOOL APIENTRY binn_load(const void *data, binn *value) {\n\n  if (data == NULL || value == NULL) return FALSE;\n  memset(value, 0, sizeof(binn));\n  value->header = BINN_MAGIC;\n  //value->allocated = FALSE;  --  already zeroed\n  //value->writable = FALSE;\n\n  if (binn_is_valid(data, &value->type, &value->count, &value->size) == FALSE) return FALSE;\n  value->ptr = (void*) data;\n  return TRUE;\n\n}",
        "definition_length": 392,
        "comment": "*********************************************************************************** deprecated: unsecure. the size can be corrupted accidentally or intentionally"
      },
      {
        "name": "binn_load_ex",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *data",
          "int size",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 406,
        "end_line": 419,
        "start_byte": 10844,
        "end_byte": 11280,
        "signature": "BOOL APIENTRY binn_load_ex(const void *data, int size, binn *value)",
        "full_definition": "BOOL APIENTRY binn_load_ex(const void *data, int size, binn *value) {\n\n  if (data == NULL || value == NULL || size <= 0) return FALSE;\n  memset(value, 0, sizeof(binn));\n  value->header = BINN_MAGIC;\n  //value->allocated = FALSE;  --  already zeroed\n  //value->writable = FALSE;\n\n  if (binn_is_valid_ex(data, &value->type, &value->count, &size) == FALSE) return FALSE;\n  value->ptr = (void*) data;\n  value->size = size;\n  return TRUE;\n\n}",
        "definition_length": 436,
        "comment": ""
      },
      {
        "name": "binn_get_ptr_type",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *ptr"
        ],
        "is_static": false,
        "start_line": 455,
        "end_line": 466,
        "start_byte": 11936,
        "end_byte": 12139,
        "signature": "BINN_PRIVATE int binn_get_ptr_type(const void *ptr)",
        "full_definition": "BINN_PRIVATE int binn_get_ptr_type(const void *ptr) {\n\n  if (ptr == NULL) return 0;\n\n  switch (*(unsigned int *)ptr) {\n  case BINN_MAGIC:\n    return BINN_STRUCT;\n  default:\n    return BINN_BUFFER;\n  }\n\n}",
        "definition_length": 203,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_is_struct",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr"
        ],
        "is_static": false,
        "start_line": 470,
        "end_line": 480,
        "start_byte": 12220,
        "end_byte": 12401,
        "signature": "BOOL APIENTRY binn_is_struct(const void *ptr)",
        "full_definition": "BOOL APIENTRY binn_is_struct(const void *ptr) {\n\n  if (ptr == NULL) return FALSE;\n\n  if ((*(unsigned int *)ptr) == BINN_MAGIC) {\n    return TRUE;\n  } else {\n    return FALSE;\n  }\n\n}",
        "definition_length": 181,
        "comment": "*************************************************************************"
      },
      {
        "name": "CalcAllocation",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int needed_size",
          "int alloc_size"
        ],
        "is_static": false,
        "start_line": 484,
        "end_line": 494,
        "start_byte": 12482,
        "end_byte": 12801,
        "signature": "BINN_PRIVATE int CalcAllocation(int needed_size, int alloc_size)",
        "full_definition": "BINN_PRIVATE int CalcAllocation(int needed_size, int alloc_size) {\n  int calc_size;\n\n  calc_size = alloc_size;\n  while (calc_size < needed_size) {\n    calc_size <<= 1;  // same as *= 2\n    //calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations\n  }\n  return calc_size;\n\n}",
        "definition_length": 319,
        "comment": "*************************************************************************"
      },
      {
        "name": "CheckAllocation",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *item",
          "int add_size"
        ],
        "is_static": false,
        "start_line": 498,
        "end_line": 513,
        "start_byte": 12882,
        "end_byte": 13314,
        "signature": "BINN_PRIVATE BOOL CheckAllocation(binn *item, int add_size)",
        "full_definition": "BINN_PRIVATE BOOL CheckAllocation(binn *item, int add_size) {\n  int  alloc_size;\n  void *ptr;\n\n  if (item->used_size + add_size > item->alloc_size) {\n    if (item->pre_allocated) return FALSE;\n    alloc_size = CalcAllocation(item->used_size + add_size, item->alloc_size);\n    ptr = realloc_fn(item->pbuf, alloc_size);\n    if (ptr == NULL) return FALSE;\n    item->pbuf = ptr;\n    item->alloc_size = alloc_size;\n  }\n\n  return TRUE;\n\n}",
        "definition_length": 432,
        "comment": "*************************************************************************"
      },
      {
        "name": "get_storage_size",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int storage_type"
        ],
        "is_static": false,
        "start_line": 519,
        "end_line": 536,
        "start_byte": 13425,
        "end_byte": 13742,
        "signature": "BINN_PRIVATE int get_storage_size(int storage_type)",
        "full_definition": "BINN_PRIVATE int get_storage_size(int storage_type) {\n\n  switch (storage_type) {\n  case BINN_STORAGE_NOBYTES:\n    return 0;\n  case BINN_STORAGE_BYTE:\n    return 1;\n  case BINN_STORAGE_WORD:\n    return 2;\n  case BINN_STORAGE_DWORD:\n    return 4;\n  case BINN_STORAGE_QWORD:\n    return 8;\n  default:\n    return 0;\n  }\n\n}",
        "definition_length": 317,
        "comment": ""
      },
      {
        "name": "AdvanceDataPos",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "unsigned char *p",
          "unsigned char *plimit"
        ],
        "is_static": false,
        "start_line": 542,
        "end_line": 602,
        "start_byte": 13831,
        "end_byte": 15198,
        "signature": "BINN_PRIVATE unsigned char * AdvanceDataPos(unsigned char *p, unsigned char *plimit)",
        "full_definition": "BINN_PRIVATE unsigned char * AdvanceDataPos(unsigned char *p, unsigned char *plimit) {\n  unsigned char byte;\n  int  storage_type, DataSize;\n\n  if (p > plimit) return 0;\n\n  byte = *p; p++;\n  storage_type = byte & BINN_STORAGE_MASK;\n  if (byte & BINN_STORAGE_HAS_MORE) p++;\n\n  switch (storage_type) {\n  case BINN_STORAGE_NOBYTES:\n    //p += 0;\n    break;\n  case BINN_STORAGE_BYTE:\n    p ++;\n    break;\n  case BINN_STORAGE_WORD:\n    p += 2;\n    break;\n  case BINN_STORAGE_DWORD:\n    p += 4;\n    break;\n  case BINN_STORAGE_QWORD:\n    p += 8;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n    if (p > plimit) return 0;\n    DataSize = *((unsigned char*)p);\n    if (DataSize & 0x80) {\n      if (p + sizeof(int) - 1 > plimit) return 0;\n      copy_be32((u32*)&DataSize, (u32*)p);\n      DataSize &= 0x7FFFFFFF;\n      p+=4;\n    } else {\n      p++;\n    }\n    p += DataSize;\n    if (storage_type == BINN_STORAGE_STRING) {\n      p++;  // null terminator.\n    }\n    break;\n  case BINN_STORAGE_CONTAINER:\n    if (p > plimit) return 0;\n    DataSize = *((unsigned char*)p);\n    if (DataSize & 0x80) {\n      if (p + sizeof(int) - 1 > plimit) return 0;\n      copy_be32((u32*)&DataSize, (u32*)p);\n      DataSize &= 0x7FFFFFFF;\n    }\n    DataSize--;  // remove the type byte already added before\n    p += DataSize;\n    break;\n  default:\n    return 0;\n  }\n\n  return p;\n\n}",
        "definition_length": 1367,
        "comment": "*************************************************************************"
      },
      {
        "name": "read_map_id",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "unsigned char **pp",
          "unsigned char *plimit"
        ],
        "is_static": false,
        "start_line": 620,
        "end_line": 668,
        "start_byte": 15461,
        "end_byte": 16386,
        "signature": "BINN_PRIVATE int read_map_id(unsigned char **pp, unsigned char *plimit)",
        "full_definition": "BINN_PRIVATE int read_map_id(unsigned char **pp, unsigned char *plimit) {\n  unsigned char *p, c, sign, type;\n  int id, extra_bytes;\n\n  p = *pp;\n  if (p > plimit) return 0;\n\n  c = *p++;\n\n  if (c & 0x80) {\n    extra_bytes = ((c & 0x60) >> 5) + 1;\n    if (p + extra_bytes > plimit ) {\n      *pp = p + extra_bytes;\n      return 0;\n    }\n  }\n\n  type = c & 0xE0;\n  sign = c & 0x10;\n\n  if ((c & 0x80) == 0) {\n    sign = c & 0x40;\n    id = c & 0x3F;\n  } else if (type == 0x80) {\n    id = c & 0x0F;\n    id = (id << 8) | *p++;\n  } else if (type == 0xA0) {\n    id = c & 0x0F;\n    id = (id << 8) | *p++;\n    id = (id << 8) | *p++;\n  } else if (type == 0xC0) {\n    id = c & 0x0F;\n    id = (id << 8) | *p++;\n    id = (id << 8) | *p++;\n    id = (id << 8) | *p++;\n  } else if (type == 0xE0) {\n    copy_be32((u32*)&id, (u32*)p);\n    p += 4;\n  } else {\n    *pp = plimit + 2;\n    return 0;\n  }\n\n  if (sign) id = -id;\n\n  *pp = p;\n\n  return id;\n}",
        "definition_length": 925,
        "comment": "The id can be stored with 1 to 5 bytes\n\nS = signal bit\nX = bit part of id\n\n  0SXX XXXX\n  100S XXXX + 1 byte\n  101S XXXX + 2 bytes\n  110S XXXX + 3 bytes\n  1110 0000 + 4 bytes"
      },
      {
        "name": "SearchForID",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "unsigned char *p",
          "int header_size",
          "int size",
          "int numitems",
          "int id"
        ],
        "is_static": false,
        "start_line": 672,
        "end_line": 693,
        "start_byte": 16467,
        "end_byte": 17000,
        "signature": "BINN_PRIVATE unsigned char * SearchForID(unsigned char *p, int header_size, int size, int numitems, int id)",
        "full_definition": "BINN_PRIVATE unsigned char * SearchForID(unsigned char *p, int header_size, int size, int numitems, int id) {\n  unsigned char *plimit, *base;\n  int  i, int32;\n\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  // search for the ID in all the arguments.\n  for (i = 0; i < numitems; i++) {\n    int32 = read_map_id(&p, plimit);\n    if (p > plimit) break;\n    // Compare if the IDs are equal.\n    if (int32 == id) return p;\n    // xxx\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) break;\n  }\n\n  return NULL;\n\n}",
        "definition_length": 533,
        "comment": "*************************************************************************"
      },
      {
        "name": "SearchForKey",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "unsigned char *p",
          "int header_size",
          "int size",
          "int numitems",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 697,
        "end_line": 732,
        "start_byte": 17081,
        "end_byte": 17975,
        "signature": "BINN_PRIVATE unsigned char * SearchForKey(unsigned char *p, int header_size, int size, int numitems, const char *key)",
        "full_definition": "BINN_PRIVATE unsigned char * SearchForKey(unsigned char *p, int header_size, int size, int numitems, const char *key) {\n  unsigned char len, *plimit, *base;\n  int  i, keylen;\n\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  keylen = strlen(key);\n\n  // search for the key in all the arguments.\n  for (i = 0; i < numitems; i++) {\n    if (p > plimit) break;\n    len = *((unsigned char *)p);\n    p++;\n    if (p + len > plimit) break;\n    // Compare if the strings are equal.\n    if (len > 0) {\n      if (strnicmp((char*)p, key, len) == 0) {   // note that there is no null terminator here\n        if (keylen == len) {\n          p += len;\n          return p;\n        }\n      }\n      p += len;\n    } else if (len == keylen) {   // in the case of empty string: \"\"\n      return p;\n    }\n    // xxx\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) break;\n  }\n\n  return NULL;\n\n}",
        "definition_length": 894,
        "comment": "*************************************************************************"
      },
      {
        "name": "AddValue",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *item",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "start_line": 736,
        "end_line": 736,
        "start_byte": 18056,
        "end_byte": 18129,
        "full_declaration": "BINN_PRIVATE BOOL AddValue(binn *item, int type, void *pvalue, int size);",
        "declaration_length": 73,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_list_add_raw",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *item",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 740,
        "end_line": 752,
        "start_byte": 18210,
        "end_byte": 18592,
        "signature": "BINN_PRIVATE BOOL binn_list_add_raw(binn *item, int type, void *pvalue, int size)",
        "full_definition": "BINN_PRIVATE BOOL binn_list_add_raw(binn *item, int type, void *pvalue, int size) {\n\n  if (item == NULL || item->type != BINN_LIST || item->writable == FALSE) return FALSE;\n\n  //if (CheckAllocation(item, 4) == FALSE) return FALSE;  // 4 bytes used for data_store and data_format.\n\n  if (AddValue(item, type, pvalue, size) == FALSE) return FALSE;\n\n  item->count++;\n\n  return TRUE;\n\n}",
        "definition_length": 382,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_object_set_raw",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *item",
          "const char *key",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 756,
        "end_line": 791,
        "start_byte": 18673,
        "end_byte": 19618,
        "signature": "BINN_PRIVATE BOOL binn_object_set_raw(binn *item, const char *key, int type, void *pvalue, int size)",
        "full_definition": "BINN_PRIVATE BOOL binn_object_set_raw(binn *item, const char *key, int type, void *pvalue, int size) {\n  unsigned char *p, len;\n  int int32;\n\n  if (item == NULL || item->type != BINN_OBJECT || item->writable == FALSE) return FALSE;\n\n  if (key == NULL) return FALSE;\n  int32 = strlen(key);\n  if (int32 > 255) return FALSE;\n\n  // is the key already in it?\n  p = SearchForKey(item->pbuf, MAX_BINN_HEADER, item->used_size, item->count, key);\n  if (p) return FALSE;\n\n  // start adding it\n\n  if (CheckAllocation(item, 1 + int32) == FALSE) return FALSE;  // bytes used for the key size and the key itself.\n\n  p = ((unsigned char *) item->pbuf) + item->used_size;\n  len = int32;\n  *p = len;\n  p++;\n  memcpy(p, key, int32);\n  int32++;  // now contains the strlen + 1 byte for the len\n  item->used_size += int32;\n\n  if (AddValue(item, type, pvalue, size) == FALSE) {\n    item->used_size -= int32;\n    return FALSE;\n  }\n\n  item->count++;\n\n  return TRUE;\n\n}",
        "definition_length": 945,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_map_set_raw",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *item",
          "int id",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 795,
        "end_line": 847,
        "start_byte": 19699,
        "end_byte": 21050,
        "signature": "BINN_PRIVATE BOOL binn_map_set_raw(binn *item, int id, int type, void *pvalue, int size)",
        "full_definition": "BINN_PRIVATE BOOL binn_map_set_raw(binn *item, int id, int type, void *pvalue, int size) {\n  unsigned char *base, *p, sign;\n  int id_size;\n\n  if (item == NULL || item->type != BINN_MAP || item->writable == FALSE) return FALSE;\n\n  // is the ID already in it?\n  p = SearchForID(item->pbuf, MAX_BINN_HEADER, item->used_size, item->count, id);\n  if (p) return FALSE;\n\n  // start adding it\n\n  if (CheckAllocation(item, 5) == FALSE) return FALSE;  // max 5 bytes used for the id.\n\n  p = base = ((unsigned char *) item->pbuf) + item->used_size;\n\n  sign = (id < 0);\n  if (sign) id = -id;\n\n  if (id <= 0x3F) {\n    *p++ = (sign << 6) | id;\n  } else if (id <= 0xFFF) {\n    *p++ = 0x80 | (sign << 4) | ((id & 0xF00) >> 8);\n    *p++ = id & 0xFF;\n  } else if (id <= 0xFFFFF) {\n    *p++ = 0xA0 | (sign << 4) | ((id & 0xF0000) >> 16);\n    *p++ = (id & 0xFF00) >> 8;\n    *p++ = id & 0xFF;\n  } else if (id <= 0xFFFFFFF) {\n    *p++ = 0xC0 | (sign << 4) | ((id & 0xF000000) >> 24);\n    *p++ = (id & 0xFF0000) >> 16;\n    *p++ = (id & 0xFF00) >> 8;\n    *p++ = id & 0xFF;\n  } else {\n    *p++ = 0xE0;\n    if (sign) id = -id;\n    copy_be32((u32*)p, (u32*)&id);\n    p += 4;\n  }\n\n  id_size = (p - base);\n  item->used_size += id_size;\n\n  if (AddValue(item, type, pvalue, size) == FALSE) {\n    item->used_size -= id_size;\n    return FALSE;\n  }\n\n  item->count++;\n\n  return TRUE;\n\n}",
        "definition_length": 1351,
        "comment": "*************************************************************************"
      },
      {
        "name": "compress_int",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int *pstorage_type",
          "int *ptype",
          "void *psource"
        ],
        "is_static": false,
        "start_line": 851,
        "end_line": 935,
        "start_byte": 21131,
        "end_byte": 22788,
        "signature": "BINN_PRIVATE void * compress_int(int *pstorage_type, int *ptype, void *psource)",
        "full_definition": "BINN_PRIVATE void * compress_int(int *pstorage_type, int *ptype, void *psource) {\n  int storage_type, storage_type2, type, type2=0;\n  int64  vint = 0;\n  uint64 vuint;\n  char *pvalue;\n#if BYTE_ORDER == BIG_ENDIAN\n  int size1, size2;\n#endif\n\n  storage_type = *pstorage_type;\n  if (storage_type == BINN_STORAGE_BYTE) return psource;\n\n  type = *ptype;\n\n  switch (type) {\n  case BINN_INT64:\n    vint = *(int64*)psource;\n    goto loc_signed;\n  case BINN_INT32:\n    vint = *(int*)psource;\n    goto loc_signed;\n  case BINN_INT16:\n    vint = *(short*)psource;\n    goto loc_signed;\n  case BINN_UINT64:\n    vuint = *(uint64*)psource;\n    goto loc_positive;\n  case BINN_UINT32:\n    vuint = *(unsigned int*)psource;\n    goto loc_positive;\n  case BINN_UINT16:\n    vuint = *(unsigned short*)psource;\n    goto loc_positive;\n  }\n\nloc_signed:\n\n  if (vint >= 0) {\n    vuint = vint;\n    goto loc_positive;\n  }\n\n//loc_negative:\n\n  if (vint >= INT8_MIN) {\n    type2 = BINN_INT8;\n  } else\n  if (vint >= INT16_MIN) {\n    type2 = BINN_INT16;\n  } else\n  if (vint >= INT32_MIN) {\n    type2 = BINN_INT32;\n  }\n  goto loc_exit;\n\nloc_positive:\n\n  if (vuint <= UINT8_MAX) {\n    type2 = BINN_UINT8;\n  } else\n  if (vuint <= UINT16_MAX) {\n    type2 = BINN_UINT16;\n  } else\n  if (vuint <= UINT32_MAX) {\n    type2 = BINN_UINT32;\n  }\n\nloc_exit:\n\n  pvalue = (char *) psource;\n\n  if (type2 && type2 != type) {\n    *ptype = type2;\n    storage_type2 = binn_get_write_storage(type2);\n    *pstorage_type = storage_type2;\n#if BYTE_ORDER == BIG_ENDIAN\n    size1 = get_storage_size(storage_type);\n    size2 = get_storage_size(storage_type2);\n    pvalue += (size1 - size2);\n#endif\n  }\n\n  return pvalue;\n\n}",
        "definition_length": 1657,
        "comment": "*************************************************************************"
      },
      {
        "name": "type_family",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int type"
        ],
        "start_line": 939,
        "end_line": 939,
        "start_byte": 22869,
        "end_byte": 22908,
        "full_declaration": "BINN_PRIVATE int type_family(int type);",
        "declaration_length": 39,
        "comment": "*************************************************************************"
      },
      {
        "name": "AddValue",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *item",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 941,
        "end_line": 1070,
        "start_byte": 22910,
        "end_byte": 26188,
        "signature": "BINN_PRIVATE BOOL AddValue(binn *item, int type, void *pvalue, int size)",
        "full_definition": "BINN_PRIVATE BOOL AddValue(binn *item, int type, void *pvalue, int size) {\n  int int32, ArgSize, storage_type, extra_type;\n  unsigned char *p;\n\n  binn_get_type_info(type, &storage_type, &extra_type);\n\n  if (pvalue == NULL) {\n    switch (storage_type) {\n      case BINN_STORAGE_NOBYTES:\n        break;\n      case BINN_STORAGE_BLOB:\n      case BINN_STORAGE_STRING:\n        if (size == 0) break; // the 2 above are allowed to have 0 length\n      default:\n        return FALSE;\n    }\n  }\n\n  if (type_family(type) == BINN_FAMILY_INT && item->disable_int_compression == FALSE)\n    pvalue = compress_int(&storage_type, &type, pvalue);\n\n  switch (storage_type) {\n    case BINN_STORAGE_NOBYTES:\n      size = 0;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_BYTE:\n      size = 1;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_WORD:\n      size = 2;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_DWORD:\n      size = 4;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_QWORD:\n      size = 8;\n      ArgSize = size;\n      break;\n    case BINN_STORAGE_BLOB:\n      if (size < 0) return FALSE;\n      //if (size == 0) ...\n      ArgSize = size + 4; // at least this size\n      break;\n    case BINN_STORAGE_STRING:\n      if (size < 0) return FALSE;\n      if (size == 0) size = strlen2( (char *) pvalue);\n      ArgSize = size + 5; // at least this size\n      break;\n    case BINN_STORAGE_CONTAINER:\n      if (size <= 0) return FALSE;\n      ArgSize = size;\n      break;\n    default:\n      return FALSE;\n  }\n\n  ArgSize += 2;  // at least 2 bytes used for data_type.\n  if (CheckAllocation(item, ArgSize) == FALSE) return FALSE;\n\n  // Gets the pointer to the next place in buffer\n  p = ((unsigned char *) item->pbuf) + item->used_size;\n\n  // If the data is not a container, store the data type\n  if (storage_type != BINN_STORAGE_CONTAINER) {\n    if (type > 255) {\n      u16 type16 = type;\n      copy_be16((u16*)p, (u16*)&type16);\n      p += 2;\n      item->used_size += 2;\n    } else {\n      *p = type;\n      p++;\n      item->used_size++;\n    }\n  }\n\n  switch (storage_type) {\n    case BINN_STORAGE_NOBYTES:\n      // Nothing to do.\n      break;\n    case BINN_STORAGE_BYTE:\n      *((char *) p) = *((char *) pvalue);\n      item->used_size += 1;\n      break;\n    case BINN_STORAGE_WORD:\n      copy_be16((u16*)p, (u16*)pvalue);\n      item->used_size += 2;\n      break;\n    case BINN_STORAGE_DWORD:\n      copy_be32((u32*)p, (u32*)pvalue);\n      item->used_size += 4;\n      break;\n    case BINN_STORAGE_QWORD:\n      copy_be64((u64*)p, (u64*)pvalue);\n      item->used_size += 8;\n      break;\n    case BINN_STORAGE_BLOB:\n    case BINN_STORAGE_STRING:\n      if (size > 127) {\n        int32 = size | 0x80000000;\n        copy_be32((u32*)p, (u32*)&int32);\n        p += 4;\n        item->used_size += 4;\n      } else {\n        *((unsigned char *) p) = size;\n        p++;\n        item->used_size++;\n      }\n      memcpy(p, pvalue, size);\n      if (storage_type == BINN_STORAGE_STRING) {\n        p += size;\n        *((char *) p) = (char) 0;\n        size++;  // null terminator\n      }\n      item->used_size += size;\n      break;\n    case BINN_STORAGE_CONTAINER:\n      memcpy(p, pvalue, size);\n      item->used_size += size;\n      break;\n  }\n\n  item->dirty = TRUE;\n\n  return TRUE;\n}",
        "definition_length": 3278,
        "comment": ""
      },
      {
        "name": "binn_save_header",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *item"
        ],
        "is_static": false,
        "start_line": 1074,
        "end_line": 1141,
        "start_byte": 26269,
        "end_byte": 27531,
        "signature": "BINN_PRIVATE BOOL binn_save_header(binn *item)",
        "full_definition": "BINN_PRIVATE BOOL binn_save_header(binn *item) {\n  unsigned char byte, *p;\n  int int32, size;\n\n  if (item == NULL) return FALSE;\n\n#ifndef BINN_DISABLE_SMALL_HEADER\n\n  p = ((unsigned char *) item->pbuf) + MAX_BINN_HEADER;\n  size = item->used_size - MAX_BINN_HEADER + 3;  // at least 3 bytes for the header\n\n  // write the count\n  if (item->count > 127) {\n    p -= 4;\n    size += 3;\n    int32 = item->count | 0x80000000;\n    copy_be32((u32*)p, (u32*)&int32);\n  } else {\n    p--;\n    *p = (unsigned char) item->count;\n  }\n\n  // write the size\n  if (size > 127) {\n    p -= 4;\n    size += 3;\n    int32 = size | 0x80000000;\n    copy_be32((u32*)p, (u32*)&int32);\n  } else {\n    p--;\n    *p = (unsigned char) size;\n  }\n\n  // write the type.\n  p--;\n  *p = (unsigned char) item->type;\n\n  // set the values\n  item->ptr = p;\n  item->size = size;\n\n  UNUSED(byte);\n\n#else\n\n  p = (unsigned char *) item->pbuf;\n\n  // write the type.\n  byte = item->type;\n  *p = byte; p++;\n  // write the size\n  int32 = item->used_size | 0x80000000;\n  copy_be32((u32*)p, (u32*)&int32);\n  p+=4;\n  // write the count\n  int32 = item->count | 0x80000000;\n  copy_be32((u32*)p, (u32*)&int32);\n\n  item->ptr = item->pbuf;\n  item->size = item->used_size;\n\n#endif\n\n  item->dirty = FALSE;\n\n  return TRUE;\n\n}",
        "definition_length": 1262,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "binn *item"
        ],
        "is_static": false,
        "start_line": 1145,
        "end_line": 1162,
        "start_byte": 27612,
        "end_byte": 27939,
        "signature": "void APIENTRY binn_free(binn *item)",
        "full_definition": "void APIENTRY binn_free(binn *item) {\n\n  if (item == NULL) return;\n\n  if (item->writable && item->pre_allocated == FALSE) {\n    free_fn(item->pbuf);\n  }\n\n  if (item->freefn) item->freefn(item->ptr);\n\n  if (item->allocated) {\n    free_fn(item);\n  } else {\n    memset(item, 0, sizeof(binn));\n    item->header = BINN_MAGIC;\n  }\n\n}",
        "definition_length": 327,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_release",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "binn *item"
        ],
        "is_static": false,
        "start_line": 1166,
        "end_line": 1187,
        "start_byte": 28160,
        "end_byte": 28519,
        "signature": "void * APIENTRY binn_release(binn *item)",
        "full_definition": "void * APIENTRY binn_release(binn *item) {\n  void *data;\n\n  if (item == NULL) return NULL;\n\n  data = binn_ptr(item);\n\n  if (data > item->pbuf) {\n    memmove(item->pbuf, data, item->size);\n    data = item->pbuf;\n  }\n\n  if (item->allocated) {\n    free_fn(item);\n  } else {\n    memset(item, 0, sizeof(binn));\n    item->header = BINN_MAGIC;\n  }\n\n  return data;\n\n}",
        "definition_length": 359,
        "comment": "************************************************************************* free the binn structure but keeps the binn buffer allocated, returning a pointer to it. use the free function to release the buffer later"
      },
      {
        "name": "IsValidBinnHeader",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *pbuf",
          "int *ptype",
          "int *pcount",
          "int *psize",
          "int *pheadersize"
        ],
        "is_static": false,
        "start_line": 1191,
        "end_line": 1253,
        "start_byte": 28600,
        "end_byte": 30098,
        "signature": "BINN_PRIVATE BOOL IsValidBinnHeader(const void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize)",
        "full_definition": "BINN_PRIVATE BOOL IsValidBinnHeader(const void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize) {\n  unsigned char byte, *p, *plimit=0;\n  int int32, type, size, count;\n\n  if (pbuf == NULL) return FALSE;\n\n  p = (unsigned char *) pbuf;\n\n  if (psize && *psize > 0) {\n    if (*psize < MIN_BINN_SIZE) return FALSE;\n    plimit = p + *psize - 1;\n  }\n\n  // get the type\n  byte = *p; p++;\n  if ((byte & BINN_STORAGE_MASK) != BINN_STORAGE_CONTAINER) return FALSE;\n  if (byte & BINN_STORAGE_HAS_MORE) return FALSE;\n  type = byte;\n\n  switch (type) {\n    case BINN_LIST:\n    case BINN_MAP:\n    case BINN_OBJECT:\n      break;\n    default:\n      return FALSE;\n  }\n\n  // get the size\n  if (plimit && p > plimit) return FALSE;\n  int32 = *((unsigned char*)p);\n  if (int32 & 0x80) {\n    if (plimit && p + sizeof(int) - 1 > plimit) return FALSE;\n    copy_be32((u32*)&int32, (u32*)p);\n    int32 &= 0x7FFFFFFF;\n    p+=4;\n  } else {\n    p++;\n  }\n  size = int32;\n\n  // get the count\n  if (plimit && p > plimit) return FALSE;\n  int32 = *((unsigned char*)p);\n  if (int32 & 0x80) {\n    if (plimit && p + sizeof(int) - 1 > plimit) return FALSE;\n    copy_be32((u32*)&int32, (u32*)p);\n    int32 &= 0x7FFFFFFF;\n    p+=4;\n  } else {\n    p++;\n  }\n  count = int32;\n\n  if (size < MIN_BINN_SIZE || count < 0) return FALSE;\n\n  // return the values\n  if (ptype)  *ptype  = type;\n  if (pcount) *pcount = count;\n  if (psize)  *psize  = size;\n  if (pheadersize) *pheadersize = (int) (p - (unsigned char*)pbuf);\n  return TRUE;\n}",
        "definition_length": 1498,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_buf_type",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *pbuf"
        ],
        "is_static": false,
        "start_line": 1257,
        "end_line": 1264,
        "start_byte": 30179,
        "end_byte": 30340,
        "signature": "BINN_PRIVATE int binn_buf_type(const void *pbuf)",
        "full_definition": "BINN_PRIVATE int binn_buf_type(const void *pbuf) {\n  int  type;\n\n  if (!IsValidBinnHeader(pbuf, &type, NULL, NULL, NULL)) return INVALID_BINN;\n\n  return type;\n\n}",
        "definition_length": 161,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_buf_count",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *pbuf"
        ],
        "is_static": false,
        "start_line": 1268,
        "end_line": 1275,
        "start_byte": 30421,
        "end_byte": 30578,
        "signature": "BINN_PRIVATE int binn_buf_count(const void *pbuf)",
        "full_definition": "BINN_PRIVATE int binn_buf_count(const void *pbuf) {\n  int  nitems;\n\n  if (!IsValidBinnHeader(pbuf, NULL, &nitems, NULL, NULL)) return 0;\n\n  return nitems;\n\n}",
        "definition_length": 157,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_buf_size",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *pbuf"
        ],
        "is_static": false,
        "start_line": 1279,
        "end_line": 1286,
        "start_byte": 30659,
        "end_byte": 30811,
        "signature": "BINN_PRIVATE int binn_buf_size(const void *pbuf)",
        "full_definition": "BINN_PRIVATE int binn_buf_size(const void *pbuf) {\n  int  size=0;\n\n  if (!IsValidBinnHeader(pbuf, NULL, NULL, &size, NULL)) return 0;\n\n  return size;\n\n}",
        "definition_length": 152,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_ptr",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *ptr"
        ],
        "is_static": false,
        "start_line": 1290,
        "end_line": 1306,
        "start_byte": 30892,
        "end_byte": 31207,
        "signature": "void * APIENTRY binn_ptr(const void *ptr)",
        "full_definition": "void * APIENTRY binn_ptr(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    if (item->writable && item->dirty) {\n      binn_save_header(item);\n    }\n    return item->ptr;\n  case BINN_BUFFER:\n    return (void*)ptr;\n  default:\n    return NULL;\n  }\n\n}",
        "definition_length": 315,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_size",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "const void *ptr"
        ],
        "is_static": false,
        "start_line": 1310,
        "end_line": 1326,
        "start_byte": 31288,
        "end_byte": 31607,
        "signature": "int APIENTRY binn_size(const void *ptr)",
        "full_definition": "int APIENTRY binn_size(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    if (item->writable && item->dirty) {\n      binn_save_header(item);\n    }\n    return item->size;\n  case BINN_BUFFER:\n    return binn_buf_size(ptr);\n  default:\n    return 0;\n  }\n\n}",
        "definition_length": 319,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_type",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "const void *ptr"
        ],
        "is_static": false,
        "start_line": 1330,
        "end_line": 1343,
        "start_byte": 31688,
        "end_byte": 31931,
        "signature": "int APIENTRY binn_type(const void *ptr)",
        "full_definition": "int APIENTRY binn_type(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    return item->type;\n  case BINN_BUFFER:\n    return binn_buf_type(ptr);\n  default:\n    return -1;\n  }\n\n}",
        "definition_length": 243,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_count",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "const void *ptr"
        ],
        "is_static": false,
        "start_line": 1347,
        "end_line": 1360,
        "start_byte": 32012,
        "end_byte": 32258,
        "signature": "int APIENTRY binn_count(const void *ptr)",
        "full_definition": "int APIENTRY binn_count(const void *ptr) {\n  binn *item;\n\n  switch (binn_get_ptr_type(ptr)) {\n  case BINN_STRUCT:\n    item = (binn*) ptr;\n    return item->count;\n  case BINN_BUFFER:\n    return binn_buf_count(ptr);\n  default:\n    return -1;\n  }\n\n}",
        "definition_length": 246,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_is_valid_ex2",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *ptr",
          "int *ptype",
          "int *pcount",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 1365,
        "end_line": 1446,
        "start_byte": 32394,
        "end_byte": 34467,
        "signature": "BINN_PRIVATE BOOL binn_is_valid_ex2(const void *ptr, int *ptype, int *pcount, int *psize)",
        "full_definition": "BINN_PRIVATE BOOL binn_is_valid_ex2(const void *ptr, int *ptype, int *pcount, int *psize) {\n  int  i, type, count, size, header_size;\n  unsigned char *p, *plimit, *base, len;\n\n  if (ptr == NULL) return FALSE;\n\n  // is there an informed size?\n  if (psize && *psize > 0) {\n    size = *psize;\n  } else {\n    size = 0;\n  }\n\n  if (!IsValidBinnHeader(ptr, &type, &count, &size, &header_size)) return FALSE;\n\n  // is there an informed size?\n  if (psize && *psize > 0) {\n    // is it bigger than the buffer?\n    if (size > *psize) return FALSE;\n  }\n  // is there an informed count?\n  if (pcount && *pcount > 0) {\n    // is it the same as the one in the buffer?\n    if (count != *pcount) return FALSE;\n  }\n  // is there an informed type?\n  if (ptype && *ptype != 0) {\n    // is it the same as the one in the buffer?\n    if (type != *ptype) return FALSE;\n  }\n\n  p = (unsigned char *)ptr;\n  base = p;\n  plimit = p + size - 1;\n\n  p += header_size;\n\n  // process each (key and) value\n  for (i = 0; i < count; i++) {\n    switch (type) {\n      case BINN_OBJECT:\n        if (p > plimit) goto Invalid;\n        // get the key (string) size\n        len = *p;\n        p++;\n        //if (len == 0) goto Invalid;\n        // advance over the key\n        p += len;\n        break;\n      case BINN_MAP:\n        // advance over the key\n        read_map_id(&p, plimit);\n        break;\n      case BINN_LIST:\n        // no key\n        break;\n      default:\n        goto Invalid;\n    }\n    // check the value\n    if (p > plimit) goto Invalid;\n    if ((*p & BINN_STORAGE_MASK) == BINN_STORAGE_CONTAINER) {\n      // recursively check the internal container\n      int size2 = plimit - p + 1;  // maximum container size\n      if (binn_is_valid_ex2(p, NULL, NULL, &size2) == FALSE) goto Invalid;\n      p += size2;\n    } else {\n      // advance over the value\n      p = AdvanceDataPos(p, plimit);\n      if (p == 0 || p < base) goto Invalid;\n    }\n  }\n\n  if (ptype  && *ptype==0) *ptype = type;\n  if (pcount && *pcount==0) *pcount = count;\n  if (psize) *psize = size;\n  return TRUE;\n\nInvalid:\n  return FALSE;\n\n}",
        "definition_length": 2073,
        "comment": "************************************************************************* the container can be smaller than the informed size"
      },
      {
        "name": "binn_is_valid_ex",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int *ptype",
          "int *pcount",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 1449,
        "end_line": 1469,
        "start_byte": 34527,
        "end_byte": 34934,
        "signature": "BOOL APIENTRY binn_is_valid_ex(const void *ptr, int *ptype, int *pcount, int *psize)",
        "full_definition": "BOOL APIENTRY binn_is_valid_ex(const void *ptr, int *ptype, int *pcount, int *psize) {\n  int size;\n\n  if (psize && *psize > 0) {\n    size = *psize;\n  } else {\n    size = 0;\n  }\n\n  if (binn_is_valid_ex2(ptr, ptype, pcount, &size) == FALSE) return FALSE;\n\n  if (psize) {\n    if (*psize > 0) {\n      if (size != *psize) return FALSE;\n    } else if (*psize==0) {\n      *psize = size;\n    }\n  }\n\n  return TRUE;\n}",
        "definition_length": 407,
        "comment": "the container must have the informed size, if informed"
      },
      {
        "name": "binn_is_valid",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int *ptype",
          "int *pcount",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 1473,
        "end_line": 1481,
        "start_byte": 35015,
        "end_byte": 35238,
        "signature": "BOOL APIENTRY binn_is_valid(const void *ptr, int *ptype, int *pcount, int *psize)",
        "full_definition": "BOOL APIENTRY binn_is_valid(const void *ptr, int *ptype, int *pcount, int *psize) {\n\n  if (ptype)  *ptype  = 0;\n  if (pcount) *pcount = 0;\n  if (psize)  *psize  = 0;\n\n  return binn_is_valid_ex(ptr, ptype, pcount, psize);\n\n}",
        "definition_length": 223,
        "comment": "*************************************************************************"
      },
      {
        "name": "GetValue",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "unsigned char *p",
          "unsigned char *plimit",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1487,
        "end_line": 1603,
        "start_byte": 35475,
        "end_byte": 38639,
        "signature": "BINN_PRIVATE BOOL GetValue(unsigned char *p, unsigned char *plimit, binn *value)",
        "full_definition": "BINN_PRIVATE BOOL GetValue(unsigned char *p, unsigned char *plimit, binn *value) {\n  unsigned char byte;\n  int   data_type, storage_type;  //, extra_type;\n  int   DataSize;\n  void *p2;\n\n  if (value == NULL) return FALSE;\n  memset(value, 0, sizeof(binn));\n  value->header = BINN_MAGIC;\n  //value->allocated = FALSE;  --  already zeroed\n  //value->writable = FALSE;\n\n  // saves for use with BINN_STORAGE_CONTAINER\n  p2 = p;\n\n  // read the data type\n  if (p > plimit) return FALSE;\n  byte = *p; p++;\n  storage_type = byte & BINN_STORAGE_MASK;\n  if (byte & BINN_STORAGE_HAS_MORE) {\n    data_type = byte << 8;\n    if (p > plimit) return FALSE;\n    byte = *p; p++;\n    data_type |= byte;\n    //extra_type = data_type & BINN_TYPE_MASK16;\n  } else {\n    data_type = byte;\n    //extra_type = byte & BINN_TYPE_MASK;\n  }\n\n  //value->storage_type = storage_type;\n  value->type = data_type;\n\n  switch (storage_type) {\n  case BINN_STORAGE_NOBYTES:\n    break;\n  case BINN_STORAGE_BYTE:\n    if (p > plimit) return FALSE;\n    value->vuint8 = *((unsigned char *) p);\n    value->ptr = p;   //value->ptr = &value->vuint8;\n    break;\n  case BINN_STORAGE_WORD:\n    if (p + 1 > plimit) return FALSE;\n    copy_be16((u16*)&value->vint16, (u16*)p);\n    value->ptr = &value->vint16;\n    break;\n  case BINN_STORAGE_DWORD:\n    if (p + 3 > plimit) return FALSE;\n    copy_be32((u32*)&value->vint32, (u32*)p);\n    value->ptr = &value->vint32;\n    break;\n  case BINN_STORAGE_QWORD:\n    if (p + 7 > plimit) return FALSE;\n    copy_be64((u64*)&value->vint64, (u64*)p);\n    value->ptr = &value->vint64;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n    if (p > plimit) return FALSE;\n    DataSize = *((unsigned char*)p);\n    if (DataSize & 0x80) {\n      if (p + 3 > plimit) return FALSE;\n      copy_be32((u32*)&DataSize, (u32*)p);\n      DataSize &= 0x7FFFFFFF;\n      p+=4;\n    } else {\n      p++;\n    }\n    if (p + DataSize - 1 > plimit) return FALSE;\n    value->size = DataSize;\n    value->ptr = p;\n    break;\n  case BINN_STORAGE_CONTAINER:\n    value->ptr = p2;  // <-- it returns the pointer to the container, not the data\n    if (IsValidBinnHeader(p2, NULL, &value->count, &value->size, NULL) == FALSE) return FALSE;\n    break;\n  default:\n    return FALSE;\n  }\n\n  // convert the returned value, if needed\n\n  switch (value->type) {\n    case BINN_TRUE:\n      value->type = BINN_BOOL;\n      value->vbool = TRUE;\n      value->ptr = &value->vbool;\n      break;\n    case BINN_FALSE:\n      value->type = BINN_BOOL;\n      value->vbool = FALSE;\n      value->ptr = &value->vbool;\n      break;\n#ifdef BINN_EXTENDED\n    case BINN_SINGLE_STR:\n      value->type = BINN_SINGLE;\n      value->vfloat = (float) atof((const char*)value->ptr);  // converts from string to double, and then to float\n      value->ptr = &value->vfloat;\n      break;\n    case BINN_DOUBLE_STR:\n      value->type = BINN_DOUBLE;\n      value->vdouble = atof((const char*)value->ptr);  // converts from string to double\n      value->ptr = &value->vdouble;\n      break;\n#endif\n    /*\n    case BINN_DECIMAL:\n    case BINN_CURRENCYSTR:\n    case BINN_DATE:\n    case BINN_DATETIME:\n    case BINN_TIME:\n    */\n  }\n\n  return TRUE;\n\n}",
        "definition_length": 3164,
        "comment": "** INTERNAL FUNCTIONS *************************************************** *************************************************************************"
      },
      {
        "name": "store_value",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1614,
        "end_line": 1629,
        "start_byte": 38963,
        "end_byte": 39481,
        "signature": "BINN_PRIVATE void * store_value(binn *value)",
        "full_definition": "BINN_PRIVATE void * store_value(binn *value) {\n\n  memcpy(&local_value, value, sizeof(binn));\n\n  switch (binn_get_read_storage(value->type)) {\n  case BINN_STORAGE_NOBYTES:\n    // return a valid pointer\n  case BINN_STORAGE_WORD:\n  case BINN_STORAGE_DWORD:\n  case BINN_STORAGE_QWORD:\n    return &local_value.vint32;  // returns the pointer to the converted value, from big-endian to little-endian\n  }\n\n  return value->ptr;   // returns from the on stack value to be thread-safe (for list, map, object, string and blob)\n\n}",
        "definition_length": 518,
        "comment": ""
      },
      {
        "name": "binn_object_get_value",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "const char *key",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1637,
        "end_line": 1658,
        "start_byte": 39726,
        "end_byte": 40337,
        "signature": "BOOL APIENTRY binn_object_get_value(const void *ptr, const char *key, binn *value)",
        "full_definition": "BOOL APIENTRY binn_object_get_value(const void *ptr, const char *key, binn *value) {\n  int type, count, size=0, header_size;\n  unsigned char *p, *plimit;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || key == NULL || value == NULL) return FALSE;\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != BINN_OBJECT) return FALSE;\n  if (count == 0) return FALSE;\n\n  p = (unsigned char *) ptr;\n  plimit = p + size - 1;\n\n  p = SearchForKey(p, header_size, size, count, key);\n  if (p == FALSE) return FALSE;\n\n  return GetValue(p, plimit, value);\n\n}",
        "definition_length": 611,
        "comment": "** READ FUNCTIONS ******************************************************* *************************************************************************"
      },
      {
        "name": "binn_map_get_value",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int id",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1662,
        "end_line": 1683,
        "start_byte": 40418,
        "end_byte": 40997,
        "signature": "BOOL APIENTRY binn_map_get_value(const void *ptr, int id, binn *value)",
        "full_definition": "BOOL APIENTRY binn_map_get_value(const void *ptr, int id, binn *value) {\n  int type, count, size=0, header_size;\n  unsigned char *p, *plimit;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || value == NULL) return FALSE;\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != BINN_MAP) return FALSE;\n  if (count == 0) return FALSE;\n\n  p = (unsigned char *) ptr;\n  plimit = p + size - 1;\n\n  p = SearchForID(p, header_size, size, count, id);\n  if (p == FALSE) return FALSE;\n\n  return GetValue(p, plimit, value);\n\n}",
        "definition_length": 579,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_list_get_value",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int pos",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1687,
        "end_line": 1714,
        "start_byte": 41078,
        "end_byte": 41818,
        "signature": "BOOL APIENTRY binn_list_get_value(const void *ptr, int pos, binn *value)",
        "full_definition": "BOOL APIENTRY binn_list_get_value(const void *ptr, int pos, binn *value) {\n  int  i, type, count, size=0, header_size;\n  unsigned char *p, *plimit, *base;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || value == NULL) return FALSE;\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != BINN_LIST) return FALSE;\n  if (count == 0) return FALSE;\n  if (pos <= 0 || pos > count) return FALSE;\n  pos--;  // convert from base 1 to base 0\n\n  p = (unsigned char *) ptr;\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  for (i = 0; i < pos; i++) {\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) return FALSE;\n  }\n\n  return GetValue(p, plimit, value);\n\n}",
        "definition_length": 740,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_read_pair",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int expected_type",
          "const void *ptr",
          "int pos",
          "int *pid",
          "char *pkey",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1720,
        "end_line": 1777,
        "start_byte": 42055,
        "end_byte": 43399,
        "signature": "BINN_PRIVATE BOOL binn_read_pair(int expected_type, const void *ptr, int pos, int *pid, char *pkey, binn *value)",
        "full_definition": "BINN_PRIVATE BOOL binn_read_pair(int expected_type, const void *ptr, int pos, int *pid, char *pkey, binn *value) {\n  int  type, count, size=0, header_size;\n  int  i, int32, id = 0, counter=0;\n  unsigned char *p, *plimit, *base, *key = NULL, len = 0;\n\n  ptr = binn_ptr(ptr);\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != expected_type || count == 0 || pos < 1 || pos > count) return FALSE;\n\n  p = (unsigned char *) ptr;\n  base = p;\n  plimit = p + size - 1;\n  p += header_size;\n\n  for (i = 0; i < count; i++) {\n    switch (type) {\n      case BINN_MAP:\n        int32 = read_map_id(&p, plimit);\n        if (p > plimit) return FALSE;\n        id = int32;\n        break;\n      case BINN_OBJECT:\n        len = *((unsigned char *)p); p++;\n        if (p > plimit) return FALSE;\n        key = p;\n        p += len;\n        if (p > plimit) return FALSE;\n        break;\n    }\n    counter++;\n    if (counter == pos) goto found;\n    //\n    p = AdvanceDataPos(p, plimit);\n    if (p == 0 || p < base) return FALSE;\n  }\n\n  return FALSE;\n\nfound:\n\n  switch (type) {\n    case BINN_MAP:\n      if (pid) *pid = id;\n      break;\n    case BINN_OBJECT:\n      if (pkey) {\n        memcpy(pkey, key, len);\n        pkey[len] = 0;\n      }\n      break;\n  }\n\n  return GetValue(p, plimit, value);\n\n}",
        "definition_length": 1344,
        "comment": "** READ PAIR BY POSITION ************************************************ *************************************************************************"
      },
      {
        "name": "binn_map_get_pair",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int pos",
          "int *pid",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1781,
        "end_line": 1785,
        "start_byte": 43480,
        "end_byte": 43629,
        "signature": "BOOL APIENTRY binn_map_get_pair(const void *ptr, int pos, int *pid, binn *value)",
        "full_definition": "BOOL APIENTRY binn_map_get_pair(const void *ptr, int pos, int *pid, binn *value) {\n\n  return binn_read_pair(BINN_MAP, ptr, pos, pid, NULL, value);\n\n}",
        "definition_length": 149,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_object_get_pair",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int pos",
          "char *pkey",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1789,
        "end_line": 1793,
        "start_byte": 43710,
        "end_byte": 43868,
        "signature": "BOOL APIENTRY binn_object_get_pair(const void *ptr, int pos, char *pkey, binn *value)",
        "full_definition": "BOOL APIENTRY binn_object_get_pair(const void *ptr, int pos, char *pkey, binn *value) {\n\n  return binn_read_pair(BINN_OBJECT, ptr, pos, NULL, pkey, value);\n\n}",
        "definition_length": 158,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_map_read_pair",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *ptr",
          "int pos",
          "int *pid",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 1832,
        "end_line": 1844,
        "start_byte": 44776,
        "end_byte": 45123,
        "signature": "void * APIENTRY binn_map_read_pair(const void *ptr, int pos, int *pid, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_map_read_pair(const void *ptr, int pos, int *pid, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_map_get_pair(ptr, pos, pid, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 347,
        "comment": "************************************************************************* *************************************************************************"
      },
      {
        "name": "binn_object_read_pair",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *ptr",
          "int pos",
          "char *pkey",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 1848,
        "end_line": 1860,
        "start_byte": 45204,
        "end_byte": 45560,
        "signature": "void * APIENTRY binn_object_read_pair(const void *ptr, int pos, char *pkey, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_object_read_pair(const void *ptr, int pos, char *pkey, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_object_get_pair(ptr, pos, pkey, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 356,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_iter_init",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "const void *ptr",
          "int expected_type"
        ],
        "is_static": false,
        "start_line": 1866,
        "end_line": 1886,
        "start_byte": 45797,
        "end_byte": 46431,
        "signature": "BOOL APIENTRY binn_iter_init(binn_iter *iter, const void *ptr, int expected_type)",
        "full_definition": "BOOL APIENTRY binn_iter_init(binn_iter *iter, const void *ptr, int expected_type) {\n  int  type, count, size=0, header_size;\n\n  ptr = binn_ptr(ptr);\n  if (ptr == NULL || iter == NULL) return FALSE;\n  memset(iter, 0, sizeof(binn_iter));\n\n  // check the header\n  if (IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == FALSE) return FALSE;\n\n  if (type != expected_type) return FALSE;\n  //if (count == 0) return FALSE;  -- should not be used\n\n  iter->plimit = (unsigned char *)ptr + size - 1;\n  iter->pnext = (unsigned char *)ptr + header_size;\n  iter->count = count;\n  iter->current = 0;\n  iter->type = type;\n\n  return TRUE;\n}",
        "definition_length": 634,
        "comment": "** SEQUENTIAL READ FUNCTIONS ******************************************** *************************************************************************"
      },
      {
        "name": "binn_list_next",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1890,
        "end_line": 1904,
        "start_byte": 46512,
        "end_byte": 46995,
        "signature": "BOOL APIENTRY binn_list_next(binn_iter *iter, binn *value)",
        "full_definition": "BOOL APIENTRY binn_list_next(binn_iter *iter, binn *value) {\n  unsigned char *pnow;\n\n  if (iter == NULL || iter->pnext == NULL || iter->pnext > iter->plimit || iter->current > iter->count || iter->type != BINN_LIST) return FALSE;\n\n  iter->current++;\n  if (iter->current > iter->count) return FALSE;\n\n  pnow = iter->pnext;\n  iter->pnext = AdvanceDataPos(pnow, iter->plimit);\n  if (iter->pnext != 0 && iter->pnext < pnow) return FALSE;\n\n  return GetValue(pnow, iter->plimit, value);\n\n}",
        "definition_length": 483,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_read_next_pair",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int expected_type",
          "binn_iter *iter",
          "int *pid",
          "char *pkey",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1908,
        "end_line": 1944,
        "start_byte": 47076,
        "end_byte": 48069,
        "signature": "BINN_PRIVATE BOOL binn_read_next_pair(int expected_type, binn_iter *iter, int *pid, char *pkey, binn *value)",
        "full_definition": "BINN_PRIVATE BOOL binn_read_next_pair(int expected_type, binn_iter *iter, int *pid, char *pkey, binn *value) {\n  int  int32, id;\n  unsigned char *p, *key;\n  unsigned short len;\n\n  if (iter == NULL || iter->pnext == NULL || iter->pnext > iter->plimit || iter->current > iter->count || iter->type != expected_type) return FALSE;\n\n  iter->current++;\n  if (iter->current > iter->count) return FALSE;\n\n  p = iter->pnext;\n\n  switch (expected_type) {\n    case BINN_MAP:\n      int32 = read_map_id(&p, iter->plimit);\n      if (p > iter->plimit) return FALSE;\n      id = int32;\n      if (pid) *pid = id;\n      break;\n    case BINN_OBJECT:\n      len = *((unsigned char *)p); p++;\n      key = p;\n      p += len;\n      if (p > iter->plimit) return FALSE;\n      if (pkey) {\n        memcpy(pkey, key, len);\n        pkey[len] = 0;\n      }\n      break;\n  }\n\n  iter->pnext = AdvanceDataPos(p, iter->plimit);\n  if (iter->pnext != 0 && iter->pnext < p) return FALSE;\n\n  return GetValue(p, iter->plimit, value);\n\n}",
        "definition_length": 993,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_map_next",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "int *pid",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1948,
        "end_line": 1952,
        "start_byte": 48150,
        "end_byte": 48287,
        "signature": "BOOL APIENTRY binn_map_next(binn_iter *iter, int *pid, binn *value)",
        "full_definition": "BOOL APIENTRY binn_map_next(binn_iter *iter, int *pid, binn *value) {\n\n  return binn_read_next_pair(BINN_MAP, iter, pid, NULL, value);\n\n}",
        "definition_length": 137,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_object_next",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "char *pkey",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 1956,
        "end_line": 1960,
        "start_byte": 48368,
        "end_byte": 48514,
        "signature": "BOOL APIENTRY binn_object_next(binn_iter *iter, char *pkey, binn *value)",
        "full_definition": "BOOL APIENTRY binn_object_next(binn_iter *iter, char *pkey, binn *value) {\n\n  return binn_read_next_pair(BINN_OBJECT, iter, NULL, pkey, value);\n\n}",
        "definition_length": 146,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_list_read_next",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "binn_iter *iter",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2017,
        "end_line": 2029,
        "start_byte": 49785,
        "end_byte": 50102,
        "signature": "void * APIENTRY binn_list_read_next(binn_iter *iter, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_list_read_next(binn_iter *iter, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_list_next(iter, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 317,
        "comment": "************************************************************************* *************************************************************************"
      },
      {
        "name": "binn_map_read_next",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "binn_iter *iter",
          "int *pid",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2033,
        "end_line": 2045,
        "start_byte": 50183,
        "end_byte": 50513,
        "signature": "void * APIENTRY binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_map_next(iter, pid, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 330,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_object_read_next",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "binn_iter *iter",
          "char *pkey",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2049,
        "end_line": 2061,
        "start_byte": 50594,
        "end_byte": 50933,
        "signature": "void * APIENTRY binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_object_next(iter, pkey, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 339,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_get_write_storage",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "int type"
        ],
        "is_static": false,
        "start_line": 2068,
        "end_line": 2084,
        "start_byte": 51288,
        "end_byte": 51617,
        "signature": "int APIENTRY binn_get_write_storage(int type)",
        "full_definition": "int APIENTRY binn_get_write_storage(int type) {\n  int storage_type;\n\n  switch (type) {\n    case BINN_SINGLE_STR:\n    case BINN_DOUBLE_STR:\n      return BINN_STORAGE_STRING;\n\n    case BINN_BOOL:\n      return BINN_STORAGE_NOBYTES;\n\n    default:\n      binn_get_type_info(type, &storage_type, NULL);\n      return storage_type;\n  }\n\n}",
        "definition_length": 329,
        "comment": "***** none of the functions above call the functions below ************************ ***********************************************************************************"
      },
      {
        "name": "binn_get_read_storage",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "int type"
        ],
        "is_static": false,
        "start_line": 2088,
        "end_line": 2107,
        "start_byte": 51708,
        "end_byte": 52133,
        "signature": "int APIENTRY binn_get_read_storage(int type)",
        "full_definition": "int APIENTRY binn_get_read_storage(int type) {\n  int storage_type;\n\n  switch (type) {\n#ifdef BINN_EXTENDED\n    case BINN_SINGLE_STR:\n      return BINN_STORAGE_DWORD;\n    case BINN_DOUBLE_STR:\n      return BINN_STORAGE_QWORD;\n#endif\n    case BINN_BOOL:\n    case BINN_TRUE:\n    case BINN_FALSE:\n      return BINN_STORAGE_DWORD;\n    default:\n      binn_get_type_info(type, &storage_type, NULL);\n      return storage_type;\n  }\n\n}",
        "definition_length": 425,
        "comment": "***********************************************************************************"
      },
      {
        "name": "GetWriteConvertedData",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int *ptype",
          "void **ppvalue",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2111,
        "end_line": 2183,
        "start_byte": 52224,
        "end_byte": 53692,
        "signature": "BINN_PRIVATE BOOL GetWriteConvertedData(int *ptype, void **ppvalue, int *psize)",
        "full_definition": "BINN_PRIVATE BOOL GetWriteConvertedData(int *ptype, void **ppvalue, int *psize) {\n  int  type;\n  float  f1;\n  double d1;\n  char pstr[128];\n\n  UNUSED(pstr);\n  UNUSED(d1);\n  UNUSED(f1);\n\n  type = *ptype;\n\n  if (*ppvalue == NULL) {\n    switch (type) {\n      case BINN_NULL:\n      case BINN_TRUE:\n      case BINN_FALSE:\n        break;\n      case BINN_STRING:\n      case BINN_BLOB:\n        if (*psize == 0) break;\n      default:\n        return FALSE;\n    }\n  }\n\n  switch (type) {\n#ifdef BINN_EXTENDED\n    case BINN_SINGLE:\n      f1 = **(float**)ppvalue;\n      d1 = f1;  // convert from float (32bits) to double (64bits)\n      type = BINN_SINGLE_STR;\n      goto conv_double;\n    case BINN_DOUBLE:\n      d1 = **(double**)ppvalue;\n      type = BINN_DOUBLE_STR;\nconv_double:\n      // the '%.17e' is more precise than the '%g'\n      snprintf(pstr, 127, \"%.17e\", d1);\n      *ppvalue = pstr;\n      *ptype = type;\n      break;\n#endif\n    case BINN_DECIMAL:\n    case BINN_CURRENCYSTR:\n      /*\n      if (binn_malloc_extptr(128) == NULL) return FALSE;\n      snprintf(sptr, 127, \"%E\", **ppvalue);\n      *ppvalue = sptr;\n      */\n      return TRUE;  //! temporary\n      break;\n\n    case BINN_DATE:\n    case BINN_DATETIME:\n    case BINN_TIME:\n      return TRUE;  //! temporary\n      break;\n\n    case BINN_BOOL:\n      if (**((BOOL**)ppvalue) == FALSE) {\n        type = BINN_FALSE;\n      } else {\n        type = BINN_TRUE;\n      }\n      *ptype = type;\n      break;\n\n  }\n\n  return TRUE;\n\n}",
        "definition_length": 1468,
        "comment": "***********************************************************************************"
      },
      {
        "name": "type_family",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int type"
        ],
        "is_static": false,
        "start_line": 2187,
        "end_line": 2246,
        "start_byte": 53783,
        "end_byte": 54933,
        "signature": "BINN_PRIVATE int type_family(int type)",
        "full_definition": "BINN_PRIVATE int type_family(int type)  {\n\n  switch (type) {\n    case BINN_LIST:\n    case BINN_MAP:\n    case BINN_OBJECT:\n      return BINN_FAMILY_BINN;\n\n    case BINN_INT8:\n    case BINN_INT16:\n    case BINN_INT32:\n    case BINN_INT64:\n    case BINN_UINT8:\n    case BINN_UINT16:\n    case BINN_UINT32:\n    case BINN_UINT64:\n      return BINN_FAMILY_INT;\n\n    case BINN_FLOAT32:\n    case BINN_FLOAT64:\n    //case BINN_SINGLE:\n    case BINN_SINGLE_STR:\n    //case BINN_DOUBLE:\n    case BINN_DOUBLE_STR:\n      return BINN_FAMILY_FLOAT;\n\n    case BINN_STRING:\n    case BINN_HTML:\n    case BINN_CSS:\n    case BINN_XML:\n    case BINN_JSON:\n    case BINN_JAVASCRIPT:\n      return BINN_FAMILY_STRING;\n\n    case BINN_BLOB:\n    case BINN_JPEG:\n    case BINN_GIF:\n    case BINN_PNG:\n    case BINN_BMP:\n      return BINN_FAMILY_BLOB;\n\n    case BINN_DECIMAL:\n    case BINN_CURRENCY:\n    case BINN_DATE:\n    case BINN_TIME:\n    case BINN_DATETIME:\n      return BINN_FAMILY_STRING;\n\n    case BINN_BOOL:\n      return BINN_FAMILY_BOOL;\n\n    case BINN_NULL:\n      return BINN_FAMILY_NULL;\n\n    default:\n      // if it wasn't found\n      return BINN_FAMILY_NONE;\n  }\n\n}",
        "definition_length": 1150,
        "comment": "***********************************************************************************"
      },
      {
        "name": "int_type",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int type"
        ],
        "is_static": false,
        "start_line": 2250,
        "end_line": 2269,
        "start_byte": 55024,
        "end_byte": 55327,
        "signature": "BINN_PRIVATE int int_type(int type)",
        "full_definition": "BINN_PRIVATE int int_type(int type)  {\n\n  switch (type) {\n  case BINN_INT8:\n  case BINN_INT16:\n  case BINN_INT32:\n  case BINN_INT64:\n    return BINN_SIGNED_INT;\n\n  case BINN_UINT8:\n  case BINN_UINT16:\n  case BINN_UINT32:\n  case BINN_UINT64:\n    return BINN_UNSIGNED_INT;\n\n  default:\n    return 0;\n  }\n\n}",
        "definition_length": 303,
        "comment": "***********************************************************************************"
      },
      {
        "name": "copy_raw_value",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *psource",
          "void *pdest",
          "int data_store"
        ],
        "is_static": false,
        "start_line": 2273,
        "end_line": 2301,
        "start_byte": 55418,
        "end_byte": 56079,
        "signature": "BINN_PRIVATE BOOL copy_raw_value(const void *psource, void *pdest, int data_store)",
        "full_definition": "BINN_PRIVATE BOOL copy_raw_value(const void *psource, void *pdest, int data_store) {\n\n  switch (data_store) {\n  case BINN_STORAGE_NOBYTES:\n    break;\n  case BINN_STORAGE_BYTE:\n    *((char *) pdest) = *(char *)psource;\n    break;\n  case BINN_STORAGE_WORD:\n    *((short *) pdest) = *(short *)psource;\n    break;\n  case BINN_STORAGE_DWORD:\n    *((int *) pdest) = *(int *)psource;\n    break;\n  case BINN_STORAGE_QWORD:\n    *((uint64 *) pdest) = *(uint64 *)psource;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n  case BINN_STORAGE_CONTAINER:\n    *((char **) pdest) = (char *)psource;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n\n}",
        "definition_length": 661,
        "comment": "***********************************************************************************"
      },
      {
        "name": "copy_int_value",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *psource",
          "void *pdest",
          "int source_type",
          "int dest_type"
        ],
        "is_static": false,
        "start_line": 2305,
        "end_line": 2390,
        "start_byte": 56170,
        "end_byte": 58260,
        "signature": "BINN_PRIVATE BOOL copy_int_value(const void *psource, void *pdest, int source_type, int dest_type)",
        "full_definition": "BINN_PRIVATE BOOL copy_int_value(const void *psource, void *pdest, int source_type, int dest_type) {\n  uint64 vuint64 = 0; int64 vint64 = 0;\n\n  switch (source_type) {\n  case BINN_INT8:\n    vint64 = *(signed char *)psource;\n    break;\n  case BINN_INT16:\n    vint64 = *(short *)psource;\n    break;\n  case BINN_INT32:\n    vint64 = *(int *)psource;\n    break;\n  case BINN_INT64:\n    vint64 = *(int64 *)psource;\n    break;\n\n  case BINN_UINT8:\n    vuint64 = *(unsigned char *)psource;\n    break;\n  case BINN_UINT16:\n    vuint64 = *(unsigned short *)psource;\n    break;\n  case BINN_UINT32:\n    vuint64 = *(unsigned int *)psource;\n    break;\n  case BINN_UINT64:\n    vuint64 = *(uint64 *)psource;\n    break;\n\n  default:\n    return FALSE;\n  }\n\n\n  // copy from int64 to uint64, if possible\n\n  if (int_type(source_type) == BINN_UNSIGNED_INT && int_type(dest_type) == BINN_SIGNED_INT) {\n    if (vuint64 > INT64_MAX) return FALSE;\n    vint64 = vuint64;\n  } else if (int_type(source_type) == BINN_SIGNED_INT && int_type(dest_type) == BINN_UNSIGNED_INT) {\n    if (vint64 < 0) return FALSE;\n    vuint64 = vint64;\n  }\n\n\n  switch (dest_type) {\n  case BINN_INT8:\n    if (vint64 < INT8_MIN || vint64 > INT8_MAX) return FALSE;\n    *(signed char *)pdest = (signed char) vint64;\n    break;\n  case BINN_INT16:\n    if (vint64 < INT16_MIN || vint64 > INT16_MAX) return FALSE;\n    *(short *)pdest = (short) vint64;\n    break;\n  case BINN_INT32:\n    if (vint64 < INT32_MIN || vint64 > INT32_MAX) return FALSE;\n    *(int *)pdest = (int) vint64;\n    break;\n  case BINN_INT64:\n    *(int64 *)pdest = vint64;\n    break;\n\n  case BINN_UINT8:\n    if (vuint64 > UINT8_MAX) return FALSE;\n    *(unsigned char *)pdest = (unsigned char) vuint64;\n    break;\n  case BINN_UINT16:\n    if (vuint64 > UINT16_MAX) return FALSE;\n    *(unsigned short *)pdest = (unsigned short) vuint64;\n    break;\n  case BINN_UINT32:\n    if (vuint64 > UINT32_MAX) return FALSE;\n    *(unsigned int *)pdest = (unsigned int) vuint64;\n    break;\n  case BINN_UINT64:\n    *(uint64 *)pdest = vuint64;\n    break;\n\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n\n}",
        "definition_length": 2090,
        "comment": "***********************************************************************************"
      },
      {
        "name": "copy_float_value",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *psource",
          "void *pdest",
          "int source_type",
          "int dest_type"
        ],
        "is_static": false,
        "start_line": 2394,
        "end_line": 2409,
        "start_byte": 58351,
        "end_byte": 58687,
        "signature": "BINN_PRIVATE BOOL copy_float_value(const void *psource, void *pdest, int source_type, int dest_type)",
        "full_definition": "BINN_PRIVATE BOOL copy_float_value(const void *psource, void *pdest, int source_type, int dest_type) {\n\n  switch (source_type) {\n  case BINN_FLOAT32:\n    *(double *)pdest = *(float *)psource;\n    break;\n  case BINN_FLOAT64:\n    *(float *)pdest = (float) *(double *)psource;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n\n}",
        "definition_length": 336,
        "comment": "***********************************************************************************"
      },
      {
        "name": "zero_value",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *pvalue",
          "int type"
        ],
        "is_static": false,
        "start_line": 2413,
        "end_line": 2444,
        "start_byte": 58778,
        "end_byte": 59430,
        "signature": "BINN_PRIVATE void zero_value(const void *pvalue, int type)",
        "full_definition": "BINN_PRIVATE void zero_value(const void *pvalue, int type) {\n  //int size=0;\n\n  switch (binn_get_read_storage(type)) {\n  case BINN_STORAGE_NOBYTES:\n    break;\n  case BINN_STORAGE_BYTE:\n    *((char *) pvalue) = 0;\n    //size=1;\n    break;\n  case BINN_STORAGE_WORD:\n    *((short *) pvalue) = 0;\n    //size=2;\n    break;\n  case BINN_STORAGE_DWORD:\n    *((int *) pvalue) = 0;\n    //size=4;\n    break;\n  case BINN_STORAGE_QWORD:\n    *((uint64 *) pvalue) = 0;\n    //size=8;\n    break;\n  case BINN_STORAGE_BLOB:\n  case BINN_STORAGE_STRING:\n  case BINN_STORAGE_CONTAINER:\n    *(char **)pvalue = NULL;\n    break;\n  }\n\n  //if (size>0) memset(pvalue, 0, size);\n\n}",
        "definition_length": 652,
        "comment": "***********************************************************************************"
      },
      {
        "name": "copy_value",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "void *psource",
          "void *pdest",
          "int source_type",
          "int dest_type",
          "int data_store"
        ],
        "is_static": false,
        "start_line": 2448,
        "end_line": 2460,
        "start_byte": 59521,
        "end_byte": 60081,
        "signature": "BINN_PRIVATE BOOL copy_value(void *psource, void *pdest, int source_type, int dest_type, int data_store)",
        "full_definition": "BINN_PRIVATE BOOL copy_value(void *psource, void *pdest, int source_type, int dest_type, int data_store) {\n\n  if (type_family(source_type) != type_family(dest_type)) return FALSE;\n\n  if (type_family(source_type) == BINN_FAMILY_INT && source_type != dest_type) {\n    return copy_int_value(psource, pdest, source_type, dest_type);\n  } else if (type_family(source_type) == BINN_FAMILY_FLOAT && source_type != dest_type) {\n    return copy_float_value(psource, pdest, source_type, dest_type);\n  } else {\n    return copy_raw_value(psource, pdest, data_store);\n  }\n\n}",
        "definition_length": 560,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_list_add",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *list",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 2466,
        "end_line": 2472,
        "start_byte": 60348,
        "end_byte": 60557,
        "signature": "BOOL APIENTRY binn_list_add(binn *list, int type, void *pvalue, int size)",
        "full_definition": "BOOL APIENTRY binn_list_add(binn *list, int type, void *pvalue, int size) {\n\n  if (GetWriteConvertedData(&type, &pvalue, &size) == FALSE) return FALSE;\n\n  return binn_list_add_raw(list, type, pvalue, size);\n\n}",
        "definition_length": 209,
        "comment": "** WRITE FUNCTIONS **************************************************************** ***********************************************************************************"
      },
      {
        "name": "binn_map_set",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *map",
          "int id",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 2476,
        "end_line": 2482,
        "start_byte": 60648,
        "end_byte": 60865,
        "signature": "BOOL APIENTRY binn_map_set(binn *map, int id, int type, void *pvalue, int size)",
        "full_definition": "BOOL APIENTRY binn_map_set(binn *map, int id, int type, void *pvalue, int size) {\n\n  if (GetWriteConvertedData(&type, &pvalue, &size) == FALSE) return FALSE;\n\n  return binn_map_set_raw(map, id, type, pvalue, size);\n\n}",
        "definition_length": 217,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_object_set",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *obj",
          "const char *key",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 2486,
        "end_line": 2492,
        "start_byte": 60956,
        "end_byte": 61189,
        "signature": "BOOL APIENTRY binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size)",
        "full_definition": "BOOL APIENTRY binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size) {\n\n  if (GetWriteConvertedData(&type, &pvalue, &size) == FALSE) return FALSE;\n\n  return binn_object_set_raw(obj, key, type, pvalue, size);\n\n}",
        "definition_length": 233,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_add_value",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *item",
          "int binn_type",
          "int id",
          "char *name",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "is_static": false,
        "start_line": 2497,
        "end_line": 2510,
        "start_byte": 61321,
        "end_byte": 61730,
        "signature": "BOOL APIENTRY binn_add_value(binn *item, int binn_type, int id, char *name, int type, void *pvalue, int size)",
        "full_definition": "BOOL APIENTRY binn_add_value(binn *item, int binn_type, int id, char *name, int type, void *pvalue, int size) {\n\n  switch (binn_type) {\n    case BINN_LIST:\n      return binn_list_add(item, type, pvalue, size);\n    case BINN_MAP:\n      return binn_map_set(item, id, type, pvalue, size);\n    case BINN_OBJECT:\n      return binn_object_set(item, name, type, pvalue, size);\n    default:\n      return FALSE;\n  }\n\n}",
        "definition_length": 409,
        "comment": "*********************************************************************************** this function is used by the wrappers"
      },
      {
        "name": "binn_list_add_new",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *list",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 2515,
        "end_line": 2522,
        "start_byte": 61909,
        "end_byte": 62077,
        "signature": "BOOL APIENTRY binn_list_add_new(binn *list, binn *value)",
        "full_definition": "BOOL APIENTRY binn_list_add_new(binn *list, binn *value) {\n  BOOL retval;\n\n  retval = binn_list_add_value(list, value);\n  if (value) free_fn(value);\n  return retval;\n\n}",
        "definition_length": 168,
        "comment": "*********************************************************************************** ***********************************************************************************"
      },
      {
        "name": "binn_map_set_new",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *map",
          "int id",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 2526,
        "end_line": 2533,
        "start_byte": 62168,
        "end_byte": 62344,
        "signature": "BOOL APIENTRY binn_map_set_new(binn *map, int id, binn *value)",
        "full_definition": "BOOL APIENTRY binn_map_set_new(binn *map, int id, binn *value) {\n  BOOL retval;\n\n  retval = binn_map_set_value(map, id, value);\n  if (value) free_fn(value);\n  return retval;\n\n}",
        "definition_length": 176,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_object_set_new",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *obj",
          "const char *key",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 2537,
        "end_line": 2544,
        "start_byte": 62435,
        "end_byte": 62627,
        "signature": "BOOL APIENTRY binn_object_set_new(binn *obj, const char *key, binn *value)",
        "full_definition": "BOOL APIENTRY binn_object_set_new(binn *obj, const char *key, binn *value) {\n  BOOL retval;\n\n  retval = binn_object_set_value(obj, key, value);\n  if (value) free_fn(value);\n  return retval;\n\n}",
        "definition_length": 192,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_list_read",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2602,
        "end_line": 2614,
        "start_byte": 64038,
        "end_byte": 64370,
        "signature": "void * APIENTRY binn_list_read(const void *list, int pos, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_list_read(const void *list, int pos, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_list_get_value(list, pos, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 332,
        "comment": "************************************************************************* *************************************************************************"
      },
      {
        "name": "binn_map_read",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2618,
        "end_line": 2630,
        "start_byte": 64451,
        "end_byte": 64777,
        "signature": "void * APIENTRY binn_map_read(const void *map, int id, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_map_read(const void *map, int id, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_map_get_value(map, id, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 326,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_object_read",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key",
          "int *ptype",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2634,
        "end_line": 2646,
        "start_byte": 64858,
        "end_byte": 65200,
        "signature": "void * APIENTRY binn_object_read(const void *obj, const char *key, int *ptype, int *psize)",
        "full_definition": "void * APIENTRY binn_object_read(const void *obj, const char *key, int *ptype, int *psize) {\n  binn value;\n\n  if (binn_object_get_value(obj, key, &value) == FALSE) return NULL;\n  if (ptype) *ptype = value.type;\n  if (psize) *psize = value.size;\n#if BYTE_ORDER == LITTLE_ENDIAN\n  return store_value(&value);\n#else\n  return value.ptr;\n#endif\n\n}",
        "definition_length": 342,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_list_get",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int pos",
          "int type",
          "void *pvalue",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2651,
        "end_line": 2668,
        "start_byte": 65359,
        "end_byte": 65852,
        "signature": "BOOL APIENTRY binn_list_get(const void *ptr, int pos, int type, void *pvalue, int *psize)",
        "full_definition": "BOOL APIENTRY binn_list_get(const void *ptr, int pos, int type, void *pvalue, int *psize) {\n  binn value;\n  int storage_type;\n\n  storage_type = binn_get_read_storage(type);\n  if (storage_type != BINN_STORAGE_NOBYTES && pvalue == NULL) return FALSE;\n\n  zero_value(pvalue, type);\n\n  if (binn_list_get_value(ptr, pos, &value) == FALSE) return FALSE;\n\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == FALSE) return FALSE;\n\n  if (psize) *psize = value.size;\n\n  return TRUE;\n\n}",
        "definition_length": 493,
        "comment": "************************************************************************* *************************************************************************"
      },
      {
        "name": "binn_map_get",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int id",
          "int type",
          "void *pvalue",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2672,
        "end_line": 2689,
        "start_byte": 65933,
        "end_byte": 66422,
        "signature": "BOOL APIENTRY binn_map_get(const void *ptr, int id, int type, void *pvalue, int *psize)",
        "full_definition": "BOOL APIENTRY binn_map_get(const void *ptr, int id, int type, void *pvalue, int *psize) {\n  binn value;\n  int storage_type;\n\n  storage_type = binn_get_read_storage(type);\n  if (storage_type != BINN_STORAGE_NOBYTES && pvalue == NULL) return FALSE;\n\n  zero_value(pvalue, type);\n\n  if (binn_map_get_value(ptr, id, &value) == FALSE) return FALSE;\n\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == FALSE) return FALSE;\n\n  if (psize) *psize = value.size;\n\n  return TRUE;\n\n}",
        "definition_length": 489,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_object_get",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "const char *key",
          "int type",
          "void *pvalue",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2695,
        "end_line": 2712,
        "start_byte": 66594,
        "end_byte": 67099,
        "signature": "BOOL APIENTRY binn_object_get(const void *ptr, const char *key, int type, void *pvalue, int *psize)",
        "full_definition": "BOOL APIENTRY binn_object_get(const void *ptr, const char *key, int type, void *pvalue, int *psize) {\n  binn value;\n  int storage_type;\n\n  storage_type = binn_get_read_storage(type);\n  if (storage_type != BINN_STORAGE_NOBYTES && pvalue == NULL) return FALSE;\n\n  zero_value(pvalue, type);\n\n  if (binn_object_get_value(ptr, key, &value) == FALSE) return FALSE;\n\n  if (copy_value(value.ptr, pvalue, value.type, type, storage_type) == FALSE) return FALSE;\n\n  if (psize) *psize = value.size;\n\n  return TRUE;\n\n}",
        "definition_length": 505,
        "comment": "if (binn_object_get(obj, \"multiplier\", BINN_INT32, &multiplier, NULL) == FALSE) xxx;"
      },
      {
        "name": "binn_list_int8",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2724,
        "end_line": 2730,
        "start_byte": 67641,
        "end_byte": 67799,
        "signature": "signed char APIENTRY binn_list_int8(const void *list, int pos)",
        "full_definition": "signed char APIENTRY binn_list_int8(const void *list, int pos) {\n  signed char value;\n\n  binn_list_get(list, pos, BINN_INT8, &value, NULL);\n\n  return value;\n}",
        "definition_length": 158,
        "comment": "is there any problem with wrappers? can these wrappers implement these functions using the header? if as static, will they be present even on modules that don't use the functions?"
      },
      {
        "name": "binn_list_int16",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2732,
        "end_line": 2738,
        "start_byte": 67801,
        "end_byte": 67949,
        "signature": "short APIENTRY binn_list_int16(const void *list, int pos)",
        "full_definition": "short APIENTRY binn_list_int16(const void *list, int pos) {\n  short value;\n\n  binn_list_get(list, pos, BINN_INT16, &value, NULL);\n\n  return value;\n}",
        "definition_length": 148,
        "comment": ""
      },
      {
        "name": "binn_list_int32",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2740,
        "end_line": 2746,
        "start_byte": 67951,
        "end_byte": 68095,
        "signature": "int APIENTRY binn_list_int32(const void *list, int pos)",
        "full_definition": "int APIENTRY binn_list_int32(const void *list, int pos) {\n  int value;\n\n  binn_list_get(list, pos, BINN_INT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 144,
        "comment": ""
      },
      {
        "name": "binn_list_int64",
        "type": "definition",
        "return_type": "int64",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2748,
        "end_line": 2754,
        "start_byte": 68097,
        "end_byte": 68245,
        "signature": "int64 APIENTRY binn_list_int64(const void *list, int pos)",
        "full_definition": "int64 APIENTRY binn_list_int64(const void *list, int pos) {\n  int64 value;\n\n  binn_list_get(list, pos, BINN_INT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 148,
        "comment": ""
      },
      {
        "name": "binn_list_uint8",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2756,
        "end_line": 2762,
        "start_byte": 68247,
        "end_byte": 68411,
        "signature": "unsigned char APIENTRY binn_list_uint8(const void *list, int pos)",
        "full_definition": "unsigned char APIENTRY binn_list_uint8(const void *list, int pos) {\n  unsigned char value;\n\n  binn_list_get(list, pos, BINN_UINT8, &value, NULL);\n\n  return value;\n}",
        "definition_length": 164,
        "comment": ""
      },
      {
        "name": "binn_list_uint16",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2764,
        "end_line": 2770,
        "start_byte": 68413,
        "end_byte": 68581,
        "signature": "unsigned short APIENTRY binn_list_uint16(const void *list, int pos)",
        "full_definition": "unsigned short APIENTRY binn_list_uint16(const void *list, int pos) {\n  unsigned short value;\n\n  binn_list_get(list, pos, BINN_UINT16, &value, NULL);\n\n  return value;\n}",
        "definition_length": 168,
        "comment": ""
      },
      {
        "name": "binn_list_uint32",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2772,
        "end_line": 2778,
        "start_byte": 68583,
        "end_byte": 68747,
        "signature": "unsigned int APIENTRY binn_list_uint32(const void *list, int pos)",
        "full_definition": "unsigned int APIENTRY binn_list_uint32(const void *list, int pos) {\n  unsigned int value;\n\n  binn_list_get(list, pos, BINN_UINT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 164,
        "comment": ""
      },
      {
        "name": "binn_list_uint64",
        "type": "definition",
        "return_type": "uint64",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2780,
        "end_line": 2786,
        "start_byte": 68749,
        "end_byte": 68901,
        "signature": "uint64 APIENTRY binn_list_uint64(const void *list, int pos)",
        "full_definition": "uint64 APIENTRY binn_list_uint64(const void *list, int pos) {\n  uint64 value;\n\n  binn_list_get(list, pos, BINN_UINT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 152,
        "comment": ""
      },
      {
        "name": "binn_list_float",
        "type": "definition",
        "return_type": "float",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2788,
        "end_line": 2794,
        "start_byte": 68903,
        "end_byte": 69053,
        "signature": "float APIENTRY binn_list_float(const void *list, int pos)",
        "full_definition": "float APIENTRY binn_list_float(const void *list, int pos) {\n  float value;\n\n  binn_list_get(list, pos, BINN_FLOAT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 150,
        "comment": ""
      },
      {
        "name": "binn_list_double",
        "type": "definition",
        "return_type": "double",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2796,
        "end_line": 2802,
        "start_byte": 69055,
        "end_byte": 69208,
        "signature": "double APIENTRY binn_list_double(const void *list, int pos)",
        "full_definition": "double APIENTRY binn_list_double(const void *list, int pos) {\n  double value;\n\n  binn_list_get(list, pos, BINN_FLOAT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 153,
        "comment": ""
      },
      {
        "name": "binn_list_bool",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2804,
        "end_line": 2810,
        "start_byte": 69210,
        "end_byte": 69354,
        "signature": "BOOL APIENTRY binn_list_bool(const void *list, int pos)",
        "full_definition": "BOOL APIENTRY binn_list_bool(const void *list, int pos) {\n  BOOL value;\n\n  binn_list_get(list, pos, BINN_BOOL, &value, NULL);\n\n  return value;\n}",
        "definition_length": 144,
        "comment": ""
      },
      {
        "name": "binn_list_null",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2812,
        "end_line": 2816,
        "start_byte": 69356,
        "end_byte": 69475,
        "signature": "BOOL APIENTRY binn_list_null(const void *list, int pos)",
        "full_definition": "BOOL APIENTRY binn_list_null(const void *list, int pos) {\n\n  return binn_list_get(list, pos, BINN_NULL, NULL, NULL);\n\n}",
        "definition_length": 119,
        "comment": ""
      },
      {
        "name": "binn_list_str",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2818,
        "end_line": 2824,
        "start_byte": 69477,
        "end_byte": 69625,
        "signature": "char * APIENTRY binn_list_str(const void *list, int pos)",
        "full_definition": "char * APIENTRY binn_list_str(const void *list, int pos) {\n  char *value;\n\n  binn_list_get(list, pos, BINN_STRING, &value, NULL);\n\n  return value;\n}",
        "definition_length": 148,
        "comment": ""
      },
      {
        "name": "binn_list_blob",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2826,
        "end_line": 2832,
        "start_byte": 69627,
        "end_byte": 69787,
        "signature": "void * APIENTRY binn_list_blob(const void *list, int pos, int *psize)",
        "full_definition": "void * APIENTRY binn_list_blob(const void *list, int pos, int *psize) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_BLOB, &value, psize);\n\n  return value;\n}",
        "definition_length": 160,
        "comment": ""
      },
      {
        "name": "binn_list_list",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2834,
        "end_line": 2840,
        "start_byte": 69789,
        "end_byte": 69936,
        "signature": "void * APIENTRY binn_list_list(const void *list, int pos)",
        "full_definition": "void * APIENTRY binn_list_list(const void *list, int pos) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_LIST, &value, NULL);\n\n  return value;\n}",
        "definition_length": 147,
        "comment": ""
      },
      {
        "name": "binn_list_map",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2842,
        "end_line": 2848,
        "start_byte": 69938,
        "end_byte": 70083,
        "signature": "void * APIENTRY binn_list_map(const void *list, int pos)",
        "full_definition": "void * APIENTRY binn_list_map(const void *list, int pos) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_MAP, &value, NULL);\n\n  return value;\n}",
        "definition_length": 145,
        "comment": ""
      },
      {
        "name": "binn_list_object",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "is_static": false,
        "start_line": 2850,
        "end_line": 2856,
        "start_byte": 70085,
        "end_byte": 70236,
        "signature": "void * APIENTRY binn_list_object(const void *list, int pos)",
        "full_definition": "void * APIENTRY binn_list_object(const void *list, int pos) {\n  void *value;\n\n  binn_list_get(list, pos, BINN_OBJECT, &value, NULL);\n\n  return value;\n}",
        "definition_length": 151,
        "comment": ""
      },
      {
        "name": "binn_map_int8",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2860,
        "end_line": 2866,
        "start_byte": 70317,
        "end_byte": 70469,
        "signature": "signed char APIENTRY binn_map_int8(const void *map, int id)",
        "full_definition": "signed char APIENTRY binn_map_int8(const void *map, int id) {\n  signed char value;\n\n  binn_map_get(map, id, BINN_INT8, &value, NULL);\n\n  return value;\n}",
        "definition_length": 152,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_map_int16",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2868,
        "end_line": 2874,
        "start_byte": 70471,
        "end_byte": 70613,
        "signature": "short APIENTRY binn_map_int16(const void *map, int id)",
        "full_definition": "short APIENTRY binn_map_int16(const void *map, int id) {\n  short value;\n\n  binn_map_get(map, id, BINN_INT16, &value, NULL);\n\n  return value;\n}",
        "definition_length": 142,
        "comment": ""
      },
      {
        "name": "binn_map_int32",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2876,
        "end_line": 2882,
        "start_byte": 70615,
        "end_byte": 70753,
        "signature": "int APIENTRY binn_map_int32(const void *map, int id)",
        "full_definition": "int APIENTRY binn_map_int32(const void *map, int id) {\n  int value;\n\n  binn_map_get(map, id, BINN_INT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 138,
        "comment": ""
      },
      {
        "name": "binn_map_int64",
        "type": "definition",
        "return_type": "int64",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2884,
        "end_line": 2890,
        "start_byte": 70755,
        "end_byte": 70897,
        "signature": "int64 APIENTRY binn_map_int64(const void *map, int id)",
        "full_definition": "int64 APIENTRY binn_map_int64(const void *map, int id) {\n  int64 value;\n\n  binn_map_get(map, id, BINN_INT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 142,
        "comment": ""
      },
      {
        "name": "binn_map_uint8",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2892,
        "end_line": 2898,
        "start_byte": 70899,
        "end_byte": 71057,
        "signature": "unsigned char APIENTRY binn_map_uint8(const void *map, int id)",
        "full_definition": "unsigned char APIENTRY binn_map_uint8(const void *map, int id) {\n  unsigned char value;\n\n  binn_map_get(map, id, BINN_UINT8, &value, NULL);\n\n  return value;\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "binn_map_uint16",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2900,
        "end_line": 2906,
        "start_byte": 71059,
        "end_byte": 71221,
        "signature": "unsigned short APIENTRY binn_map_uint16(const void *map, int id)",
        "full_definition": "unsigned short APIENTRY binn_map_uint16(const void *map, int id) {\n  unsigned short value;\n\n  binn_map_get(map, id, BINN_UINT16, &value, NULL);\n\n  return value;\n}",
        "definition_length": 162,
        "comment": ""
      },
      {
        "name": "binn_map_uint32",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2908,
        "end_line": 2914,
        "start_byte": 71223,
        "end_byte": 71381,
        "signature": "unsigned int APIENTRY binn_map_uint32(const void *map, int id)",
        "full_definition": "unsigned int APIENTRY binn_map_uint32(const void *map, int id) {\n  unsigned int value;\n\n  binn_map_get(map, id, BINN_UINT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "binn_map_uint64",
        "type": "definition",
        "return_type": "uint64",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2916,
        "end_line": 2922,
        "start_byte": 71383,
        "end_byte": 71529,
        "signature": "uint64 APIENTRY binn_map_uint64(const void *map, int id)",
        "full_definition": "uint64 APIENTRY binn_map_uint64(const void *map, int id) {\n  uint64 value;\n\n  binn_map_get(map, id, BINN_UINT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 146,
        "comment": ""
      },
      {
        "name": "binn_map_float",
        "type": "definition",
        "return_type": "float",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2924,
        "end_line": 2930,
        "start_byte": 71531,
        "end_byte": 71675,
        "signature": "float APIENTRY binn_map_float(const void *map, int id)",
        "full_definition": "float APIENTRY binn_map_float(const void *map, int id) {\n  float value;\n\n  binn_map_get(map, id, BINN_FLOAT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 144,
        "comment": ""
      },
      {
        "name": "binn_map_double",
        "type": "definition",
        "return_type": "double",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2932,
        "end_line": 2938,
        "start_byte": 71677,
        "end_byte": 71824,
        "signature": "double APIENTRY binn_map_double(const void *map, int id)",
        "full_definition": "double APIENTRY binn_map_double(const void *map, int id) {\n  double value;\n\n  binn_map_get(map, id, BINN_FLOAT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 147,
        "comment": ""
      },
      {
        "name": "binn_map_bool",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2940,
        "end_line": 2946,
        "start_byte": 71826,
        "end_byte": 71964,
        "signature": "BOOL APIENTRY binn_map_bool(const void *map, int id)",
        "full_definition": "BOOL APIENTRY binn_map_bool(const void *map, int id) {\n  BOOL value;\n\n  binn_map_get(map, id, BINN_BOOL, &value, NULL);\n\n  return value;\n}",
        "definition_length": 138,
        "comment": ""
      },
      {
        "name": "binn_map_null",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2948,
        "end_line": 2952,
        "start_byte": 71966,
        "end_byte": 72079,
        "signature": "BOOL APIENTRY binn_map_null(const void *map, int id)",
        "full_definition": "BOOL APIENTRY binn_map_null(const void *map, int id) {\n\n  return binn_map_get(map, id, BINN_NULL, NULL, NULL);\n\n}",
        "definition_length": 113,
        "comment": ""
      },
      {
        "name": "binn_map_str",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2954,
        "end_line": 2960,
        "start_byte": 72081,
        "end_byte": 72223,
        "signature": "char * APIENTRY binn_map_str(const void *map, int id)",
        "full_definition": "char * APIENTRY binn_map_str(const void *map, int id) {\n  char *value;\n\n  binn_map_get(map, id, BINN_STRING, &value, NULL);\n\n  return value;\n}",
        "definition_length": 142,
        "comment": ""
      },
      {
        "name": "binn_map_blob",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 2962,
        "end_line": 2968,
        "start_byte": 72225,
        "end_byte": 72379,
        "signature": "void * APIENTRY binn_map_blob(const void *map, int id, int *psize)",
        "full_definition": "void * APIENTRY binn_map_blob(const void *map, int id, int *psize) {\n  void *value;\n\n  binn_map_get(map, id, BINN_BLOB, &value, psize);\n\n  return value;\n}",
        "definition_length": 154,
        "comment": ""
      },
      {
        "name": "binn_map_list",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2970,
        "end_line": 2976,
        "start_byte": 72381,
        "end_byte": 72522,
        "signature": "void * APIENTRY binn_map_list(const void *map, int id)",
        "full_definition": "void * APIENTRY binn_map_list(const void *map, int id) {\n  void *value;\n\n  binn_map_get(map, id, BINN_LIST, &value, NULL);\n\n  return value;\n}",
        "definition_length": 141,
        "comment": ""
      },
      {
        "name": "binn_map_map",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2978,
        "end_line": 2984,
        "start_byte": 72524,
        "end_byte": 72663,
        "signature": "void * APIENTRY binn_map_map(const void *map, int id)",
        "full_definition": "void * APIENTRY binn_map_map(const void *map, int id) {\n  void *value;\n\n  binn_map_get(map, id, BINN_MAP, &value, NULL);\n\n  return value;\n}",
        "definition_length": 139,
        "comment": ""
      },
      {
        "name": "binn_map_object",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 2986,
        "end_line": 2992,
        "start_byte": 72665,
        "end_byte": 72810,
        "signature": "void * APIENTRY binn_map_object(const void *map, int id)",
        "full_definition": "void * APIENTRY binn_map_object(const void *map, int id) {\n  void *value;\n\n  binn_map_get(map, id, BINN_OBJECT, &value, NULL);\n\n  return value;\n}",
        "definition_length": 145,
        "comment": ""
      },
      {
        "name": "binn_object_int8",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 2996,
        "end_line": 3002,
        "start_byte": 72891,
        "end_byte": 73059,
        "signature": "signed char APIENTRY binn_object_int8(const void *obj, const char *key)",
        "full_definition": "signed char APIENTRY binn_object_int8(const void *obj, const char *key) {\n  signed char value;\n\n  binn_object_get(obj, key, BINN_INT8, &value, NULL);\n\n  return value;\n}",
        "definition_length": 168,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_object_int16",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3004,
        "end_line": 3010,
        "start_byte": 73061,
        "end_byte": 73219,
        "signature": "short APIENTRY binn_object_int16(const void *obj, const char *key)",
        "full_definition": "short APIENTRY binn_object_int16(const void *obj, const char *key) {\n  short value;\n\n  binn_object_get(obj, key, BINN_INT16, &value, NULL);\n\n  return value;\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "binn_object_int32",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3012,
        "end_line": 3018,
        "start_byte": 73221,
        "end_byte": 73375,
        "signature": "int APIENTRY binn_object_int32(const void *obj, const char *key)",
        "full_definition": "int APIENTRY binn_object_int32(const void *obj, const char *key) {\n  int value;\n\n  binn_object_get(obj, key, BINN_INT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 154,
        "comment": ""
      },
      {
        "name": "binn_object_int64",
        "type": "definition",
        "return_type": "int64",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3020,
        "end_line": 3026,
        "start_byte": 73377,
        "end_byte": 73535,
        "signature": "int64 APIENTRY binn_object_int64(const void *obj, const char *key)",
        "full_definition": "int64 APIENTRY binn_object_int64(const void *obj, const char *key) {\n  int64 value;\n\n  binn_object_get(obj, key, BINN_INT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "binn_object_uint8",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3028,
        "end_line": 3034,
        "start_byte": 73537,
        "end_byte": 73711,
        "signature": "unsigned char APIENTRY binn_object_uint8(const void *obj, const char *key)",
        "full_definition": "unsigned char APIENTRY binn_object_uint8(const void *obj, const char *key) {\n  unsigned char value;\n\n  binn_object_get(obj, key, BINN_UINT8, &value, NULL);\n\n  return value;\n}",
        "definition_length": 174,
        "comment": ""
      },
      {
        "name": "binn_object_uint16",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3036,
        "end_line": 3042,
        "start_byte": 73713,
        "end_byte": 73891,
        "signature": "unsigned short APIENTRY binn_object_uint16(const void *obj, const char *key)",
        "full_definition": "unsigned short APIENTRY binn_object_uint16(const void *obj, const char *key) {\n  unsigned short value;\n\n  binn_object_get(obj, key, BINN_UINT16, &value, NULL);\n\n  return value;\n}",
        "definition_length": 178,
        "comment": ""
      },
      {
        "name": "binn_object_uint32",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3044,
        "end_line": 3050,
        "start_byte": 73893,
        "end_byte": 74067,
        "signature": "unsigned int APIENTRY binn_object_uint32(const void *obj, const char *key)",
        "full_definition": "unsigned int APIENTRY binn_object_uint32(const void *obj, const char *key) {\n  unsigned int value;\n\n  binn_object_get(obj, key, BINN_UINT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 174,
        "comment": ""
      },
      {
        "name": "binn_object_uint64",
        "type": "definition",
        "return_type": "uint64",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3052,
        "end_line": 3058,
        "start_byte": 74069,
        "end_byte": 74231,
        "signature": "uint64 APIENTRY binn_object_uint64(const void *obj, const char *key)",
        "full_definition": "uint64 APIENTRY binn_object_uint64(const void *obj, const char *key) {\n  uint64 value;\n\n  binn_object_get(obj, key, BINN_UINT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 162,
        "comment": ""
      },
      {
        "name": "binn_object_float",
        "type": "definition",
        "return_type": "float",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3060,
        "end_line": 3066,
        "start_byte": 74233,
        "end_byte": 74393,
        "signature": "float APIENTRY binn_object_float(const void *obj, const char *key)",
        "full_definition": "float APIENTRY binn_object_float(const void *obj, const char *key) {\n  float value;\n\n  binn_object_get(obj, key, BINN_FLOAT32, &value, NULL);\n\n  return value;\n}",
        "definition_length": 160,
        "comment": ""
      },
      {
        "name": "binn_object_double",
        "type": "definition",
        "return_type": "double",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3068,
        "end_line": 3074,
        "start_byte": 74395,
        "end_byte": 74558,
        "signature": "double APIENTRY binn_object_double(const void *obj, const char *key)",
        "full_definition": "double APIENTRY binn_object_double(const void *obj, const char *key) {\n  double value;\n\n  binn_object_get(obj, key, BINN_FLOAT64, &value, NULL);\n\n  return value;\n}",
        "definition_length": 163,
        "comment": ""
      },
      {
        "name": "binn_object_bool",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3076,
        "end_line": 3082,
        "start_byte": 74560,
        "end_byte": 74714,
        "signature": "BOOL APIENTRY binn_object_bool(const void *obj, const char *key)",
        "full_definition": "BOOL APIENTRY binn_object_bool(const void *obj, const char *key) {\n  BOOL value;\n\n  binn_object_get(obj, key, BINN_BOOL, &value, NULL);\n\n  return value;\n}",
        "definition_length": 154,
        "comment": ""
      },
      {
        "name": "binn_object_null",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3084,
        "end_line": 3088,
        "start_byte": 74716,
        "end_byte": 74845,
        "signature": "BOOL APIENTRY binn_object_null(const void *obj, const char *key)",
        "full_definition": "BOOL APIENTRY binn_object_null(const void *obj, const char *key) {\n\n  return binn_object_get(obj, key, BINN_NULL, NULL, NULL);\n\n}",
        "definition_length": 129,
        "comment": ""
      },
      {
        "name": "binn_object_str",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3090,
        "end_line": 3096,
        "start_byte": 74847,
        "end_byte": 75005,
        "signature": "char * APIENTRY binn_object_str(const void *obj, const char *key)",
        "full_definition": "char * APIENTRY binn_object_str(const void *obj, const char *key) {\n  char *value;\n\n  binn_object_get(obj, key, BINN_STRING, &value, NULL);\n\n  return value;\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "binn_object_blob",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 3098,
        "end_line": 3104,
        "start_byte": 75007,
        "end_byte": 75177,
        "signature": "void * APIENTRY binn_object_blob(const void *obj, const char *key, int *psize)",
        "full_definition": "void * APIENTRY binn_object_blob(const void *obj, const char *key, int *psize) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_BLOB, &value, psize);\n\n  return value;\n}",
        "definition_length": 170,
        "comment": ""
      },
      {
        "name": "binn_object_list",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3106,
        "end_line": 3112,
        "start_byte": 75179,
        "end_byte": 75336,
        "signature": "void * APIENTRY binn_object_list(const void *obj, const char *key)",
        "full_definition": "void * APIENTRY binn_object_list(const void *obj, const char *key) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_LIST, &value, NULL);\n\n  return value;\n}",
        "definition_length": 157,
        "comment": ""
      },
      {
        "name": "binn_object_map",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3114,
        "end_line": 3120,
        "start_byte": 75338,
        "end_byte": 75493,
        "signature": "void * APIENTRY binn_object_map(const void *obj, const char *key)",
        "full_definition": "void * APIENTRY binn_object_map(const void *obj, const char *key) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_MAP, &value, NULL);\n\n  return value;\n}",
        "definition_length": 155,
        "comment": ""
      },
      {
        "name": "binn_object_object",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 3122,
        "end_line": 3128,
        "start_byte": 75495,
        "end_byte": 75656,
        "signature": "void * APIENTRY binn_object_object(const void *obj, const char *key)",
        "full_definition": "void * APIENTRY binn_object_object(const void *obj, const char *key) {\n  void *value;\n\n  binn_object_get(obj, key, BINN_OBJECT, &value, NULL);\n\n  return value;\n}",
        "definition_length": 161,
        "comment": ""
      },
      {
        "name": "binn_alloc_item",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [],
        "is_static": false,
        "start_line": 3133,
        "end_line": 3143,
        "start_byte": 75835,
        "end_byte": 76111,
        "signature": "BINN_PRIVATE binn * binn_alloc_item()",
        "full_definition": "BINN_PRIVATE binn * binn_alloc_item() {\n  binn *item;\n  item = (binn *) binn_malloc(sizeof(binn));\n  if (item) {\n    memset(item, 0, sizeof(binn));\n    item->header = BINN_MAGIC;\n    item->allocated = TRUE;\n    //item->writable = FALSE;  -- already zeroed\n  }\n  return item;\n}",
        "definition_length": 276,
        "comment": "*********************************************************************************** ***********************************************************************************"
      },
      {
        "name": "binn_set_string",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *item",
          "char *str",
          "binn_mem_free pfree"
        ],
        "is_static": false,
        "start_line": 3184,
        "end_line": 3200,
        "start_byte": 77250,
        "end_byte": 77638,
        "signature": "BOOL APIENTRY binn_set_string(binn *item, char *str, binn_mem_free pfree)",
        "full_definition": "BOOL APIENTRY binn_set_string(binn *item, char *str, binn_mem_free pfree) {\n\n  if (item == NULL || str == NULL) return FALSE;\n\n  if (pfree == BINN_TRANSIENT) {\n    item->ptr = binn_memdup(str, strlen(str) + 1);\n    if (item->ptr == NULL) return FALSE;\n    item->freefn = free_fn;\n  } else {\n    item->ptr = str;\n    item->freefn = pfree;\n  }\n\n  item->type = BINN_STRING;\n  return TRUE;\n\n}",
        "definition_length": 388,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_set_blob",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *item",
          "void *ptr",
          "int size",
          "binn_mem_free pfree"
        ],
        "is_static": false,
        "start_line": 3204,
        "end_line": 3221,
        "start_byte": 77729,
        "end_byte": 78133,
        "signature": "BOOL APIENTRY binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree)",
        "full_definition": "BOOL APIENTRY binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree) {\n\n  if (item == NULL || ptr == NULL) return FALSE;\n\n  if (pfree == BINN_TRANSIENT) {\n    item->ptr = binn_memdup(ptr, size);\n    if (item->ptr == NULL) return FALSE;\n    item->freefn = free_fn;\n  } else {\n    item->ptr = ptr;\n    item->freefn = pfree;\n  }\n\n  item->type = BINN_BLOB;\n  item->size = size;\n  return TRUE;\n\n}",
        "definition_length": 404,
        "comment": "***********************************************************************************"
      },
      {
        "name": "atoi64",
        "type": "definition",
        "return_type": "int64",
        "parameters": [
          "char *str"
        ],
        "is_static": false,
        "start_line": 3230,
        "end_line": 3244,
        "start_byte": 78445,
        "end_byte": 78700,
        "signature": "int64 atoi64(char *str)",
        "full_definition": "int64 atoi64(char *str) {\n  int64 retval;\n  int is_negative=0;\n\n  if (*str == '-') {\n    is_negative = 1;\n    str++;\n  }\n  retval = 0;\n  for (; *str; str++) {\n    retval = 10 * retval + (*str - '0');\n  }\n  if (is_negative) retval *= -1;\n  return retval;\n}",
        "definition_length": 255,
        "comment": ""
      },
      {
        "name": "is_integer",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "char *p"
        ],
        "is_static": false,
        "start_line": 3249,
        "end_line": 3265,
        "start_byte": 78790,
        "end_byte": 79054,
        "signature": "BINN_PRIVATE BOOL is_integer(char *p)",
        "full_definition": "BINN_PRIVATE BOOL is_integer(char *p) {\n  BOOL retval;\n\n  if (p == NULL) return FALSE;\n  if (*p == '-') p++;\n  if (*p == 0) return FALSE;\n\n  retval = TRUE;\n\n  for (; *p; p++) {\n    if ( (*p < '0' || *p > '9') ) {\n      retval = FALSE;\n    }\n  }\n\n  return retval;\n}",
        "definition_length": 264,
        "comment": "***************************************************************************"
      },
      {
        "name": "is_float",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "char *p"
        ],
        "is_static": false,
        "start_line": 3269,
        "end_line": 3289,
        "start_byte": 79137,
        "end_byte": 79539,
        "signature": "BINN_PRIVATE BOOL is_float(char *p)",
        "full_definition": "BINN_PRIVATE BOOL is_float(char *p) {\n  BOOL retval, number_found=FALSE;\n\n  if (p == NULL) return FALSE;\n  if (*p == '-') p++;\n  if (*p == 0) return FALSE;\n\n  retval = TRUE;\n\n  for (; *p; p++) {\n    if (*p == '.' || *p == ',') {\n      if (!number_found) retval = FALSE;\n    } else if ( *p >= '0' && *p <= '9' ) {\n      number_found = TRUE;\n    } else {\n      return FALSE;\n    }\n  }\n\n  return retval;\n}",
        "definition_length": 402,
        "comment": "***************************************************************************"
      },
      {
        "name": "is_bool_str",
        "type": "definition",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "char *str",
          "BOOL *pbool"
        ],
        "is_static": false,
        "start_line": 3293,
        "end_line": 3329,
        "start_byte": 79630,
        "end_byte": 80488,
        "signature": "BINN_PRIVATE BOOL is_bool_str(char *str, BOOL *pbool)",
        "full_definition": "BINN_PRIVATE BOOL is_bool_str(char *str, BOOL *pbool) {\n  int64  vint;\n  double vdouble;\n\n  if (str == NULL || pbool == NULL) return FALSE;\n\n  if (stricmp(str, \"true\") == 0) goto loc_true;\n  if (stricmp(str, \"yes\") == 0) goto loc_true;\n  if (stricmp(str, \"on\") == 0) goto loc_true;\n  //if (stricmp(str, \"1\") == 0) goto loc_true;\n\n  if (stricmp(str, \"false\") == 0) goto loc_false;\n  if (stricmp(str, \"no\") == 0) goto loc_false;\n  if (stricmp(str, \"off\") == 0) goto loc_false;\n  //if (stricmp(str, \"0\") == 0) goto loc_false;\n\n  if (is_integer(str)) {\n    vint = atoi64(str);\n    *pbool = (vint != 0) ? TRUE : FALSE;\n    return TRUE;\n  } else if (is_float(str)) {\n    vdouble = atof(str);\n    *pbool = (vdouble != 0) ? TRUE : FALSE;\n    return TRUE;\n  }\n\n  return FALSE;\n\nloc_true:\n  *pbool = TRUE;\n  return TRUE;\n\nloc_false:\n  *pbool = FALSE;\n  return TRUE;\n\n}",
        "definition_length": 858,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_get_int32",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "int *pint"
        ],
        "is_static": false,
        "start_line": 3333,
        "end_line": 3366,
        "start_byte": 80579,
        "end_byte": 81498,
        "signature": "BOOL APIENTRY binn_get_int32(binn *value, int *pint)",
        "full_definition": "BOOL APIENTRY binn_get_int32(binn *value, int *pint) {\n\n  if (value == NULL || pint == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    return copy_int_value(value->ptr, pint, value->type, BINN_INT32);\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    if (value->vfloat < (float)INT32_MIN || value->vfloat > (float)INT32_MAX) return FALSE;\n    *pint = roundval(value->vfloat);\n    break;\n  case BINN_DOUBLE:\n    if (value->vdouble < (double)INT32_MIN || value->vdouble > (double)INT32_MAX) return FALSE;\n    *pint = roundval(value->vdouble);\n    break;\n  case BINN_STRING:\n    if (is_integer((char*)value->ptr))\n      *pint = atoi((char*)value->ptr);\n    else if (is_float((char*)value->ptr))\n      *pint = roundval(atof((char*)value->ptr));\n    else\n      return FALSE;\n    break;\n  case BINN_BOOL:\n    *pint = value->vbool;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}",
        "definition_length": 919,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_get_int64",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "int64 *pint"
        ],
        "is_static": false,
        "start_line": 3370,
        "end_line": 3403,
        "start_byte": 81589,
        "end_byte": 82512,
        "signature": "BOOL APIENTRY binn_get_int64(binn *value, int64 *pint)",
        "full_definition": "BOOL APIENTRY binn_get_int64(binn *value, int64 *pint) {\n\n  if (value == NULL || pint == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    return copy_int_value(value->ptr, pint, value->type, BINN_INT64);\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    if (value->vfloat < (float)INT64_MIN || value->vfloat > (float)INT64_MAX) return FALSE;\n    *pint = roundval(value->vfloat);\n    break;\n  case BINN_DOUBLE:\n    if (value->vdouble < (double)INT64_MIN || value->vdouble > (double)INT64_MAX) return FALSE;\n    *pint = roundval(value->vdouble);\n    break;\n  case BINN_STRING:\n    if (is_integer((char*)value->ptr))\n      *pint = atoi64((char*)value->ptr);\n    else if (is_float((char*)value->ptr))\n      *pint = roundval(atof((char*)value->ptr));\n    else\n      return FALSE;\n    break;\n  case BINN_BOOL:\n    *pint = value->vbool;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}",
        "definition_length": 923,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_get_double",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "double *pfloat"
        ],
        "is_static": false,
        "start_line": 3407,
        "end_line": 3441,
        "start_byte": 82603,
        "end_byte": 83414,
        "signature": "BOOL APIENTRY binn_get_double(binn *value, double *pfloat)",
        "full_definition": "BOOL APIENTRY binn_get_double(binn *value, double *pfloat) {\n  int64 vint;\n\n  if (value == NULL || pfloat == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    if (copy_int_value(value->ptr, &vint, value->type, BINN_INT64) == FALSE) return FALSE;\n    *pfloat = (double) vint;\n    return TRUE;\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    *pfloat = value->vfloat;\n    break;\n  case BINN_DOUBLE:\n    *pfloat = value->vdouble;\n    break;\n  case BINN_STRING:\n    if (is_integer((char*)value->ptr))\n      *pfloat = (double) atoi64((char*)value->ptr);\n    else if (is_float((char*)value->ptr))\n      *pfloat = atof((char*)value->ptr);\n    else\n      return FALSE;\n    break;\n  case BINN_BOOL:\n    *pfloat = value->vbool;\n    break;\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}",
        "definition_length": 811,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_get_bool",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "BOOL *pbool"
        ],
        "is_static": false,
        "start_line": 3445,
        "end_line": 3473,
        "start_byte": 83505,
        "end_byte": 84199,
        "signature": "BOOL APIENTRY binn_get_bool(binn *value, BOOL *pbool)",
        "full_definition": "BOOL APIENTRY binn_get_bool(binn *value, BOOL *pbool) {\n  int64 vint;\n\n  if (value == NULL || pbool == NULL) return FALSE;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    if (copy_int_value(value->ptr, &vint, value->type, BINN_INT64) == FALSE) return FALSE;\n    *pbool = (vint != 0) ? TRUE : FALSE;\n    return TRUE;\n  }\n\n  switch (value->type) {\n  case BINN_BOOL:\n    *pbool = value->vbool;\n    break;\n  case BINN_FLOAT:\n    *pbool = (value->vfloat != 0) ? TRUE : FALSE;\n    break;\n  case BINN_DOUBLE:\n    *pbool = (value->vdouble != 0) ? TRUE : FALSE;\n    break;\n  case BINN_STRING:\n    return is_bool_str((char*)value->ptr, pbool);\n  default:\n    return FALSE;\n  }\n\n  return TRUE;\n}",
        "definition_length": 694,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_get_str",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "binn *value"
        ],
        "is_static": false,
        "start_line": 3477,
        "end_line": 3516,
        "start_byte": 84290,
        "end_byte": 85211,
        "signature": "char * APIENTRY binn_get_str(binn *value)",
        "full_definition": "char * APIENTRY binn_get_str(binn *value) {\n  int64 vint;\n  char buf[128];\n\n  if (value == NULL) return NULL;\n\n  if (type_family(value->type) == BINN_FAMILY_INT) {\n    if (copy_int_value(value->ptr, &vint, value->type, BINN_INT64) == FALSE) return NULL;\n    snprintf(buf, sizeof buf, \"%\" INT64_FORMAT, vint);\n    goto loc_convert_value;\n  }\n\n  switch (value->type) {\n  case BINN_FLOAT:\n    value->vdouble = value->vfloat;\n  case BINN_DOUBLE:\n    snprintf(buf, sizeof buf, \"%g\", value->vdouble);\n    goto loc_convert_value;\n  case BINN_STRING:\n    return (char*) value->ptr;\n  case BINN_BOOL:\n    if (value->vbool)\n      strcpy(buf, \"true\");\n    else\n      strcpy(buf, \"false\");\n    goto loc_convert_value;\n  }\n\n  return NULL;\n\nloc_convert_value:\n\n  //value->vint64 = 0;\n  value->ptr = strdup(buf);\n  if (value->ptr == NULL) return NULL;\n  value->freefn = free;\n  value->type = BINN_STRING;\n  return (char*) value->ptr;\n\n}",
        "definition_length": 921,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_is_container",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "binn *item"
        ],
        "is_static": false,
        "start_line": 3522,
        "end_line": 3535,
        "start_byte": 85478,
        "end_byte": 85691,
        "signature": "BOOL APIENTRY binn_is_container(binn *item)",
        "full_definition": "BOOL APIENTRY binn_is_container(binn *item) {\n\n  if (item == NULL) return FALSE;\n\n  switch (item->type) {\n  case BINN_LIST:\n  case BINN_MAP:\n  case BINN_OBJECT:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n\n}",
        "definition_length": 213,
        "comment": "** GENERAL FUNCTIONS ************************************************************** ***********************************************************************************"
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 19
      },
      {
        "text": "#include <stdlib.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 19,
        "end_byte": 39
      },
      {
        "text": "#include <stdint.h>",
        "line": 3,
        "start_line": 3,
        "end_line": 4,
        "start_byte": 39,
        "end_byte": 59
      },
      {
        "text": "#include <string.h>",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 59,
        "end_byte": 79
      },
      {
        "text": "#include <memory.h>",
        "line": 5,
        "start_line": 5,
        "end_line": 6,
        "start_byte": 79,
        "end_byte": 99
      },
      {
        "text": "#include \"binn.h\"",
        "line": 6,
        "start_line": 6,
        "end_line": 7,
        "start_byte": 99,
        "end_byte": 117
      },
      {
        "text": "#include <endian.h>",
        "line": 41,
        "start_line": 41,
        "end_line": 42,
        "start_byte": 1458,
        "end_byte": 1478
      },
      {
        "text": "#include <endian.h>",
        "line": 43,
        "start_line": 43,
        "end_line": 44,
        "start_byte": 1498,
        "end_byte": 1518
      },
      {
        "text": "#include <endian.h>",
        "line": 45,
        "start_line": 45,
        "end_line": 46,
        "start_byte": 1524,
        "end_byte": 1544
      }
    ],
    "variables": [
      {
        "text": "void* (*malloc_fn)(size_t len) = 0;",
        "line": 22,
        "start_line": 22,
        "end_line": 22,
        "start_byte": 714,
        "end_byte": 749,
        "comment": ""
      },
      {
        "text": "void* (*realloc_fn)(void *ptr, size_t len) = 0;",
        "line": 23,
        "start_line": 23,
        "end_line": 23,
        "start_byte": 750,
        "end_byte": 797,
        "comment": ""
      },
      {
        "text": "void  (*free_fn)(void *ptr) = 0;",
        "line": 24,
        "start_line": 24,
        "end_line": 24,
        "start_byte": 798,
        "end_byte": 830,
        "comment": ""
      }
    ],
    "typedefs": [
      {
        "text": "typedef unsigned short int     u16;",
        "name": "u16",
        "line": 64,
        "start_line": 64,
        "end_line": 64,
        "start_byte": 1906,
        "end_byte": 1941,
        "comment": ""
      },
      {
        "text": "typedef unsigned int           u32;",
        "name": "u32",
        "line": 65,
        "start_line": 65,
        "end_line": 65,
        "start_byte": 1942,
        "end_byte": 1977,
        "comment": ""
      },
      {
        "text": "typedef unsigned long long int u64;",
        "name": "u64",
        "line": 66,
        "start_line": 66,
        "end_line": 66,
        "start_byte": 1978,
        "end_byte": 2013,
        "comment": ""
      }
    ],
    "macros": [
      {
        "text": "#define UNUSED(x) (void)(x)",
        "name": "UNUSED",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 118,
        "end_byte": 146,
        "comment": ""
      },
      {
        "text": "#define roundval(dbl) dbl >= 0.0 ? (int)(dbl + 0.5) : ((dbl - (double)(int)dbl) <= -0.5 ? (int)dbl : (int)(dbl - 0.5))",
        "name": "roundval",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 146,
        "end_byte": 265,
        "comment": ""
      },
      {
        "text": "#define BINN_MAGIC            0x1F22B11F",
        "name": "BINN_MAGIC",
        "line": 13,
        "start_line": 13,
        "end_line": 14,
        "start_byte": 445,
        "end_byte": 486,
        "comment": "magic number:  0x1F 0xb1 0x22 0x1F  =>  0x1FB1221F or 0x1F22B11F because the BINN_STORAGE_NOBYTES (binary 000) may not have so many sub-types (BINN_STORAGE_HAS_MORE = 0x10)"
      },
      {
        "text": "#define MAX_BINN_HEADER       9  // [1:type][4:size][4:count]",
        "name": "MAX_BINN_HEADER",
        "line": 15,
        "start_line": 15,
        "end_line": 16,
        "start_byte": 487,
        "end_byte": 549,
        "comment": "because the BINN_STORAGE_NOBYTES (binary 000) may not have so many sub-types (BINN_STORAGE_HAS_MORE = 0x10)"
      },
      {
        "text": "#define MIN_BINN_SIZE         3  // [1:type][1:size][1:count]",
        "name": "MIN_BINN_SIZE",
        "line": 16,
        "start_line": 16,
        "end_line": 17,
        "start_byte": 549,
        "end_byte": 611,
        "comment": ""
      },
      {
        "text": "#define CHUNK_SIZE            256  // 1024",
        "name": "CHUNK_SIZE",
        "line": 17,
        "start_line": 17,
        "end_line": 18,
        "start_byte": 611,
        "end_byte": 654,
        "comment": ""
      },
      {
        "text": "#define BINN_STRUCT        1",
        "name": "BINN_STRUCT",
        "line": 19,
        "start_line": 19,
        "end_line": 20,
        "start_byte": 655,
        "end_byte": 684,
        "comment": ""
      },
      {
        "text": "#define BINN_BUFFER        2",
        "name": "BINN_BUFFER",
        "line": 20,
        "start_line": 20,
        "end_line": 21,
        "start_byte": 684,
        "end_byte": 713,
        "comment": ""
      },
      {
        "text": "#define BINN_ONLY_ALIGNED_ACCESS",
        "name": "BINN_ONLY_ALIGNED_ACCESS",
        "line": 29,
        "start_line": 29,
        "end_line": 30,
        "start_byte": 1022,
        "end_byte": 1055,
        "comment": "*************************************************************************"
      },
      {
        "text": "#define BINN_ONLY_ALIGNED_ACCESS",
        "name": "BINN_ONLY_ALIGNED_ACCESS",
        "line": 31,
        "start_line": 31,
        "end_line": 32,
        "start_byte": 1143,
        "end_byte": 1176,
        "comment": ""
      },
      {
        "text": "#define BIG_ENDIAN      0x1000",
        "name": "BIG_ENDIAN",
        "line": 35,
        "start_line": 35,
        "end_line": 36,
        "start_byte": 1204,
        "end_byte": 1235,
        "comment": ""
      },
      {
        "text": "#define LITTLE_ENDIAN   0x0001",
        "name": "LITTLE_ENDIAN",
        "line": 36,
        "start_line": 36,
        "end_line": 37,
        "start_byte": 1235,
        "end_byte": 1266,
        "comment": ""
      },
      {
        "text": "#define BYTE_ORDER      LITTLE_ENDIAN",
        "name": "BYTE_ORDER",
        "line": 37,
        "start_line": 37,
        "end_line": 38,
        "start_byte": 1266,
        "end_byte": 1304,
        "comment": ""
      },
      {
        "text": "#define stricmp strcasecmp",
        "name": "stricmp",
        "line": 145,
        "start_line": 145,
        "end_line": 146,
        "start_byte": 4151,
        "end_byte": 4178,
        "comment": "*************************************************************************"
      },
      {
        "text": "#define strnicmp strncasecmp",
        "name": "strnicmp",
        "line": 146,
        "start_line": 146,
        "end_line": 147,
        "start_byte": 4178,
        "end_byte": 4207,
        "comment": ""
      },
      {
        "text": "#define atoi64 _atoi64",
        "name": "atoi64",
        "line": 3228,
        "start_line": 3228,
        "end_line": 3229,
        "start_byte": 78416,
        "end_byte": 78439,
        "comment": "***********************************************************************************"
      }
    ],
    "enums": [],
    "total_nodes": 24414,
    "file_size": 85781
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/quadtree.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/quadtree.c",
    "parse_success": true,
    "functions": [
      {
        "name": "split_node_",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "quadtree_t *tree",
          "quadtree_node_t *node"
        ],
        "start_line": 5,
        "end_line": 6,
        "start_byte": 67,
        "end_byte": 131,
        "full_declaration": "static int\nsplit_node_(quadtree_t *tree, quadtree_node_t *node);",
        "declaration_length": 64,
        "comment": "private prototypes"
      },
      {
        "name": "insert_",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "quadtree_t* tree",
          "quadtree_node_t *root",
          "quadtree_point_t *point",
          "void *key"
        ],
        "start_line": 8,
        "end_line": 9,
        "start_byte": 133,
        "end_byte": 229,
        "full_declaration": "static int\ninsert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key);",
        "declaration_length": 96,
        "comment": ""
      },
      {
        "name": "node_contains_",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *outer",
          "quadtree_point_t *it"
        ],
        "start_line": 11,
        "end_line": 12,
        "start_byte": 231,
        "end_byte": 303,
        "full_declaration": "static int\nnode_contains_(quadtree_node_t *outer, quadtree_point_t *it);",
        "declaration_length": 72,
        "comment": ""
      },
      {
        "name": "get_quadrant_",
        "type": "declaration",
        "return_type": "quadtree_node_t",
        "parameters": [
          "quadtree_node_t *root",
          "quadtree_point_t *point"
        ],
        "start_line": 14,
        "end_line": 15,
        "start_byte": 305,
        "end_byte": 392,
        "full_declaration": "static quadtree_node_t *\nget_quadrant_(quadtree_node_t *root, quadtree_point_t *point);",
        "declaration_length": 87,
        "comment": ""
      },
      {
        "name": "node_contains_",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *outer",
          "quadtree_point_t *it"
        ],
        "is_static": true,
        "start_line": 18,
        "end_line": 25,
        "start_byte": 424,
        "end_byte": 687,
        "signature": "static int\nnode_contains_(quadtree_node_t *outer, quadtree_point_t *it)",
        "full_definition": "static int\nnode_contains_(quadtree_node_t *outer, quadtree_point_t *it) {\n  return outer->bounds != NULL\n      && outer->bounds->nw->x <= it->x\n      && outer->bounds->nw->y >= it->y\n      && outer->bounds->se->x >= it->x\n      && outer->bounds->se->y <= it->y;\n}",
        "definition_length": 263,
        "comment": "private implementations"
      },
      {
        "name": "elision_",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "void* key"
        ],
        "is_static": true,
        "start_line": 27,
        "end_line": 28,
        "start_byte": 689,
        "end_byte": 722,
        "signature": "static void\nelision_(void* key)",
        "full_definition": "static void\nelision_(void* key){}",
        "definition_length": 33,
        "comment": ""
      },
      {
        "name": "reset_node_",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_t *tree",
          "quadtree_node_t *node"
        ],
        "is_static": true,
        "start_line": 30,
        "end_line": 37,
        "start_byte": 724,
        "end_byte": 925,
        "signature": "static void\nreset_node_(quadtree_t *tree, quadtree_node_t *node)",
        "full_definition": "static void\nreset_node_(quadtree_t *tree, quadtree_node_t *node){\n  if(tree->key_free != NULL) {\n    quadtree_node_reset(node, tree->key_free);\n  } else {\n    quadtree_node_reset(node, elision_);\n  }\n}",
        "definition_length": 201,
        "comment": ""
      },
      {
        "name": "get_quadrant_",
        "type": "definition",
        "return_type": "quadtree_node_t",
        "parameters": [
          "quadtree_node_t *root",
          "quadtree_point_t *point"
        ],
        "is_static": true,
        "start_line": 39,
        "end_line": 46,
        "start_byte": 927,
        "end_byte": 1252,
        "signature": "static quadtree_node_t *\nget_quadrant_(quadtree_node_t *root, quadtree_point_t *point)",
        "full_definition": "static quadtree_node_t *\nget_quadrant_(quadtree_node_t *root, quadtree_point_t *point) {\n  if(node_contains_(root->nw, point)) return root->nw;\n  if(node_contains_(root->ne, point)) return root->ne;\n  if(node_contains_(root->sw, point)) return root->sw;\n  if(node_contains_(root->se, point)) return root->se;\n  return NULL;\n}",
        "definition_length": 325,
        "comment": ""
      },
      {
        "name": "split_node_",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "quadtree_t *tree",
          "quadtree_node_t *node"
        ],
        "is_static": true,
        "start_line": 49,
        "end_line": 80,
        "start_byte": 1255,
        "end_byte": 2224,
        "signature": "static int\nsplit_node_(quadtree_t *tree, quadtree_node_t *node)",
        "full_definition": "static int\nsplit_node_(quadtree_t *tree, quadtree_node_t *node){\n  quadtree_node_t *nw;\n  quadtree_node_t *ne;\n  quadtree_node_t *sw;\n  quadtree_node_t *se;\n  quadtree_point_t *old;\n  void *key;\n\n  double x  = node->bounds->nw->x;\n  double y  = node->bounds->nw->y;\n  double hw = node->bounds->width / 2;\n  double hh = node->bounds->height / 2;\n\n                                    //minx,   miny,       maxx,       maxy\n  if(!(nw = quadtree_node_with_bounds(x,      y - hh,     x + hw,     y))) return 0;\n  if(!(ne = quadtree_node_with_bounds(x + hw, y - hh,     x + hw * 2, y))) return 0;\n  if(!(sw = quadtree_node_with_bounds(x,      y - hh * 2, x + hw,     y - hh))) return 0;\n  if(!(se = quadtree_node_with_bounds(x + hw, y - hh * 2, x + hw * 2, y - hh))) return 0;\n\n  node->nw = nw;\n  node->ne = ne;\n  node->sw = sw;\n  node->se = se;\n\n  old = node->point;\n  key   = node->key;\n  node->point = NULL;\n  node->key   = NULL;\n\n  return insert_(tree, node, old, key);\n}",
        "definition_length": 969,
        "comment": ""
      },
      {
        "name": "find_",
        "type": "definition",
        "return_type": "quadtree_point_t",
        "parameters": [
          "quadtree_node_t* node",
          "double x",
          "double y"
        ],
        "is_static": true,
        "start_line": 83,
        "end_line": 99,
        "start_byte": 2227,
        "end_byte": 2624,
        "signature": "static quadtree_point_t*\nfind_(quadtree_node_t* node, double x, double y)",
        "full_definition": "static quadtree_point_t*\nfind_(quadtree_node_t* node, double x, double y) {\n  if(!node){\n    return NULL;\n  }\n  if(quadtree_node_isleaf(node)){\n    if(node->point->x == x && node->point->y == y)\n      return node->point;\n  } else if(quadtree_node_ispointer(node)){\n    quadtree_point_t test;\n    test.x = x;\n    test.y = y;\n    return find_(get_quadrant_(node, &test), x, y);\n  }\n\n  return NULL;\n}",
        "definition_length": 397,
        "comment": ""
      },
      {
        "name": "insert_",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "quadtree_t* tree",
          "quadtree_node_t *root",
          "quadtree_point_t *point",
          "void *key"
        ],
        "is_static": true,
        "start_line": 102,
        "end_line": 125,
        "start_byte": 2673,
        "end_byte": 3478,
        "signature": "static int\ninsert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key)",
        "full_definition": "static int\ninsert_(quadtree_t* tree, quadtree_node_t *root, quadtree_point_t *point, void *key) {\n  if(quadtree_node_isempty(root)){\n    root->point = point;\n    root->key   = key;\n    return 1; /* normal insertion flag */\n  } else if(quadtree_node_isleaf(root)){\n    if(root->point->x == point->x && root->point->y == point->y){\n      reset_node_(tree, root);\n      root->point = point;\n      root->key   = key;\n      return 2; /* replace insertion flag */\n    } else {\n      if(!split_node_(tree, root)){\n        return 0; /* failed insertion flag */\n      }\n      return insert_(tree, root, point, key);\n    }\n  } else if(quadtree_node_ispointer(root)){\n    quadtree_node_t* quadrant = get_quadrant_(root, point);\n    return quadrant == NULL ? 0 : insert_(tree, quadrant, point, key);\n  }\n  return 0;\n}",
        "definition_length": 805,
        "comment": "cribbed from the google closure library."
      },
      {
        "name": "quadtree_new",
        "type": "definition",
        "return_type": "quadtree_t",
        "parameters": [
          "double minx",
          "double miny",
          "double maxx",
          "double maxy"
        ],
        "is_static": false,
        "start_line": 129,
        "end_line": 140,
        "start_byte": 3494,
        "end_byte": 3812,
        "signature": "quadtree_t*\nquadtree_new(double minx, double miny, double maxx, double maxy)",
        "full_definition": "quadtree_t*\nquadtree_new(double minx, double miny, double maxx, double maxy) {\n  quadtree_t *tree;\n  if(!(tree = malloc(sizeof(*tree))))\n    return NULL;\n  tree->root = quadtree_node_with_bounds(minx, miny, maxx, maxy);\n  if(!(tree->root))\n    return NULL;\n  tree->key_free = NULL;\n  tree->length = 0;\n  return tree;\n}",
        "definition_length": 318,
        "comment": "public"
      },
      {
        "name": "quadtree_insert",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "quadtree_t *tree",
          "double x",
          "double y",
          "void *key"
        ],
        "is_static": false,
        "start_line": 142,
        "end_line": 159,
        "start_byte": 3814,
        "end_byte": 4262,
        "signature": "int\nquadtree_insert(quadtree_t *tree, double x, double y, void *key)",
        "full_definition": "int\nquadtree_insert(quadtree_t *tree, double x, double y, void *key) {\n  quadtree_point_t *point;\n  int insert_status;\n\n  if(!(point = quadtree_point_new(x, y))) return 0;\n  if(!node_contains_(tree->root, point)){\n    quadtree_point_free(point);\n    return 0;\n  }\n  \n  if(!(insert_status = insert_(tree, tree->root, point, key))){\n    quadtree_point_free(point);\n    return 0;\n  }\n  if (insert_status == 1) tree->length++;\n  return insert_status;\n}",
        "definition_length": 448,
        "comment": ""
      },
      {
        "name": "quadtree_search",
        "type": "definition",
        "return_type": "quadtree_point_t",
        "parameters": [
          "quadtree_t *tree",
          "double x",
          "double y"
        ],
        "is_static": false,
        "start_line": 161,
        "end_line": 164,
        "start_byte": 4264,
        "end_byte": 4373,
        "signature": "quadtree_point_t*\nquadtree_search(quadtree_t *tree, double x, double y)",
        "full_definition": "quadtree_point_t*\nquadtree_search(quadtree_t *tree, double x, double y) {\n  return find_(tree->root, x, y);\n}",
        "definition_length": 109,
        "comment": ""
      },
      {
        "name": "quadtree_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_t *tree"
        ],
        "is_static": false,
        "start_line": 166,
        "end_line": 174,
        "start_byte": 4375,
        "end_byte": 4573,
        "signature": "void\nquadtree_free(quadtree_t *tree)",
        "full_definition": "void\nquadtree_free(quadtree_t *tree) {\n  if(tree->key_free != NULL) {\n    quadtree_node_free(tree->root, tree->key_free);\n  } else {\n    quadtree_node_free(tree->root, elision_);\n  }\n  free(tree);\n}",
        "definition_length": 198,
        "comment": ""
      },
      {
        "name": "quadtree_walk",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_node_t *root",
          "void (*descent)(quadtree_node_t *node)",
          "void (*ascent)(quadtree_node_t *node)"
        ],
        "is_static": false,
        "start_line": 176,
        "end_line": 185,
        "start_byte": 4575,
        "end_byte": 5035,
        "signature": "void\nquadtree_walk(quadtree_node_t *root, void (*descent)(quadtree_node_t *node),\n                                     void (*ascent)(quadtree_node_t *node))",
        "full_definition": "void\nquadtree_walk(quadtree_node_t *root, void (*descent)(quadtree_node_t *node),\n                                     void (*ascent)(quadtree_node_t *node)) {\n  (*descent)(root);\n  if(root->nw != NULL) quadtree_walk(root->nw, descent, ascent);\n  if(root->ne != NULL) quadtree_walk(root->ne, descent, ascent);\n  if(root->sw != NULL) quadtree_walk(root->sw, descent, ascent);\n  if(root->se != NULL) quadtree_walk(root->se, descent, ascent);\n  (*ascent)(root);\n}",
        "definition_length": 460,
        "comment": ""
      },
      {
        "name": "quadtree_bounds_extend",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_bounds_t *bounds",
          "double x",
          "double y"
        ],
        "is_static": false,
        "start_line": 201,
        "end_line": 209,
        "start_byte": 5277,
        "end_byte": 5634,
        "signature": "void\nquadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y)",
        "full_definition": "void\nquadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y){\n  bounds->nw->x = fmin(x, bounds->nw->x);\n  bounds->nw->y = fmax(y, bounds->nw->y);\n  bounds->se->x = fmax(x, bounds->se->x);\n  bounds->se->y = fmin(y, bounds->se->y);\n  bounds->width  = fabs(bounds->nw->x - bounds->se->x);\n  bounds->height = fabs(bounds->nw->y - bounds->se->y);\n}",
        "definition_length": 357,
        "comment": ""
      },
      {
        "name": "quadtree_bounds_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_bounds_t *bounds"
        ],
        "is_static": false,
        "start_line": 211,
        "end_line": 216,
        "start_byte": 5636,
        "end_byte": 5777,
        "signature": "void\nquadtree_bounds_free(quadtree_bounds_t *bounds)",
        "full_definition": "void\nquadtree_bounds_free(quadtree_bounds_t *bounds){\n  quadtree_point_free(bounds->nw);\n  quadtree_point_free(bounds->se);\n  free(bounds);\n}",
        "definition_length": 141,
        "comment": ""
      },
      {
        "name": "quadtree_bounds_new",
        "type": "definition",
        "return_type": "quadtree_bounds_t",
        "parameters": [
          "void"
        ],
        "is_static": false,
        "start_line": 219,
        "end_line": 229,
        "start_byte": 5780,
        "end_byte": 6103,
        "signature": "quadtree_bounds_t*\nquadtree_bounds_new(void)",
        "full_definition": "quadtree_bounds_t*\nquadtree_bounds_new(void){\n  quadtree_bounds_t *bounds;\n  if((bounds = malloc(sizeof(*bounds))) == NULL)\n    return NULL;\n  bounds->nw     = quadtree_point_new(INFINITY, -INFINITY);\n  bounds->se     = quadtree_point_new(-INFINITY, INFINITY);\n  bounds->width  = 0;\n  bounds->height = 0;\n  return bounds;\n}",
        "definition_length": 323,
        "comment": ""
      },
      {
        "name": "quadtree_node_ispointer",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *node"
        ],
        "is_static": false,
        "start_line": 235,
        "end_line": 242,
        "start_byte": 6122,
        "end_byte": 6317,
        "signature": "int\nquadtree_node_ispointer(quadtree_node_t *node)",
        "full_definition": "int\nquadtree_node_ispointer(quadtree_node_t *node){\n  return node->nw != NULL\n      && node->ne != NULL\n      && node->sw != NULL\n      && node->se != NULL\n      && !quadtree_node_isleaf(node);\n}",
        "definition_length": 195,
        "comment": "helpers"
      },
      {
        "name": "quadtree_node_isempty",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *node"
        ],
        "is_static": false,
        "start_line": 244,
        "end_line": 251,
        "start_byte": 6319,
        "end_byte": 6512,
        "signature": "int\nquadtree_node_isempty(quadtree_node_t *node)",
        "full_definition": "int\nquadtree_node_isempty(quadtree_node_t *node){\n  return node->nw == NULL\n      && node->ne == NULL\n      && node->sw == NULL\n      && node->se == NULL\n      && !quadtree_node_isleaf(node);\n}",
        "definition_length": 193,
        "comment": ""
      },
      {
        "name": "quadtree_node_isleaf",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *node"
        ],
        "is_static": false,
        "start_line": 253,
        "end_line": 256,
        "start_byte": 6514,
        "end_byte": 6594,
        "signature": "int\nquadtree_node_isleaf(quadtree_node_t *node)",
        "full_definition": "int\nquadtree_node_isleaf(quadtree_node_t *node){\n  return node->point != NULL;\n}",
        "definition_length": 80,
        "comment": ""
      },
      {
        "name": "quadtree_node_reset",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_node_t* node",
          "void (*key_free)(void*)"
        ],
        "is_static": false,
        "start_line": 258,
        "end_line": 262,
        "start_byte": 6596,
        "end_byte": 6734,
        "signature": "void\nquadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*))",
        "full_definition": "void\nquadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*)) {\n  quadtree_point_free(node->point);\n  (*key_free)(node->key);\n}",
        "definition_length": 138,
        "comment": ""
      },
      {
        "name": "quadtree_node_new",
        "type": "definition",
        "return_type": "quadtree_node_t",
        "parameters": [
          "void"
        ],
        "is_static": false,
        "start_line": 265,
        "end_line": 278,
        "start_byte": 6746,
        "end_byte": 7046,
        "signature": "quadtree_node_t*\nquadtree_node_new(void)",
        "full_definition": "quadtree_node_t*\nquadtree_node_new(void) {\n  quadtree_node_t *node;\n  if(!(node = malloc(sizeof(*node))))\n    return NULL;\n  node->ne     = NULL;\n  node->nw     = NULL;\n  node->se     = NULL;\n  node->sw     = NULL;\n  node->point  = NULL;\n  node->bounds = NULL;\n  node->key    = NULL;\n  return node;\n}",
        "definition_length": 300,
        "comment": "api"
      },
      {
        "name": "quadtree_node_with_bounds",
        "type": "definition",
        "return_type": "quadtree_node_t",
        "parameters": [
          "double minx",
          "double miny",
          "double maxx",
          "double maxy"
        ],
        "is_static": false,
        "start_line": 280,
        "end_line": 288,
        "start_byte": 7048,
        "end_byte": 7397,
        "signature": "quadtree_node_t*\nquadtree_node_with_bounds(double minx, double miny, double maxx, double maxy)",
        "full_definition": "quadtree_node_t*\nquadtree_node_with_bounds(double minx, double miny, double maxx, double maxy){\n  quadtree_node_t* node;\n  if(!(node = quadtree_node_new())) return NULL;\n  if(!(node->bounds = quadtree_bounds_new())) return NULL;\n  quadtree_bounds_extend(node->bounds, maxx, maxy);\n  quadtree_bounds_extend(node->bounds, minx, miny);\n  return node;\n}",
        "definition_length": 349,
        "comment": ""
      },
      {
        "name": "quadtree_node_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_node_t* node",
          "void (*key_free)(void*)"
        ],
        "is_static": false,
        "start_line": 290,
        "end_line": 300,
        "start_byte": 7399,
        "end_byte": 7818,
        "signature": "void\nquadtree_node_free(quadtree_node_t* node, void (*key_free)(void*))",
        "full_definition": "void\nquadtree_node_free(quadtree_node_t* node, void (*key_free)(void*)) {\n  if(node->nw != NULL) quadtree_node_free(node->nw, key_free);\n  if(node->ne != NULL) quadtree_node_free(node->ne, key_free);\n  if(node->sw != NULL) quadtree_node_free(node->sw, key_free);\n  if(node->se != NULL) quadtree_node_free(node->se, key_free);\n\n  quadtree_bounds_free(node->bounds);\n  quadtree_node_reset(node, key_free);\n  free(node);\n}",
        "definition_length": 419,
        "comment": ""
      },
      {
        "name": "quadtree_point_new",
        "type": "definition",
        "return_type": "quadtree_point_t",
        "parameters": [
          "double x",
          "double y"
        ],
        "is_static": false,
        "start_line": 303,
        "end_line": 311,
        "start_byte": 7821,
        "end_byte": 8013,
        "signature": "quadtree_point_t*\nquadtree_point_new(double x, double y)",
        "full_definition": "quadtree_point_t*\nquadtree_point_new(double x, double y) {\n  quadtree_point_t* point;\n  if(!(point = malloc(sizeof(*point))))\n    return NULL;\n  point->x = x;\n  point->y = y;\n  return point;\n}",
        "definition_length": 192,
        "comment": ""
      },
      {
        "name": "quadtree_point_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "quadtree_point_t *point"
        ],
        "is_static": false,
        "start_line": 313,
        "end_line": 316,
        "start_byte": 8015,
        "end_byte": 8082,
        "signature": "void\nquadtree_point_free(quadtree_point_t *point)",
        "full_definition": "void\nquadtree_point_free(quadtree_point_t *point){\n  free(point);\n}",
        "definition_length": 67,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include \"quadtree.h\"",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 22
      },
      {
        "text": "#include <stdio.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 22,
        "end_byte": 41
      },
      {
        "text": "#include <float.h>",
        "line": 192,
        "start_line": 192,
        "end_line": 193,
        "start_byte": 5121,
        "end_byte": 5140
      },
      {
        "text": "#include <math.h>",
        "line": 193,
        "start_line": 193,
        "end_line": 194,
        "start_byte": 5142,
        "end_byte": 5160
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [
      {
        "text": "#define INFINITY DBL_MAX",
        "name": "INFINITY",
        "line": 194,
        "start_line": 194,
        "end_line": 195,
        "start_byte": 5162,
        "end_byte": 5187,
        "comment": "no infinity defined? high chance we are compiling as c89"
      },
      {
        "text": "#define fmin(a,b) (((a)<(b))?(a):(b))",
        "name": "fmin",
        "line": 195,
        "start_line": 195,
        "end_line": 196,
        "start_byte": 5189,
        "end_byte": 5227,
        "comment": ""
      },
      {
        "text": "#define fmax(a,b) (((a)>(b))?(a):(b))",
        "name": "fmax",
        "line": 196,
        "start_line": 196,
        "end_line": 197,
        "start_byte": 5229,
        "end_byte": 5267,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 2905,
    "file_size": 8083
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/urlparser.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/urlparser.c",
    "parse_success": true,
    "functions": [
      {
        "name": "ParseURL",
        "type": "definition",
        "return_type": "bool",
        "parameters": [
          "char* URL",
          "URL_PARTS* pURL_Parts"
        ],
        "is_static": false,
        "start_line": 12,
        "end_line": 204,
        "start_byte": 221,
        "end_byte": 4414,
        "signature": "bool ParseURL(char* URL, URL_PARTS* pURL_Parts)",
        "full_definition": "bool ParseURL(char* URL, URL_PARTS* pURL_Parts)\n{\n    int i;\n    unsigned char c;\n    bool b = false;\n\n    // Clear the data\n    memset(pURL_Parts, 0, sizeof(URL_PARTS));\n\n    // Setup our parser pointer\n    char* string = URL;\n\n    // Check for the authority preceding double slash\n    char* authority = strstr(string, \"//\");\n    if (authority == NULL) {\n        authority = string;\n    }\n    else\n    {\n        // Parse the sheme\n        i = 0;\n        while (string < authority)\n        {\n            unsigned char c = *string;\n            if (c == ':') {\n                // End of scheme\n                break;\n            }\n            if (c == '/') {\n                // End of scheme\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_SCHEME_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->scheme[i] = c;\n            string++;\n            i++;\n        }\n\n        // Skip the slashes\n        authority += 2;\n    }\n\n    c = *authority;\n    if (c == '[') {\n        b = true;\n        authority++;\n    }\n\n    // Parse the authority\n    i = 0;\n    while ((c = *authority) != 0)\n    {\n        // Skip spaces\n        if (c == ' ') {\n            authority++;\n            continue;\n        }\n        // Check for path\n        if (c == '/') {\n            break;\n        }\n        // Check for port number\n        if (c == ':') {\n            // Check if bracket used (IPv6)\n            if (!b) {\n                break;\n            }\n        }\n        // Check for query\n        if (c == '?') {\n            break;\n        }\n        // Check for fragment\n        if (c == '#') {\n            break;\n        }\n        // Should we check for closing bracket?\n        if (b) {\n            if (c == ']') {\n                authority++;\n                break;\n            }\n        }\n        // Check for overflow\n        if (i == (MAX_URL_AUTHORITY_LEN - 1)) {\n            return false;\n        }\n        pURL_Parts->authority[i] = c;\n        authority++;\n        i++;\n    }\n\n    // Switch back to string variable\n    string = authority;\n\n    // Check for a port number\n    if (*string == ':')\n    {\n        string++;\n        // Parse the port number\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for path\n            if (c == '/') {\n                break;\n            }\n            // Check for query\n            if (c == '?') {\n                break;\n            }\n            // Check for fragment\n            if (c == '#') {\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_PORT_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->port[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    // Check for a path\n    if (*string == '/')\n    {\n        // Parse the path\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for query\n            if (c == '?') {\n                break;\n            }\n            // Check for fragment\n            if (c == '#') {\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_PATH_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->path[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    // Check for a query\n    if (*string == '?')\n    {\n        // Parse the query\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for fragment\n            if (c == '#') {\n                break;\n            }\n            // Check for overflow\n            if (i == (MAX_URL_QUERY_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->query[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    // Check for a fragment\n    if (*string == '#')\n    {\n        // Parse the fragment\n        i = 0;\n        while ((c = *string) != 0)\n        {\n            // Check for overflow\n            if (i == (MAX_URL_FRAGMENT_LEN - 1)) {\n                return false;\n            }\n            pURL_Parts->fragment[i] = c;\n            string++;\n            i++;\n        }\n    }\n\n    return true;\n}",
        "definition_length": 4193,
        "comment": ""
      },
      {
        "name": "PrintURL",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "struct URL_PARTS* pURL_Parts"
        ],
        "is_static": false,
        "start_line": 206,
        "end_line": 239,
        "start_byte": 4416,
        "end_byte": 5505,
        "signature": "void PrintURL(struct URL_PARTS* pURL_Parts)",
        "full_definition": "void PrintURL(struct URL_PARTS* pURL_Parts)\n{\n    // Safety check\n    if (pURL_Parts == NULL) {\n        fprintf(stderr, \"%s\\n\", \"PrintURL Error: Parameter 'pURL_Parts' is NULL\");\n        return;\n    }\n\n    // Print each individually\n    printf(\"Scheme: %s\\nAuthority: %s\\nPort: %s\\nPath: %s\\nQuery: %s\\nFragment: %s\\n\",\n        pURL_Parts->scheme, pURL_Parts->authority, pURL_Parts->port,\n        pURL_Parts->path, pURL_Parts->query, pURL_Parts->fragment);\n\n    // Print as a single URL\n    if (strlen(pURL_Parts->scheme) != 0) {\n        printf(\"%s://%s\", pURL_Parts->scheme, pURL_Parts->authority);\n    } else if (strlen(pURL_Parts->authority) != 0) {\n        printf(\"%s\", pURL_Parts->authority);\n    }\n    if (strlen(pURL_Parts->port) != 0) {\n        printf(\":%s\", pURL_Parts->port);\n    }\n    if (strlen(pURL_Parts->path) != 0) {\n        printf(\"%s\", pURL_Parts->path);\n    }\n    if (strlen(pURL_Parts->query) != 0) {\n        printf(\"%s\", pURL_Parts->query);\n    }\n    if (strlen(pURL_Parts->fragment) != 0) {\n        printf(\"%s\", pURL_Parts->fragment);\n    }\n\n    printf(\"%s\", \"\\n\");\n}",
        "definition_length": 1089,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include \"urlparser.h\"",
        "line": 10,
        "start_line": 10,
        "end_line": 11,
        "start_byte": 197,
        "end_byte": 220
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 1338,
    "file_size": 5507
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/bst.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/bst.c",
    "parse_success": true,
    "functions": [
      {
        "name": "bst_create",
        "type": "definition",
        "return_type": "",
        "parameters": [],
        "is_static": false,
        "start_line": 26,
        "end_line": 31,
        "start_byte": 386,
        "end_byte": 511,
        "signature": "struct bst* bst_create()",
        "full_definition": "struct bst* bst_create() {\n  struct bst* bst = malloc(sizeof(struct bst));\n  assert(bst);\n  bst->root = NULL;\n  return bst;\n}",
        "definition_length": 125,
        "comment": ""
      },
      {
        "name": "bst_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "struct bst* bst"
        ],
        "is_static": false,
        "start_line": 34,
        "end_line": 46,
        "start_byte": 514,
        "end_byte": 771,
        "signature": "void bst_free(struct bst* bst)",
        "full_definition": "void bst_free(struct bst* bst) {\n  assert(bst);\n\n  /*\n   * Assume that bst_remove() frees each node it removes and use it to free\n   * all of the nodes in the tree.\n   */\n  while (!bst_isempty(bst)) {\n    bst_remove(bst->root->val, bst);\n  }\n\n  free(bst);\n}",
        "definition_length": 257,
        "comment": ""
      },
      {
        "name": "bst_isempty",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "struct bst* bst"
        ],
        "is_static": false,
        "start_line": 49,
        "end_line": 52,
        "start_byte": 774,
        "end_byte": 853,
        "signature": "int bst_isempty(struct bst* bst)",
        "full_definition": "int bst_isempty(struct bst* bst) {\n  assert(bst);\n  return bst->root == NULL;\n}",
        "definition_length": 79,
        "comment": ""
      },
      {
        "name": "_bst_node_create",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "int val"
        ],
        "is_static": false,
        "start_line": 58,
        "end_line": 64,
        "start_byte": 938,
        "end_byte": 1110,
        "signature": "struct bst_node* _bst_node_create(int val)",
        "full_definition": "struct bst_node* _bst_node_create(int val) {\n  struct bst_node* n = malloc(sizeof(struct bst_node));\n  assert(n);\n  n->val = val;\n  n->left = n->right = NULL;\n  return n;\n}",
        "definition_length": 172,
        "comment": "* Helper function to generate a single BST node containing a given value."
      },
      {
        "name": "_bst_subtree_insert",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "int val",
          "struct bst_node* n"
        ],
        "is_static": false,
        "start_line": 76,
        "end_line": 113,
        "start_byte": 1493,
        "end_byte": 2501,
        "signature": "struct bst_node* _bst_subtree_insert(int val, struct bst_node* n)",
        "full_definition": "struct bst_node* _bst_subtree_insert(int val, struct bst_node* n) {\n\n  if (n == NULL) {\n\n    /*\n     * If n is NULL, we know we've reached a place to insert val, so we\n     * create a new node holding val and return it.\n     */\n    return _bst_node_create(val);\n\n  } else if (val < n->val) {\n\n    /*\n     * If val is less than the value at n, we insert val in n's left subtree\n     * (somewhere) and update n->left to point to the modified subtree (with\n     * val inserted).\n     */\n    n->left = _bst_subtree_insert(val, n->left);\n\n  } else {\n\n    /*\n     * If val is greater than or equal to the value at n, we insert val in n's\n     * right subtree (somewhere) and update n->right to point to the modified\n     * subtree (with val inserted).\n     */\n    n->right = _bst_subtree_insert(val, n->right);\n\n  }\n\n  /*\n   * For the else if and else conditions, the subtree rooted at n has already\n   * been modified (by setting n->left or n->right above), so we can just\n   * return n here.\n   */\n  return n;\n\n}",
        "definition_length": 1008,
        "comment": "* Helper function to insert a given value into a subtree of a BST rooted at\n * a given node.  Operates recursively by determining into which subtree (left\n * or right) under the given node the value should be inserted and performing\n * the insertion on that subtree.\n *\n * Returns the root of the given subtree, modified to contain a new node with\n * the specified value."
      },
      {
        "name": "bst_insert",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "int val",
          "struct bst* bst"
        ],
        "is_static": false,
        "start_line": 116,
        "end_line": 126,
        "start_byte": 2504,
        "end_byte": 2762,
        "signature": "void bst_insert(int val, struct bst* bst)",
        "full_definition": "void bst_insert(int val, struct bst* bst) {\n\n  assert(bst);\n\n  /*\n   * We insert val by using our subtree insertion function starting with the\n   * subtree rooted at bst->root (i.e. the whole tree).\n   */\n  bst->root = _bst_subtree_insert(val, bst->root);\n\n}",
        "definition_length": 258,
        "comment": ""
      },
      {
        "name": "_bst_subtree_min_val",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "struct bst_node* n"
        ],
        "is_static": false,
        "start_line": 132,
        "end_line": 141,
        "start_byte": 2842,
        "end_byte": 3074,
        "signature": "int _bst_subtree_min_val(struct bst_node* n)",
        "full_definition": "int _bst_subtree_min_val(struct bst_node* n) {\n  /*\n   * The minimum value in any subtree is just the leftmost value.  Keep going\n   * left till we get there.\n   */\n  while (n->left != NULL) {\n    n = n->left;\n  }\n  return n->val;\n}",
        "definition_length": 232,
        "comment": "* Helper function to return the minimum value in a subtree of a BST."
      },
      {
        "name": "_bst_subtree_remove",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "int val",
          "struct bst_node* n"
        ],
        "is_static": false,
        "start_line": 153,
        "end_line": 237,
        "start_byte": 3459,
        "end_byte": 5966,
        "signature": "struct bst_node* _bst_subtree_remove(int val, struct bst_node* n)",
        "full_definition": "struct bst_node* _bst_subtree_remove(int val, struct bst_node* n) {\n\n  if (n == NULL) {\n\n    /*\n     * If n is NULL, that means we've reached a leaf node without finding\n     * the value we wanted to remove.  The tree won't be modified.\n     */\n    return NULL;\n\n  } else if (val < n->val) {\n\n    /*\n     * If val is less than n, remove val from n's left subtree and update\n     * n->left to point to the modified subtree (with val removed).  Return n,\n     * whose subtree itself has now been modified.\n     */\n    n->left = _bst_subtree_remove(val, n->left);\n    return n;\n\n  } else if (val > n->val) {\n\n    /*\n     * If val is greater than n, remove val from n's right subtree and update\n     * n->right to point to the modified subtree (with val removed).  Return n,\n     * whose subtree itself has now been modified.\n     */\n    n->right = _bst_subtree_remove(val, n->right);\n    return n;\n\n  } else {\n\n    /*\n     * If we've reached this point, we've found a node with value val.  We\n     * need to remove this node from the tree, and the way we do that will\n     * differ based on whether the node has 0, 1, or 2 children.\n     */\n    if (n->left != NULL && n->right != NULL) {\n\n      /*\n       * If n has 2 children, we replace the value at n with the value at n's\n       * in-order successor node, which is the minimum value in n's right\n       * subtree.  Then we recursively remove n's in-order successor node from\n       * the tree (specifically from n's right subtree).\n       */\n      n->val = _bst_subtree_min_val(n->right);\n      n->right = _bst_subtree_remove(n->val, n->right);\n      return n;\n\n    } else if (n->left != NULL) {\n\n      /*\n       * If n has only a left child, we simply delete n by freeing it and\n       * returning the left child node so that it becomes the new child of\n       * n's parent via the recursion.\n       */\n      struct bst_node* left_child = n->left;\n      free(n);\n      return left_child;\n\n    } else if (n->right != NULL) {\n\n      /*\n       * If n has only a right child, we simply delete n by freeing it and\n       * returning the right child node so that it becomes the new child of\n       * n's parent via the recursion.\n       */\n      struct bst_node* right_child = n->right;\n      free(n);\n      return right_child;\n\n    } else {\n\n      /*\n       * Otherwise, n has no children, and we can simply free it and return\n       * NULL so that n's parent will lose n as a child via the recursion.\n       */\n      free(n);\n      return NULL;\n\n    }\n\n  }\n\n}",
        "definition_length": 2507,
        "comment": "* Helper function to remove a given value from a subtree of a BST rooted at\n * a specified node.  Operates recursively by figuring out whether val is in\n * the left or the right subtree of the specified node and performing the\n * remove operation on that subtree.\n *\n * Returns the potentially new root of the given subtree, modified to have\n * the specified value removed."
      },
      {
        "name": "bst_remove",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "int val",
          "struct bst* bst"
        ],
        "is_static": false,
        "start_line": 240,
        "end_line": 250,
        "start_byte": 5969,
        "end_byte": 6225,
        "signature": "void bst_remove(int val, struct bst* bst)",
        "full_definition": "void bst_remove(int val, struct bst* bst) {\n\n  assert(bst);\n\n  /*\n   * We remove val by using our subtree removal function starting with the\n   * subtree rooted at bst->root (i.e. the whole tree).\n   */\n  bst->root = _bst_subtree_remove(val, bst->root);\n\n}",
        "definition_length": 256,
        "comment": ""
      },
      {
        "name": "bst_contains",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "int val",
          "struct bst* bst"
        ],
        "is_static": false,
        "start_line": 253,
        "end_line": 291,
        "start_byte": 6228,
        "end_byte": 6970,
        "signature": "int bst_contains(int val, struct bst* bst)",
        "full_definition": "int bst_contains(int val, struct bst* bst) {\n\n  assert(bst);\n\n  // Iteratively search for val in bst.\n  struct bst_node* cur = bst->root;\n  while (cur != NULL) {\n\n    if (val == cur->val) {\n\n      // We found the value we're looking for in cur.\n      return 1;\n\n    } else if (val < cur->val) {\n\n      /*\n       * The value we're looking for is less than the value at cur, so we\n       * branch left.\n       */\n      cur = cur->left;\n\n    } else {\n\n      /*\n       * The value we're looking for is greater than or equal to the value at\n       * cur, so we branch right.\n       */\n       cur = cur->right;\n\n    }\n\n  }\n\n  /*\n   * If we make it to a leaf node (i.e. cur is NULL), we didn't find what we\n   * were looking for.\n   */\n  return 0;\n}",
        "definition_length": 742,
        "comment": ""
      }
    ],
    "structs": [
      {
        "name": "bst_node",
        "start_line": 10,
        "end_line": 14,
        "start_byte": 138,
        "end_byte": 219,
        "full_definition": "struct bst_node {\n  int val;\n  struct bst_node* left;\n  struct bst_node* right;\n}",
        "fields": [
          {
            "text": "int val;",
            "line": 11,
            "start_line": 11,
            "end_line": 11,
            "start_byte": 158,
            "end_byte": 166
          },
          {
            "text": "struct bst_node* left;",
            "line": 12,
            "start_line": 12,
            "end_line": 12,
            "start_byte": 169,
            "end_byte": 191
          },
          {
            "text": "struct bst_node* right;",
            "line": 13,
            "start_line": 13,
            "end_line": 13,
            "start_byte": 194,
            "end_byte": 217
          }
        ],
        "definition_length": 81,
        "comment": "* This structure represents a single node in a BST."
      },
      {
        "name": "bst",
        "start_line": 21,
        "end_line": 23,
        "start_byte": 343,
        "end_byte": 382,
        "full_definition": "struct bst {\n  struct bst_node* root;\n}",
        "fields": [
          {
            "text": "struct bst_node* root;",
            "line": 22,
            "start_line": 22,
            "end_line": 22,
            "start_byte": 358,
            "end_byte": 380
          }
        ],
        "definition_length": 39,
        "comment": "* This structure represents an entire BST.  Note that we only need a\n * reference to the root node of the tree."
      }
    ],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 19
      },
      {
        "text": "#include <stdlib.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 19,
        "end_byte": 39
      },
      {
        "text": "#include <assert.h>",
        "line": 3,
        "start_line": 3,
        "end_line": 4,
        "start_byte": 39,
        "end_byte": 59
      },
      {
        "text": "#include \"bst.h\"",
        "line": 5,
        "start_line": 5,
        "end_line": 6,
        "start_byte": 60,
        "end_byte": 77
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 1000,
    "file_size": 6971
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/lil.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/lil.c",
    "parse_success": true,
    "functions": [
      {
        "name": "next_word",
        "type": "declaration",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil"
        ],
        "start_line": 161,
        "end_line": 161,
        "start_byte": 3798,
        "end_byte": 3838,
        "full_declaration": "static lil_value_t next_word(lil_t lil);",
        "declaration_length": 40,
        "comment": ""
      },
      {
        "name": "register_stdcmds",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "lil_t lil"
        ],
        "start_line": 162,
        "end_line": 162,
        "start_byte": 3839,
        "end_byte": 3879,
        "full_declaration": "static void register_stdcmds(lil_t lil);",
        "declaration_length": 40,
        "comment": ""
      },
      {
        "name": "strclone",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "const char* s"
        ],
        "is_static": true,
        "start_line": 173,
        "end_line": 180,
        "start_byte": 4105,
        "end_byte": 4270,
        "signature": "static char* strclone(const char* s)",
        "full_definition": "static char* strclone(const char* s)\n{\n    size_t len = strlen(s) + 1;\n    char* ns = malloc(len);\n    if (!ns) return NULL;\n    memcpy(ns, s, len);\n    return ns;\n}",
        "definition_length": 165,
        "comment": ""
      },
      {
        "name": "hm_hash",
        "type": "definition",
        "return_type": "",
        "parameters": [
          "const char* key"
        ],
        "is_static": true,
        "start_line": 182,
        "end_line": 188,
        "start_byte": 4272,
        "end_byte": 4438,
        "signature": "static unsigned long hm_hash(const char* key)",
        "full_definition": "static unsigned long hm_hash(const char* key)\n{\n    unsigned long hash = 5381;\n    int c;\n    while ((c = *key++)) hash = ((hash << 5) + hash) + c;\n    return hash;\n}",
        "definition_length": 166,
        "comment": ""
      },
      {
        "name": "hm_init",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "hashmap_t* hm"
        ],
        "is_static": true,
        "start_line": 190,
        "end_line": 193,
        "start_byte": 4440,
        "end_byte": 4516,
        "signature": "static void hm_init(hashmap_t* hm)",
        "full_definition": "static void hm_init(hashmap_t* hm)\n{\n    memset(hm, 0, sizeof(hashmap_t));\n}",
        "definition_length": 76,
        "comment": ""
      },
      {
        "name": "hm_destroy",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "hashmap_t* hm"
        ],
        "is_static": true,
        "start_line": 195,
        "end_line": 203,
        "start_byte": 4518,
        "end_byte": 4727,
        "signature": "static void hm_destroy(hashmap_t* hm)",
        "full_definition": "static void hm_destroy(hashmap_t* hm)\n{\n    size_t i, j;\n    for (i=0; i<HASHMAP_CELLS; i++) {\n        for (j=0; j<hm->cell[i].c; j++)\n            free(hm->cell[i].e[j].k);\n        free(hm->cell[i].e);\n    }\n}",
        "definition_length": 209,
        "comment": ""
      },
      {
        "name": "hm_put",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "hashmap_t* hm",
          "const char* key",
          "void* value"
        ],
        "is_static": true,
        "start_line": 205,
        "end_line": 218,
        "start_byte": 4729,
        "end_byte": 5183,
        "signature": "static void hm_put(hashmap_t* hm, const char* key, void* value)",
        "full_definition": "static void hm_put(hashmap_t* hm, const char* key, void* value)\n{\n    struct hashcell_t* cell = hm->cell + (hm_hash(key) & HASHMAP_CELLMASK);\n    size_t i;\n    for (i=0; i<cell->c; i++)\n        if (!strcmp(key, cell->e[i].k)) {\n            cell->e[i].v = value;\n            return;\n        }\n    cell->e = realloc(cell->e, sizeof(struct hashentry_t)*(cell->c + 1));\n    cell->e[cell->c].k = strclone(key);\n    cell->e[cell->c].v = value;\n    cell->c++;\n}",
        "definition_length": 454,
        "comment": ""
      },
      {
        "name": "hm_get",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "hashmap_t* hm",
          "const char* key"
        ],
        "is_static": true,
        "start_line": 220,
        "end_line": 228,
        "start_byte": 5185,
        "end_byte": 5452,
        "signature": "static void* hm_get(hashmap_t* hm, const char* key)",
        "full_definition": "static void* hm_get(hashmap_t* hm, const char* key)\n{\n    struct hashcell_t* cell = hm->cell + (hm_hash(key) & HASHMAP_CELLMASK);\n    size_t i;\n    for (i = 0; i<cell->c; i++)\n        if (!strcmp(key, cell->e[i].k))\n            return cell->e[i].v;\n    return NULL;\n}",
        "definition_length": 267,
        "comment": ""
      },
      {
        "name": "hm_has",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "hashmap_t* hm",
          "const char* key"
        ],
        "is_static": true,
        "start_line": 230,
        "end_line": 238,
        "start_byte": 5454,
        "end_byte": 5707,
        "signature": "static int hm_has(hashmap_t* hm, const char* key)",
        "full_definition": "static int hm_has(hashmap_t* hm, const char* key)\n{\n    struct hashcell_t* cell = hm->cell + (hm_hash(key) & HASHMAP_CELLMASK);\n    size_t i;\n    for (i = 0; i < cell->c; i++)\n        if (!strcmp(key, cell->e[i].k))\n            return 1;\n    return 0;\n}",
        "definition_length": 253,
        "comment": ""
      },
      {
        "name": "alloc_from_pool",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "void"
        ],
        "is_static": true,
        "start_line": 241,
        "end_line": 250,
        "start_byte": 5733,
        "end_byte": 5957,
        "signature": "static lil_value_t alloc_from_pool(void)",
        "full_definition": "static lil_value_t alloc_from_pool(void)\n{\n    if (poolsize > 0) {\n        poolsize--;\n        return pool[poolsize];\n    } else {\n        lil_value_t val = calloc(1, sizeof(struct _lil_value_t));\n        return val;\n    }\n}",
        "definition_length": 224,
        "comment": ""
      },
      {
        "name": "release_to_pool",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_value_t val"
        ],
        "is_static": true,
        "start_line": 252,
        "end_line": 259,
        "start_byte": 5959,
        "end_byte": 6189,
        "signature": "static void release_to_pool(lil_value_t val)",
        "full_definition": "static void release_to_pool(lil_value_t val)\n{\n    if (poolsize == poolcap) {\n        poolcap = poolcap ? (poolcap + poolcap / 2) : 64;\n        pool = realloc(pool, sizeof(lil_value_t)*poolcap);\n    }\n    pool[poolsize++] = val;\n}",
        "definition_length": 230,
        "comment": ""
      },
      {
        "name": "ensure_capacity",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_value_t val",
          "size_t cap"
        ],
        "is_static": true,
        "start_line": 261,
        "end_line": 267,
        "start_byte": 6191,
        "end_byte": 6351,
        "signature": "static void ensure_capacity(lil_value_t val, size_t cap)",
        "full_definition": "static void ensure_capacity(lil_value_t val, size_t cap)\n{\n    if (val->c < cap) {\n        val->c = cap + 128;\n        val->d = realloc(val->d, val->c);\n    }\n}",
        "definition_length": 160,
        "comment": ""
      },
      {
        "name": "alloc_value_len",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "const char* str",
          "size_t len"
        ],
        "is_static": true,
        "start_line": 270,
        "end_line": 301,
        "start_byte": 6360,
        "end_byte": 7055,
        "signature": "static lil_value_t alloc_value_len(const char* str, size_t len)",
        "full_definition": "static lil_value_t alloc_value_len(const char* str, size_t len)\n{\n#ifdef LIL_ENABLE_POOLS\n    lil_value_t val = alloc_from_pool();\n#else\n    lil_value_t val = calloc(1, sizeof(struct _lil_value_t));\n#endif\n    if (!val) return NULL;\n    if (str) {\n        val->l = len;\n#ifdef LIL_ENABLE_POOLS\n        ensure_capacity(val, len + 1);\n#else\n        val->d = malloc(len + 1);\n        if (!val->d) {\n            free(val);\n            return NULL;\n        }\n#endif\n        memcpy(val->d, str, len);\n        val->d[len] = 0;\n    } else {\n        val->l = 0;\n#ifdef LIL_ENABLE_POOLS\n        ensure_capacity(val, 1);\n        val->d[0] = '\\0';\n#else\n        val->d = NULL;\n#endif\n    }\n    return val;\n}",
        "definition_length": 695,
        "comment": ""
      },
      {
        "name": "alloc_value",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "const char* str"
        ],
        "is_static": true,
        "start_line": 303,
        "end_line": 306,
        "start_byte": 7057,
        "end_byte": 7164,
        "signature": "static lil_value_t alloc_value(const char* str)",
        "full_definition": "static lil_value_t alloc_value(const char* str)\n{\n    return alloc_value_len(str, str ? strlen(str) : 0);\n}",
        "definition_length": 107,
        "comment": ""
      },
      {
        "name": "lil_clone_value",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_value_t src"
        ],
        "is_static": false,
        "start_line": 308,
        "end_line": 339,
        "start_byte": 7166,
        "end_byte": 7839,
        "signature": "lil_value_t lil_clone_value(lil_value_t src)",
        "full_definition": "lil_value_t lil_clone_value(lil_value_t src)\n{\n    lil_value_t val;\n    if (!src) return NULL;\n#ifdef LIL_ENABLE_POOLS\n    val = alloc_from_pool();\n#else\n    val = calloc(1, sizeof(struct _lil_value_t));\n#endif\n    if (!val) return NULL;\n    val->l = src->l;\n    if (src->l) {\n#ifdef LIL_ENABLE_POOLS\n        ensure_capacity(val, val->l + 1);\n#else\n        val->d = malloc(val->l + 1);\n        if (!val->d) {\n            free(val);\n            return NULL;\n        }\n#endif\n        memcpy(val->d, src->d, val->l + 1);\n    } else {\n#ifdef LIL_ENABLE_POOLS\n        ensure_capacity(val, 1);\n        val->d[0] = '\\0';\n#else\n        val->d = NULL;\n#endif\n    }\n    return val;\n}",
        "definition_length": 673,
        "comment": ""
      },
      {
        "name": "lil_append_char",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_value_t val",
          "char ch"
        ],
        "is_static": false,
        "start_line": 341,
        "end_line": 355,
        "start_byte": 7841,
        "end_byte": 8165,
        "signature": "int lil_append_char(lil_value_t val, char ch)",
        "full_definition": "int lil_append_char(lil_value_t val, char ch)\n{\n#ifdef LIL_ENABLE_POOLS\n    ensure_capacity(val, val->l + 2);\n    val->d[val->l++] = ch;\n    val->d[val->l] = '\\0';\n#else\n    char* new = realloc(val->d, val->l + 2);\n    if (!new) return 0;\n    new[val->l++] = ch;\n    new[val->l] = 0;\n    val->d = new;\n#endif\n    return 1;\n}",
        "definition_length": 324,
        "comment": ""
      },
      {
        "name": "lil_append_string_len",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_value_t val",
          "const char* s",
          "size_t len"
        ],
        "is_static": false,
        "start_line": 357,
        "end_line": 374,
        "start_byte": 8167,
        "end_byte": 8598,
        "signature": "int lil_append_string_len(lil_value_t val, const char* s, size_t len)",
        "full_definition": "int lil_append_string_len(lil_value_t val, const char* s, size_t len)\n{\n#ifndef LIL_ENABLE_POOLS\n    char* new;\n#endif\n    if (!s || !s[0]) return 1;\n#ifdef LIL_ENABLE_POOLS\n    ensure_capacity(val, val->l + len + 1);\n    memcpy(val->d + val->l, s, len + 1);\n#else\n    new = realloc(val->d, val->l + len + 1);\n    if (!new) return 0;\n    memcpy(new + val->l, s, len + 1);\n    val->d = new;\n#endif\n    val->l += len;\n    return 1;\n}",
        "definition_length": 431,
        "comment": ""
      },
      {
        "name": "lil_append_string",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_value_t val",
          "const char* s"
        ],
        "is_static": false,
        "start_line": 376,
        "end_line": 379,
        "start_byte": 8600,
        "end_byte": 8710,
        "signature": "int lil_append_string(lil_value_t val, const char* s)",
        "full_definition": "int lil_append_string(lil_value_t val, const char* s)\n{\n    return lil_append_string_len(val, s, strlen(s));\n}",
        "definition_length": 110,
        "comment": ""
      },
      {
        "name": "lil_append_val",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_value_t val",
          "lil_value_t v"
        ],
        "is_static": false,
        "start_line": 381,
        "end_line": 398,
        "start_byte": 8712,
        "end_byte": 9135,
        "signature": "int lil_append_val(lil_value_t val, lil_value_t v)",
        "full_definition": "int lil_append_val(lil_value_t val, lil_value_t v)\n{\n#ifndef LIL_ENABLE_POOLS\n    char* new;\n#endif\n    if (!v || !v->l) return 1;\n#ifdef LIL_ENABLE_POOLS\n    ensure_capacity(val, val->l + v->l + 1);\n    memcpy(val->d + val->l, v->d, v->l + 1);\n#else\n    new = realloc(val->d, val->l + v->l + 1);\n    if (!new) return 0;\n    memcpy(new + val->l, v->d, v->l + 1);\n    val->d = new;\n#endif\n    val->l += v->l;\n    return 1;\n}",
        "definition_length": 423,
        "comment": ""
      },
      {
        "name": "lil_free_value",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_value_t val"
        ],
        "is_static": false,
        "start_line": 400,
        "end_line": 409,
        "start_byte": 9137,
        "end_byte": 9295,
        "signature": "void lil_free_value(lil_value_t val)",
        "full_definition": "void lil_free_value(lil_value_t val)\n{\n    if (!val) return;\n#ifdef LIL_ENABLE_POOLS\n    release_to_pool(val);\n#else\n    free(val->d);\n    free(val);\n#endif\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "lil_alloc_list",
        "type": "definition",
        "return_type": "lil_list_t",
        "parameters": [
          "void"
        ],
        "is_static": false,
        "start_line": 411,
        "end_line": 421,
        "start_byte": 9297,
        "end_byte": 9538,
        "signature": "lil_list_t lil_alloc_list(void)",
        "full_definition": "lil_list_t lil_alloc_list(void)\n{\n    lil_list_t list;\n#ifdef LIL_ENABLE_POOLS\n    if (listpoolsize > 0)\n        return listpool[--listpoolsize];\n#endif\n    list = calloc(1, sizeof(struct _lil_list_t));\n    list->v = NULL;\n    return list;\n}",
        "definition_length": 241,
        "comment": ""
      },
      {
        "name": "lil_free_list",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_list_t list"
        ],
        "is_static": false,
        "start_line": 423,
        "end_line": 439,
        "start_byte": 9540,
        "end_byte": 9991,
        "signature": "void lil_free_list(lil_list_t list)",
        "full_definition": "void lil_free_list(lil_list_t list)\n{\n    size_t i;\n    if (!list) return;\n    for (i = 0; i<list->c; i++) lil_free_value(list->v[i]);\n#ifdef LIL_ENABLE_POOLS\n    list->c = 0;\n    if (listpoolsize == listpoolcap) {\n        listpoolcap = listpoolcap ? (listpoolcap + listpoolcap / 2) : 32;\n        listpool = realloc(listpool, sizeof(lil_list_t)*listpoolcap);\n    }\n    listpool[listpoolsize++] = list;\n#else\n    free(list->v);\n    free(list);\n#endif\n}",
        "definition_length": 451,
        "comment": ""
      },
      {
        "name": "lil_list_append",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_list_t list",
          "lil_value_t val"
        ],
        "is_static": false,
        "start_line": 441,
        "end_line": 451,
        "start_byte": 9993,
        "end_byte": 10327,
        "signature": "void lil_list_append(lil_list_t list, lil_value_t val)",
        "full_definition": "void lil_list_append(lil_list_t list, lil_value_t val)\n{\n    if (list->c == list->cap) {\n        size_t cap = list->cap ? (list->cap + list->cap / 2) : 32;\n        lil_value_t* nv = realloc(list->v, sizeof(lil_value_t)*cap);\n        if (!nv) return;\n        list->cap = cap;\n        list->v = nv;\n    }\n    list->v[list->c++] = val;\n}",
        "definition_length": 334,
        "comment": ""
      },
      {
        "name": "lil_list_size",
        "type": "definition",
        "return_type": "size_t",
        "parameters": [
          "lil_list_t list"
        ],
        "is_static": false,
        "start_line": 453,
        "end_line": 456,
        "start_byte": 10329,
        "end_byte": 10390,
        "signature": "size_t lil_list_size(lil_list_t list)",
        "full_definition": "size_t lil_list_size(lil_list_t list)\n{\n    return list->c;\n}",
        "definition_length": 61,
        "comment": ""
      },
      {
        "name": "lil_list_get",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_list_t list",
          "size_t index"
        ],
        "is_static": false,
        "start_line": 458,
        "end_line": 461,
        "start_byte": 10392,
        "end_byte": 10504,
        "signature": "lil_value_t lil_list_get(lil_list_t list, size_t index)",
        "full_definition": "lil_value_t lil_list_get(lil_list_t list, size_t index)\n{\n    return index >= list->c ? NULL : list->v[index];\n}",
        "definition_length": 112,
        "comment": ""
      },
      {
        "name": "needs_escape",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "const char* str"
        ],
        "is_static": true,
        "start_line": 463,
        "end_line": 470,
        "start_byte": 10506,
        "end_byte": 10698,
        "signature": "static int needs_escape(const char* str)",
        "full_definition": "static int needs_escape(const char* str)\n{\n    size_t i;\n    if (!str || !str[0]) return 1;\n    for (i=0; str[i]; i++)\n        if (ispunct(str[i]) || isspace(str[i])) return 1;\n    return 0;\n}",
        "definition_length": 192,
        "comment": ""
      },
      {
        "name": "lil_list_to_value",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_list_t list",
          "int do_escape"
        ],
        "is_static": false,
        "start_line": 472,
        "end_line": 492,
        "start_byte": 10700,
        "end_byte": 11477,
        "signature": "lil_value_t lil_list_to_value(lil_list_t list, int do_escape)",
        "full_definition": "lil_value_t lil_list_to_value(lil_list_t list, int do_escape)\n{\n    lil_value_t val = alloc_value(NULL);\n    size_t i, j;\n    for (i=0; i<list->c; i++) {\n        int escape = do_escape ? needs_escape(lil_to_string(list->v[i])) : 0;\n        if (i) lil_append_char(val, ' ');\n        if (escape) {\n            lil_append_char(val, '{');\n            for (j=0; j < list->v[i]->l; j++) {\n                if (list->v[i]->d[j] == '{')\n                    lil_append_string(val, \"}\\\"\\\\o\\\"{\");\n                else if (list->v[i]->d[j] == '}')\n                    lil_append_string(val, \"}\\\"\\\\c\\\"{\");\n                else lil_append_char(val, list->v[i]->d[j]);\n            }\n            lil_append_char(val, '}');\n        } else lil_append_val(val, list->v[i]);\n    }\n    return val;\n}",
        "definition_length": 777,
        "comment": ""
      },
      {
        "name": "lil_alloc_env",
        "type": "definition",
        "return_type": "lil_env_t",
        "parameters": [
          "lil_env_t parent"
        ],
        "is_static": false,
        "start_line": 494,
        "end_line": 520,
        "start_byte": 11479,
        "end_byte": 12198,
        "signature": "lil_env_t lil_alloc_env(lil_env_t parent)",
        "full_definition": "lil_env_t lil_alloc_env(lil_env_t parent)\n{\n    lil_env_t env;\n#ifdef LIL_ENABLE_POOLS\n    if (envpoolsize > 0) {\n        size_t i, j;\n        env = envpool[--envpoolsize];\n        env->parent = parent;\n        env->func = NULL;\n        env->catcher_for = NULL;\n        env->var = NULL;\n        env->vars = 0;\n        env->retval = NULL;\n        env->retval_set = 0;\n        env->breakrun = 0;\n        for (i = 0; i < HASHMAP_CELLS; i++) {\n            for (j = 0; j < env->varmap.cell[i].c; j++)\n                free(env->varmap.cell[i].e[j].k);\n            env->varmap.cell[i].c = 0;\n        }\n        return env;\n    }\n#endif\n    env = calloc(1, sizeof(struct _lil_env_t));\n    env->parent = parent;\n    return env;\n}",
        "definition_length": 719,
        "comment": ""
      },
      {
        "name": "lil_free_env",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_env_t env"
        ],
        "is_static": false,
        "start_line": 522,
        "end_line": 551,
        "start_byte": 12200,
        "end_byte": 12976,
        "signature": "void lil_free_env(lil_env_t env)",
        "full_definition": "void lil_free_env(lil_env_t env)\n{\n    size_t i;\n    if (!env) return;\n    lil_free_value(env->retval);\n#ifdef LIL_ENABLE_POOLS\n    for (i = 0; i<env->vars; i++) {\n        free(env->var[i]->n);\n        lil_free_value(env->var[i]->v);\n        free(env->var[i]->w);\n        free(env->var[i]);\n    }\n    free(env->var);\n    if (envpoolsize == envpoolcap) {\n        envpoolcap = envpoolcap ? (envpoolcap + envpoolcap / 2) : 64;\n        envpool = realloc(envpool, sizeof(lil_env_t)*envpoolcap);\n    }\n    envpool[envpoolsize++] = env;\n#else\n    hm_destroy(&env->varmap);\n    for (i=0; i<env->vars; i++) {\n        free(env->var[i]->n);\n        lil_free_value(env->var[i]->v);\n        free(env->var[i]->w);\n        free(env->var[i]);\n    }\n    free(env->var);\n    free(env);\n#endif\n}",
        "definition_length": 776,
        "comment": ""
      },
      {
        "name": "lil_find_local_var",
        "type": "definition",
        "return_type": "lil_var_t",
        "parameters": [
          "lil_t lil",
          "lil_env_t env",
          "const char* name"
        ],
        "is_static": true,
        "start_line": 553,
        "end_line": 568,
        "start_byte": 12978,
        "end_byte": 13354,
        "signature": "static lil_var_t lil_find_local_var(lil_t lil, lil_env_t env, const char* name)",
        "full_definition": "static lil_var_t lil_find_local_var(lil_t lil, lil_env_t env, const char* name)\n{\n    #if 0\n    if (env->vars > 0) {\n        size_t i = env->vars - 1;\n        while (1) {\n            if (!strcmp(env->var[i]->n, name)) return env->var[i];\n            if (!i) break;\n            i--;\n        }\n    }\n    return NULL;\n    #else\n    return hm_get(&env->varmap, name);\n    #endif\n}",
        "definition_length": 376,
        "comment": ""
      },
      {
        "name": "lil_find_var",
        "type": "definition",
        "return_type": "lil_var_t",
        "parameters": [
          "lil_t lil",
          "lil_env_t env",
          "const char* name"
        ],
        "is_static": true,
        "start_line": 570,
        "end_line": 574,
        "start_byte": 13356,
        "end_byte": 13576,
        "signature": "static lil_var_t lil_find_var(lil_t lil, lil_env_t env, const char* name)",
        "full_definition": "static lil_var_t lil_find_var(lil_t lil, lil_env_t env, const char* name)\n{\n    lil_var_t r = lil_find_local_var(lil, env, name);\n    return r ? r : (env == lil->rootenv ? NULL : lil_find_var(lil, lil->rootenv, name));\n}",
        "definition_length": 220,
        "comment": ""
      },
      {
        "name": "find_cmd",
        "type": "definition",
        "return_type": "lil_func_t",
        "parameters": [
          "lil_t lil",
          "const char* name"
        ],
        "is_static": true,
        "start_line": 576,
        "end_line": 591,
        "start_byte": 13578,
        "end_byte": 13933,
        "signature": "static lil_func_t find_cmd(lil_t lil, const char* name)",
        "full_definition": "static lil_func_t find_cmd(lil_t lil, const char* name)\n{\n    #if 0\n    if (lil->cmds > 0) {\n        size_t i = lil->cmds - 1;\n        while (1) {\n            if (!strcmp(lil->cmd[i]->name, name)) return lil->cmd[i];\n            if (!i) break;\n            i--;\n        }\n    }\n    return NULL;\n    #else\n    return hm_get(&lil->cmdmap, name);\n    #endif\n}",
        "definition_length": 355,
        "comment": ""
      },
      {
        "name": "add_func",
        "type": "definition",
        "return_type": "lil_func_t",
        "parameters": [
          "lil_t lil",
          "const char* name"
        ],
        "is_static": true,
        "start_line": 593,
        "end_line": 617,
        "start_byte": 13935,
        "end_byte": 14598,
        "signature": "static lil_func_t add_func(lil_t lil, const char* name)",
        "full_definition": "static lil_func_t add_func(lil_t lil, const char* name)\n{\n    lil_func_t cmd;\n    lil_func_t* ncmd;\n    cmd = find_cmd(lil, name);\n    if (cmd) {\n        if (cmd->argnames) lil_free_list(cmd->argnames);\n        lil_free_value(cmd->code);\n        cmd->argnames = NULL;\n        cmd->code = NULL;   \n        cmd->proc = NULL;\n        return cmd;\n    }\n    cmd = calloc(1, sizeof(struct _lil_func_t));\n    cmd->name = strclone(name);\n    ncmd = realloc(lil->cmd, sizeof(lil_func_t)*(lil->cmds + 1));\n    if (!ncmd) {\n        free(cmd);\n        return NULL;\n    }\n    lil->cmd = ncmd;\n    ncmd[lil->cmds++] = cmd;\n    hm_put(&lil->cmdmap, name, cmd);\n    return cmd;\n}",
        "definition_length": 663,
        "comment": ""
      },
      {
        "name": "del_func",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil",
          "lil_func_t cmd"
        ],
        "is_static": true,
        "start_line": 619,
        "end_line": 635,
        "start_byte": 14600,
        "end_byte": 15086,
        "signature": "static void del_func(lil_t lil, lil_func_t cmd)",
        "full_definition": "static void del_func(lil_t lil, lil_func_t cmd)\n{\n    size_t i, index = lil->cmds;\n    for (i=0; i < lil->cmds; i++)\n        if (lil->cmd[i] == cmd) {\n            index = i;\n            break;\n        }\n    if (index == lil->cmds) return;\n    hm_put(&lil->cmdmap, cmd->name, 0);\n    if (cmd->argnames) lil_free_list(cmd->argnames);\n    lil_free_value(cmd->code);\n    free(cmd->name);\n    free(cmd);\n    lil->cmds--;\n    for (i=index; i < lil->cmds; i++) lil->cmd[i] = lil->cmd[i + 1];\n}",
        "definition_length": 486,
        "comment": ""
      },
      {
        "name": "lil_register",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_t lil",
          "const char* name",
          "lil_func_proc_t proc"
        ],
        "is_static": false,
        "start_line": 637,
        "end_line": 643,
        "start_byte": 15088,
        "end_byte": 15261,
        "signature": "int lil_register(lil_t lil, const char* name, lil_func_proc_t proc)",
        "full_definition": "int lil_register(lil_t lil, const char* name, lil_func_proc_t proc)\n{\n    lil_func_t cmd = add_func(lil, name);\n    if (!cmd) return 0;\n    cmd->proc = proc;\n    return 1;\n}",
        "definition_length": 173,
        "comment": ""
      },
      {
        "name": "lil_set_var",
        "type": "definition",
        "return_type": "lil_var_t",
        "parameters": [
          "lil_t lil",
          "const char* name",
          "lil_value_t val",
          "int local"
        ],
        "is_static": false,
        "start_line": 645,
        "end_line": 692,
        "start_byte": 15263,
        "end_byte": 17045,
        "signature": "lil_var_t lil_set_var(lil_t lil, const char* name, lil_value_t val, int local)",
        "full_definition": "lil_var_t lil_set_var(lil_t lil, const char* name, lil_value_t val, int local)\n{\n    lil_var_t* nvar;\n    lil_env_t env = local == LIL_SETVAR_GLOBAL ? lil->rootenv : lil->env;\n    int freeval = 0;\n    if (!name[0]) return NULL;\n    if (local != LIL_SETVAR_LOCAL_NEW) {\n        lil_var_t var = lil_find_var(lil, env, name);\n        if (local == LIL_SETVAR_LOCAL_ONLY && var && var->env == lil->rootenv && var->env != env)\n            var = NULL;\n        if (((!var && env == lil->rootenv) || (var && var->env == lil->rootenv)) && lil->callback[LIL_CALLBACK_SETVAR]) {\n            lil_setvar_callback_proc_t proc = (lil_setvar_callback_proc_t)lil->callback[LIL_CALLBACK_SETVAR];\n            lil_value_t newval = val;\n            int r = proc(lil, name, &newval);\n            if (r < 0) return NULL;\n            if (r) {\n                val = newval;\n                freeval = 1;\n            }\n        }\n        if (var) {\n            lil_free_value(var->v);\n            var->v = freeval ? val : lil_clone_value(val);\n            if (var->w) {\n                lil_env_t save_env;\n                save_env = lil->env;\n                lil->env = var->env;\n                lil_free_value(lil_parse(lil, var->w, 0, 1));\n                lil->env = save_env;\n            }\n            return var;\n        }\n    }\n\n    nvar = realloc(env->var, sizeof(lil_var_t)*(env->vars + 1));\n    if (!nvar) {\n        /* TODO: report memory error */\n        return NULL;\n    }\n    env->var = nvar;\n    nvar[env->vars] = calloc(1, sizeof(struct _lil_var_t));\n    nvar[env->vars]->n = strclone(name);\n    nvar[env->vars]->w = NULL;\n    nvar[env->vars]->env = env;\n    nvar[env->vars]->v = freeval ? val : lil_clone_value(val);\n    hm_put(&env->varmap, name, nvar[env->vars]);\n    return nvar[env->vars++];\n}",
        "definition_length": 1782,
        "comment": ""
      },
      {
        "name": "lil_get_var",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "const char* name"
        ],
        "is_static": false,
        "start_line": 694,
        "end_line": 697,
        "start_byte": 17047,
        "end_byte": 17153,
        "signature": "lil_value_t lil_get_var(lil_t lil, const char* name)",
        "full_definition": "lil_value_t lil_get_var(lil_t lil, const char* name)\n{\n    return lil_get_var_or(lil, name, lil->empty);\n}",
        "definition_length": 106,
        "comment": ""
      },
      {
        "name": "lil_get_var_or",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "const char* name",
          "lil_value_t defvalue"
        ],
        "is_static": false,
        "start_line": 699,
        "end_line": 710,
        "start_byte": 17155,
        "end_byte": 17669,
        "signature": "lil_value_t lil_get_var_or(lil_t lil, const char* name, lil_value_t defvalue)",
        "full_definition": "lil_value_t lil_get_var_or(lil_t lil, const char* name, lil_value_t defvalue)\n{\n    lil_var_t var = lil_find_var(lil, lil->env, name);\n    lil_value_t retval = var ? var->v : defvalue;\n    if (lil->callback[LIL_CALLBACK_GETVAR] && (!var || var->env == lil->rootenv)) {\n        lil_getvar_callback_proc_t proc = (lil_getvar_callback_proc_t)lil->callback[LIL_CALLBACK_GETVAR];\n        lil_value_t newretval = retval;\n        if (proc(lil, name, &newretval))\n            retval = newretval;\n    }\n    return retval;\n}",
        "definition_length": 514,
        "comment": ""
      },
      {
        "name": "lil_push_env",
        "type": "definition",
        "return_type": "lil_env_t",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": false,
        "start_line": 712,
        "end_line": 717,
        "start_byte": 17671,
        "end_byte": 17789,
        "signature": "lil_env_t lil_push_env(lil_t lil)",
        "full_definition": "lil_env_t lil_push_env(lil_t lil)\n{\n    lil_env_t env = lil_alloc_env(lil->env);\n    lil->env = env;\n    return env;\n}",
        "definition_length": 118,
        "comment": ""
      },
      {
        "name": "lil_pop_env",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": false,
        "start_line": 719,
        "end_line": 726,
        "start_byte": 17791,
        "end_byte": 17956,
        "signature": "void lil_pop_env(lil_t lil)",
        "full_definition": "void lil_pop_env(lil_t lil)\n{\n    if (lil->env->parent) {\n        lil_env_t next = lil->env->parent;\n        lil_free_env(lil->env);\n        lil->env = next;\n    }\n}",
        "definition_length": 165,
        "comment": ""
      },
      {
        "name": "lil_new",
        "type": "definition",
        "return_type": "lil_t",
        "parameters": [
          "void"
        ],
        "is_static": false,
        "start_line": 728,
        "end_line": 737,
        "start_byte": 17958,
        "end_byte": 18230,
        "signature": "lil_t lil_new(void)",
        "full_definition": "lil_t lil_new(void)\n{\n    lil_t lil = calloc(1, sizeof(struct _lil_t));\n    lil->rootenv = lil->env = lil_alloc_env(NULL);\n    lil->empty = alloc_value(NULL);\n    lil->dollarprefix = strclone(\"set \");\n    hm_init(&lil->cmdmap);\n    register_stdcmds(lil);\n    return lil;\n}",
        "definition_length": 272,
        "comment": ""
      },
      {
        "name": "islilspecial",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "char ch"
        ],
        "is_static": true,
        "start_line": 739,
        "end_line": 742,
        "start_byte": 18232,
        "end_byte": 18382,
        "signature": "static int islilspecial(char ch)",
        "full_definition": "static int islilspecial(char ch)\n{\n    return ch == '$' || ch == '{' || ch == '}' || ch == '[' || ch == ']' || ch == '\"' || ch == '\\'' || ch == ';';\n}",
        "definition_length": 150,
        "comment": ""
      },
      {
        "name": "ateol",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": true,
        "start_line": 744,
        "end_line": 747,
        "start_byte": 18384,
        "end_byte": 18542,
        "signature": "static int ateol(lil_t lil)",
        "full_definition": "static int ateol(lil_t lil)\n{\n    return !(lil->ignoreeol) && (lil->code[lil->head] == '\\n' || lil->code[lil->head] == '\\r' || lil->code[lil->head] == ';');\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "skip_spaces",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": true,
        "start_line": 749,
        "end_line": 775,
        "start_byte": 18544,
        "end_byte": 19683,
        "signature": "static void skip_spaces(lil_t lil)",
        "full_definition": "static void skip_spaces(lil_t lil)\n{\n    while (lil->head < lil->clen) {\n        if (lil->code[lil->head] == '#') {\n            if (lil->code[lil->head + 1] == '#' && lil->code[lil->head + 2] != '#') {\n                lil->head += 2;\n                while (lil->head < lil->clen) {\n                    if ((lil->code[lil->head] == '#') && (lil->code[lil->head + 1] == '#') && (lil->code[lil->head + 2] != '#')) {\n                        lil->head += 2;\n                        break;\n                    }\n                    lil->head++;\n                }\n            } else {\n                while (lil->head < lil->clen && !ateol(lil)) lil->head++;\n            }\n        } else if (lil->code[lil->head] == '\\\\' && (lil->code[lil->head + 1] == '\\r' || lil->code[lil->head + 1] == '\\n')) {\n            lil->head++;\n            while (lil->head < lil->clen && ateol(lil)) lil->head++;\n        } else if (lil->code[lil->head] == '\\r' || lil->code[lil->head] == '\\n') {\n            if (lil->ignoreeol) lil->head++;\n            else break;\n        } else if (isspace(lil->code[lil->head]))\n            lil->head++;\n        else break;\n    }\n}",
        "definition_length": 1139,
        "comment": ""
      },
      {
        "name": "get_bracketpart",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": true,
        "start_line": 777,
        "end_line": 798,
        "start_byte": 19685,
        "end_byte": 20305,
        "signature": "static lil_value_t get_bracketpart(lil_t lil)",
        "full_definition": "static lil_value_t get_bracketpart(lil_t lil)\n{\n    size_t cnt = 1;\n    lil_value_t val, cmd = alloc_value(NULL);\n    lil->head++;\n    while (lil->head < lil->clen) {\n        if (lil->code[lil->head] == '[') {\n            lil->head++;\n            cnt++;\n            lil_append_char(cmd, '[');\n        } else if (lil->code[lil->head] == ']') {\n            lil->head++;\n            if (--cnt == 0) break;\n            else lil_append_char(cmd, ']');\n        } else {\n            lil_append_char(cmd, lil->code[lil->head++]);\n        }\n    }\n    val = lil_parse_value(lil, cmd, 0);\n    lil_free_value(cmd);\n    return val;\n}",
        "definition_length": 620,
        "comment": ""
      },
      {
        "name": "get_dollarpart",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": true,
        "start_line": 800,
        "end_line": 811,
        "start_byte": 20307,
        "end_byte": 20611,
        "signature": "static lil_value_t get_dollarpart(lil_t lil)",
        "full_definition": "static lil_value_t get_dollarpart(lil_t lil)\n{\n    lil_value_t val, name, tmp;\n    lil->head++;\n    name = next_word(lil);\n    tmp = alloc_value(lil->dollarprefix);\n    lil_append_val(tmp, name);\n    lil_free_value(name);\n    val = lil_parse_value(lil, tmp, 0);\n    lil_free_value(tmp);\n    return val;\n}",
        "definition_length": 304,
        "comment": ""
      },
      {
        "name": "next_word",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": true,
        "start_line": 813,
        "end_line": 879,
        "start_byte": 20613,
        "end_byte": 23394,
        "signature": "static lil_value_t next_word(lil_t lil)",
        "full_definition": "static lil_value_t next_word(lil_t lil)\n{\n    lil_value_t val;\n    size_t start;\n    skip_spaces(lil);\n    if (lil->code[lil->head] == '$') {\n        val = get_dollarpart(lil);\n    } else if (lil->code[lil->head] == '{') {\n        size_t cnt = 1;\n        lil->head++;\n        val = alloc_value(NULL);\n        while (lil->head < lil->clen) {\n            if (lil->code[lil->head] == '{') {\n                lil->head++;\n                cnt++;\n                lil_append_char(val, '{');\n            } else if (lil->code[lil->head] == '}') {\n                lil->head++;\n                if (--cnt == 0) break;\n                else lil_append_char(val, '}');\n            } else {\n                lil_append_char(val, lil->code[lil->head++]);\n            }\n        }\n    } else if (lil->code[lil->head] == '[') {\n        val = get_bracketpart(lil);\n    } else if (lil->code[lil->head] == '\"' || lil->code[lil->head] == '\\'') {\n        char sc = lil->code[lil->head++];\n        val = alloc_value(NULL);\n        while (lil->head < lil->clen) {\n            if (lil->code[lil->head] == '[' || lil->code[lil->head] == '$') {\n                lil_value_t tmp = lil->code[lil->head] == '$' ? get_dollarpart(lil) : get_bracketpart(lil);\n                lil_append_val(val, tmp);\n                lil_free_value(tmp);\n                lil->head--; /* avoid skipping the char below */\n            } else if (lil->code[lil->head] == '\\\\') {\n                lil->head++;\n                switch (lil->code[lil->head]) {\n                    case 'b': lil_append_char(val, '\\b'); break;\n                    case 't': lil_append_char(val, '\\t'); break;\n                    case 'n': lil_append_char(val, '\\n'); break;\n                    case 'v': lil_append_char(val, '\\v'); break;\n                    case 'f': lil_append_char(val, '\\f'); break;\n                    case 'r': lil_append_char(val, '\\r'); break;\n                    case '0': lil_append_char(val, 0); break;\n                    case 'a': lil_append_char(val, '\\a'); break;\n                    case 'c': lil_append_char(val, '}'); break;\n                    case 'o': lil_append_char(val, '{'); break;\n                    default: lil_append_char(val, lil->code[lil->head]); break;\n                }\n            } else if (lil->code[lil->head] == sc) {\n                lil->head++;\n                break;\n            } else {\n                lil_append_char(val, lil->code[lil->head]);\n            }\n            lil->head++;\n        }\n    } else {\n        start = lil->head;\n        while (lil->head < lil->clen && !isspace(lil->code[lil->head]) && !islilspecial(lil->code[lil->head])) {\n            lil->head++;\n        }\n        val = alloc_value_len(lil->code + start, lil->head - start);\n    }\n    return val ? val : alloc_value(NULL);\n}",
        "definition_length": 2781,
        "comment": ""
      },
      {
        "name": "substitute",
        "type": "definition",
        "return_type": "lil_list_t",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": true,
        "start_line": 881,
        "end_line": 906,
        "start_byte": 23396,
        "end_byte": 24203,
        "signature": "static lil_list_t substitute(lil_t lil)",
        "full_definition": "static lil_list_t substitute(lil_t lil)\n{\n    lil_list_t words = lil_alloc_list();\n\n    skip_spaces(lil);\n    while (lil->head < lil->clen && !ateol(lil) && !lil->error) {\n        lil_value_t w = alloc_value(NULL);\n        do {\n            size_t head = lil->head;\n            lil_value_t wp = next_word(lil);\n            if (head == lil->head) { /* something wrong, the parser can't proceed */\n                lil_free_value(w);\n                lil_free_value(wp);\n                lil_free_list(words);\n                return NULL;\n            }\n            lil_append_val(w, wp);\n            lil_free_value(wp);\n        } while (lil->head < lil->clen && !ateol(lil) && !isspace(lil->code[lil->head]) && !lil->error);\n        skip_spaces(lil);\n\n        lil_list_append(words, w);\n    }\n\n    return words;\n}",
        "definition_length": 807,
        "comment": ""
      },
      {
        "name": "lil_subst_to_list",
        "type": "definition",
        "return_type": "lil_list_t",
        "parameters": [
          "lil_t lil",
          "lil_value_t code"
        ],
        "is_static": false,
        "start_line": 908,
        "end_line": 926,
        "start_byte": 24205,
        "end_byte": 24740,
        "signature": "lil_list_t lil_subst_to_list(lil_t lil, lil_value_t code)",
        "full_definition": "lil_list_t lil_subst_to_list(lil_t lil, lil_value_t code)\n{\n    const char* save_code = lil->code;\n    size_t save_clen = lil->clen;\n    size_t save_head = lil->head;\n    int save_igeol = lil->ignoreeol;\n    lil_list_t words;\n    lil->code = lil_to_string(code);\n    lil->clen = code->l;\n    lil->head = 0;\n    lil->ignoreeol = 1;\n    words = substitute(lil);\n    if (!words) words = lil_alloc_list();\n    lil->code = save_code;\n    lil->clen = save_clen;\n    lil->head = save_head;\n    lil->ignoreeol = save_igeol;\n    return words;\n}",
        "definition_length": 535,
        "comment": ""
      },
      {
        "name": "lil_subst_to_value",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "lil_value_t code"
        ],
        "is_static": false,
        "start_line": 928,
        "end_line": 935,
        "start_byte": 24742,
        "end_byte": 24960,
        "signature": "lil_value_t lil_subst_to_value(lil_t lil, lil_value_t code)",
        "full_definition": "lil_value_t lil_subst_to_value(lil_t lil, lil_value_t code)\n{\n    lil_list_t words = lil_subst_to_list(lil, code);\n    lil_value_t val;\n    val = lil_list_to_value(words, 0);\n    lil_free_list(words);\n    return val;\n}",
        "definition_length": 218,
        "comment": ""
      },
      {
        "name": "lil_parse",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "const char* code",
          "size_t codelen",
          "int funclevel"
        ],
        "is_static": false,
        "start_line": 937,
        "end_line": 1049,
        "start_byte": 24962,
        "end_byte": 29492,
        "signature": "lil_value_t lil_parse(lil_t lil, const char* code, size_t codelen, int funclevel)",
        "full_definition": "lil_value_t lil_parse(lil_t lil, const char* code, size_t codelen, int funclevel)\n{\n    const char* save_code = lil->code;\n    size_t save_clen = lil->clen;\n    size_t save_head = lil->head;\n    lil_value_t val = NULL;\n    lil_list_t words = NULL;\n    if (!save_code) lil->rootcode = code;\n    lil->code = code;\n    lil->clen = codelen ? codelen : strlen(code);\n    lil->head = 0;\n    skip_spaces(lil);\n    lil->parse_depth++;\n#ifdef LIL_ENABLE_RECLIMIT\n    if (lil->parse_depth > LIL_ENABLE_RECLIMIT) {\n        lil_set_error(lil, \"Too many recursive calls\");\n        goto cleanup;\n    }\n#endif\n    if (lil->parse_depth == 1) lil->error = 0;\n    if (funclevel) lil->env->breakrun = 0;\n    while (lil->head < lil->clen && !lil->error) {\n        if (words) lil_free_list(words);\n        if (val) lil_free_value(val);\n        val = NULL;\n\n        words = substitute(lil);\n        if (!words || lil->error) goto cleanup;\n\n        if (words->c) {\n            lil_func_t cmd = find_cmd(lil, lil_to_string(words->v[0]));\n            if (!cmd) {\n                if (words->v[0]->l) {\n                    if (lil->catcher) {\n                        if (lil->in_catcher < MAX_CATCHER_DEPTH) {\n                            lil_value_t args;\n                            lil->in_catcher++;\n                            lil_push_env(lil);\n                            lil->env->catcher_for = words->v[0];\n                            args = lil_list_to_value(words, 1);\n                            lil_set_var(lil, \"args\", args, LIL_SETVAR_LOCAL_NEW);\n                            lil_free_value(args);\n                            val = lil_parse(lil, lil->catcher, 0, 1);\n                            lil_pop_env(lil);\n                            lil->in_catcher--;\n                        } else {\n                            char* msg = malloc(words->v[0]->l + 64);\n                            sprintf(msg, \"catcher limit reached while trying to call unknown function %s\", words->v[0]->d);\n                            lil_set_error_at(lil, lil->head, msg);\n                            free(msg);\n                            goto cleanup;\n                        }\n                    } else {\n                        char* msg = malloc(words->v[0]->l + 32);\n                        sprintf(msg, \"unknown function %s\", words->v[0]->d);\n                        lil_set_error_at(lil, lil->head, msg);\n                        free(msg);\n                        goto cleanup;\n                    }\n                }\n            }\n            if (cmd) {\n                if (cmd->proc) {\n                    size_t shead = lil->head;\n                    val = cmd->proc(lil, words->c - 1, words->v + 1);\n                    if (lil->error == ERROR_FIXHEAD) {\n                        lil->error = ERROR_DEFAULT;\n                        lil->err_head = shead;\n                    }\n                } else {\n                    lil_push_env(lil);\n                    lil->env->func = cmd;\n                    if (cmd->argnames->c == 1 && !strcmp(lil_to_string(cmd->argnames->v[0]), \"args\")) {\n                        lil_value_t args = lil_list_to_value(words, 1);\n                        lil_set_var(lil, \"args\", args, LIL_SETVAR_LOCAL_NEW);\n                        lil_free_value(args);\n                    } else {\n                        size_t i;\n                        for (i=0; i<cmd->argnames->c; i++) {\n                            lil_set_var(lil, lil_to_string(cmd->argnames->v[i]), i < words->c - 1 ? words->v[i + 1] : lil->empty, LIL_SETVAR_LOCAL_NEW);\n                        }\n                    }\n                    val = lil_parse_value(lil, cmd->code, 1);\n                    lil_pop_env(lil);\n                }\n            }\n        }\n\n        if (lil->env->breakrun) goto cleanup;\n\n        skip_spaces(lil);\n        while (ateol(lil)) lil->head++;\n        skip_spaces(lil);\n    }\ncleanup:\n    if (lil->error && lil->callback[LIL_CALLBACK_ERROR] && lil->parse_depth == 1) {\n        lil_error_callback_proc_t proc = (lil_error_callback_proc_t)lil->callback[LIL_CALLBACK_ERROR];\n        proc(lil, lil->err_head, lil->err_msg);\n    }\n    if (words) lil_free_list(words);\n    lil->code = save_code;\n    lil->clen = save_clen;\n    lil->head = save_head;\n    if (funclevel && lil->env->retval_set) {\n        if (val) lil_free_value(val);\n        val = lil->env->retval;\n        lil->env->retval = NULL;\n        lil->env->retval_set = 0;\n        lil->env->breakrun = 0;\n    }\n    lil->parse_depth--;\n    return val ? val : alloc_value(NULL);\n}",
        "definition_length": 4530,
        "comment": ""
      },
      {
        "name": "lil_parse_value",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "lil_value_t val",
          "int funclevel"
        ],
        "is_static": false,
        "start_line": 1051,
        "end_line": 1055,
        "start_byte": 29494,
        "end_byte": 29684,
        "signature": "lil_value_t lil_parse_value(lil_t lil, lil_value_t val, int funclevel)",
        "full_definition": "lil_value_t lil_parse_value(lil_t lil, lil_value_t val, int funclevel)\n{\n    if (!val || !val->d || !val->l) return alloc_value(NULL);\n    return lil_parse(lil, val->d, val->l, funclevel);\n}",
        "definition_length": 190,
        "comment": ""
      },
      {
        "name": "lil_call",
        "type": "definition",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* funcname",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": false,
        "start_line": 1057,
        "end_line": 1086,
        "start_byte": 29686,
        "end_byte": 30857,
        "signature": "LILAPI lil_value_t lil_call(lil_t lil, const char* funcname, size_t argc, lil_value_t* argv)",
        "full_definition": "LILAPI lil_value_t lil_call(lil_t lil, const char* funcname, size_t argc, lil_value_t* argv)\n{\n    lil_func_t cmd = find_cmd(lil, funcname);\n    lil_value_t r = NULL;\n    if (cmd) {\n        if (cmd->proc)\n            r = cmd->proc(lil, argc, argv);\n        else {\n            size_t i;\n            lil_push_env(lil);\n            lil->env->func = cmd;\n            if (cmd->argnames->c == 1 && !strcmp(lil_to_string(cmd->argnames->v[0]), \"args\")) {\n                lil_list_t args = lil_alloc_list();\n                lil_value_t argsval;\n                for (i=0; i<argc; i++)\n                    lil_list_append(args, lil_clone_value(argv[i]));\n                argsval = lil_list_to_value(args, 0);\n                lil_set_var(lil, \"args\", argsval, LIL_SETVAR_LOCAL_NEW);\n                lil_free_value(argsval);\n                lil_free_list(args);\n            } else {\n                for (i=0; i<cmd->argnames->c; i++)\n                    lil_set_var(lil, lil_to_string(cmd->argnames->v[i]), i < argc ? argv[i] : NULL, LIL_SETVAR_LOCAL_NEW);\n            }\n            r = lil_parse_value(lil, cmd->code, 1);\n            lil_pop_env(lil);\n        }\n    }\n    return r;\n}",
        "definition_length": 1171,
        "comment": ""
      },
      {
        "name": "lil_callback",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil",
          "int cb",
          "lil_callback_proc_t proc"
        ],
        "is_static": false,
        "start_line": 1088,
        "end_line": 1092,
        "start_byte": 30859,
        "end_byte": 30997,
        "signature": "void lil_callback(lil_t lil, int cb, lil_callback_proc_t proc)",
        "full_definition": "void lil_callback(lil_t lil, int cb, lil_callback_proc_t proc)\n{\n    if (cb < 0 || cb > CALLBACKS) return;\n    lil->callback[cb] = proc;\n}",
        "definition_length": 138,
        "comment": ""
      },
      {
        "name": "lil_set_error",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil",
          "const char* msg"
        ],
        "is_static": false,
        "start_line": 1094,
        "end_line": 1101,
        "start_byte": 30999,
        "end_byte": 31201,
        "signature": "void lil_set_error(lil_t lil, const char* msg)",
        "full_definition": "void lil_set_error(lil_t lil, const char* msg)\n{\n    if (lil->error) return;\n    free(lil->err_msg);\n    lil->error = ERROR_FIXHEAD;\n    lil->err_head = 0;\n    lil->err_msg = strclone(msg ? msg : \"\");\n}",
        "definition_length": 202,
        "comment": ""
      },
      {
        "name": "lil_set_error_at",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil",
          "size_t pos",
          "const char* msg"
        ],
        "is_static": false,
        "start_line": 1103,
        "end_line": 1110,
        "start_byte": 31203,
        "end_byte": 31422,
        "signature": "void lil_set_error_at(lil_t lil, size_t pos, const char* msg)",
        "full_definition": "void lil_set_error_at(lil_t lil, size_t pos, const char* msg)\n{\n    if (lil->error) return;\n    free(lil->err_msg);\n    lil->error = ERROR_DEFAULT;\n    lil->err_head = pos;\n    lil->err_msg = strclone(msg ? msg : \"\");\n}",
        "definition_length": 219,
        "comment": ""
      },
      {
        "name": "lil_error",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_t lil",
          "const char** msg",
          "size_t* pos"
        ],
        "is_static": false,
        "start_line": 1112,
        "end_line": 1119,
        "start_byte": 31424,
        "end_byte": 31611,
        "signature": "int lil_error(lil_t lil, const char** msg, size_t* pos)",
        "full_definition": "int lil_error(lil_t lil, const char** msg, size_t* pos)\n{\n    if (!lil->error) return 0;\n    *msg = lil->err_msg;\n    *pos = lil->err_head;\n    lil->error = ERROR_NOERROR;\n    return 1;\n}",
        "definition_length": 187,
        "comment": ""
      },
      {
        "name": "ee_expr",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "start_line": 1129,
        "end_line": 1129,
        "start_byte": 31796,
        "end_byte": 31832,
        "full_declaration": "static void ee_expr(expreval_t* ee);",
        "declaration_length": 36,
        "comment": ""
      },
      {
        "name": "ee_invalidpunct",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "int ch"
        ],
        "is_static": true,
        "start_line": 1131,
        "end_line": 1134,
        "start_byte": 31834,
        "end_byte": 31974,
        "signature": "static int ee_invalidpunct(int ch)",
        "full_definition": "static int ee_invalidpunct(int ch)\n{\n    return ispunct(ch) && ch != '!' && ch != '~' && ch != '(' && ch != ')' && ch != '-' && ch != '+';\n}",
        "definition_length": 140,
        "comment": ""
      },
      {
        "name": "ee_skip_spaces",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1136,
        "end_line": 1139,
        "start_byte": 31976,
        "end_byte": 32096,
        "signature": "static void ee_skip_spaces(expreval_t* ee)",
        "full_definition": "static void ee_skip_spaces(expreval_t* ee)\n{\n    while (ee->head < ee->len && isspace(ee->code[ee->head])) ee->head++;\n}",
        "definition_length": 120,
        "comment": ""
      },
      {
        "name": "ee_numeric_element",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1141,
        "end_line": 1164,
        "start_byte": 32098,
        "end_byte": 32828,
        "signature": "static void ee_numeric_element(expreval_t* ee)",
        "full_definition": "static void ee_numeric_element(expreval_t* ee)\n{\n    lilint_t fpart = 0, fpartlen = 1;\n    ee->type = EE_INT;\n    ee_skip_spaces(ee);\n    ee->ival = 0;\n    ee->dval = 0;\n    while (ee->head < ee->len) {\n        if (ee->code[ee->head] == '.') {\n            if (ee->type == EE_FLOAT) break;\n            ee->type = EE_FLOAT;\n            ee->head++;\n        } else if (!isdigit(ee->code[ee->head])) break;\n        if (ee->type == EE_INT)\n            ee->ival = ee->ival*10 + (ee->code[ee->head] - '0');\n        else {\n            fpart = fpart*10 + (ee->code[ee->head] - '0');\n            fpartlen *= 10;\n        }\n        ee->head++;\n    }\n    if (ee->type == EE_FLOAT)\n        ee->dval = ee->ival + (double)fpart/(double)fpartlen;\n}",
        "definition_length": 730,
        "comment": ""
      },
      {
        "name": "ee_element",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1166,
        "end_line": 1179,
        "start_byte": 32830,
        "end_byte": 33264,
        "signature": "static void ee_element(expreval_t* ee)",
        "full_definition": "static void ee_element(expreval_t* ee)\n{\n    if (isdigit(ee->code[ee->head])) {\n        ee_numeric_element(ee);\n        return;\n    }\n\n    /* for anything else that might creep in (usually from strings), we set the\n     * value to 1 so that strings evaluate as \"true\" when used in conditional\n     * expressions */\n    ee->type = EE_INT;\n    ee->ival = 1;\n    ee->error = EERR_INVALID_EXPRESSION; /* special flag, will be cleared */\n}",
        "definition_length": 434,
        "comment": ""
      },
      {
        "name": "ee_paren",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1181,
        "end_line": 1191,
        "start_byte": 33266,
        "end_byte": 33558,
        "signature": "static void ee_paren(expreval_t* ee)",
        "full_definition": "static void ee_paren(expreval_t* ee)\n{\n    ee_skip_spaces(ee);\n    if (ee->code[ee->head] == '(') {\n        ee->head++;\n        ee_expr(ee);\n        ee_skip_spaces(ee);\n        if (ee->code[ee->head] == ')') ee->head++;\n        else ee->error = EERR_SYNTAX_ERROR;\n    } else ee_element(ee);\n}",
        "definition_length": 292,
        "comment": "special flag, will be cleared"
      },
      {
        "name": "ee_unary",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1193,
        "end_line": 1252,
        "start_byte": 33560,
        "end_byte": 35167,
        "signature": "static void ee_unary(expreval_t* ee)",
        "full_definition": "static void ee_unary(expreval_t* ee)\n{\n    ee_skip_spaces(ee);\n    if (ee->head < ee->len && !ee->error &&\n        (ee->code[ee->head] == '-' ||\n         ee->code[ee->head] == '+' ||\n         ee->code[ee->head] == '~' ||\n         ee->code[ee->head] == '!')) {\n        char op = ee->code[ee->head++];\n        ee_unary(ee);\n        if (ee->error) return;\n        switch (op) {\n        case '-':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->dval = -ee->dval;\n                break;\n            case EE_INT:\n                ee->ival = -ee->ival;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case '+':\n            /* ignore it, doesn't change a thing */\n            break;\n        case '~':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = ~((lilint_t)ee->dval);\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = ~ee->ival;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case '!':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->dval = !ee->dval;\n                break;\n            case EE_INT:\n                ee->ival = !ee->ival;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        }\n    } else {\n        ee_paren(ee);\n    }\n}",
        "definition_length": 1607,
        "comment": ""
      },
      {
        "name": "ee_muldiv",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1254,
        "end_line": 1477,
        "start_byte": 35169,
        "end_byte": 42539,
        "signature": "static void ee_muldiv(expreval_t* ee)",
        "full_definition": "static void ee_muldiv(expreval_t* ee)\n{\n    ee_unary(ee);\n    if (ee->error) return;\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error && !ee_invalidpunct(ee->code[ee->head + 1]) &&\n        (ee->code[ee->head] == '*' ||\n         ee->code[ee->head] == '/' ||\n         ee->code[ee->head] == '\\\\' ||\n         ee->code[ee->head] == '%')) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n\n        switch (ee->code[ee->head]) {\n        case '*':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->dval = ee->dval*odval;\n                    break;\n                case EE_INT:\n                    ee->dval = ee->ival*odval;\n                    ee->type = EE_FLOAT;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->dval = ee->dval*oival;\n                    ee->type = EE_FLOAT;\n                    break;\n                case EE_INT:\n                    ee->ival = ee->ival*oival;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case '%':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    if (ee->dval == 0.0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->dval = fmod(odval, ee->dval);\n                    }\n                    break;\n                case EE_INT:\n                    if (ee->ival == 0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->dval = fmod(odval, ee->ival);\n                    }\n                    ee->type = EE_FLOAT;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    if (ee->dval == 0.0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->dval = fmod(oival, ee->dval);\n                    }\n                    break;\n                case EE_INT:\n                    if (ee->ival == 0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->ival = oival%ee->ival;\n                    }\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            }\n            break;\n        case '/':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    if (ee->dval == 0.0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->dval = odval/ee->dval;\n                    }\n                    break;\n                case EE_INT:\n                    if (ee->ival == 0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->dval = odval/(double)ee->ival;\n                    }\n                    ee->type = EE_FLOAT;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    if (ee->dval == 0.0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->dval = (double)oival/ee->dval;\n                    }\n                    break;\n                case EE_INT:\n                    if (ee->ival == 0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->dval = (double)oival/(double)ee->ival;\n                    }\n                    ee->type = EE_FLOAT;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            }\n            break;\n        case '\\\\':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    if (ee->dval == 0.0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->ival = (lilint_t)(odval/ee->dval);\n                    }\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    if (ee->ival == 0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->ival = (lilint_t)(odval/(double)ee->ival);\n                    }\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_unary(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    if (ee->dval == 0.0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->ival = (lilint_t)((double)oival/ee->dval);\n                    }\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    if (ee->ival == 0) {\n                        ee->error = EERR_DIVISION_BY_ZERO;\n                    } else {\n                        ee->ival = oival/ee->ival;\n                    }\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 7370,
        "comment": ""
      },
      {
        "name": "ee_addsub",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1479,
        "end_line": 1576,
        "start_byte": 42541,
        "end_byte": 45513,
        "signature": "static void ee_addsub(expreval_t* ee)",
        "full_definition": "static void ee_addsub(expreval_t* ee)\n{\n    ee_muldiv(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error && !ee_invalidpunct(ee->code[ee->head + 1]) &&\n        (ee->code[ee->head] == '+' ||\n         ee->code[ee->head] == '-')) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n\n        switch (ee->code[ee->head]) {\n        case '+':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_muldiv(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->dval = ee->dval+odval;\n                    break;\n                case EE_INT:\n                    ee->dval = ee->ival+odval;\n                    ee->type = EE_FLOAT;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_muldiv(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->dval = ee->dval+oival;\n                    ee->type = EE_FLOAT;\n                    break;\n                case EE_INT:\n                    ee->ival = ee->ival+oival;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case '-':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_muldiv(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->dval = odval-ee->dval;\n                    break;\n                case EE_INT:\n                    ee->dval = odval-ee->ival;\n                    ee->type = EE_FLOAT;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_muldiv(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->dval = (double)oival-ee->dval;\n                    ee->type = EE_FLOAT;\n                    break;\n                case EE_INT:\n                    ee->ival = oival-ee->ival;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 2972,
        "comment": ""
      },
      {
        "name": "ee_shift",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1578,
        "end_line": 1676,
        "start_byte": 45515,
        "end_byte": 48620,
        "signature": "static void ee_shift(expreval_t* ee)",
        "full_definition": "static void ee_shift(expreval_t* ee)\n{\n    ee_addsub(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error &&\n        ((ee->code[ee->head] == '<' && ee->code[ee->head + 1] == '<') ||\n         (ee->code[ee->head] == '>' && ee->code[ee->head + 1] == '>'))) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n        ee->head++;\n\n        switch (ee->code[ee->head]) {\n        case '<':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_addsub(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (lilint_t)odval << (lilint_t)ee->dval;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (lilint_t)odval << ee->ival;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_addsub(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = oival << (lilint_t)ee->dval;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = oival << ee->ival;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case '>':\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->head++;\n                ee_addsub(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (lilint_t)odval >> (lilint_t)ee->dval;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (lilint_t)odval >> ee->ival;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee->head++;\n                ee_addsub(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = oival >> (lilint_t)ee->dval;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = oival >> ee->ival;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 3105,
        "comment": ""
      },
      {
        "name": "ee_compare",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1678,
        "end_line": 1857,
        "start_byte": 48622,
        "end_byte": 54533,
        "signature": "static void ee_compare(expreval_t* ee)",
        "full_definition": "static void ee_compare(expreval_t* ee)\n{\n    ee_shift(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error &&\n        ((ee->code[ee->head] == '<' && !ee_invalidpunct(ee->code[ee->head + 1])) ||\n         (ee->code[ee->head] == '>' && !ee_invalidpunct(ee->code[ee->head + 1])) ||\n         (ee->code[ee->head] == '<' && ee->code[ee->head + 1] == '=') ||\n         (ee->code[ee->head] == '>' && ee->code[ee->head + 1] == '='))) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n        int op = 4;\n        if (ee->code[ee->head] == '<' && !ee_invalidpunct(ee->code[ee->head + 1])) op = 1;\n        else if (ee->code[ee->head] == '>' && !ee_invalidpunct(ee->code[ee->head + 1])) op = 2;\n        else if (ee->code[ee->head] == '<' && ee->code[ee->head + 1] == '=') op = 3;\n\n        ee->head += op > 2 ? 2 : 1;\n\n        switch (op) {\n        case 1:\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (odval < ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (odval < ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (oival < ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (oival < ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case 2:\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (odval > ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (odval > ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (oival > ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (oival > ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case 3:\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (odval <= ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (odval <= ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (oival <= ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (oival <= ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case 4:\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (odval >= ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (odval >= ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee_shift(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (oival >= ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (oival >= ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 5911,
        "comment": ""
      },
      {
        "name": "ee_equals",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1859,
        "end_line": 1954,
        "start_byte": 54535,
        "end_byte": 57537,
        "signature": "static void ee_equals(expreval_t* ee)",
        "full_definition": "static void ee_equals(expreval_t* ee)\n{\n    ee_compare(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error &&\n        ((ee->code[ee->head] == '=' && ee->code[ee->head + 1] == '=') ||\n         (ee->code[ee->head] == '!' && ee->code[ee->head + 1] == '='))) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n        int op = ee->code[ee->head] == '=' ? 1 : 2;\n        ee->head += 2;\n\n        switch (op) {\n        case 1:\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee_compare(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (odval == ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (odval == ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee_compare(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (oival == ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (oival == ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case 2:\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee_compare(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (odval != ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (odval != ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            case EE_INT:\n                ee_compare(ee);\n                if (ee->error) return;\n                switch (ee->type) {\n                case EE_FLOAT:\n                    ee->ival = (oival != ee->dval)?1:0;\n                    ee->type = EE_INT;\n                    break;\n                case EE_INT:\n                    ee->ival = (oival != ee->ival)?1:0;\n                    break;\n                default:\n                    ee->error = EERR_INVALID_TYPE;\n                    break;\n                }\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 3002,
        "comment": ""
      },
      {
        "name": "ee_bitand",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 1956,
        "end_line": 2006,
        "start_byte": 57539,
        "end_byte": 58960,
        "signature": "static void ee_bitand(expreval_t* ee)",
        "full_definition": "static void ee_bitand(expreval_t* ee)\n{\n    ee_equals(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error &&\n        (ee->code[ee->head] == '&' && !ee_invalidpunct(ee->code[ee->head + 1]))) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n        ee->head++;\n\n        switch (ee->type) {\n        case EE_FLOAT:\n            ee_equals(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = (lilint_t)odval & (lilint_t)ee->dval;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = (lilint_t)odval & ee->ival;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case EE_INT:\n            ee_equals(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = oival & (lilint_t)ee->dval;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = oival & ee->ival;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        default:\n            ee->error = EERR_INVALID_TYPE;\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 1421,
        "comment": ""
      },
      {
        "name": "ee_bitor",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 2008,
        "end_line": 2058,
        "start_byte": 58962,
        "end_byte": 60382,
        "signature": "static void ee_bitor(expreval_t* ee)",
        "full_definition": "static void ee_bitor(expreval_t* ee)\n{\n    ee_bitand(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error &&\n        (ee->code[ee->head] == '|' && !ee_invalidpunct(ee->code[ee->head + 1]))) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n        ee->head++;\n\n        switch (ee->type) {\n        case EE_FLOAT:\n            ee_bitand(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = (lilint_t)odval | (lilint_t)ee->dval;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = (lilint_t)odval | ee->ival;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case EE_INT:\n            ee_bitand(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = oival | (lilint_t)ee->dval;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = oival | ee->ival;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        default:\n            ee->error = EERR_INVALID_TYPE;\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 1420,
        "comment": ""
      },
      {
        "name": "ee_logand",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 2060,
        "end_line": 2110,
        "start_byte": 60384,
        "end_byte": 61782,
        "signature": "static void ee_logand(expreval_t* ee)",
        "full_definition": "static void ee_logand(expreval_t* ee)\n{\n    ee_bitor(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error &&\n        (ee->code[ee->head] == '&' && ee->code[ee->head + 1] == '&')) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n        ee->head += 2;\n\n        switch (ee->type) {\n        case EE_FLOAT:\n            ee_bitor(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = (odval && ee->dval)?1:0;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = (odval && ee->ival)?1:0;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case EE_INT:\n            ee_bitor(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = (oival && ee->dval)?1:0;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = (oival && ee->ival)?1:0;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        default:\n            ee->error = EERR_INVALID_TYPE;\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 1398,
        "comment": ""
      },
      {
        "name": "ee_logor",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 2112,
        "end_line": 2162,
        "start_byte": 61784,
        "end_byte": 63184,
        "signature": "static void ee_logor(expreval_t* ee)",
        "full_definition": "static void ee_logor(expreval_t* ee)\n{\n    ee_logand(ee);\n    ee_skip_spaces(ee);\n    while (ee->head < ee->len && !ee->error &&\n        (ee->code[ee->head] == '|' && ee->code[ee->head + 1] == '|')) {\n        double odval = ee->dval;\n        lilint_t oival = ee->ival;\n        ee->head += 2;\n\n        switch (ee->type) {\n        case EE_FLOAT:\n            ee_logand(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = (odval || ee->dval)?1:0;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = (odval || ee->ival)?1:0;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        case EE_INT:\n            ee_logand(ee);\n            if (ee->error) return;\n            switch (ee->type) {\n            case EE_FLOAT:\n                ee->ival = (oival || ee->dval)?1:0;\n                ee->type = EE_INT;\n                break;\n            case EE_INT:\n                ee->ival = (oival || ee->ival)?1:0;\n                break;\n            default:\n                ee->error = EERR_INVALID_TYPE;\n                break;\n            }\n            break;\n        default:\n            ee->error = EERR_INVALID_TYPE;\n            break;\n        }\n\n        ee_skip_spaces(ee);\n    }\n}",
        "definition_length": 1400,
        "comment": ""
      },
      {
        "name": "ee_expr",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "expreval_t* ee"
        ],
        "is_static": true,
        "start_line": 2164,
        "end_line": 2173,
        "start_byte": 63186,
        "end_byte": 63461,
        "signature": "static void ee_expr(expreval_t* ee)",
        "full_definition": "static void ee_expr(expreval_t* ee)\n{\n    ee_logor(ee);\n    /* invalid expression doesn't really matter, it is only used to stop\n     * the expression parsing. */\n    if (ee->error == EERR_INVALID_EXPRESSION) {\n        ee->error = EERR_NO_ERROR;\n        ee->ival = 1;\n    }\n}",
        "definition_length": 275,
        "comment": ""
      },
      {
        "name": "lil_eval_expr",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "lil_value_t code"
        ],
        "is_static": false,
        "start_line": 2175,
        "end_line": 2213,
        "start_byte": 63463,
        "end_byte": 64566,
        "signature": "lil_value_t lil_eval_expr(lil_t lil, lil_value_t code)",
        "full_definition": "lil_value_t lil_eval_expr(lil_t lil, lil_value_t code)\n{\n    expreval_t ee;\n    code = lil_subst_to_value(lil, code);\n    if (lil->error) return NULL;\n    ee.code = lil_to_string(code);\n    /* an empty expression equals to 0 so that it can be used as a false value\n     * in conditionals */\n    if (!ee.code[0]) {\n        lil_free_value(code);\n        return lil_alloc_integer(0);\n    }\n    ee.head = 0;\n    ee.len = code->l;\n    ee.ival = 0;\n    ee.dval = 0;\n    ee.type = EE_INT;\n    ee.error = 0;\n    ee_expr(&ee);\n    lil_free_value(code);\n    if (ee.error) {\n        switch (ee.error) {\n        case EERR_DIVISION_BY_ZERO:\n            lil_set_error(lil, \"division by zero in expression\");\n            break;\n        case EERR_INVALID_TYPE:\n            lil_set_error(lil, \"mixing invalid types in expression\");\n            break;\n        case EERR_SYNTAX_ERROR:\n            lil_set_error(lil, \"expression syntax error\");\n            break;\n        }\n        return NULL;\n    }\n    if (ee.type == EE_INT)\n        return lil_alloc_integer(ee.ival);\n    else\n        return lil_alloc_double(ee.dval);\n}",
        "definition_length": 1103,
        "comment": ""
      },
      {
        "name": "lil_unused_name",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "const char* part"
        ],
        "is_static": false,
        "start_line": 2215,
        "end_line": 2229,
        "start_byte": 64568,
        "end_byte": 65010,
        "signature": "lil_value_t lil_unused_name(lil_t lil, const char* part)",
        "full_definition": "lil_value_t lil_unused_name(lil_t lil, const char* part)\n{\n    char* name = malloc(strlen(part) + 64);\n    lil_value_t val;\n    size_t i;\n    for (i=0; i<(size_t)-1; i++) {\n        sprintf(name, \"!!un!%s!%09u!nu!!\", part, (unsigned int)i);\n        if (find_cmd(lil, name)) continue;\n        if (lil_find_var(lil, lil->env, name)) continue;\n        val = lil_alloc_string(name);\n        free(name);\n        return val;\n    }\n    return NULL;\n}",
        "definition_length": 442,
        "comment": ""
      },
      {
        "name": "lil_arg",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_value_t* argv",
          "size_t index"
        ],
        "is_static": false,
        "start_line": 2231,
        "end_line": 2234,
        "start_byte": 65012,
        "end_byte": 65106,
        "signature": "lil_value_t lil_arg(lil_value_t* argv, size_t index)",
        "full_definition": "lil_value_t lil_arg(lil_value_t* argv, size_t index)\n{\n    return argv ? argv[index] : NULL;\n}",
        "definition_length": 94,
        "comment": ""
      },
      {
        "name": "lil_to_string",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "lil_value_t val"
        ],
        "is_static": false,
        "start_line": 2236,
        "end_line": 2239,
        "start_byte": 65108,
        "end_byte": 65196,
        "signature": "const char* lil_to_string(lil_value_t val)",
        "full_definition": "const char* lil_to_string(lil_value_t val)\n{\n    return (val && val->l) ? val->d : \"\";\n}",
        "definition_length": 88,
        "comment": ""
      },
      {
        "name": "lil_to_double",
        "type": "definition",
        "return_type": "double",
        "parameters": [
          "lil_value_t val"
        ],
        "is_static": false,
        "start_line": 2241,
        "end_line": 2244,
        "start_byte": 65198,
        "end_byte": 65276,
        "signature": "double lil_to_double(lil_value_t val)",
        "full_definition": "double lil_to_double(lil_value_t val)\n{\n    return atof(lil_to_string(val));\n}",
        "definition_length": 78,
        "comment": ""
      },
      {
        "name": "lil_to_integer",
        "type": "definition",
        "return_type": "lilint_t",
        "parameters": [
          "lil_value_t val"
        ],
        "is_static": false,
        "start_line": 2246,
        "end_line": 2249,
        "start_byte": 65278,
        "end_byte": 65370,
        "signature": "lilint_t lil_to_integer(lil_value_t val)",
        "full_definition": "lilint_t lil_to_integer(lil_value_t val)\n{\n    return (lilint_t)atoll(lil_to_string(val));\n}",
        "definition_length": 92,
        "comment": ""
      },
      {
        "name": "lil_to_boolean",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "lil_value_t val"
        ],
        "is_static": false,
        "start_line": 2251,
        "end_line": 2264,
        "start_byte": 65372,
        "end_byte": 65690,
        "signature": "int lil_to_boolean(lil_value_t val)",
        "full_definition": "int lil_to_boolean(lil_value_t val)\n{\n    const char* s = lil_to_string(val);\n    size_t i, dots = 0;\n    if (!s[0]) {return 0;}\n    for (i=0; s[i]; i++) {\n        if (s[i] != '0' && s[i] != '.') return 1;\n        if (s[i] == '.') {\n            if (dots) return 1;\n            dots = 1;\n        }\n    }\n    return 0;\n}",
        "definition_length": 318,
        "comment": ""
      },
      {
        "name": "lil_alloc_string",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "const char* str"
        ],
        "is_static": false,
        "start_line": 2266,
        "end_line": 2269,
        "start_byte": 65692,
        "end_byte": 65770,
        "signature": "lil_value_t lil_alloc_string(const char* str)",
        "full_definition": "lil_value_t lil_alloc_string(const char* str)\n{\n    return alloc_value(str);\n}",
        "definition_length": 78,
        "comment": ""
      },
      {
        "name": "lil_alloc_string_len",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "const char* str",
          "size_t len"
        ],
        "is_static": false,
        "start_line": 2271,
        "end_line": 2274,
        "start_byte": 65772,
        "end_byte": 65875,
        "signature": "lil_value_t lil_alloc_string_len(const char* str, size_t len)",
        "full_definition": "lil_value_t lil_alloc_string_len(const char* str, size_t len)\n{\n    return alloc_value_len(str, len);\n}",
        "definition_length": 103,
        "comment": ""
      },
      {
        "name": "lil_alloc_double",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "double num"
        ],
        "is_static": false,
        "start_line": 2276,
        "end_line": 2281,
        "start_byte": 65877,
        "end_byte": 66001,
        "signature": "lil_value_t lil_alloc_double(double num)",
        "full_definition": "lil_value_t lil_alloc_double(double num)\n{\n    char buff[128];\n    sprintf(buff, \"%f\", num);\n    return alloc_value(buff);\n}",
        "definition_length": 124,
        "comment": ""
      },
      {
        "name": "lil_alloc_integer",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lilint_t num"
        ],
        "is_static": false,
        "start_line": 2283,
        "end_line": 2288,
        "start_byte": 66003,
        "end_byte": 66139,
        "signature": "lil_value_t lil_alloc_integer(lilint_t num)",
        "full_definition": "lil_value_t lil_alloc_integer(lilint_t num)\n{\n    char buff[128];\n    sprintf(buff, LILINT_PRINTF, num);\n    return alloc_value(buff);\n}",
        "definition_length": 136,
        "comment": ""
      },
      {
        "name": "lil_free",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": false,
        "start_line": 2290,
        "end_line": 2313,
        "start_byte": 66141,
        "end_byte": 66736,
        "signature": "void lil_free(lil_t lil)",
        "full_definition": "void lil_free(lil_t lil)\n{\n    size_t i;\n    if (!lil) return;\n    free(lil->err_msg);\n    lil_free_value(lil->empty);\n    while (lil->env) {\n        lil_env_t next = lil->env->parent;\n        lil_free_env(lil->env);\n        lil->env = next;\n    }\n    for (i=0; i<lil->cmds; i++) {\n        if (lil->cmd[i]->argnames)\n            lil_free_list(lil->cmd[i]->argnames);\n        lil_free_value(lil->cmd[i]->code);\n        free(lil->cmd[i]->name);\n        free(lil->cmd[i]);\n    }\n    hm_destroy(&lil->cmdmap);\n    free(lil->cmd);\n    free(lil->dollarprefix);\n    free(lil->catcher);\n    free(lil);\n}",
        "definition_length": 595,
        "comment": ""
      },
      {
        "name": "lil_set_data",
        "type": "definition",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "void* data"
        ],
        "is_static": false,
        "start_line": 2315,
        "end_line": 2318,
        "start_byte": 66738,
        "end_byte": 66811,
        "signature": "LILAPI void lil_set_data(lil_t lil, void* data)",
        "full_definition": "LILAPI void lil_set_data(lil_t lil, void* data)\n{\n    lil->data = data;\n}",
        "definition_length": 73,
        "comment": ""
      },
      {
        "name": "lil_get_data",
        "type": "definition",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": false,
        "start_line": 2320,
        "end_line": 2323,
        "start_byte": 66813,
        "end_byte": 66875,
        "signature": "LILAPI void* lil_get_data(lil_t lil)",
        "full_definition": "LILAPI void* lil_get_data(lil_t lil)\n{\n    return lil->data;\n}",
        "definition_length": 62,
        "comment": ""
      },
      {
        "name": "fnc_embed_write",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "const char* msg"
        ],
        "is_static": true,
        "start_line": 2325,
        "end_line": 2331,
        "start_byte": 66877,
        "end_byte": 67121,
        "signature": "static LILCALLBACK void fnc_embed_write(lil_t lil, const char* msg)",
        "full_definition": "static LILCALLBACK void fnc_embed_write(lil_t lil, const char* msg)\n{\n    size_t len = strlen(msg) + 1;\n    lil->embed = realloc(lil->embed, lil->embedlen + len);\n    memcpy(lil->embed + lil->embedlen, msg, len);\n    lil->embedlen += len - 1;\n}",
        "definition_length": 244,
        "comment": ""
      },
      {
        "name": "lil_embedded",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "lil_t lil",
          "const char* code",
          "unsigned int flags"
        ],
        "is_static": false,
        "start_line": 2333,
        "end_line": 2418,
        "start_byte": 67123,
        "end_byte": 70144,
        "signature": "char* lil_embedded(lil_t lil, const char* code, unsigned int flags)",
        "full_definition": "char* lil_embedded(lil_t lil, const char* code, unsigned int flags)\n{\n    char* prev_embed = lil->embed;\n    size_t prev_embedlen = lil->embedlen;\n    lil_callback_proc_t prev_write = lil->callback[LIL_CALLBACK_WRITE];\n    char* lilcode = NULL;\n    size_t lilcodelen = 0;\n    char* cont = NULL;\n    size_t contlen = 0;\n    size_t head = 0, codelen = strlen(code);\n    char* result;\n\n    lil->callback[LIL_CALLBACK_WRITE] = (lil_callback_proc_t)fnc_embed_write;\n    lil->embed = NULL;\n    lil->embedlen = 0;\n\n    while (head < codelen) {\n        if (head < codelen - 4 &&\n            code[head] == '<' &&\n            code[head + 1] == '?' &&\n            code[head + 2] == 'l' &&\n            code[head + 3] == 'i' &&\n            code[head + 4] == 'l') {\n            head += 5;\n            if (contlen) {\n                lilcode = realloc(lilcode, lilcodelen + contlen + 10);\n                memcpy(lilcode + lilcodelen, \"\\nwrite {\", 8);\n                memcpy(lilcode + lilcodelen + 8, cont, contlen);\n                lilcode[lilcodelen + contlen + 8] = '}';\n                lilcode[lilcodelen + contlen + 9] = '\\n';\n                lilcodelen += contlen + 10;\n                free(cont);\n                cont = NULL;\n                contlen = 0;\n            }\n            while (head < codelen) {\n                if (head < codelen - 1 && code[head] == '?' && code[head + 1] == '>') {\n                    head += 2;\n                    break;\n                }\n                lilcode = realloc(lilcode, lilcodelen + 1);\n                lilcode[lilcodelen++] = code[head++];\n            }\n            lilcode = realloc(lilcode, lilcodelen + 1);\n            lilcode[lilcodelen++] = '\\n';\n        } else {\n            if (code[head] == '{' || code[head] == '}') {\n                cont = realloc(cont, contlen + 6);\n                cont[contlen++] = '}';\n                cont[contlen++] = '\"';\n                cont[contlen++] = '\\\\';\n                if (code[head] == '{')\n                    cont[contlen++] = 'o';\n                else\n                    cont[contlen++] = 'c';\n                cont[contlen++] = '\"';\n                cont[contlen++] = '{';\n                head++;\n            } else {\n                cont = realloc(cont, contlen + 1);\n                cont[contlen++] = code[head++];\n            }\n        }\n    }\n    if (contlen) {\n        lilcode = realloc(lilcode, lilcodelen + contlen + 10);\n        memcpy(lilcode + lilcodelen, \"\\nwrite {\", 8);\n        memcpy(lilcode + lilcodelen + 8, cont, contlen);\n        lilcode[lilcodelen + contlen + 8] = '}';\n        lilcode[lilcodelen + contlen + 9] = '\\n';\n        lilcodelen += contlen + 10;\n        free(cont);\n    }\n\n    lilcode = realloc(lilcode, lilcodelen + 1);\n    lilcode[lilcodelen] = 0;\n    lil_free_value(lil_parse(lil, lilcode, 0, 1));\n    free(lilcode);\n    result = lil->embed ? lil->embed : strclone(\"\");\n\n    lil->embed = prev_embed;\n    lil->embedlen = prev_embedlen;\n    lil->callback[LIL_CALLBACK_WRITE] = prev_write;\n\n    return result;\n}",
        "definition_length": 3021,
        "comment": ""
      },
      {
        "name": "lil_freemem",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "void* ptr"
        ],
        "is_static": false,
        "start_line": 2420,
        "end_line": 2423,
        "start_byte": 70146,
        "end_byte": 70192,
        "signature": "void lil_freemem(void* ptr)",
        "full_definition": "void lil_freemem(void* ptr)\n{\n    free(ptr);\n}",
        "definition_length": 46,
        "comment": ""
      },
      {
        "name": "lil_write",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil",
          "const char* msg"
        ],
        "is_static": false,
        "start_line": 2425,
        "end_line": 2431,
        "start_byte": 70194,
        "end_byte": 70442,
        "signature": "void lil_write(lil_t lil, const char* msg)",
        "full_definition": "void lil_write(lil_t lil, const char* msg)\n{\n    if (lil->callback[LIL_CALLBACK_WRITE]) {\n        lil_write_callback_proc_t proc = (lil_write_callback_proc_t)lil->callback[LIL_CALLBACK_WRITE];\n        proc(lil, msg);\n    } else printf(\"%s\", msg);\n}",
        "definition_length": 248,
        "comment": ""
      },
      {
        "name": "fnc_reflect",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2433,
        "end_line": 2538,
        "start_byte": 70444,
        "end_byte": 74250,
        "signature": "static LILCALLBACK lil_value_t fnc_reflect(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_reflect(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_func_t func;\n    const char* type;\n    size_t i;\n    lil_value_t r;\n    if (!argc) return NULL;\n    type = lil_to_string(argv[0]);\n    if (!strcmp(type, \"version\")) {\n        return lil_alloc_string(LIL_VERSION_STRING);\n    }\n    if (!strcmp(type, \"args\")) {\n        if (argc < 2) return NULL;\n        func = find_cmd(lil, lil_to_string(argv[1]));\n        if (!func || !func->argnames) return NULL;\n        return lil_list_to_value(func->argnames, 1);\n    }\n    if (!strcmp(type, \"body\")) {\n        if (argc < 2) return NULL;\n        func = find_cmd(lil, lil_to_string(argv[1]));\n        if (!func || func->proc) return NULL;\n        return lil_clone_value(func->code);\n    }\n    if (!strcmp(type, \"func-count\")) {\n        return lil_alloc_integer(lil->cmds);\n    }\n    if (!strcmp(type, \"funcs\")) {\n        lil_list_t funcs = lil_alloc_list();\n        for (i=0; i<lil->cmds; i++)\n            lil_list_append(funcs, lil_alloc_string(lil->cmd[i]->name));\n        r = lil_list_to_value(funcs, 1);\n        lil_free_list(funcs);\n        return r;\n    }\n    if (!strcmp(type, \"vars\")) {\n        lil_list_t vars = lil_alloc_list();\n        lil_env_t env = lil->env;\n        while (env) {\n            for (i=0; i<env->vars; i++)\n                lil_list_append(vars, lil_alloc_string(env->var[i]->n));\n            env = env->parent;\n        }\n        r = lil_list_to_value(vars, 1);\n        lil_free_list(vars);\n        return r;\n    }\n    if (!strcmp(type, \"globals\")) {\n        lil_list_t vars = lil_alloc_list();\n        for (i=0; i<lil->rootenv->vars; i++)\n            lil_list_append(vars, lil_alloc_string(lil->rootenv->var[i]->n));\n        r = lil_list_to_value(vars, 1);\n        lil_free_list(vars);\n        return r;\n    }\n    if (!strcmp(type, \"has-func\")) {\n        const char* target;\n        if (argc == 1) return NULL;\n        target = lil_to_string(argv[1]);\n        return hm_has(&lil->cmdmap, target) ? lil_alloc_string(\"1\") : NULL;\n    }\n    if (!strcmp(type, \"has-var\")) {\n        const char* target;\n        lil_env_t env = lil->env;\n        if (argc == 1) return NULL;\n        target = lil_to_string(argv[1]);\n        while (env) {\n            if (hm_has(&env->varmap, target)) return lil_alloc_string(\"1\");\n            env = env->parent;\n        }\n        return NULL;\n    }\n    if (!strcmp(type, \"has-global\")) {\n        const char* target;\n        if (argc == 1) return NULL;\n        target = lil_to_string(argv[1]);\n        for (i=0; i<lil->rootenv->vars; i++)\n            if (!strcmp(target, lil->rootenv->var[i]->n)) return lil_alloc_string(\"1\");\n        return NULL;\n    }\n    if (!strcmp(type, \"error\")) {\n        return lil->err_msg ? lil_alloc_string(lil->err_msg) : NULL;\n    }\n    if (!strcmp(type, \"dollar-prefix\")) {\n        lil_value_t r;\n        if (argc == 1) return lil_alloc_string(lil->dollarprefix);\n        r = lil_alloc_string(lil->dollarprefix);\n        free(lil->dollarprefix);\n        lil->dollarprefix = strclone(lil_to_string(argv[1]));\n        return r;\n    }\n    if (!strcmp(type, \"this\")) {\n        lil_env_t env = lil->env;\n        while (env != lil->rootenv && !env->catcher_for && !env->func) env = env->parent;\n        if (env->catcher_for) return lil_alloc_string(lil->catcher);\n        if (env == lil->rootenv) return lil_alloc_string(lil->rootcode);\n        return env->func ? env->func->code : NULL;\n    }\n    if (!strcmp(type, \"name\")) {\n        lil_env_t env = lil->env;\n        while (env != lil->rootenv && !env->catcher_for && !env->func) env = env->parent;\n        if (env->catcher_for) return env->catcher_for;\n        if (env == lil->rootenv) return NULL;\n        return env->func ? lil_alloc_string(env->func->name) : NULL;\n    }\n    return NULL;\n}",
        "definition_length": 3806,
        "comment": ""
      },
      {
        "name": "fnc_func",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2540,
        "end_line": 2569,
        "start_byte": 74252,
        "end_byte": 75289,
        "signature": "static LILCALLBACK lil_value_t fnc_func(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_func(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t name;\n    lil_func_t cmd;\n    lil_list_t fargs;\n    if (argc < 1) return NULL;\n    if (argc >= 3) {\n        name = lil_clone_value(argv[0]);\n        fargs = lil_subst_to_list(lil, argv[1]);\n        cmd = add_func(lil, lil_to_string(argv[0]));\n        cmd->argnames = fargs;\n        cmd->code = lil_clone_value(argv[2]);\n    } else {\n        name = lil_unused_name(lil, \"anonymous-function\");\n        if (argc < 2) {\n            lil_value_t tmp = lil_alloc_string(\"args\");\n            fargs = lil_subst_to_list(lil, tmp);\n            lil_free_value(tmp);\n            cmd = add_func(lil, lil_to_string(name));\n            cmd->argnames = fargs;\n            cmd->code = lil_clone_value(argv[0]);\n        } else {\n            fargs = lil_subst_to_list(lil, argv[0]);\n            cmd = add_func(lil, lil_to_string(name));\n            cmd->argnames = fargs;\n            cmd->code = lil_clone_value(argv[1]);\n        }\n    }\n    return name;\n}",
        "definition_length": 1037,
        "comment": ""
      },
      {
        "name": "fnc_rename",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2571,
        "end_line": 2598,
        "start_byte": 75291,
        "end_byte": 76102,
        "signature": "static LILCALLBACK lil_value_t fnc_rename(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_rename(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t r;\n    lil_func_t func;\n    const char* oldname;\n    const char* newname;\n    if (argc < 2) return NULL;\n    oldname = lil_to_string(argv[0]);\n    newname = lil_to_string(argv[1]);\n    func = find_cmd(lil, oldname);\n    if (!func) {\n        char* msg = malloc(24 + strlen(oldname));\n        sprintf(msg, \"unknown function '%s'\", oldname);\n        lil_set_error_at(lil, lil->head, msg);\n        free(msg);\n        return NULL;\n    }\n    r = lil_alloc_string(func->name);\n    if (newname[0]) {\n        hm_put(&lil->cmdmap, oldname, 0);\n        hm_put(&lil->cmdmap, newname, func);\n        free(func->name);\n        func->name = strclone(newname);\n    } else {\n        del_func(lil, func);\n    }\n    return r;\n}",
        "definition_length": 811,
        "comment": ""
      },
      {
        "name": "fnc_unusedname",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2600,
        "end_line": 2603,
        "start_byte": 76104,
        "end_byte": 76279,
        "signature": "static LILCALLBACK lil_value_t fnc_unusedname(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_unusedname(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    return lil_unused_name(lil, argc > 0 ? lil_to_string(argv[0]) : \"unusedname\");\n}",
        "definition_length": 175,
        "comment": ""
      },
      {
        "name": "fnc_quote",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2605,
        "end_line": 2616,
        "start_byte": 76281,
        "end_byte": 76584,
        "signature": "static LILCALLBACK lil_value_t fnc_quote(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_quote(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t r;\n    size_t i;\n    if (argc < 1) return NULL;\n    r = alloc_value(NULL);\n    for (i=0; i<argc; i++) {\n        if (i) lil_append_char(r, ' ');\n        lil_append_val(r, argv[i]);\n    }\n    return r;\n}",
        "definition_length": 303,
        "comment": ""
      },
      {
        "name": "fnc_set",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2618,
        "end_line": 2634,
        "start_byte": 76586,
        "end_byte": 77152,
        "signature": "static LILCALLBACK lil_value_t fnc_set(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_set(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t i = 0;\n    lil_var_t var = NULL;\n    int access = LIL_SETVAR_LOCAL;\n    if (!argc) return NULL;\n    if (!strcmp(lil_to_string(argv[0]), \"global\")) {\n        i = 1;\n        access = LIL_SETVAR_GLOBAL;\n    }\n    while (i < argc) {\n        if (argc == i + 1) return lil_clone_value(lil_get_var(lil, lil_to_string(argv[i])));\n        var = lil_set_var(lil, lil_to_string(argv[i]), argv[i + 1], access);\n        i += 2;\n    }\n    return var ? lil_clone_value(var->v) : NULL;\n}",
        "definition_length": 566,
        "comment": ""
      },
      {
        "name": "fnc_local",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2636,
        "end_line": 2645,
        "start_byte": 77154,
        "end_byte": 77491,
        "signature": "static LILCALLBACK lil_value_t fnc_local(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_local(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t i;\n    for (i=0; i<argc; i++) {\n        const char* varname = lil_to_string(argv[i]);\n        if (!lil_find_local_var(lil, lil->env, varname))\n            lil_set_var(lil, varname, lil->empty, LIL_SETVAR_LOCAL_NEW);\n    }\n    return NULL;\n}",
        "definition_length": 337,
        "comment": ""
      },
      {
        "name": "fnc_write",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2647,
        "end_line": 2658,
        "start_byte": 77493,
        "end_byte": 77837,
        "signature": "static LILCALLBACK lil_value_t fnc_write(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_write(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t i;\n    lil_value_t msg = lil_alloc_string(NULL);\n    for (i=0; i<argc; i++) {\n        if (i) lil_append_char(msg, ' ');\n        lil_append_val(msg, argv[i]);\n    }\n    lil_write(lil, lil_to_string(msg));\n    lil_free_value(msg);\n    return NULL;\n}",
        "definition_length": 344,
        "comment": ""
      },
      {
        "name": "fnc_print",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2660,
        "end_line": 2665,
        "start_byte": 77839,
        "end_byte": 78001,
        "signature": "static LILCALLBACK lil_value_t fnc_print(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_print(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    fnc_write(lil, argc, argv);\n    lil_write(lil, \"\\n\");\n    return NULL;\n}",
        "definition_length": 162,
        "comment": ""
      },
      {
        "name": "fnc_eval",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2667,
        "end_line": 2682,
        "start_byte": 78003,
        "end_byte": 78478,
        "signature": "static LILCALLBACK lil_value_t fnc_eval(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_eval(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc == 1) return lil_parse_value(lil, argv[0], 0);\n    if (argc > 1) {\n        lil_value_t val = alloc_value(NULL), r;\n        size_t i;\n        for (i=0; i<argc; i++) {\n            if (i) lil_append_char(val, ' ');\n            lil_append_val(val, argv[i]);\n        }\n        r = lil_parse_value(lil, val, 0);\n        lil_free_value(val);\n        return r;\n    }\n    return NULL;\n}",
        "definition_length": 475,
        "comment": ""
      },
      {
        "name": "fnc_topeval",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2684,
        "end_line": 2695,
        "start_byte": 78480,
        "end_byte": 78826,
        "signature": "static LILCALLBACK lil_value_t fnc_topeval(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_topeval(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_env_t thisenv = lil->env;\n    lil_env_t thisdownenv = lil->downenv;\n    lil_value_t r;\n    lil->env = lil->rootenv;\n    lil->downenv = thisenv;\n    r = fnc_eval(lil, argc, argv);\n    lil->downenv = thisdownenv;\n    lil->env = thisenv;\n    return r;\n}",
        "definition_length": 346,
        "comment": ""
      },
      {
        "name": "fnc_upeval",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2697,
        "end_line": 2709,
        "start_byte": 78828,
        "end_byte": 79243,
        "signature": "static LILCALLBACK lil_value_t fnc_upeval(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_upeval(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_env_t thisenv = lil->env;\n    lil_env_t thisdownenv = lil->downenv;\n    lil_value_t r;\n    if (lil->rootenv == thisenv) return fnc_eval(lil, argc, argv);\n    lil->env = thisenv->parent;\n    lil->downenv = thisenv;\n    r = fnc_eval(lil, argc, argv);\n    lil->env = thisenv;\n    lil->downenv = thisdownenv;\n    return r;\n}",
        "definition_length": 415,
        "comment": ""
      },
      {
        "name": "fnc_downeval",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2711,
        "end_line": 2723,
        "start_byte": 79245,
        "end_byte": 79624,
        "signature": "static LILCALLBACK lil_value_t fnc_downeval(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_downeval(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t r;\n    lil_env_t upenv = lil->env;\n    lil_env_t downenv = lil->downenv;\n    if (!downenv) return fnc_eval(lil, argc, argv);\n    lil->downenv = NULL;\n    lil->env = downenv;\n    r = fnc_eval(lil, argc, argv);\n    lil->downenv = downenv;\n    lil->env = upenv;\n    return r;\n}",
        "definition_length": 379,
        "comment": ""
      },
      {
        "name": "fnc_enveval",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2725,
        "end_line": 2783,
        "start_byte": 79626,
        "end_byte": 81840,
        "signature": "static LILCALLBACK lil_value_t fnc_enveval(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_enveval(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t r;\n    lil_list_t invars = NULL;\n    lil_list_t outvars = NULL;\n    lil_value_t* varvalues = NULL;\n    int codeindex;\n    size_t i;\n    if (argc < 1) return NULL;\n    if (argc == 1) codeindex = 0;\n    else if (argc >= 2) {\n        invars = lil_subst_to_list(lil, argv[0]);\n        varvalues = malloc(sizeof(lil_value_t)*lil_list_size(invars));\n        for (i=0; i<lil_list_size(invars); i++)\n            varvalues[i] = lil_clone_value(lil_get_var(lil, lil_to_string(lil_list_get(invars, i))));\n        if (argc > 2) {\n            codeindex = 2;\n            outvars = lil_subst_to_list(lil, argv[1]);\n        } else {\n            codeindex = 1;\n        }\n    }\n    lil_push_env(lil);\n    if (invars) {\n        for (i=0; i<lil_list_size(invars); i++) {\n            lil_set_var(lil, lil_to_string(lil_list_get(invars, i)), varvalues[i], LIL_SETVAR_LOCAL_NEW);\n            lil_free_value(varvalues[i]);\n        }\n    }\n    r = lil_parse_value(lil, argv[codeindex], 0);\n    if (invars || outvars) {\n        if (outvars) {\n            varvalues = realloc(varvalues, sizeof(lil_value_t)*lil_list_size(outvars));\n            for (i=0; i<lil_list_size(outvars); i++)\n                varvalues[i] = lil_clone_value(lil_get_var(lil, lil_to_string(lil_list_get(outvars, i))));\n        } else {\n            for (i=0; i<lil_list_size(invars); i++)\n                varvalues[i] = lil_clone_value(lil_get_var(lil, lil_to_string(lil_list_get(invars, i))));\n        }\n    }\n    lil_pop_env(lil);\n    if (invars) {\n        if (outvars) {\n            for (i=0; i<lil_list_size(outvars); i++) {\n                lil_set_var(lil, lil_to_string(lil_list_get(outvars, i)), varvalues[i], LIL_SETVAR_LOCAL);\n                lil_free_value(varvalues[i]);\n            }\n        } else {\n            for (i=0; i<lil_list_size(invars); i++) {\n                lil_set_var(lil, lil_to_string(lil_list_get(invars, i)), varvalues[i], LIL_SETVAR_LOCAL);\n                lil_free_value(varvalues[i]);\n            }\n        }\n        lil_free_list(invars);\n        if (outvars) lil_free_list(outvars);\n        free(varvalues);\n    }\n    return r;\n}",
        "definition_length": 2214,
        "comment": ""
      },
      {
        "name": "fnc_jaileval",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2785,
        "end_line": 2807,
        "start_byte": 81842,
        "end_byte": 82474,
        "signature": "static LILCALLBACK lil_value_t fnc_jaileval(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_jaileval(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t i;\n    lil_t sublil;\n    lil_value_t r;\n    size_t base = 0;\n    if (!argc) return NULL;\n    if (!strcmp(lil_to_string(argv[0]), \"clean\")) {\n        base = 1;\n        if (argc == 1) return NULL;\n    }\n    sublil = lil_new();\n    if (base != 1) {\n        for (i=lil->syscmds; i<lil->cmds; i++) {\n            lil_func_t fnc = lil->cmd[i];\n            if (!fnc->proc) continue;\n            lil_register(sublil, fnc->name, fnc->proc);\n        }\n    }\n    r = lil_parse_value(sublil, argv[base], 1);\n    lil_free(sublil);\n    return r;\n}",
        "definition_length": 632,
        "comment": ""
      },
      {
        "name": "fnc_count",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2809,
        "end_line": 2818,
        "start_byte": 82476,
        "end_byte": 82790,
        "signature": "static LILCALLBACK lil_value_t fnc_count(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_count(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list;\n    char buff[64];\n    if (!argc) return alloc_value(\"0\");\n    list = lil_subst_to_list(lil, argv[0]);\n    sprintf(buff, \"%u\", (unsigned int)list->c);\n    lil_free_list(list);\n    return alloc_value(buff);\n}",
        "definition_length": 314,
        "comment": ""
      },
      {
        "name": "fnc_index",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2820,
        "end_line": 2834,
        "start_byte": 82792,
        "end_byte": 83194,
        "signature": "static LILCALLBACK lil_value_t fnc_index(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_index(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list;\n    size_t index;\n    lil_value_t r;\n    if (argc < 2) return NULL;\n    list = lil_subst_to_list(lil, argv[0]);\n    index = (size_t)lil_to_integer(argv[1]);\n    if (index >= list->c)\n        r = NULL;\n    else\n        r = lil_clone_value(list->v[index]);\n    lil_free_list(list);\n    return r;\n}",
        "definition_length": 402,
        "comment": ""
      },
      {
        "name": "fnc_indexof",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2836,
        "end_line": 2850,
        "start_byte": 83196,
        "end_byte": 83659,
        "signature": "static LILCALLBACK lil_value_t fnc_indexof(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_indexof(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list;\n    size_t index;\n    lil_value_t r = NULL;\n    if (argc < 2) return NULL;\n    list = lil_subst_to_list(lil, argv[0]);\n    for (index = 0; index < list->c; index++)\n        if (!strcmp(lil_to_string(list->v[index]), lil_to_string(argv[1]))) {\n            r = lil_alloc_integer(index);\n            break;\n        }\n    lil_free_list(list);\n    return r;\n}",
        "definition_length": 463,
        "comment": ""
      },
      {
        "name": "fnc_append",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2852,
        "end_line": 2874,
        "start_byte": 83661,
        "end_byte": 84383,
        "signature": "static LILCALLBACK lil_value_t fnc_append(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_append(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list;\n    lil_value_t r;\n    size_t i, base = 1;\n    int access = LIL_SETVAR_LOCAL;\n    const char* varname;\n    if (argc < 2) return NULL;\n    varname = lil_to_string(argv[0]);\n    if (!strcmp(varname, \"global\")) {\n        if (argc < 3) return NULL;\n        varname = lil_to_string(argv[1]);\n        base = 2;\n        access = LIL_SETVAR_GLOBAL;\n    }\n    list = lil_subst_to_list(lil, lil_get_var(lil, varname));\n    for (i=base; i<argc; i++)\n        lil_list_append(list, lil_clone_value(argv[i]));\n    r = lil_list_to_value(list, 1);\n    lil_free_list(list);\n    lil_set_var(lil, varname, r, access);\n    return r;\n}",
        "definition_length": 722,
        "comment": ""
      },
      {
        "name": "fnc_slice",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2876,
        "end_line": 2897,
        "start_byte": 84385,
        "end_byte": 85124,
        "signature": "static LILCALLBACK lil_value_t fnc_slice(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_slice(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list, slice;\n    size_t i;\n    lilint_t from, to;\n    lil_value_t r;\n    if (argc < 1) return NULL;\n    if (argc < 2) return lil_clone_value(argv[0]);\n    from = lil_to_integer(argv[1]);\n    if (from < 0) from = 0;\n    list = lil_subst_to_list(lil, argv[0]);\n    to = argc > 2 ? lil_to_integer(argv[2]) : (lilint_t)list->c;\n    if (to > (lilint_t)list->c) to = list->c;\n    if (to < from) to = from;\n    slice = lil_alloc_list();\n    for (i=(size_t)from; i<(size_t)to; i++)\n        lil_list_append(slice, lil_clone_value(list->v[i]));\n    lil_free_list(list);\n    r = lil_list_to_value(slice, 1);\n    lil_free_list(slice);\n    return r;\n}",
        "definition_length": 739,
        "comment": ""
      },
      {
        "name": "fnc_filter",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2899,
        "end_line": 2925,
        "start_byte": 85126,
        "end_byte": 85988,
        "signature": "static LILCALLBACK lil_value_t fnc_filter(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_filter(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list, filtered;\n    size_t i;\n    lil_value_t r;\n    const char* varname = \"x\";\n    int base = 0;\n    if (argc < 1) return NULL;\n    if (argc < 2) return lil_clone_value(argv[0]);\n    if (argc > 2) {\n        base = 1;\n        varname = lil_to_string(argv[0]);\n    }\n    list = lil_subst_to_list(lil, argv[base]);\n    filtered = lil_alloc_list();\n    for (i=0; i<list->c && !lil->env->breakrun; i++) {\n        lil_set_var(lil, varname, list->v[i], LIL_SETVAR_LOCAL_ONLY);\n        r = lil_eval_expr(lil, argv[base + 1]);\n        if (lil_to_boolean(r))\n            lil_list_append(filtered, lil_clone_value(list->v[i]));\n        lil_free_value(r);\n    }\n    lil_free_list(list);\n    r = lil_list_to_value(filtered, 1);\n    lil_free_list(filtered);\n    return r;\n}",
        "definition_length": 862,
        "comment": ""
      },
      {
        "name": "fnc_list",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2927,
        "end_line": 2937,
        "start_byte": 85990,
        "end_byte": 86308,
        "signature": "static LILCALLBACK lil_value_t fnc_list(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_list(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list = lil_alloc_list();\n    lil_value_t r;\n    size_t i;\n    for (i=0; i<argc; i++)\n        lil_list_append(list, lil_clone_value(argv[i]));\n    r = lil_list_to_value(list, 1);\n    lil_free_list(list);\n    return r;\n}",
        "definition_length": 318,
        "comment": ""
      },
      {
        "name": "fnc_subst",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2939,
        "end_line": 2943,
        "start_byte": 86310,
        "end_byte": 86473,
        "signature": "static LILCALLBACK lil_value_t fnc_subst(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_subst(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc < 1) return NULL;\n    return lil_subst_to_value(lil, argv[0]);\n}",
        "definition_length": 163,
        "comment": ""
      },
      {
        "name": "fnc_concat",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2945,
        "end_line": 2960,
        "start_byte": 86475,
        "end_byte": 86912,
        "signature": "static LILCALLBACK lil_value_t fnc_concat(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_concat(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list;\n    lil_value_t r, tmp;\n    size_t i;\n    if (argc < 1) return NULL;\n    r = lil_alloc_string(\"\");\n    for (i=0; i<argc; i++) {\n        list = lil_subst_to_list(lil, argv[i]);\n        tmp = lil_list_to_value(list, 1);\n        lil_free_list(list);\n        lil_append_val(r, tmp);\n        lil_free_value(tmp);\n    }\n    return r;\n}",
        "definition_length": 437,
        "comment": ""
      },
      {
        "name": "fnc_foreach",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2962,
        "end_line": 2988,
        "start_byte": 86914,
        "end_byte": 87763,
        "signature": "static LILCALLBACK lil_value_t fnc_foreach(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_foreach(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list, rlist;\n    lil_value_t r;\n    size_t i, listidx = 0, codeidx = 1;\n    const char* varname = \"i\";\n    if (argc < 2) return NULL;\n    if (argc >= 3) {\n        varname = lil_to_string(argv[0]);\n        listidx = 1;\n        codeidx = 2;\n    }\n    rlist = lil_alloc_list();\n    list = lil_subst_to_list(lil, argv[listidx]);\n    for (i=0; i<list->c; i++) {\n        lil_value_t rv;\n        lil_set_var(lil, varname, list->v[i], LIL_SETVAR_LOCAL_ONLY);\n        rv = lil_parse_value(lil, argv[codeidx], 0);\n        if (rv->l) lil_list_append(rlist, rv);\n        else lil_free_value(rv);\n        if (lil->env->breakrun || lil->error) break;\n    }\n    r = lil_list_to_value(rlist, 1);\n    lil_free_list(list);\n    lil_free_list(rlist);\n    return r;\n}",
        "definition_length": 849,
        "comment": ""
      },
      {
        "name": "fnc_return",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2990,
        "end_line": 2997,
        "start_byte": 87765,
        "end_byte": 88071,
        "signature": "static LILCALLBACK lil_value_t fnc_return(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_return(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil->env->breakrun = 1;\n    lil_free_value(lil->env->retval);\n    lil->env->retval = argc < 1 ? NULL : lil_clone_value(argv[0]);\n    lil->env->retval_set = 1;\n    return argc < 1 ? NULL : lil_clone_value(argv[0]);\n}",
        "definition_length": 306,
        "comment": ""
      },
      {
        "name": "fnc_result",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 2999,
        "end_line": 3007,
        "start_byte": 88073,
        "end_byte": 88392,
        "signature": "static LILCALLBACK lil_value_t fnc_result(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_result(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc > 0) {\n        lil_free_value(lil->env->retval);\n        lil->env->retval = lil_clone_value(argv[0]);\n        lil->env->retval_set = 1;\n    }\n    return lil->env->retval_set ? lil_clone_value(lil->env->retval) : NULL;\n}",
        "definition_length": 319,
        "comment": ""
      },
      {
        "name": "fnc_expr",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3009,
        "end_line": 3024,
        "start_byte": 88394,
        "end_byte": 88859,
        "signature": "static LILCALLBACK lil_value_t fnc_expr(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_expr(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc == 1) return lil_eval_expr(lil, argv[0]);\n    if (argc > 1) {\n        lil_value_t val = alloc_value(NULL), r;\n        size_t i;\n        for (i=0; i<argc; i++) {\n            if (i) lil_append_char(val, ' ');\n            lil_append_val(val, argv[i]);\n        }\n        r = lil_eval_expr(lil, val);\n        lil_free_value(val);\n        return r;\n    }\n    return NULL;\n}",
        "definition_length": 465,
        "comment": ""
      },
      {
        "name": "real_inc",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "lil_t lil",
          "const char* varname",
          "float v"
        ],
        "is_static": true,
        "start_line": 3026,
        "end_line": 3036,
        "start_byte": 88861,
        "end_byte": 89199,
        "signature": "static lil_value_t real_inc(lil_t lil, const char* varname, float v)",
        "full_definition": "static lil_value_t real_inc(lil_t lil, const char* varname, float v)\n{\n    lil_value_t pv = lil_get_var(lil, varname);\n    double dv = lil_to_double(pv) + v;\n    if (fmod(dv, 1))\n        pv = lil_alloc_double(dv);\n    else\n        pv = lil_alloc_integer((lilint_t)dv);\n    lil_set_var(lil, varname, pv, LIL_SETVAR_LOCAL);\n    return pv;\n}",
        "definition_length": 338,
        "comment": ""
      },
      {
        "name": "fnc_inc",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3038,
        "end_line": 3042,
        "start_byte": 89201,
        "end_byte": 89406,
        "signature": "static LILCALLBACK lil_value_t fnc_inc(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_inc(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc < 1) return NULL;\n    return real_inc(lil, lil_to_string(argv[0]), argc > 1 ? lil_to_double(argv[1]) : 1);\n}",
        "definition_length": 205,
        "comment": ""
      },
      {
        "name": "fnc_dec",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3044,
        "end_line": 3048,
        "start_byte": 89408,
        "end_byte": 89616,
        "signature": "static LILCALLBACK lil_value_t fnc_dec(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_dec(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc < 1) return NULL;\n    return real_inc(lil, lil_to_string(argv[0]), -(argc > 1 ? lil_to_double(argv[1]) : 1));\n}",
        "definition_length": 208,
        "comment": ""
      },
      {
        "name": "fnc_read",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3050,
        "end_line": 3074,
        "start_byte": 89618,
        "end_byte": 90364,
        "signature": "static LILCALLBACK lil_value_t fnc_read(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_read(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    FILE* f;\n    size_t size;\n    char* buffer;\n    lil_value_t r;\n    if (argc < 1) return NULL;\n    if (lil->callback[LIL_CALLBACK_READ]) {\n        lil_read_callback_proc_t proc = (lil_read_callback_proc_t) lil->callback[LIL_CALLBACK_READ];\n        buffer = proc(lil, lil_to_string(argv[0]));\n    } else {\n        f = fopen(lil_to_string(argv[0]), \"rb\");\n        if (!f) return NULL;\n        fseek(f, 0, SEEK_END);\n        size = ftell(f);\n        fseek(f, 0, SEEK_SET);\n        buffer = malloc(size + 1);\n        fread(buffer, 1, size, f);\n        buffer[size] = 0;\n        fclose(f);\n    }\n    r = lil_alloc_string(buffer);\n    free(buffer);\n    return r;\n}",
        "definition_length": 746,
        "comment": ""
      },
      {
        "name": "fnc_store",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3076,
        "end_line": 3092,
        "start_byte": 90366,
        "end_byte": 90976,
        "signature": "static LILCALLBACK lil_value_t fnc_store(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_store(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    FILE* f;\n    const char* buffer;\n    if (argc < 2) return NULL;\n    if (lil->callback[LIL_CALLBACK_STORE]) {\n        lil_store_callback_proc_t proc = (lil_store_callback_proc_t)lil->callback[LIL_CALLBACK_STORE];\n        proc(lil, lil_to_string(argv[0]), lil_to_string(argv[1]));\n    } else {\n        f = fopen(lil_to_string(argv[0]), \"wb\");\n        if (!f) return NULL;\n        buffer = lil_to_string(argv[1]);\n        fwrite(buffer, 1, strlen(buffer), f);\n        fclose(f);\n    }\n    return lil_clone_value(argv[1]);\n}",
        "definition_length": 610,
        "comment": ""
      },
      {
        "name": "fnc_if",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3094,
        "end_line": 3112,
        "start_byte": 90978,
        "end_byte": 91603,
        "signature": "static LILCALLBACK lil_value_t fnc_if(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_if(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t val, r = NULL;\n    int base = 0, not = 0, v;\n    if (argc < 1) return NULL;\n    if (!strcmp(lil_to_string(argv[0]), \"not\")) base = not = 1;\n    if (argc < (size_t)base + 2) return NULL;\n    val = lil_eval_expr(lil, argv[base]);\n    if (!val || lil->error) return NULL;\n    v = lil_to_boolean(val);\n    if (not) v = !v;\n    if (v) {\n        r = lil_parse_value(lil, argv[base + 1], 0);\n    } else if (argc > (size_t)base + 2) {\n        r = lil_parse_value(lil, argv[base + 2], 0);\n    }\n    lil_free_value(val);\n    return r;\n}",
        "definition_length": 625,
        "comment": ""
      },
      {
        "name": "fnc_while",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3114,
        "end_line": 3135,
        "start_byte": 91605,
        "end_byte": 92308,
        "signature": "static LILCALLBACK lil_value_t fnc_while(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_while(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t val, r = NULL;\n    int base = 0, not = 0, v;\n    if (argc < 1) return NULL;\n    if (!strcmp(lil_to_string(argv[0]), \"not\")) base = not = 1;\n    if (argc < (size_t)base + 2) return NULL;\n    while (!lil->error && !lil->env->breakrun) {\n        val = lil_eval_expr(lil, argv[base]);\n        if (!val || lil->error) return NULL;\n        v = lil_to_boolean(val);\n        if (not) v = !v;\n        if (!v) {\n            lil_free_value(val);\n            break;\n        }\n        if (r) lil_free_value(r);\n        r = lil_parse_value(lil, argv[base + 1], 0);\n        lil_free_value(val);\n    }\n    return r;\n}",
        "definition_length": 703,
        "comment": ""
      },
      {
        "name": "fnc_for",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3137,
        "end_line": 3155,
        "start_byte": 92310,
        "end_byte": 92933,
        "signature": "static LILCALLBACK lil_value_t fnc_for(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_for(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t val, r = NULL;\n    if (argc < 4) return NULL;\n    lil_free_value(lil_parse_value(lil, argv[0], 0));\n    while (!lil->error && !lil->env->breakrun) {\n        val = lil_eval_expr(lil, argv[1]);\n        if (!val || lil->error) return NULL;\n        if (!lil_to_boolean(val)) {\n            lil_free_value(val);\n            break;\n        }\n        if (r) lil_free_value(r);\n        r = lil_parse_value(lil, argv[3], 0);\n        lil_free_value(val);\n        lil_free_value(lil_parse_value(lil, argv[2], 0));\n    }\n    return r;\n}",
        "definition_length": 623,
        "comment": ""
      },
      {
        "name": "fnc_char",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3158,
        "end_line": 3165,
        "start_byte": 92936,
        "end_byte": 93153,
        "signature": "static LILCALLBACK lil_value_t fnc_char(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_char(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    char s[2];\n    if (!argc) return NULL;\n    s[0] = (char)lil_to_integer(argv[0]);\n    s[1] = 0;\n    return lil_alloc_string(s);\n}",
        "definition_length": 217,
        "comment": ""
      },
      {
        "name": "fnc_charat",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3167,
        "end_line": 3179,
        "start_byte": 93155,
        "end_byte": 93535,
        "signature": "static LILCALLBACK lil_value_t fnc_charat(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_charat(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t index;\n    char chstr[2];\n    const char* str;\n    if (argc < 2) return NULL;\n    str = lil_to_string(argv[0]);\n    index = (size_t)lil_to_integer(argv[1]);\n    if (index >= strlen(str)) return NULL;\n    chstr[0] = str[index];\n    chstr[1] = 0;\n    return lil_alloc_string(chstr);\n}",
        "definition_length": 380,
        "comment": ""
      },
      {
        "name": "fnc_codeat",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3181,
        "end_line": 3190,
        "start_byte": 93537,
        "end_byte": 93859,
        "signature": "static LILCALLBACK lil_value_t fnc_codeat(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_codeat(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t index;\n    const char* str;\n    if (argc < 2) return NULL;\n    str = lil_to_string(argv[0]);\n    index = (size_t)lil_to_integer(argv[1]);\n    if (index >= strlen(str)) return NULL;\n    return lil_alloc_integer(str[index]);\n}",
        "definition_length": 322,
        "comment": ""
      },
      {
        "name": "fnc_substr",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3192,
        "end_line": 3209,
        "start_byte": 93861,
        "end_byte": 94435,
        "signature": "static LILCALLBACK lil_value_t fnc_substr(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_substr(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    const char* str;\n    lil_value_t r;\n    size_t start, end, i, slen;\n    if (argc < 2) return NULL;\n    str = lil_to_string(argv[0]);\n    if (!str[0]) return NULL;\n    slen = strlen(str);\n    start = (size_t)atoll(lil_to_string(argv[1]));\n    end = argc > 2 ? (size_t)atoll(lil_to_string(argv[2])) : slen;\n    if (end > slen) end = slen;\n    if (start >= end) return NULL;\n    r = lil_alloc_string(\"\");\n    for (i=start; i<end; i++)\n        lil_append_char(r, str[i]);\n    return r;\n}",
        "definition_length": 574,
        "comment": ""
      },
      {
        "name": "fnc_strpos",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3211,
        "end_line": 3225,
        "start_byte": 94437,
        "end_byte": 94948,
        "signature": "static LILCALLBACK lil_value_t fnc_strpos(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_strpos(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    const char* hay;\n    const char* str;\n    size_t min = 0;\n    if (argc < 2) return lil_alloc_integer(-1);\n    hay = lil_to_string(argv[0]);\n    if (argc > 2) {\n        min = (size_t)atoll(lil_to_string(argv[2]));\n        if (min >= strlen(hay)) return lil_alloc_integer(-1);\n    }\n    str = strstr(hay + min, lil_to_string(argv[1]));\n    if (!str) return lil_alloc_integer(-1);\n    return lil_alloc_integer(str - hay);\n}",
        "definition_length": 511,
        "comment": ""
      },
      {
        "name": "fnc_length",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3227,
        "end_line": 3235,
        "start_byte": 94950,
        "end_byte": 95218,
        "signature": "static LILCALLBACK lil_value_t fnc_length(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_length(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t i, total = 0;\n    for (i=0; i<argc; i++) {\n        if (i) total++;\n        total += strlen(lil_to_string(argv[i]));\n    }\n    return lil_alloc_integer((lilint_t)total);\n}",
        "definition_length": 268,
        "comment": ""
      },
      {
        "name": "real_trim",
        "type": "definition",
        "return_type": "lil_value_t",
        "parameters": [
          "const char* str",
          "const char* chars",
          "int left",
          "int right"
        ],
        "is_static": true,
        "start_line": 3237,
        "end_line": 3256,
        "start_byte": 95220,
        "end_byte": 95769,
        "signature": "static lil_value_t real_trim(const char* str, const char* chars, int left, int right)",
        "full_definition": "static lil_value_t real_trim(const char* str, const char* chars, int left, int right)\n{\n    int base = 0;\n    lil_value_t r = NULL;\n    if (left) {\n        while (str[base] && strchr(chars, str[base])) base++;\n        if (!right) r = lil_alloc_string(str[base] ? str + base : NULL);\n    }\n    if (right) {\n        size_t len;\n        char* s;\n        s = strclone(str + base);\n        len = strlen(s);\n        while (len && strchr(chars, s[len - 1])) len--;\n        s[len] = 0;\n        r = lil_alloc_string(s);\n        free(s);\n    }\n    return r;\n}",
        "definition_length": 549,
        "comment": ""
      },
      {
        "name": "fnc_trim",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3258,
        "end_line": 3262,
        "start_byte": 95771,
        "end_byte": 95988,
        "signature": "static LILCALLBACK lil_value_t fnc_trim(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_trim(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (!argc) return NULL;\n    return real_trim(lil_to_string(argv[0]), argc < 2 ? \" \\f\\n\\r\\t\\v\" : lil_to_string(argv[1]), 1, 1);\n}",
        "definition_length": 217,
        "comment": ""
      },
      {
        "name": "fnc_ltrim",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3264,
        "end_line": 3268,
        "start_byte": 95990,
        "end_byte": 96208,
        "signature": "static LILCALLBACK lil_value_t fnc_ltrim(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_ltrim(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (!argc) return NULL;\n    return real_trim(lil_to_string(argv[0]), argc < 2 ? \" \\f\\n\\r\\t\\v\" : lil_to_string(argv[1]), 1, 0);\n}",
        "definition_length": 218,
        "comment": ""
      },
      {
        "name": "fnc_rtrim",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3270,
        "end_line": 3274,
        "start_byte": 96210,
        "end_byte": 96428,
        "signature": "static LILCALLBACK lil_value_t fnc_rtrim(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_rtrim(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (!argc) return NULL;\n    return real_trim(lil_to_string(argv[0]), argc < 2 ? \" \\f\\n\\r\\t\\v\" : lil_to_string(argv[1]), 0, 1);\n}",
        "definition_length": 218,
        "comment": ""
      },
      {
        "name": "fnc_strcmp",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3276,
        "end_line": 3280,
        "start_byte": 96430,
        "end_byte": 96635,
        "signature": "static LILCALLBACK lil_value_t fnc_strcmp(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_strcmp(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc < 2) return NULL;\n    return lil_alloc_integer(strcmp(lil_to_string(argv[0]), lil_to_string(argv[1])));\n}",
        "definition_length": 205,
        "comment": ""
      },
      {
        "name": "fnc_streq",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3282,
        "end_line": 3286,
        "start_byte": 96637,
        "end_byte": 96845,
        "signature": "static LILCALLBACK lil_value_t fnc_streq(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_streq(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc < 2) return NULL;\n    return lil_alloc_integer(strcmp(lil_to_string(argv[0]), lil_to_string(argv[1]))?0:1);\n}",
        "definition_length": 208,
        "comment": ""
      },
      {
        "name": "fnc_repstr",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3288,
        "end_line": 3322,
        "start_byte": 96847,
        "end_byte": 97876,
        "signature": "static LILCALLBACK lil_value_t fnc_repstr(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_repstr(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    const char* from;\n    const char* to;\n    char* src;\n    const char* sub;\n    size_t idx;\n    size_t fromlen;\n    size_t tolen;\n    size_t srclen;\n    lil_value_t r;\n    if (argc < 1) return NULL;\n    if (argc < 3) return lil_clone_value(argv[0]);\n    from = lil_to_string(argv[1]);\n    to = lil_to_string(argv[2]);\n    if (!from[0]) return NULL;\n    src = strclone(lil_to_string(argv[0]));\n    srclen = strlen(src);\n    fromlen = strlen(from);\n    tolen = strlen(to);\n    while ((sub = strstr(src, from))) {\n        char* newsrc = malloc(srclen - fromlen + tolen + 1);\n        idx = sub - src;\n        if (idx) memcpy(newsrc, src, idx);\n        memcpy(newsrc + idx, to, tolen);\n        memcpy(newsrc + idx + tolen, src + idx + fromlen, srclen - idx - fromlen);\n        srclen = srclen - fromlen + tolen;\n        free(src);\n        src = newsrc;\n        src[srclen] = 0;\n    }\n    r = lil_alloc_string(src);\n    free(src);\n    return r;\n}",
        "definition_length": 1029,
        "comment": ""
      },
      {
        "name": "fnc_split",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3324,
        "end_line": 3351,
        "start_byte": 97878,
        "end_byte": 98652,
        "signature": "static LILCALLBACK lil_value_t fnc_split(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_split(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list;\n    const char* sep = \" \";\n    size_t i;\n    lil_value_t val;\n    const char* str;\n    if (argc == 0) return NULL;\n    if (argc > 1) {\n        sep = lil_to_string(argv[1]);\n        if (!sep || !sep[0]) return lil_clone_value(argv[0]);\n    }\n    val = lil_alloc_string(\"\");\n    str = lil_to_string(argv[0]);\n    list = lil_alloc_list();\n    for (i=0; str[i]; i++) {\n        if (strchr(sep, str[i])) {\n            lil_list_append(list, val);\n            val = lil_alloc_string(\"\");\n        } else {\n            lil_append_char(val, str[i]);\n        }\n    }\n    lil_list_append(list, val);\n    val = lil_list_to_value(list, 1);\n    lil_free_list(list);\n    return val;\n}",
        "definition_length": 774,
        "comment": ""
      },
      {
        "name": "fnc_try",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3353,
        "end_line": 3366,
        "start_byte": 98654,
        "end_byte": 99049,
        "signature": "static LILCALLBACK lil_value_t fnc_try(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_try(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_value_t r;\n    if (argc < 1) return NULL;\n    if (lil->error) return NULL;\n    r = lil_parse_value(lil, argv[0], 0);\n    if (lil->error) {\n        lil->error = ERROR_NOERROR;\n        lil_free_value(r);\n        if (argc > 1) r = lil_parse_value(lil, argv[1], 0);\n        else r = 0;\n    }\n    return r;\n}",
        "definition_length": 395,
        "comment": ""
      },
      {
        "name": "fnc_error",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3368,
        "end_line": 3372,
        "start_byte": 99051,
        "end_byte": 99221,
        "signature": "static LILCALLBACK lil_value_t fnc_error(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_error(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_set_error(lil, argc > 0 ? lil_to_string(argv[0]) : NULL);\n    return NULL;\n}",
        "definition_length": 170,
        "comment": ""
      },
      {
        "name": "fnc_exit",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3374,
        "end_line": 3381,
        "start_byte": 99223,
        "end_byte": 99522,
        "signature": "static LILCALLBACK lil_value_t fnc_exit(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_exit(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (lil->callback[LIL_CALLBACK_EXIT]) {\n        lil_exit_callback_proc_t proc = (lil_exit_callback_proc_t)lil->callback[LIL_CALLBACK_EXIT];\n        proc(lil, argc > 0 ? argv[0] : NULL);\n    }\n    return NULL;\n}",
        "definition_length": 299,
        "comment": ""
      },
      {
        "name": "fnc_source",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3383,
        "end_line": 3410,
        "start_byte": 99524,
        "end_byte": 100486,
        "signature": "static LILCALLBACK lil_value_t fnc_source(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_source(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    FILE* f;\n    size_t size;\n    char* buffer;\n    lil_value_t r;\n    if (argc < 1) return NULL;\n    if (lil->callback[LIL_CALLBACK_SOURCE]) {\n        lil_source_callback_proc_t proc = (lil_source_callback_proc_t)lil->callback[LIL_CALLBACK_SOURCE];\n        buffer = proc(lil, lil_to_string(argv[0]));\n    } else if (lil->callback[LIL_CALLBACK_READ]) {\n        lil_read_callback_proc_t proc = (lil_read_callback_proc_t)lil->callback[LIL_CALLBACK_READ];\n        buffer = proc(lil, lil_to_string(argv[0]));\n    } else {\n        f = fopen(lil_to_string(argv[0]), \"rb\");\n        if (!f) return NULL;\n        fseek(f, 0, SEEK_END);\n        size = ftell(f);\n        fseek(f, 0, SEEK_SET);\n        buffer = malloc(size + 1);\n        fread(buffer, 1, size, f);\n        buffer[size] = 0;\n        fclose(f);\n    }\n    r = lil_parse(lil, buffer, 0, 0);\n    free(buffer);\n    return r;\n}",
        "definition_length": 962,
        "comment": ""
      },
      {
        "name": "fnc_lmap",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3412,
        "end_line": 3422,
        "start_byte": 100488,
        "end_byte": 100848,
        "signature": "static LILCALLBACK lil_value_t fnc_lmap(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_lmap(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    lil_list_t list;\n    size_t i;\n    if (argc < 2) return NULL;\n    list = lil_subst_to_list(lil, argv[0]);\n    for (i=1; i<argc; i++)\n        lil_set_var(lil, lil_to_string(argv[i]), lil_list_get(list, i - 1), LIL_SETVAR_LOCAL);\n    lil_free_list(list);\n    return NULL;\n}",
        "definition_length": 360,
        "comment": ""
      },
      {
        "name": "fnc_rand",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3424,
        "end_line": 3427,
        "start_byte": 100850,
        "end_byte": 100990,
        "signature": "static LILCALLBACK lil_value_t fnc_rand(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_rand(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    return lil_alloc_double(rand()/(double)RAND_MAX);\n}",
        "definition_length": 140,
        "comment": ""
      },
      {
        "name": "fnc_catcher",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3429,
        "end_line": 3439,
        "start_byte": 100992,
        "end_byte": 101329,
        "signature": "static LILCALLBACK lil_value_t fnc_catcher(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_catcher(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (argc == 0) {\n        return lil_alloc_string(lil->catcher);\n    } else {\n        const char* catcher = lil_to_string(argv[0]);\n        free(lil->catcher);\n        lil->catcher = catcher[0] ? strclone(catcher) : NULL;\n    }\n    return NULL;\n}",
        "definition_length": 337,
        "comment": ""
      },
      {
        "name": "fnc_watch",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 3441,
        "end_line": 3457,
        "start_byte": 101331,
        "end_byte": 101901,
        "signature": "static LILCALLBACK lil_value_t fnc_watch(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_watch(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    size_t i;\n    const char* wcode;\n    if (argc < 2) return NULL;\n    wcode = lil_to_string(argv[argc - 1]);\n    for (i=0; i + 1 < argc; i++) {\n        const char* vname = lil_to_string(argv[i]);\n        lil_var_t v;\n        if (!vname[0]) continue;\n        v = lil_find_var(lil, lil->env, lil_to_string(argv[i]));\n        if (!v) v = lil_set_var(lil, vname, NULL, LIL_SETVAR_LOCAL_NEW);\n        free(v->w);\n        v->w = wcode[0] ? strclone(wcode) : NULL;\n    }\n    return NULL;\n}",
        "definition_length": 570,
        "comment": ""
      },
      {
        "name": "register_stdcmds",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "lil_t lil"
        ],
        "is_static": true,
        "start_line": 3459,
        "end_line": 3518,
        "start_byte": 101903,
        "end_byte": 104414,
        "signature": "static void register_stdcmds(lil_t lil)",
        "full_definition": "static void register_stdcmds(lil_t lil)\n{\n    lil_register(lil, \"reflect\", fnc_reflect);\n    lil_register(lil, \"func\", fnc_func);\n    lil_register(lil, \"rename\", fnc_rename);\n    lil_register(lil, \"unusedname\", fnc_unusedname);\n    lil_register(lil, \"quote\", fnc_quote);\n    lil_register(lil, \"set\", fnc_set);\n    lil_register(lil, \"local\", fnc_local);\n    lil_register(lil, \"write\", fnc_write);\n    lil_register(lil, \"print\", fnc_print);\n    lil_register(lil, \"eval\", fnc_eval);\n    lil_register(lil, \"topeval\", fnc_topeval);\n    lil_register(lil, \"upeval\", fnc_upeval);\n    lil_register(lil, \"downeval\", fnc_downeval);\n    lil_register(lil, \"enveval\", fnc_enveval);\n    lil_register(lil, \"jaileval\", fnc_jaileval);\n    lil_register(lil, \"count\", fnc_count);\n    lil_register(lil, \"index\", fnc_index);\n    lil_register(lil, \"indexof\", fnc_indexof);\n    lil_register(lil, \"filter\", fnc_filter);\n    lil_register(lil, \"list\", fnc_list);\n    lil_register(lil, \"append\", fnc_append);\n    lil_register(lil, \"slice\", fnc_slice);\n    lil_register(lil, \"subst\", fnc_subst);\n    lil_register(lil, \"concat\", fnc_concat);\n    lil_register(lil, \"foreach\", fnc_foreach);\n    lil_register(lil, \"return\", fnc_return);\n    lil_register(lil, \"result\", fnc_result);\n    lil_register(lil, \"expr\", fnc_expr);\n    lil_register(lil, \"inc\", fnc_inc);\n    lil_register(lil, \"dec\", fnc_dec);\n    lil_register(lil, \"read\", fnc_read);\n    lil_register(lil, \"store\", fnc_store);\n    lil_register(lil, \"if\", fnc_if);\n    lil_register(lil, \"while\", fnc_while);\n    lil_register(lil, \"for\", fnc_for);\n    lil_register(lil, \"char\", fnc_char);\n    lil_register(lil, \"charat\", fnc_charat);\n    lil_register(lil, \"codeat\", fnc_codeat);\n    lil_register(lil, \"substr\", fnc_substr);\n    lil_register(lil, \"strpos\", fnc_strpos);\n    lil_register(lil, \"length\", fnc_length);\n    lil_register(lil, \"trim\", fnc_trim);\n    lil_register(lil, \"ltrim\", fnc_ltrim);\n    lil_register(lil, \"rtrim\", fnc_rtrim);\n    lil_register(lil, \"strcmp\", fnc_strcmp);\n    lil_register(lil, \"streq\", fnc_streq);\n    lil_register(lil, \"repstr\", fnc_repstr);\n    lil_register(lil, \"split\", fnc_split);\n    lil_register(lil, \"try\", fnc_try);\n    lil_register(lil, \"error\", fnc_error);\n    lil_register(lil, \"exit\", fnc_exit);\n    lil_register(lil, \"source\", fnc_source);\n    lil_register(lil, \"lmap\", fnc_lmap);\n    lil_register(lil, \"rand\", fnc_rand);\n    lil_register(lil, \"catcher\", fnc_catcher);\n    lil_register(lil, \"watch\", fnc_watch);\n    lil->syscmds = lil->cmds;\n}",
        "definition_length": 2511,
        "comment": ""
      }
    ],
    "structs": [
      {
        "name": "hashentry_t",
        "start_line": 61,
        "end_line": 65,
        "start_byte": 2229,
        "end_byte": 2277,
        "full_definition": "struct hashentry_t\n{\n    char* k;\n    void* v;\n}",
        "fields": [
          {
            "text": "char* k;",
            "line": 63,
            "start_line": 63,
            "end_line": 63,
            "start_byte": 2254,
            "end_byte": 2262
          },
          {
            "text": "void* v;",
            "line": 64,
            "start_line": 64,
            "end_line": 64,
            "start_byte": 2267,
            "end_byte": 2275
          }
        ],
        "definition_length": 48,
        "comment": "note: static lil_xxx functions might become public later"
      },
      {
        "name": "hashcell_t",
        "start_line": 67,
        "end_line": 71,
        "start_byte": 2280,
        "end_byte": 2342,
        "full_definition": "struct hashcell_t\n{\n    struct hashentry_t* e;\n    size_t c;\n}",
        "fields": [
          {
            "text": "struct hashentry_t* e;",
            "line": 69,
            "start_line": 69,
            "end_line": 69,
            "start_byte": 2304,
            "end_byte": 2326
          },
          {
            "text": "size_t c;",
            "line": 70,
            "start_line": 70,
            "end_line": 70,
            "start_byte": 2331,
            "end_byte": 2340
          }
        ],
        "definition_length": 62,
        "comment": ""
      },
      {
        "name": "_lil_value_t",
        "start_line": 78,
        "end_line": 85,
        "start_byte": 2430,
        "end_byte": 2525,
        "full_definition": "struct _lil_value_t\n{\n    size_t l;\n#ifdef LIL_ENABLE_POOLS\n    size_t c;\n#endif\n    char* d;\n}",
        "fields": [
          {
            "text": "size_t l;",
            "line": 80,
            "start_line": 80,
            "end_line": 80,
            "start_byte": 2456,
            "end_byte": 2465
          },
          {
            "text": "size_t c;",
            "line": 82,
            "start_line": 82,
            "end_line": 82,
            "start_byte": 2494,
            "end_byte": 2503
          },
          {
            "text": "char* d;",
            "line": 84,
            "start_line": 84,
            "end_line": 84,
            "start_byte": 2515,
            "end_byte": 2523
          }
        ],
        "definition_length": 95,
        "comment": ""
      },
      {
        "name": "_lil_var_t",
        "start_line": 87,
        "end_line": 93,
        "start_byte": 2528,
        "end_byte": 2622,
        "full_definition": "struct _lil_var_t\n{\n    char* n;\n    char* w;\n    struct _lil_env_t* env;\n    lil_value_t v;\n}",
        "fields": [
          {
            "text": "char* n;",
            "line": 89,
            "start_line": 89,
            "end_line": 89,
            "start_byte": 2552,
            "end_byte": 2560
          },
          {
            "text": "char* w;",
            "line": 90,
            "start_line": 90,
            "end_line": 90,
            "start_byte": 2565,
            "end_byte": 2573
          },
          {
            "text": "struct _lil_env_t* env;",
            "line": 91,
            "start_line": 91,
            "end_line": 91,
            "start_byte": 2578,
            "end_byte": 2601
          },
          {
            "text": "lil_value_t v;",
            "line": 92,
            "start_line": 92,
            "end_line": 92,
            "start_byte": 2606,
            "end_byte": 2620
          }
        ],
        "definition_length": 94,
        "comment": ""
      },
      {
        "name": "_lil_env_t",
        "start_line": 95,
        "end_line": 106,
        "start_byte": 2625,
        "end_byte": 2848,
        "full_definition": "struct _lil_env_t\n{\n    struct _lil_env_t* parent;\n    lil_func_t func;\n    lil_value_t catcher_for;\n    lil_var_t* var;\n    size_t vars;\n    hashmap_t varmap;\n    lil_value_t retval;\n    int retval_set;\n    int breakrun;\n}",
        "fields": [
          {
            "text": "struct _lil_env_t* parent;",
            "line": 97,
            "start_line": 97,
            "end_line": 97,
            "start_byte": 2649,
            "end_byte": 2675
          },
          {
            "text": "lil_func_t func;",
            "line": 98,
            "start_line": 98,
            "end_line": 98,
            "start_byte": 2680,
            "end_byte": 2696
          },
          {
            "text": "lil_value_t catcher_for;",
            "line": 99,
            "start_line": 99,
            "end_line": 99,
            "start_byte": 2701,
            "end_byte": 2725
          },
          {
            "text": "lil_var_t* var;",
            "line": 100,
            "start_line": 100,
            "end_line": 100,
            "start_byte": 2730,
            "end_byte": 2745
          },
          {
            "text": "size_t vars;",
            "line": 101,
            "start_line": 101,
            "end_line": 101,
            "start_byte": 2750,
            "end_byte": 2762
          },
          {
            "text": "hashmap_t varmap;",
            "line": 102,
            "start_line": 102,
            "end_line": 102,
            "start_byte": 2767,
            "end_byte": 2784
          },
          {
            "text": "lil_value_t retval;",
            "line": 103,
            "start_line": 103,
            "end_line": 103,
            "start_byte": 2789,
            "end_byte": 2808
          },
          {
            "text": "int retval_set;",
            "line": 104,
            "start_line": 104,
            "end_line": 104,
            "start_byte": 2813,
            "end_byte": 2828
          },
          {
            "text": "int breakrun;",
            "line": 105,
            "start_line": 105,
            "end_line": 105,
            "start_byte": 2833,
            "end_byte": 2846
          }
        ],
        "definition_length": 223,
        "comment": ""
      },
      {
        "name": "_lil_list_t",
        "start_line": 108,
        "end_line": 113,
        "start_byte": 2851,
        "end_byte": 2923,
        "full_definition": "struct _lil_list_t\n{\n    lil_value_t* v;\n    size_t c;\n    size_t cap;\n}",
        "fields": [
          {
            "text": "lil_value_t* v;",
            "line": 110,
            "start_line": 110,
            "end_line": 110,
            "start_byte": 2876,
            "end_byte": 2891
          },
          {
            "text": "size_t c;",
            "line": 111,
            "start_line": 111,
            "end_line": 111,
            "start_byte": 2896,
            "end_byte": 2905
          },
          {
            "text": "size_t cap;",
            "line": 112,
            "start_line": 112,
            "end_line": 112,
            "start_byte": 2910,
            "end_byte": 2921
          }
        ],
        "definition_length": 72,
        "comment": ""
      },
      {
        "name": "_lil_func_t",
        "start_line": 115,
        "end_line": 121,
        "start_byte": 2926,
        "end_byte": 3037,
        "full_definition": "struct _lil_func_t\n{\n    char* name;\n    lil_value_t code;\n    lil_list_t argnames;\n    lil_func_proc_t proc;\n}",
        "fields": [
          {
            "text": "char* name;",
            "line": 117,
            "start_line": 117,
            "end_line": 117,
            "start_byte": 2951,
            "end_byte": 2962
          },
          {
            "text": "lil_value_t code;",
            "line": 118,
            "start_line": 118,
            "end_line": 118,
            "start_byte": 2967,
            "end_byte": 2984
          },
          {
            "text": "lil_list_t argnames;",
            "line": 119,
            "start_line": 119,
            "end_line": 119,
            "start_byte": 2989,
            "end_byte": 3009
          },
          {
            "text": "lil_func_proc_t proc;",
            "line": 120,
            "start_line": 120,
            "end_line": 120,
            "start_byte": 3014,
            "end_byte": 3035
          }
        ],
        "definition_length": 111,
        "comment": ""
      },
      {
        "name": "_lil_t",
        "start_line": 123,
        "end_line": 149,
        "start_byte": 3040,
        "end_byte": 3642,
        "full_definition": "struct _lil_t\n{\n    const char* code; /* need save on parse */\n    const char* rootcode;\n    size_t clen; /* need save on parse */\n    size_t head; /* need save on parse */\n    int ignoreeol;\n    lil_func_t* cmd;\n    size_t cmds;\n    size_t syscmds;\n    hashmap_t cmdmap;\n    char* catcher;\n    int in_catcher;\n    char* dollarprefix;\n    lil_env_t env;\n    lil_env_t rootenv;\n    lil_env_t downenv;\n    lil_value_t empty;\n    int error;\n    size_t err_head;\n    char* err_msg;\n    lil_callback_proc_t callback[CALLBACKS];\n    size_t parse_depth;\n    void* data;\n    char* embed;\n    size_t embedlen;\n}",
        "fields": [
          {
            "text": "const char* code;",
            "line": 125,
            "start_line": 125,
            "end_line": 125,
            "start_byte": 3060,
            "end_byte": 3077
          },
          {
            "text": "const char* rootcode;",
            "line": 126,
            "start_line": 126,
            "end_line": 126,
            "start_byte": 3107,
            "end_byte": 3128
          },
          {
            "text": "size_t clen;",
            "line": 127,
            "start_line": 127,
            "end_line": 127,
            "start_byte": 3133,
            "end_byte": 3145
          },
          {
            "text": "size_t head;",
            "line": 128,
            "start_line": 128,
            "end_line": 128,
            "start_byte": 3175,
            "end_byte": 3187
          },
          {
            "text": "int ignoreeol;",
            "line": 129,
            "start_line": 129,
            "end_line": 129,
            "start_byte": 3217,
            "end_byte": 3231
          },
          {
            "text": "lil_func_t* cmd;",
            "line": 130,
            "start_line": 130,
            "end_line": 130,
            "start_byte": 3236,
            "end_byte": 3252
          },
          {
            "text": "size_t cmds;",
            "line": 131,
            "start_line": 131,
            "end_line": 131,
            "start_byte": 3257,
            "end_byte": 3269
          },
          {
            "text": "size_t syscmds;",
            "line": 132,
            "start_line": 132,
            "end_line": 132,
            "start_byte": 3274,
            "end_byte": 3289
          },
          {
            "text": "hashmap_t cmdmap;",
            "line": 133,
            "start_line": 133,
            "end_line": 133,
            "start_byte": 3294,
            "end_byte": 3311
          },
          {
            "text": "char* catcher;",
            "line": 134,
            "start_line": 134,
            "end_line": 134,
            "start_byte": 3316,
            "end_byte": 3330
          },
          {
            "text": "int in_catcher;",
            "line": 135,
            "start_line": 135,
            "end_line": 135,
            "start_byte": 3335,
            "end_byte": 3350
          },
          {
            "text": "char* dollarprefix;",
            "line": 136,
            "start_line": 136,
            "end_line": 136,
            "start_byte": 3355,
            "end_byte": 3374
          },
          {
            "text": "lil_env_t env;",
            "line": 137,
            "start_line": 137,
            "end_line": 137,
            "start_byte": 3379,
            "end_byte": 3393
          },
          {
            "text": "lil_env_t rootenv;",
            "line": 138,
            "start_line": 138,
            "end_line": 138,
            "start_byte": 3398,
            "end_byte": 3416
          },
          {
            "text": "lil_env_t downenv;",
            "line": 139,
            "start_line": 139,
            "end_line": 139,
            "start_byte": 3421,
            "end_byte": 3439
          },
          {
            "text": "lil_value_t empty;",
            "line": 140,
            "start_line": 140,
            "end_line": 140,
            "start_byte": 3444,
            "end_byte": 3462
          },
          {
            "text": "int error;",
            "line": 141,
            "start_line": 141,
            "end_line": 141,
            "start_byte": 3467,
            "end_byte": 3477
          },
          {
            "text": "size_t err_head;",
            "line": 142,
            "start_line": 142,
            "end_line": 142,
            "start_byte": 3482,
            "end_byte": 3498
          },
          {
            "text": "char* err_msg;",
            "line": 143,
            "start_line": 143,
            "end_line": 143,
            "start_byte": 3503,
            "end_byte": 3517
          },
          {
            "text": "lil_callback_proc_t callback[CALLBACKS];",
            "line": 144,
            "start_line": 144,
            "end_line": 144,
            "start_byte": 3522,
            "end_byte": 3562
          },
          {
            "text": "size_t parse_depth;",
            "line": 145,
            "start_line": 145,
            "end_line": 145,
            "start_byte": 3567,
            "end_byte": 3586
          },
          {
            "text": "void* data;",
            "line": 146,
            "start_line": 146,
            "end_line": 146,
            "start_byte": 3591,
            "end_byte": 3602
          },
          {
            "text": "char* embed;",
            "line": 147,
            "start_line": 147,
            "end_line": 147,
            "start_byte": 3607,
            "end_byte": 3619
          },
          {
            "text": "size_t embedlen;",
            "line": 148,
            "start_line": 148,
            "end_line": 148,
            "start_byte": 3624,
            "end_byte": 3640
          }
        ],
        "definition_length": 602,
        "comment": ""
      }
    ],
    "includes": [
      {
        "text": "#include <stdlib.h>",
        "line": 25,
        "start_line": 25,
        "end_line": 26,
        "start_byte": 1038,
        "end_byte": 1058
      },
      {
        "text": "#include <stdio.h>",
        "line": 26,
        "start_line": 26,
        "end_line": 27,
        "start_byte": 1058,
        "end_byte": 1077
      },
      {
        "text": "#include <string.h>",
        "line": 27,
        "start_line": 27,
        "end_line": 28,
        "start_byte": 1077,
        "end_byte": 1097
      },
      {
        "text": "#include <ctype.h>",
        "line": 28,
        "start_line": 28,
        "end_line": 29,
        "start_byte": 1097,
        "end_byte": 1116
      },
      {
        "text": "#include <math.h>",
        "line": 29,
        "start_line": 29,
        "end_line": 30,
        "start_byte": 1116,
        "end_byte": 1134
      },
      {
        "text": "#include \"lil.h\"",
        "line": 30,
        "start_line": 30,
        "end_line": 31,
        "start_byte": 1134,
        "end_byte": 1151
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef struct _hashmap_t\n{\n    struct hashcell_t cell[HASHMAP_CELLS];\n} hashmap_t;",
        "name": "hashmap_t",
        "line": 73,
        "start_line": 73,
        "end_line": 76,
        "start_byte": 2345,
        "end_byte": 2428,
        "comment": ""
      },
      {
        "text": "typedef struct _expreval_t\n{\n    const char* code;\n    size_t len, head;\n    lilint_t ival;\n    double dval;\n    int type;\n    int error;\n} expreval_t;",
        "name": "expreval_t",
        "line": 151,
        "start_line": 151,
        "end_line": 159,
        "start_byte": 3645,
        "end_byte": 3796,
        "comment": ""
      }
    ],
    "macros": [
      {
        "text": "#define __LIL_C_FILE__",
        "name": "__LIL_C_FILE__",
        "line": 24,
        "start_line": 24,
        "end_line": 25,
        "start_byte": 1015,
        "end_byte": 1038,
        "comment": "* LIL - Little Interpreted Language\n * Copyright (C) 2010-2013 Kostas Michalopoulos\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n *    claim that you wrote the original software. If you use this software\n *    in a product, an acknowledgment in the product documentation would be\n *    appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n *\n * Kostas Michalopoulos <badsector@runtimelegend.com>"
      },
      {
        "text": "#define atoll _atoi64",
        "name": "atoll",
        "line": 43,
        "start_line": 43,
        "end_line": 44,
        "start_byte": 1797,
        "end_byte": 1819,
        "comment": "Visual C++ does not have atoll (Pelles C does and thinks it is fully MSVC compatible)"
      },
      {
        "text": "#define ERROR_NOERROR 0",
        "name": "ERROR_NOERROR",
        "line": 50,
        "start_line": 50,
        "end_line": 51,
        "start_byte": 1983,
        "end_byte": 2007,
        "comment": ""
      },
      {
        "text": "#define ERROR_DEFAULT 1",
        "name": "ERROR_DEFAULT",
        "line": 51,
        "start_line": 51,
        "end_line": 52,
        "start_byte": 2007,
        "end_byte": 2031,
        "comment": ""
      },
      {
        "text": "#define ERROR_FIXHEAD 2",
        "name": "ERROR_FIXHEAD",
        "line": 52,
        "start_line": 52,
        "end_line": 53,
        "start_byte": 2031,
        "end_byte": 2055,
        "comment": ""
      },
      {
        "text": "#define CALLBACKS 8",
        "name": "CALLBACKS",
        "line": 54,
        "start_line": 54,
        "end_line": 55,
        "start_byte": 2056,
        "end_byte": 2076,
        "comment": ""
      },
      {
        "text": "#define MAX_CATCHER_DEPTH 16384",
        "name": "MAX_CATCHER_DEPTH",
        "line": 55,
        "start_line": 55,
        "end_line": 56,
        "start_byte": 2076,
        "end_byte": 2108,
        "comment": ""
      },
      {
        "text": "#define HASHMAP_CELLS 256",
        "name": "HASHMAP_CELLS",
        "line": 56,
        "start_line": 56,
        "end_line": 57,
        "start_byte": 2108,
        "end_byte": 2134,
        "comment": ""
      },
      {
        "text": "#define HASHMAP_CELLMASK 0xFF",
        "name": "HASHMAP_CELLMASK",
        "line": 57,
        "start_line": 57,
        "end_line": 58,
        "start_byte": 2134,
        "end_byte": 2164,
        "comment": ""
      },
      {
        "text": "#define EE_INT 0",
        "name": "EE_INT",
        "line": 1121,
        "start_line": 1121,
        "end_line": 1122,
        "start_byte": 31613,
        "end_byte": 31630,
        "comment": ""
      },
      {
        "text": "#define EE_FLOAT 1",
        "name": "EE_FLOAT",
        "line": 1122,
        "start_line": 1122,
        "end_line": 1123,
        "start_byte": 31630,
        "end_byte": 31649,
        "comment": ""
      },
      {
        "text": "#define EERR_NO_ERROR 0",
        "name": "EERR_NO_ERROR",
        "line": 1123,
        "start_line": 1123,
        "end_line": 1124,
        "start_byte": 31649,
        "end_byte": 31673,
        "comment": ""
      },
      {
        "text": "#define EERR_SYNTAX_ERROR 1",
        "name": "EERR_SYNTAX_ERROR",
        "line": 1124,
        "start_line": 1124,
        "end_line": 1125,
        "start_byte": 31673,
        "end_byte": 31701,
        "comment": ""
      },
      {
        "text": "#define EERR_INVALID_TYPE 2",
        "name": "EERR_INVALID_TYPE",
        "line": 1125,
        "start_line": 1125,
        "end_line": 1126,
        "start_byte": 31701,
        "end_byte": 31729,
        "comment": ""
      },
      {
        "text": "#define EERR_DIVISION_BY_ZERO 3",
        "name": "EERR_DIVISION_BY_ZERO",
        "line": 1126,
        "start_line": 1126,
        "end_line": 1127,
        "start_byte": 31729,
        "end_byte": 31761,
        "comment": ""
      },
      {
        "text": "#define EERR_INVALID_EXPRESSION 4",
        "name": "EERR_INVALID_EXPRESSION",
        "line": 1127,
        "start_line": 1127,
        "end_line": 1128,
        "start_byte": 31761,
        "end_byte": 31795,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 33498,
    "file_size": 104415
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/rgba.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/rgba.c",
    "parse_success": true,
    "functions": [
      {
        "name": "h",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "char c"
        ],
        "is_static": true,
        "start_line": 201,
        "end_line": 231,
        "start_byte": 5463,
        "end_byte": 5906,
        "signature": "static int\nh(char c)",
        "full_definition": "static int\nh(char c) {\n  switch (c) {\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      return c - '0';\n    case 'a':\n    case 'b':\n    case 'c':\n    case 'd':\n    case 'e':\n    case 'f':\n      return (c - 'a') + 10;\n    case 'A':\n    case 'B':\n    case 'C':\n    case 'D':\n    case 'E':\n    case 'F':\n      return (c - 'A') + 10;\n  }\n  return 0;\n}",
        "definition_length": 443,
        "comment": "* Hex digit int val."
      },
      {
        "name": "rgba_new",
        "type": "definition",
        "return_type": "rgba_t",
        "parameters": [
          "uint32_t rgba"
        ],
        "is_static": false,
        "start_line": 237,
        "end_line": 245,
        "start_byte": 5944,
        "end_byte": 6188,
        "signature": "rgba_t\nrgba_new(uint32_t rgba)",
        "full_definition": "rgba_t\nrgba_new(uint32_t rgba) {\n  rgba_t color;\n  color.r = (double) (rgba >> 24) / 255;\n  color.g = (double) (rgba >> 16 & 0xff) / 255;\n  color.b = (double) (rgba >> 8 & 0xff) / 255;\n  color.a = (double) (rgba & 0xff) / 255;\n  return color;\n}",
        "definition_length": 244,
        "comment": "* Return rgba_t from rgba."
      },
      {
        "name": "rgba_to_string",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "rgba_t rgba",
          "char *buf",
          "size_t len"
        ],
        "is_static": false,
        "start_line": 251,
        "end_line": 265,
        "start_byte": 6246,
        "end_byte": 6614,
        "signature": "void\nrgba_to_string(rgba_t rgba, char *buf, size_t len)",
        "full_definition": "void\nrgba_to_string(rgba_t rgba, char *buf, size_t len) {\n  if (1 == rgba.a) {\n    snprintf(buf, len, \"#%.2x%.2x%.2x\",\n      (int) (rgba.r * 255),\n      (int) (rgba.g * 255),\n      (int) (rgba.b * 255));\n  } else {\n    snprintf(buf, len, \"rgba(%d, %d, %d, %.2f)\",\n      (int) (rgba.r * 255),\n      (int) (rgba.g * 255),\n      (int) (rgba.b * 255),\n      rgba.a);\n  }\n}",
        "definition_length": 368,
        "comment": "* Return a string representation of the color."
      },
      {
        "name": "rgba_from_rgba",
        "type": "definition",
        "return_type": "uint32_t",
        "parameters": [
          "uint8_t r",
          "uint8_t g",
          "uint8_t b",
          "uint8_t a"
        ],
        "is_static": true,
        "start_line": 271,
        "end_line": 278,
        "start_byte": 6655,
        "end_byte": 6799,
        "signature": "static inline uint32_t\nrgba_from_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a)",
        "full_definition": "static inline uint32_t\nrgba_from_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {\n  return\n      r << 24\n    | g << 16\n    | b << 8\n    | a;\n}",
        "definition_length": 144,
        "comment": "* Return rgba from (r,g,b,a)."
      },
      {
        "name": "rgba_from_rgb",
        "type": "definition",
        "return_type": "int32_t",
        "parameters": [
          "uint8_t r",
          "uint8_t g",
          "uint8_t b"
        ],
        "is_static": true,
        "start_line": 284,
        "end_line": 287,
        "start_byte": 6838,
        "end_byte": 6942,
        "signature": "static int32_t\nrgba_from_rgb(uint8_t r, uint8_t g, uint8_t b)",
        "full_definition": "static int32_t\nrgba_from_rgb(uint8_t r, uint8_t g, uint8_t b) {\n  return rgba_from_rgba(r, g, b, 255);\n}",
        "definition_length": 104,
        "comment": "* Return rgba from (r,g,b)."
      },
      {
        "name": "rgba_from_hex6_string",
        "type": "definition",
        "return_type": "uint32_t",
        "parameters": [
          "const char *str"
        ],
        "is_static": true,
        "start_line": 293,
        "end_line": 299,
        "start_byte": 6982,
        "end_byte": 7167,
        "signature": "static uint32_t\nrgba_from_hex6_string(const char *str)",
        "full_definition": "static uint32_t\nrgba_from_hex6_string(const char *str) {\n  return rgba_from_rgb(\n    (h(str[0]) << 4) + h(str[1]),\n    (h(str[2]) << 4) + h(str[3]),\n    (h(str[4]) << 4) + h(str[5]));\n}",
        "definition_length": 185,
        "comment": "* Return rgb from \"#RRGGBB\"."
      },
      {
        "name": "rgba_from_hex3_string",
        "type": "definition",
        "return_type": "int32_t",
        "parameters": [
          "const char *str"
        ],
        "is_static": true,
        "start_line": 305,
        "end_line": 311,
        "start_byte": 7203,
        "end_byte": 7387,
        "signature": "static int32_t\nrgba_from_hex3_string(const char *str)",
        "full_definition": "static int32_t\nrgba_from_hex3_string(const char *str) {\n  return rgba_from_rgb(\n    (h(str[0]) << 4) + h(str[0]),\n    (h(str[1]) << 4) + h(str[1]),\n    (h(str[2]) << 4) + h(str[2]));\n}",
        "definition_length": 184,
        "comment": "* Return rgb from \"#RGB\""
      },
      {
        "name": "rgba_from_rgb_string",
        "type": "definition",
        "return_type": "int32_t",
        "parameters": [
          "const char *str",
          "short *ok"
        ],
        "is_static": true,
        "start_line": 317,
        "end_line": 330,
        "start_byte": 7424,
        "end_byte": 7715,
        "signature": "static int32_t\nrgba_from_rgb_string(const char *str, short *ok)",
        "full_definition": "static int32_t\nrgba_from_rgb_string(const char *str, short *ok) {\n  if (str == strstr(str, \"rgb(\")) {\n    str += 4;\n    WHITESPACE;\n    uint8_t r = 0, g = 0, b = 0;\n    int c;\n    CHANNEL(r);\n    CHANNEL(g);\n    CHANNEL(b);\n    return *ok = 1, rgba_from_rgb(r, g, b);\n  }\n  return *ok = 0;\n}",
        "definition_length": 291,
        "comment": "* Return rgb from \"rgb()\""
      },
      {
        "name": "rgba_from_rgba_string",
        "type": "definition",
        "return_type": "int32_t",
        "parameters": [
          "const char *str",
          "short *ok"
        ],
        "is_static": true,
        "start_line": 336,
        "end_line": 363,
        "start_byte": 7753,
        "end_byte": 8360,
        "signature": "static int32_t\nrgba_from_rgba_string(const char *str, short *ok)",
        "full_definition": "static int32_t\nrgba_from_rgba_string(const char *str, short *ok) {\n  if (str == strstr(str, \"rgba(\")) {\n    str += 5;\n    WHITESPACE;\n    uint8_t r = 0, g = 0, b = 0;\n    int c;\n    float a = 0;\n    CHANNEL(r);\n    CHANNEL(g);\n    CHANNEL(b);\n    if (*str >= '1' && *str <= '9') {\n      a = 1;\n    } else {\n      if ('0' == *str) ++str;\n      if ('.' == *str) {\n        ++str;\n        float n = .1;\n        while (*str >= '0' && *str <= '9') {\n          a += (*str++ - '0') * n;\n          n *= .1;\n        }\n      }\n    }\n    return *ok = 1, rgba_from_rgba(r, g, b, (int) (a * 255));\n  }\n  return *ok = 0;\n}",
        "definition_length": 607,
        "comment": "* Return rgb from \"rgba()\""
      },
      {
        "name": "rgba_from_hex_string",
        "type": "definition",
        "return_type": "int32_t",
        "parameters": [
          "const char *str",
          "short *ok"
        ],
        "is_static": true,
        "start_line": 373,
        "end_line": 380,
        "start_byte": 8427,
        "end_byte": 8653,
        "signature": "static int32_t\nrgba_from_hex_string(const char *str, short *ok)",
        "full_definition": "static int32_t\nrgba_from_hex_string(const char *str, short *ok) {\n  size_t len = strlen(str);\n  *ok = 1;\n  if (6 == len) return rgba_from_hex6_string(str);\n  if (3 == len) return rgba_from_hex3_string(str);\n  return *ok = 0;\n}",
        "definition_length": 226,
        "comment": "* Return rgb from:\n *  \n *  - \"#RGB\"\n *  - \"#RRGGBB\"\n *"
      },
      {
        "name": "rgba_from_name_string",
        "type": "definition",
        "return_type": "int32_t",
        "parameters": [
          "const char *str",
          "short *ok"
        ],
        "is_static": true,
        "start_line": 386,
        "end_line": 396,
        "start_byte": 8692,
        "end_byte": 8978,
        "signature": "static int32_t\nrgba_from_name_string(const char *str, short *ok)",
        "full_definition": "static int32_t\nrgba_from_name_string(const char *str, short *ok) {\n  // TODO: hash\n  int i = 0;\n  struct named_color color;\n  while ((color = named_colors[i++]).name) {\n    if (*str == *color.name && 0 == strcmp(str, color.name))\n      return *ok = 1, color.val;\n  }\n  return *ok = 0;\n}",
        "definition_length": 286,
        "comment": "* Return named color value."
      },
      {
        "name": "rgba_from_string",
        "type": "definition",
        "return_type": "uint32_t",
        "parameters": [
          "const char *str",
          "short *ok"
        ],
        "is_static": false,
        "start_line": 411,
        "end_line": 417,
        "start_byte": 9109,
        "end_byte": 9413,
        "signature": "uint32_t\nrgba_from_string(const char *str, short *ok)",
        "full_definition": "uint32_t\nrgba_from_string(const char *str, short *ok) {\n  if ('#' == str[0])  return rgba_from_hex_string(++str, ok);\n  if (str == strstr(str, \"rgba\")) return rgba_from_rgba_string(str, ok);\n  if (str == strstr(str, \"rgb\")) return rgba_from_rgb_string(str, ok);\n  return rgba_from_name_string(str, ok);\n}",
        "definition_length": 304,
        "comment": "* Return rgb from:\n *  \n *  - #RGB\n *  - #RRGGBB\n *  - rgb(r,g,b)\n *  - rgba(r,g,b,a)\n *  - name\n *\n * or return -1.\n *"
      },
      {
        "name": "rgba_inspect",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "uint32_t rgba"
        ],
        "is_static": false,
        "start_line": 423,
        "end_line": 430,
        "start_byte": 9456,
        "end_byte": 9610,
        "signature": "void\nrgba_inspect(uint32_t rgba)",
        "full_definition": "void\nrgba_inspect(uint32_t rgba) {\n  printf(\"rgba(%d,%d,%d,%d)\\n\",\n    rgba >> 24 & 0xff,\n    rgba >> 16 & 0xff,\n    rgba >> 8 & 0xff,\n    rgba & 0xff);\n}",
        "definition_length": 154,
        "comment": "* Inspect the given rgba color."
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 79,
        "end_byte": 98
      },
      {
        "text": "#include <stdlib.h>",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 98,
        "end_byte": 118
      },
      {
        "text": "#include <string.h>",
        "line": 10,
        "start_line": 10,
        "end_line": 11,
        "start_byte": 118,
        "end_byte": 138
      },
      {
        "text": "#include \"rgba.h\"",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 138,
        "end_byte": 156
      }
    ],
    "variables": [
      {
        "text": "static struct named_color {\n  const char *name;\n  uint32_t val;\n} named_colors[] = {\n    { \"transparent\", 0xFFFFFF00}\n  , { \"aliceblue\", 0xF0F8FFFF }\n  , { \"antiquewhite\", 0xFAEBD7FF }\n  , { \"aqua\", 0x00FFFFFF }\n  , { \"aquamarine\", 0x7FFFD4FF }\n  , { \"azure\", 0xF0FFFFFF }\n  , { \"beige\", 0xF5F5DCFF }\n  , { \"bisque\", 0xFFE4C4FF }\n  , { \"black\", 0x000000FF }\n  , { \"blanchedalmond\", 0xFFEBCDFF }\n  , { \"blue\", 0x0000FFFF }\n  , { \"blueviolet\", 0x8A2BE2FF }\n  , { \"brown\", 0xA52A2AFF }\n  , { \"burlywood\", 0xDEB887FF }\n  , { \"cadetblue\", 0x5F9EA0FF }\n  , { \"chartreuse\", 0x7FFF00FF }\n  , { \"chocolate\", 0xD2691EFF }\n  , { \"coral\", 0xFF7F50FF }\n  , { \"cornflowerblue\", 0x6495EDFF }\n  , { \"cornsilk\", 0xFFF8DCFF }\n  , { \"crimson\", 0xDC143CFF }\n  , { \"cyan\", 0x00FFFFFF }\n  , { \"darkblue\", 0x00008BFF }\n  , { \"darkcyan\", 0x008B8BFF }\n  , { \"darkgoldenrod\", 0xB8860BFF }\n  , { \"darkgray\", 0xA9A9A9FF }\n  , { \"darkgreen\", 0x006400FF }\n  , { \"darkgrey\", 0xA9A9A9FF }\n  , { \"darkkhaki\", 0xBDB76BFF }\n  , { \"darkmagenta\", 0x8B008BFF }\n  , { \"darkolivegreen\", 0x556B2FFF }\n  , { \"darkorange\", 0xFF8C00FF }\n  , { \"darkorchid\", 0x9932CCFF }\n  , { \"darkred\", 0x8B0000FF }\n  , { \"darksalmon\", 0xE9967AFF }\n  , { \"darkseagreen\", 0x8FBC8FFF }\n  , { \"darkslateblue\", 0x483D8BFF }\n  , { \"darkslategray\", 0x2F4F4FFF }\n  , { \"darkslategrey\", 0x2F4F4FFF }\n  , { \"darkturquoise\", 0x00CED1FF }\n  , { \"darkviolet\", 0x9400D3FF }\n  , { \"deeppink\", 0xFF1493FF }\n  , { \"deepskyblue\", 0x00BFFFFF }\n  , { \"dimgray\", 0x696969FF }\n  , { \"dimgrey\", 0x696969FF }\n  , { \"dodgerblue\", 0x1E90FFFF }\n  , { \"firebrick\", 0xB22222FF }\n  , { \"floralwhite\", 0xFFFAF0FF }\n  , { \"forestgreen\", 0x228B22FF }\n  , { \"fuchsia\", 0xFF00FFFF }\n  , { \"gainsboro\", 0xDCDCDCFF }\n  , { \"ghostwhite\", 0xF8F8FFFF }\n  , { \"gold\", 0xFFD700FF }\n  , { \"goldenrod\", 0xDAA520FF }\n  , { \"gray\", 0x808080FF }\n  , { \"green\", 0x008000FF }\n  , { \"greenyellow\", 0xADFF2FFF }\n  , { \"grey\", 0x808080FF }\n  , { \"honeydew\", 0xF0FFF0FF }\n  , { \"hotpink\", 0xFF69B4FF }\n  , { \"indianred\", 0xCD5C5CFF }\n  , { \"indigo\", 0x4B0082FF }\n  , { \"ivory\", 0xFFFFF0FF }\n  , { \"khaki\", 0xF0E68CFF }\n  , { \"lavender\", 0xE6E6FAFF }\n  , { \"lavenderblush\", 0xFFF0F5FF }\n  , { \"lawngreen\", 0x7CFC00FF }\n  , { \"lemonchiffon\", 0xFFFACDFF }\n  , { \"lightblue\", 0xADD8E6FF }\n  , { \"lightcoral\", 0xF08080FF }\n  , { \"lightcyan\", 0xE0FFFFFF }\n  , { \"lightgoldenrodyellow\", 0xFAFAD2FF }\n  , { \"lightgray\", 0xD3D3D3FF }\n  , { \"lightgreen\", 0x90EE90FF }\n  , { \"lightgrey\", 0xD3D3D3FF }\n  , { \"lightpink\", 0xFFB6C1FF }\n  , { \"lightsalmon\", 0xFFA07AFF }\n  , { \"lightseagreen\", 0x20B2AAFF }\n  , { \"lightskyblue\", 0x87CEFAFF }\n  , { \"lightslategray\", 0x778899FF }\n  , { \"lightslategrey\", 0x778899FF }\n  , { \"lightsteelblue\", 0xB0C4DEFF }\n  , { \"lightyellow\", 0xFFFFE0FF }\n  , { \"lime\", 0x00FF00FF }\n  , { \"limegreen\", 0x32CD32FF }\n  , { \"linen\", 0xFAF0E6FF }\n  , { \"magenta\", 0xFF00FFFF }\n  , { \"maroon\", 0x800000FF }\n  , { \"mediumaquamarine\", 0x66CDAAFF }\n  , { \"mediumblue\", 0x0000CDFF }\n  , { \"mediumorchid\", 0xBA55D3FF }\n  , { \"mediumpurple\", 0x9370DBFF }\n  , { \"mediumseagreen\", 0x3CB371FF }\n  , { \"mediumslateblue\", 0x7B68EEFF }\n  , { \"mediumspringgreen\", 0x00FA9AFF }\n  , { \"mediumturquoise\", 0x48D1CCFF }\n  , { \"mediumvioletred\", 0xC71585FF }\n  , { \"midnightblue\", 0x191970FF }\n  , { \"mintcream\", 0xF5FFFAFF }\n  , { \"mistyrose\", 0xFFE4E1FF }\n  , { \"moccasin\", 0xFFE4B5FF }\n  , { \"navajowhite\", 0xFFDEADFF }\n  , { \"navy\", 0x000080FF }\n  , { \"oldlace\", 0xFDF5E6FF }\n  , { \"olive\", 0x808000FF }\n  , { \"olivedrab\", 0x6B8E23FF }\n  , { \"orange\", 0xFFA500FF }\n  , { \"orangered\", 0xFF4500FF }\n  , { \"orchid\", 0xDA70D6FF }\n  , { \"palegoldenrod\", 0xEEE8AAFF }\n  , { \"palegreen\", 0x98FB98FF }\n  , { \"paleturquoise\", 0xAFEEEEFF }\n  , { \"palevioletred\", 0xDB7093FF }\n  , { \"papayawhip\", 0xFFEFD5FF }\n  , { \"peachpuff\", 0xFFDAB9FF }\n  , { \"peru\", 0xCD853FFF }\n  , { \"pink\", 0xFFC0CBFF }\n  , { \"plum\", 0xDDA0DDFF }\n  , { \"powderblue\", 0xB0E0E6FF }\n  , { \"purple\", 0x800080FF }\n  , { \"red\", 0xFF0000FF }\n  , { \"rosybrown\", 0xBC8F8FFF }\n  , { \"royalblue\", 0x4169E1FF }\n  , { \"saddlebrown\", 0x8B4513FF }\n  , { \"salmon\", 0xFA8072FF }\n  , { \"sandybrown\", 0xF4A460FF }\n  , { \"seagreen\", 0x2E8B57FF }\n  , { \"seashell\", 0xFFF5EEFF }\n  , { \"sienna\", 0xA0522DFF }\n  , { \"silver\", 0xC0C0C0FF }\n  , { \"skyblue\", 0x87CEEBFF }\n  , { \"slateblue\", 0x6A5ACDFF }\n  , { \"slategray\", 0x708090FF }\n  , { \"slategrey\", 0x708090FF }\n  , { \"snow\", 0xFFFAFAFF }\n  , { \"springgreen\", 0x00FF7FFF }\n  , { \"steelblue\", 0x4682B4FF }\n  , { \"tan\", 0xD2B48CFF }\n  , { \"teal\", 0x008080FF }\n  , { \"thistle\", 0xD8BFD8FF }\n  , { \"tomato\", 0xFF6347FF }\n  , { \"turquoise\", 0x40E0D0FF }\n  , { \"violet\", 0xEE82EEFF }\n  , { \"wheat\", 0xF5DEB3FF }\n  , { \"white\", 0xFFFFFFFF }\n  , { \"whitesmoke\", 0xF5F5F5FF }\n  , { \"yellow\", 0xFFFF00FF }\n  , { \"yellowgreen\", 0x9ACD32FF }\n  , { NULL, 0 }\n};",
        "line": 42,
        "start_line": 42,
        "end_line": 195,
        "start_byte": 605,
        "end_byte": 5431,
        "comment": "* Named colors."
      }
    ],
    "typedefs": [],
    "macros": [
      {
        "text": "#define WHITESPACE \\\n  while (' ' == *str) ++str;",
        "name": "WHITESPACE",
        "line": 17,
        "start_line": 17,
        "end_line": 19,
        "start_byte": 188,
        "end_byte": 238,
        "comment": "* Consume whitespace."
      },
      {
        "text": "#define CHANNEL(NAME) \\\n   c = 0; \\\n   if (*str >= '0' && *str <= '9') { \\\n     do { \\\n       c *= 10; \\\n       c += *str++ - '0'; \\\n     } while (*str >= '0' && *str <= '9'); \\\n   } else { \\\n     return 0; \\\n   } \\\n   if (c > 255) c = 255; \\\n   NAME = c; \\\n   while (' ' == *str || ',' == *str) str++;",
        "name": "CHANNEL",
        "line": 24,
        "start_line": 24,
        "end_line": 37,
        "start_byte": 276,
        "end_byte": 579,
        "comment": "* Parse color channel value"
      }
    ],
    "enums": [],
    "total_nodes": 3215,
    "file_size": 9610
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-bst.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-bst.c",
    "parse_success": true,
    "functions": [
      {
        "name": "test_bst",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 7,
        "end_line": 42,
        "start_byte": 59,
        "end_byte": 1140,
        "signature": "void test_bst()",
        "full_definition": "void test_bst(){\n    struct bst* bst = bst_create();\n    int good_nums[8] = {32, 16, 8, 12, 4, 64, 48, 80};\n    int bad_nums[8] = {1, 3, 5, 7, 9, 11, 13, 15};\n  \n    // Initialize the tree.\n    for (int i = 0; i < 8; i++) {\n      bst_insert(good_nums[i], bst);\n    }\n  \n    // Test containment.\n    for (int i = 0; i < 8; i++) {\n      assert(bst_contains(good_nums[i], bst) == 1);\n    }\n    printf(\"== Verified that BST contains all the expected values.\\n\");\n  \n    for (int i = 0; i < 8; i++) {\n      assert(bst_contains(bad_nums[i], bst) == 0);\n    }\n    printf(\"== Verified that BST contains none of the unexpected values.\\n\");\n  \n    /*\n     * Test removal by removing one good number at a time and making sure the\n     * remaining good numbers are still in the tree.\n     */\n    for (int i = 0; i < 8; i++) {\n      bst_remove(good_nums[i], bst);\n      assert(!bst_contains(good_nums[i], bst));\n      for (int j = i + 1; j < 8; j++) {\n        assert(bst_contains(good_nums[j], bst));\n      }\n    }\n    printf(\"== Verified removal works as expected.\\n\");\n  \n    bst_free(bst);\n}",
        "definition_length": 1081,
        "comment": ""
      },
      {
        "name": "main",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "int argc",
          "char** argv"
        ],
        "is_static": false,
        "start_line": 44,
        "end_line": 46,
        "start_byte": 1142,
        "end_byte": 1193,
        "signature": "int main(int argc, char** argv)",
        "full_definition": "int main(int argc, char** argv) {\n    test_bst();\n}",
        "definition_length": 51,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 19
      },
      {
        "text": "#include <assert.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 19,
        "end_byte": 39
      },
      {
        "text": "#include \"bst.h\"",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 40,
        "end_byte": 57
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 394,
    "file_size": 1194
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-rgba.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-rgba.c",
    "parse_success": true,
    "functions": [
      {
        "name": "test_named",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 11,
        "end_line": 17,
        "start_byte": 109,
        "end_byte": 233,
        "signature": "void\ntest_named()",
        "full_definition": "void\ntest_named() {\n  short ok;\n  int32_t val = rgba_from_string(\"olive\", &ok);\n  assert(ok);\n  assert(0x808000FF == val);\n}",
        "definition_length": 124,
        "comment": "* Test named colors."
      },
      {
        "name": "test_rgb",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 23,
        "end_line": 33,
        "start_byte": 257,
        "end_byte": 481,
        "signature": "void\ntest_rgb()",
        "full_definition": "void\ntest_rgb() {\n  short ok;\n  int32_t val = rgba_from_string(\"rgb(255, 30   , 0)\", &ok);\n  assert(ok);\n  assert(0xff1e00ff == val);\n\n  val = rgba_from_string(\"rgb(0,0,0)\", &ok);\n  assert(ok);\n  assert(0x000000ff == val);\n}",
        "definition_length": 224,
        "comment": "* Test rgb()"
      },
      {
        "name": "test_rgba",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 39,
        "end_line": 49,
        "start_byte": 506,
        "end_byte": 740,
        "signature": "void\ntest_rgba()",
        "full_definition": "void\ntest_rgba() {\n  short ok;\n  int32_t val = rgba_from_string(\"rgba(255, 30   , 0, .5)\", &ok);\n  assert(ok);\n  assert(0xff1e007f == val);\n\n  val = rgba_from_string(\"rgba(0,0,0, 1)\", &ok);\n  assert(ok);\n  assert(0x000000ff == val);\n}",
        "definition_length": 234,
        "comment": "* Test rgba()"
      },
      {
        "name": "test_hex",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 55,
        "end_line": 73,
        "start_byte": 775,
        "end_byte": 1154,
        "signature": "void\ntest_hex()",
        "full_definition": "void\ntest_hex() {\n  short ok;\n  int32_t val = rgba_from_string(\"#ff1e00\", &ok);\n  assert(ok);\n  assert(0xff1e00ff == val);\n\n  val = rgba_from_string(\"#ffffff\", &ok);\n  assert(ok);\n  assert(0xffffffff == val);\n\n  val = rgba_from_string(\"#ffcc00\", &ok);\n  assert(ok);\n  assert(0xffcc00ff == val);\n\n  val = rgba_from_string(\"#fco\", &ok);\n  assert(ok);\n  assert(0xffcc00ff == val);\n}",
        "definition_length": 379,
        "comment": "* Test #rgb and #rrggbb"
      },
      {
        "name": "test_to_string",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 79,
        "end_line": 89,
        "start_byte": 1183,
        "end_byte": 1461,
        "signature": "void\ntest_to_string()",
        "full_definition": "void\ntest_to_string() {\n  char buf[256];\n  rgba_t color = rgba_new(0xffcc00ff);\n  rgba_to_string(color, buf, 256);\n  assert(0 == strcmp(\"#ffcc00\", buf));\n\n  color = rgba_new(0xffcc0050);\n  rgba_to_string(color, buf, 256);\n  assert(0 == strcmp(\"rgba(255, 204, 0, 0.31)\", buf));\n}",
        "definition_length": 278,
        "comment": "* Test to string."
      },
      {
        "name": "main",
        "type": "definition",
        "return_type": "int",
        "parameters": [
          "int argc",
          "char **argv"
        ],
        "is_static": false,
        "start_line": 95,
        "end_line": 104,
        "start_byte": 1485,
        "end_byte": 1658,
        "signature": "int\nmain(int argc, char **argv)",
        "full_definition": "int\nmain(int argc, char **argv){\n  test_named();\n  test_rgb();\n  test_rgba();\n  test_hex();\n  test_to_string();\n  printf(\"\\n  \\e[32m\\u2713 \\e[90mok\\e[0m\\n\\n\");\n  return 0;\n}",
        "definition_length": 173,
        "comment": "* Run tests."
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 1,
        "end_byte": 20
      },
      {
        "text": "#include <assert.h>",
        "line": 3,
        "start_line": 3,
        "end_line": 4,
        "start_byte": 20,
        "end_byte": 40
      },
      {
        "text": "#include <string.h>",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 40,
        "end_byte": 60
      },
      {
        "text": "#include \"rgba.h\"",
        "line": 5,
        "start_line": 5,
        "end_line": 6,
        "start_byte": 60,
        "end_byte": 78
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 608,
    "file_size": 1658
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-quadtree.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-quadtree.c",
    "parse_success": true,
    "functions": [
      {
        "name": "descent",
        "type": "definition",
        "return_type": "id d",
        "parameters": [
          "adtree_node_t *node){"
        ],
        "is_static": false,
        "start_line": 13,
        "end_line": 13,
        "start_byte": 190,
        "end_byte": 229,
        "signature": "void descent(quadtree_node_t *node)",
        "full_definition": "void descent(quadtree_node_t *node){}\n\n",
        "definition_length": 39,
        "comment": ""
      },
      {
        "name": "ascent",
        "type": "definition",
        "return_type": "id a",
        "parameters": [
          "adtree_node_t *node){"
        ],
        "is_static": false,
        "start_line": 15,
        "end_line": 15,
        "start_byte": 229,
        "end_byte": 267,
        "signature": "void ascent(quadtree_node_t *node)",
        "full_definition": "void ascent(quadtree_node_t *node){}\n\n",
        "definition_length": 38,
        "comment": ""
      },
      {
        "name": "test_node",
        "type": "definition",
        "return_type": "id\nt",
        "parameters": [
          "id){"
        ],
        "is_static": false,
        "start_line": 17,
        "end_line": 24,
        "start_byte": 267,
        "end_byte": 480,
        "signature": "static void\ntest_node(void)",
        "full_definition": "static void\ntest_node(void){\n  quadtree_node_t *node = quadtree_node_new();\n  assert(!quadtree_node_isleaf(node));\n  assert(quadtree_node_isempty(node));\n  assert(!quadtree_node_ispointer(node));\n  free(node);\n}\n\n",
        "definition_length": 213,
        "comment": ""
      },
      {
        "name": "test_bounds",
        "type": "definition",
        "return_type": "id\nt",
        "parameters": [
          "id){"
        ],
        "is_static": false,
        "start_line": 26,
        "end_line": 48,
        "start_byte": 480,
        "end_byte": 1046,
        "signature": "static void\ntest_bounds(void)",
        "full_definition": "static void\ntest_bounds(void){\n  quadtree_bounds_t *bounds = quadtree_bounds_new();\n\n  assert(bounds);\n  assert(bounds->nw->x == INFINITY);\n  assert(bounds->se->x == -INFINITY);\n\n  quadtree_bounds_extend(bounds, 5.0, 5.0);\n  assert(bounds->nw->x == 5.0);\n  assert(bounds->se->x == 5.0);\n\n  quadtree_bounds_extend(bounds, 10.0, 10.0);\n  assert(bounds->nw->y == 10.0);\n  assert(bounds->nw->y == 10.0);\n  assert(bounds->se->y == 5.0);\n  assert(bounds->se->y == 5.0);\n\n  assert(bounds->width == 5.0);\n  assert(bounds->height == 5.0);\n\n  quadtree_bounds_free(bounds);\n}\n\n",
        "definition_length": 566,
        "comment": ""
      },
      {
        "name": "test_tree",
        "type": "definition",
        "return_type": "id\nt",
        "parameters": [
          "id){"
        ],
        "is_static": false,
        "start_line": 51,
        "end_line": 81,
        "start_byte": 1047,
        "end_byte": 2100,
        "signature": "static void\ntest_tree(void)",
        "full_definition": "static void\ntest_tree(void){\n  int val = 10;\n\n  quadtree_t *tree = quadtree_new(1, 1, 10, 10);\n  assert(tree->root->bounds->nw->x == 1);\n  assert(tree->root->bounds->nw->y == 10.0);\n  assert(tree->root->bounds->se->x == 10.0);\n  assert(tree->root->bounds->se->y == 1);\n\n\n  assert(quadtree_insert(tree, 0, 0, &val) == 0);\n  assert(quadtree_insert(tree, 110.0, 110.0, &val) == 0);\n\n  assert(quadtree_insert(tree, 8.0, 2.0, &val) != 0);\n  assert(tree->length == 1);\n  assert(tree->root->point->x == 8.0);\n  assert(tree->root->point->y == 2.0);\n\n  assert(quadtree_insert(tree, 0.0, 1.0, &val) == 0); /* failed insertion */\n  assert(quadtree_insert(tree, 2.0, 3.0, &val) == 1); /* normal insertion */\n  assert(quadtree_insert(tree, 2.0, 3.0, &val) == 2); /* replacement insertion */\n  assert(tree->length == 2);\n  assert(tree->root->point == NULL);\n\n  assert(quadtree_insert(tree, 3.0, 1.1, &val) == 1);\n  assert(tree->length == 3);\n  assert(quadtree_search(tree, 3.0, 1.1)->x == 3.0);\n  quadtree_walk(tree->root, ascent, descent);\n  quadtree_free(tree);\n}\n\n",
        "definition_length": 1053,
        "comment": ""
      },
      {
        "name": "test_points",
        "type": "definition",
        "return_type": "id\nt",
        "parameters": [
          "id){"
        ],
        "is_static": false,
        "start_line": 83,
        "end_line": 89,
        "start_byte": 2100,
        "end_byte": 2268,
        "signature": "static void\ntest_points(void)",
        "full_definition": "static void\ntest_points(void){\n  quadtree_point_t *point = quadtree_point_new(5, 6);\n  assert(point->x == 5);\n  assert(point->y == 6);\n  quadtree_point_free(point);\n}\n\n",
        "definition_length": 168,
        "comment": ""
      },
      {
        "name": "main",
        "type": "definition",
        "return_type": "t\nm",
        "parameters": [
          "t argc,",
          "nst char *argv[]){"
        ],
        "is_static": false,
        "start_line": 91,
        "end_line": 97,
        "start_byte": 2268,
        "end_byte": 2371,
        "signature": "int\nmain(int argc, const char *argv[])",
        "full_definition": "int\nmain(int argc, const char *argv[]){\n  test(tree);\n  test(node);\n  test(bounds);\n  test(points);\n}\n",
        "definition_length": 102,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <assert.h>",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 20
      },
      {
        "text": "#include <stdio.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 20,
        "end_byte": 39
      },
      {
        "text": "#include \"quadtree.h\"",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 40,
        "end_byte": 62
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [
      {
        "text": "#define test(fn) \\\n        printf(\"\\x1b[33m\" # fn \"\\x1b[0m \"); \\\n        test_##fn(); \\\n        puts(\"\\x1b[1;32m✓\\x1b[0m\");",
        "name": "test",
        "line": 6,
        "start_line": 6,
        "end_line": 10,
        "start_byte": 63,
        "end_byte": 189,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 934,
    "file_size": 2370
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-binn.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-binn.c",
    "parse_success": true,
    "functions": [
      {
        "name": "CalcAllocation",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "int needed_size",
          "int alloc_size"
        ],
        "start_line": 23,
        "end_line": 23,
        "start_byte": 592,
        "end_byte": 658,
        "full_declaration": "BINN_PRIVATE int CalcAllocation(int needed_size, int alloc_size) ;",
        "declaration_length": 66,
        "comment": ""
      },
      {
        "name": "IsValidBinnHeader",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "const void *pbuf",
          "int *ptype",
          "int *pcount",
          "int *psize",
          "int *pheadersize"
        ],
        "start_line": 24,
        "end_line": 24,
        "start_byte": 659,
        "end_byte": 768,
        "full_declaration": "BINN_PRIVATE BOOL IsValidBinnHeader(const void *pbuf, int *ptype, int *pcount, int *psize, int *pheadersize);",
        "declaration_length": 109,
        "comment": ""
      },
      {
        "name": "test_binn_version",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 28,
        "end_line": 32,
        "start_byte": 859,
        "end_byte": 978,
        "signature": "void test_binn_version()",
        "full_definition": "void test_binn_version() {\n  char *version = binn_version();\n  assert(version);\n  assert(strcmp(version,\"3.0.0\")==0);\n}",
        "definition_length": 119,
        "comment": "***********************************************************************************"
      },
      {
        "name": "copy_be16",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "u16 *pdest",
          "u16 *psource"
        ],
        "start_line": 36,
        "end_line": 36,
        "start_byte": 1069,
        "end_byte": 1123,
        "full_declaration": "BINN_PRIVATE void copy_be16(u16 *pdest, u16 *psource);",
        "declaration_length": 54,
        "comment": "***********************************************************************************"
      },
      {
        "name": "copy_be32",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "u32 *pdest",
          "u32 *psource"
        ],
        "start_line": 37,
        "end_line": 37,
        "start_byte": 1124,
        "end_byte": 1178,
        "full_declaration": "BINN_PRIVATE void copy_be32(u32 *pdest, u32 *psource);",
        "declaration_length": 54,
        "comment": "***********************************************************************************"
      },
      {
        "name": "copy_be64",
        "type": "declaration",
        "return_type": "BINN_PRIVATE",
        "parameters": [
          "u64 *pdest",
          "u64 *psource"
        ],
        "start_line": 38,
        "end_line": 38,
        "start_byte": 1179,
        "end_byte": 1233,
        "full_declaration": "BINN_PRIVATE void copy_be64(u64 *pdest, u64 *psource);",
        "declaration_length": 54,
        "comment": ""
      },
      {
        "name": "test_endianess",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 40,
        "end_line": 124,
        "start_byte": 1235,
        "end_byte": 3096,
        "signature": "void test_endianess()",
        "full_definition": "void test_endianess() {\n  u16 vshort1, vshort2, vshort3;\n  u32 vint1, vint2, vint3;\n  u64 value1, value2, value3;\n\n  printf(\"testing endianess... \");\n\n  /* tobe16 */\n  vshort1 = 0x1122;\n  copy_be16(&vshort2, &vshort1);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  assert(vshort2 == 0x2211);\n#else\n  assert(vshort2 == 0x1122);\n#endif\n  copy_be16(&vshort3, &vshort2);\n  assert(vshort3 == vshort1);\n\n  vshort1 = 0xF123;\n  copy_be16(&vshort2, &vshort1);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  assert(vshort2 == 0x23F1);\n#else\n  assert(vshort2 == 0xF123);\n#endif\n  copy_be16(&vshort3, &vshort2);\n  assert(vshort3 == vshort1);\n\n  vshort1 = 0x0123;\n  copy_be16(&vshort2, &vshort1);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  assert(vshort2 == 0x2301);\n#else\n  assert(vshort2 == 0x0123);\n#endif\n  copy_be16(&vshort3, &vshort2);\n  assert(vshort3 == vshort1);\n\n  /* tobe32 */\n  vint1 = 0x11223344;\n  copy_be32(&vint2, &vint1);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  assert(vint2 == 0x44332211);\n#else\n  assert(vint2 == 0x11223344);\n#endif\n  copy_be32(&vint3, &vint2);\n  assert(vint3 == vint1);\n\n  vint1 = 0xF1234580;\n  copy_be32(&vint2, &vint1);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  assert(vint2 == 0x804523F1);\n#else\n  assert(vint2 == 0xF1234580);\n#endif\n  copy_be32(&vint3, &vint2);\n  assert(vint3 == vint1);\n\n  vint1 = 0x00112233;\n  copy_be32(&vint2, &vint1);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  assert(vint2 == 0x33221100);\n#else\n  assert(vint2 == 0x00112233);\n#endif\n  copy_be32(&vint3, &vint2);\n  assert(vint3 == vint1);\n\n  /* tobe64 */\n  value1 = 0x1122334455667788;\n  copy_be64(&value2, &value1);\n  //printf(\"v1: %llx\\n\", value1);\n  //printf(\"v2: %llx\\n\", value2);\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  assert(value2 == 0x8877665544332211);\n#else\n  assert(value2 == 0x1122334455667788);\n#endif\n  copy_be64(&value3, &value2);\n  assert(value3 == value1);\n\n  printf(\"OK\\n\");\n\n}",
        "definition_length": 1861,
        "comment": ""
      },
      {
        "name": "memdup",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "void *src",
          "int size"
        ],
        "is_static": false,
        "start_line": 128,
        "end_line": 137,
        "start_byte": 3177,
        "end_byte": 3374,
        "signature": "void * memdup(void *src, int size)",
        "full_definition": "void * memdup(void *src, int size) {\n  void *dest;\n\n  if (src == NULL || size <= 0) return NULL;\n  dest = malloc(size);\n  if (dest == NULL) return NULL;\n  memcpy(dest, src, size);\n  return dest;\n\n}",
        "definition_length": 197,
        "comment": "*************************************************************************"
      },
      {
        "name": "i64toa",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "int64 value",
          "char *buf",
          "int radix"
        ],
        "is_static": false,
        "start_line": 141,
        "end_line": 157,
        "start_byte": 3455,
        "end_byte": 3781,
        "signature": "char * i64toa(int64 value, char *buf, int radix)",
        "full_definition": "char * i64toa(int64 value, char *buf, int radix) {\n#ifdef _MSC_VER\n  return _i64toa(value, buf, radix);\n#else\n  switch (radix) {\n  case 10:\n    snprintf(buf, 64, \"%\" INT64_FORMAT, value);\n    break;\n  case 16:\n    snprintf(buf, 64, \"%\" INT64_HEX_FORMAT, value);\n    break;\n  default:\n    buf[0] = 0;\n  }\n  return buf;\n#endif\n}",
        "definition_length": 326,
        "comment": "*************************************************************************"
      },
      {
        "name": "pass_int64",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "int64 a"
        ],
        "is_static": false,
        "start_line": 161,
        "end_line": 166,
        "start_byte": 3872,
        "end_byte": 3973,
        "signature": "void pass_int64(int64 a)",
        "full_definition": "void pass_int64(int64 a) {\n\n  assert(a == 9223372036854775807);\n  assert(a > 9223372036854775806);\n\n}",
        "definition_length": 101,
        "comment": "***********************************************************************************"
      },
      {
        "name": "return_int64",
        "type": "definition",
        "return_type": "int64",
        "parameters": [],
        "is_static": false,
        "start_line": 168,
        "end_line": 172,
        "start_byte": 3975,
        "end_byte": 4031,
        "signature": "int64 return_int64()",
        "full_definition": "int64 return_int64() {\n\n  return 9223372036854775807;\n\n}",
        "definition_length": 56,
        "comment": ""
      },
      {
        "name": "return_passed_int64",
        "type": "definition",
        "return_type": "int64",
        "parameters": [
          "int64 a"
        ],
        "is_static": false,
        "start_line": 174,
        "end_line": 178,
        "start_byte": 4033,
        "end_byte": 4085,
        "signature": "int64 return_passed_int64(int64 a)",
        "full_definition": "int64 return_passed_int64(int64 a) {\n\n  return a;\n\n}",
        "definition_length": 52,
        "comment": ""
      },
      {
        "name": "test_int64",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 182,
        "end_line": 218,
        "start_byte": 4176,
        "end_byte": 5005,
        "signature": "void test_int64()",
        "full_definition": "void test_int64() {\n  int64 i64;\n  //uint64 b;\n  //long long int b;  -- did not work!\n  char buf[64];\n\n  printf(\"testing int64... \");\n\n  pass_int64(9223372036854775807);\n\n  i64 = return_int64();\n  assert(i64 == 9223372036854775807);\n\n  /*  do not worked!\n  b = 9223372036854775807;\n  printf(\"value of b1=%\" G_GINT64_FORMAT \"\\n\", b);\n  snprintf(64, buf, \"%\" G_GINT64_FORMAT, b);\n  printf(\" value of b2=%s\\n\", buf);\n\n  ltoa(i64, buf, 10);\n  printf(\" value of i64=%s\\n\", buf);\n  */\n\n  i64toa(i64, buf, 10);\n  //printf(\" value of i64=%s\\n\", buf);\n  assert(strcmp(buf, \"9223372036854775807\") == 0);\n\n  i64 = return_passed_int64(-987654321987654321);\n  assert(i64 == -987654321987654321);\n\n  //snprintf(64, buf, \"%\" G_GINT64_FORMAT, i64);\n  i64toa(i64, buf, 10);\n  assert(strcmp(buf, \"-987654321987654321\") == 0);\n\n  printf(\"OK\\n\");\n\n}",
        "definition_length": 829,
        "comment": "***********************************************************************************"
      },
      {
        "name": "AlmostEqualFloats",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "float A",
          "float B",
          "int maxUlps"
        ],
        "is_static": false,
        "start_line": 224,
        "end_line": 237,
        "start_byte": 5225,
        "end_byte": 5754,
        "signature": "BOOL AlmostEqualFloats(float A, float B, int maxUlps)",
        "full_definition": "BOOL AlmostEqualFloats(float A, float B, int maxUlps) {\n  int aInt, bInt, intDiff;\n  // Make sure maxUlps is non-negative and small enough that the\n  // default NAN won't compare as equal to anything.\n  assert(maxUlps > 0 && maxUlps < 4 * 1024 * 1024);\n  aInt = *(int*)&A;\n  bInt = *(int*)&B;\n  // Make aInt lexicographically ordered as a twos-complement int\n  if (aInt < 0) aInt = 0x80000000 - aInt;\n  if (bInt < 0) bInt = 0x80000000 - bInt;\n  intDiff = abs(aInt - bInt);\n  if (intDiff <= maxUlps) return TRUE;\n  return FALSE;\n}",
        "definition_length": 529,
        "comment": "! this code may not work on processors that does not use the default float standard original name: AlmostEqual2sComplement"
      },
      {
        "name": "AlmostEqualDoubles",
        "type": "definition",
        "return_type": "BOOL",
        "parameters": [
          "double a",
          "double b"
        ],
        "is_static": false,
        "start_line": 252,
        "end_line": 265,
        "start_byte": 6034,
        "end_byte": 6371,
        "signature": "BOOL AlmostEqualDoubles(double a, double b)",
        "full_definition": "BOOL AlmostEqualDoubles(double a, double b) {\n    double absDiff, maxAbs, absA, absB;\n\n    absDiff = fabs(a - b);\n    if (absDiff < VERYSMALL) return TRUE;\n\n    absA = fabs(a);\n    absB = fabs(b);\n    maxAbs  = max(absA, absB);\n    if ((absDiff / maxAbs) < EPSILON)\n      return TRUE;\n    printf(\"a=%g b=%g\\n\", a, b);\n    return FALSE;\n}",
        "definition_length": 337,
        "comment": ""
      },
      {
        "name": "test_floating_point_numbers",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 269,
        "end_line": 346,
        "start_byte": 6462,
        "end_byte": 8079,
        "signature": "void test_floating_point_numbers()",
        "full_definition": "void test_floating_point_numbers() {\n  char  buf[256];\n  float f1;\n  double d1;\n\n  printf(\"testing floating point... \");\n\n  f1 = 1.25;\n  assert(f1 == 1.25);\n  d1 = 1.25;\n  assert(d1 == 1.25);\n\n  d1 = 0;\n  d1 = f1;\n  assert(d1 == 1.25);\n  f1 = 0;\n  f1 = d1;\n  assert(f1 == 1.25);\n\n  d1 = 1.234;\n  assert(AlmostEqualDoubles(d1, 1.234) == TRUE);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n  d1 = 1.2345;\n  assert(AlmostEqualDoubles(d1, 1.2345) == TRUE);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 1.2345, 2) == TRUE);\n\n\n  // from string to number, and back to string\n\n  d1 = atof(\"1.234\");  // converts from string to double\n  assert(AlmostEqualDoubles(d1, 1.234) == TRUE);\n  f1 = d1;             // converts from double to float\n  assert(AlmostEqualFloats(f1, 1.234, 2) == TRUE);\n\n  /*\n  sprintf(buf, \"%f\", d1);  // from double to string\n  assert(buf[0] != 0);\n  assert(strcmp(buf, \"1.234\") == 0);\n  */\n\n  sprintf(buf, \"%g\", d1);\n  assert(buf[0] != 0);\n  assert(strcmp(buf, \"1.234\") == 0);\n\n\n  d1 = atof(\"12.34\");\n  assert(d1 == 12.34);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 12.34, 2) == TRUE);\n\n  /*\n  sprintf(buf, \"%f\", d1);  // from double to string\n  assert(buf[0] != 0);\n  assert(strcmp(buf, \"12.34\") == 0);\n  */\n\n  sprintf(buf, \"%g\", d1);\n  assert(buf[0] != 0);\n  assert(strcmp(buf, \"12.34\") == 0);\n\n\n  d1 = atof(\"1.234e25\");\n  assert(AlmostEqualDoubles(d1, 1.234e25) == TRUE);\n  f1 = d1;\n  assert(AlmostEqualFloats(f1, 1.234e25, 2) == TRUE);\n\n  sprintf(buf, \"%g\", d1);\n  assert(buf[0] != 0);\n  //printf(\"\\nbuf=%s\\n\", buf);\n  //assert(strcmp(buf, \"1.234e+025\") == 0);\n\n\n  printf(\"OK\\n\");\n\n}",
        "definition_length": 1617,
        "comment": "***********************************************************************************"
      },
      {
        "name": "print_binn",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "binn *map"
        ],
        "is_static": false,
        "start_line": 350,
        "end_line": 359,
        "start_byte": 8170,
        "end_byte": 8349,
        "signature": "void print_binn(binn *map)",
        "full_definition": "void print_binn(binn *map) {\n  unsigned char *p;\n  int size, i;\n  p = binn_ptr(map);\n  size = binn_size(map);\n  for(i=0; i<size; i++){\n    printf(\"%02x \", p[i]);\n  }\n  puts(\"\");\n}",
        "definition_length": 179,
        "comment": "***********************************************************************************"
      },
      {
        "name": "test_create_binn_structures",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 366,
        "end_line": 405,
        "start_byte": 8443,
        "end_byte": 9566,
        "signature": "void test_create_binn_structures()",
        "full_definition": "void test_create_binn_structures() {\n    binn *list, *map, *obj;\n\n    list = binn_list();\n    assert(list != INVALID_BINN);\n\n    map = binn_map();\n    assert(map != INVALID_BINN);\n\n    obj = binn_object();\n    assert(obj != INVALID_BINN);\n\n    assert(list->header == BINN_MAGIC);\n    assert(list->type == BINN_LIST);\n    assert(list->count == 0);\n    assert(list->pbuf != NULL);\n    assert(list->alloc_size > MAX_BINN_HEADER);\n    assert(list->used_size == MAX_BINN_HEADER);\n    assert(list->pre_allocated == FALSE);\n\n    assert(map->header == BINN_MAGIC);\n    assert(map->type == BINN_MAP);\n    assert(map->count == 0);\n    assert(map->pbuf != NULL);\n    assert(map->alloc_size > MAX_BINN_HEADER);\n    assert(map->used_size == MAX_BINN_HEADER);\n    assert(map->pre_allocated == FALSE);\n\n    assert(obj->header == BINN_MAGIC);\n    assert(obj->type == BINN_OBJECT);\n    assert(obj->count == 0);\n    assert(obj->pbuf != NULL);\n    assert(obj->alloc_size > MAX_BINN_HEADER);\n    assert(obj->used_size == MAX_BINN_HEADER);\n    assert(obj->pre_allocated == FALSE);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 1123,
        "comment": ""
      },
      {
        "name": "test_preallocated_binn",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 407,
        "end_line": 425,
        "start_byte": 9568,
        "end_byte": 10097,
        "signature": "void test_preallocated_binn()",
        "full_definition": "void test_preallocated_binn() {\n    static const int fix_size = 512;\n    char *ptr = malloc(fix_size);\n    assert(ptr != NULL);\n\n    binn *obj1 = binn_new(BINN_OBJECT, fix_size, ptr);\n    assert(obj1 != INVALID_BINN);\n\n    assert(obj1->header == BINN_MAGIC);\n    assert(obj1->type == BINN_OBJECT);\n    assert(obj1->count == 0);\n    assert(obj1->pbuf != NULL);\n    assert(obj1->alloc_size == fix_size);\n    assert(obj1->used_size == MAX_BINN_HEADER);\n    assert(obj1->pre_allocated == TRUE);\n\n    binn_free(obj1);\n    free(ptr);\n}",
        "definition_length": 529,
        "comment": ""
      },
      {
        "name": "test_invalid_read_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 427,
        "end_line": 450,
        "start_byte": 10099,
        "end_byte": 10714,
        "signature": "void test_invalid_read_operations()",
        "full_definition": "void test_invalid_read_operations() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n    char *ptr;\n    int type, size;\n\n    ptr = binn_ptr(list);\n    assert(ptr != NULL);\n    assert(binn_list_read(ptr, 0, &type, &size) == NULL);\n    assert(binn_list_read(ptr, 1, &type, &size) == NULL);\n\n    ptr = binn_ptr(map);\n    assert(ptr != NULL);\n    assert(binn_map_read(ptr, 0, &type, &size) == NULL);\n\n    ptr = binn_ptr(obj);\n    assert(ptr != NULL);\n    assert(binn_object_read(ptr, NULL, &type, &size) == NULL);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 615,
        "comment": ""
      },
      {
        "name": "test_valid_add_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 452,
        "end_line": 465,
        "start_byte": 10716,
        "end_byte": 11114,
        "signature": "void test_valid_add_operations()",
        "full_definition": "void test_valid_add_operations() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n    int i = 123;\n\n    assert(binn_list_add(list, BINN_INT32, &i, 0) == TRUE);\n    assert(binn_map_set(map, 5501, BINN_INT32, &i, 0) == TRUE);\n    assert(binn_object_set(obj, \"test\", BINN_INT32, &i, 0) == TRUE);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 398,
        "comment": ""
      },
      {
        "name": "test_read_keys",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 467,
        "end_line": 477,
        "start_byte": 11116,
        "end_byte": 11386,
        "signature": "void test_read_keys()",
        "full_definition": "void test_read_keys() {\n    binn *map = binn_map();\n    int id;\n    binn value;\n\n    assert(binn_map_set(map, 5501, BINN_INT32, &(int){123}, 0) == TRUE);\n    assert(binn_map_get_pair(binn_ptr(map), 1, &id, &value) == TRUE);\n    assert(id == 5501);\n\n    binn_free(map);\n}",
        "definition_length": 270,
        "comment": ""
      },
      {
        "name": "test_binn_size_and_validation",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 479,
        "end_line": 495,
        "start_byte": 11388,
        "end_byte": 11822,
        "signature": "void test_binn_size_and_validation()",
        "full_definition": "void test_binn_size_and_validation() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n    char *ptr;\n    int type, count, size, header_size;\n\n    ptr = binn_ptr(obj);\n    assert(ptr != NULL);\n    assert(IsValidBinnHeader(ptr, &type, &count, &size, &header_size) == TRUE);\n    assert(type == BINN_OBJECT);\n    assert(count == 0);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 434,
        "comment": ""
      },
      {
        "name": "test_add_and_read_blob",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 497,
        "end_line": 512,
        "start_byte": 11824,
        "end_byte": 12241,
        "signature": "void test_add_and_read_blob()",
        "full_definition": "void test_add_and_read_blob() {\n    binn *list = binn_list();\n    int blobsize = 150;\n    char *pblob = malloc(blobsize);\n    assert(pblob != NULL);\n    memset(pblob, 55, blobsize);\n\n    assert(binn_list_add(list, BINN_BLOB, pblob, blobsize) == TRUE);\n\n    char *ptr = binn_list_blob(list, 1, &blobsize);\n    assert(ptr != NULL);\n    assert(memcmp(ptr, pblob, blobsize) == 0);\n\n    free(pblob);\n    binn_free(list);\n}",
        "definition_length": 417,
        "comment": ""
      },
      {
        "name": "test_add_and_read_string",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 514,
        "end_line": 526,
        "start_byte": 12243,
        "end_byte": 12600,
        "signature": "void test_add_and_read_string()",
        "full_definition": "void test_add_and_read_string() {\n    binn *obj = binn_object();\n    const char *key = \"test_key\";\n    const char *value = \"test_value\";\n\n    assert(binn_object_set(obj, key, BINN_STRING, value, 0) == TRUE);\n\n    char *read_value = binn_object_str(obj, key);\n    assert(read_value != NULL);\n    assert(strcmp(read_value, value) == 0);\n\n    binn_free(obj);\n}",
        "definition_length": 357,
        "comment": ""
      },
      {
        "name": "test_add_and_read_integer",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 528,
        "end_line": 539,
        "start_byte": 12602,
        "end_byte": 12893,
        "signature": "void test_add_and_read_integer()",
        "full_definition": "void test_add_and_read_integer() {\n    binn *list = binn_list();\n    int value = 123;\n\n    assert(binn_list_add(list, BINN_INT32, &value, 0) == TRUE);\n\n    int read_value;\n    assert(binn_list_get_int32(list, 1, &read_value) == TRUE);\n    assert(read_value == value);\n\n    binn_free(list);\n}",
        "definition_length": 291,
        "comment": ""
      },
      {
        "name": "test_invalid_binn",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 543,
        "end_line": 600,
        "start_byte": 12984,
        "end_byte": 15048,
        "signature": "void test_invalid_binn()",
        "full_definition": "void test_invalid_binn() {\n\n  char buffers[][20] = {\n    { 0xE0 },\n    { 0xE0, 0x7E },\n    { 0xE0, 0x7E, 0x7F },\n    { 0xE0, 0x7E, 0x7F, 0x12 },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34 },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x01 },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0x7F },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01 },\n    { 0xE0, 0x7E, 0x7F, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x7E, 0xFF },\n    { 0xE0, 0x7E, 0xFF, 0x12 },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34 },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x01 },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0x7F },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01 },\n    { 0xE0, 0x7E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x8E },\n    { 0xE0, 0x8E, 0xFF },\n    { 0xE0, 0x8E, 0xFF, 0x12 },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34 },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x01 },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0x7F },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0x01 },\n    { 0xE0, 0x8E, 0xFF, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }\n  };\n\n  int count, size, i;\n  char *ptr;\n\n  puts(\"testing invalid binn buffers...\");\n\n  count = sizeof buffers / sizeof buffers[0];\n\n  for (i=0; i < count; i++) {\n    ptr = buffers[i];\n    size = strlen(ptr);\n    printf(\"checking invalid binn #%d   size: %d bytes\\n\", i, size);\n    assert(binn_is_valid_ex(ptr, NULL, NULL, &size) == FALSE);\n  }\n\n  puts(\"OK\");\n\n}",
        "definition_length": 2064,
        "comment": "***********************************************************************************"
      },
      {
        "name": "test_calc_allocation",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 603,
        "end_line": 614,
        "start_byte": 15051,
        "end_byte": 15507,
        "signature": "void test_calc_allocation()",
        "full_definition": "void test_calc_allocation() {\n    assert(CalcAllocation(512, 512) == 512);\n    assert(CalcAllocation(510, 512) == 512);\n    assert(CalcAllocation(1, 512) == 512);\n    assert(CalcAllocation(0, 512) == 512);\n\n    assert(CalcAllocation(513, 512) == 1024);\n    assert(CalcAllocation(512 + CHUNK_SIZE, 512) == 1024);\n    assert(CalcAllocation(1025, 512) == 2048);\n    assert(CalcAllocation(1025, 1024) == 2048);\n    assert(CalcAllocation(2100, 1024) == 4096);\n}",
        "definition_length": 456,
        "comment": ""
      },
      {
        "name": "test_invalid_binn_creation",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 616,
        "end_line": 628,
        "start_byte": 15509,
        "end_byte": 15969,
        "signature": "void test_invalid_binn_creation()",
        "full_definition": "void test_invalid_binn_creation() {\n    char *ptr;\n    binn *obj1;\n\n    assert(binn_new(-1, 0, NULL) == INVALID_BINN);\n    assert(binn_new(0, 0, NULL) == INVALID_BINN);\n    assert(binn_new(5, 0, NULL) == INVALID_BINN);\n    assert(binn_new(BINN_MAP, -1, NULL) == INVALID_BINN);\n\n    ptr = (char *)&obj1;  // create a valid pointer\n    assert(binn_new(BINN_MAP, -1, ptr) == INVALID_BINN);\n    assert(binn_new(BINN_MAP, MIN_BINN_SIZE - 1, ptr) == INVALID_BINN);\n}",
        "definition_length": 460,
        "comment": ""
      },
      {
        "name": "test_valid_binn_creation",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 630,
        "end_line": 669,
        "start_byte": 15971,
        "end_byte": 17142,
        "signature": "void test_valid_binn_creation()",
        "full_definition": "void test_valid_binn_creation() {\n    binn *list, *map, *obj;\n\n    list = binn_new(BINN_LIST, 0, NULL);\n    assert(list != INVALID_BINN);\n\n    map = binn_new(BINN_MAP, 0, NULL);\n    assert(map != INVALID_BINN);\n\n    obj = binn_new(BINN_OBJECT, 0, NULL);\n    assert(obj != INVALID_BINN);\n\n    assert(list->header == BINN_MAGIC);\n    assert(list->type == BINN_LIST);\n    assert(list->count == 0);\n    assert(list->pbuf != NULL);\n    assert(list->alloc_size > MAX_BINN_HEADER);\n    assert(list->used_size == MAX_BINN_HEADER);\n    assert(list->pre_allocated == FALSE);\n\n    assert(map->header == BINN_MAGIC);\n    assert(map->type == BINN_MAP);\n    assert(map->count == 0);\n    assert(map->pbuf != NULL);\n    assert(map->alloc_size > MAX_BINN_HEADER);\n    assert(map->used_size == MAX_BINN_HEADER);\n    assert(map->pre_allocated == FALSE);\n\n    assert(obj->header == BINN_MAGIC);\n    assert(obj->type == BINN_OBJECT);\n    assert(obj->count == 0);\n    assert(obj->pbuf != NULL);\n    assert(obj->alloc_size > MAX_BINN_HEADER);\n    assert(obj->used_size == MAX_BINN_HEADER);\n    assert(obj->pre_allocated == FALSE);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 1171,
        "comment": ""
      },
      {
        "name": "test_preallocated_binn_creation",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 671,
        "end_line": 689,
        "start_byte": 17144,
        "end_byte": 17682,
        "signature": "void test_preallocated_binn_creation()",
        "full_definition": "void test_preallocated_binn_creation() {\n    static const int fix_size = 512;\n    char *ptr = malloc(fix_size);\n    assert(ptr != NULL);\n\n    binn *obj1 = binn_new(BINN_OBJECT, fix_size, ptr);\n    assert(obj1 != INVALID_BINN);\n\n    assert(obj1->header == BINN_MAGIC);\n    assert(obj1->type == BINN_OBJECT);\n    assert(obj1->count == 0);\n    assert(obj1->pbuf != NULL);\n    assert(obj1->alloc_size == fix_size);\n    assert(obj1->used_size == MAX_BINN_HEADER);\n    assert(obj1->pre_allocated == TRUE);\n\n    binn_free(obj1);\n    free(ptr);\n}",
        "definition_length": 538,
        "comment": ""
      },
      {
        "name": "test_invalid_binn_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 691,
        "end_line": 709,
        "start_byte": 17684,
        "end_byte": 18339,
        "signature": "void test_invalid_binn_operations()",
        "full_definition": "void test_invalid_binn_operations() {\n    binn *list = binn_new(BINN_LIST, 0, NULL);\n    binn *map = binn_new(BINN_MAP, 0, NULL);\n    binn *obj = binn_new(BINN_OBJECT, 0, NULL);\n    int i = 123;\n\n    assert(binn_map_set(list, 55001, BINN_INT32, &i, 0) == FALSE);\n    assert(binn_object_set(list, \"test\", BINN_INT32, &i, 0) == FALSE);\n\n    assert(binn_list_add(map, BINN_INT32, &i, 0) == FALSE);\n    assert(binn_object_set(map, \"test\", BINN_INT32, &i, 0) == FALSE);\n\n    assert(binn_list_add(obj, BINN_INT32, &i, 0) == FALSE);\n    assert(binn_map_set(obj, 55001, BINN_INT32, &i, 0) == FALSE);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 655,
        "comment": ""
      },
      {
        "name": "test_valid_binn_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 711,
        "end_line": 726,
        "start_byte": 18341,
        "end_byte": 18973,
        "signature": "void test_valid_binn_operations()",
        "full_definition": "void test_valid_binn_operations() {\n    binn *list = binn_new(BINN_LIST, 0, NULL);\n    binn *map = binn_new(BINN_MAP, 0, NULL);\n    binn *obj = binn_new(BINN_OBJECT, 0, NULL);\n    int i = 0x1234;\n\n    assert(binn_list_add(list, BINN_INT32, &i, 0) == TRUE);\n    assert(binn_map_set(map, 5501, BINN_INT32, &i, 0) == TRUE);\n    assert(binn_map_set(map, 5501, BINN_INT32, &i, 0) == FALSE);  // with the same ID\n    assert(binn_object_set(obj, \"test\", BINN_INT32, &i, 0) == TRUE);\n    assert(binn_object_set(obj, \"test\", BINN_INT32, &i, 0) == FALSE);  // with the same name\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 632,
        "comment": ""
      },
      {
        "name": "test_binn_size_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 728,
        "end_line": 741,
        "start_byte": 18975,
        "end_byte": 19373,
        "signature": "void test_binn_size_operations()",
        "full_definition": "void test_binn_size_operations() {\n    binn *list = binn_new(BINN_LIST, 0, NULL);\n    binn *map = binn_new(BINN_MAP, 0, NULL);\n    binn *obj = binn_new(BINN_OBJECT, 0, NULL);\n\n    assert(binn_size(NULL) == 0);\n    assert(binn_size(list) == list->size);\n    assert(binn_size(map) == map->size);\n    assert(binn_size(obj) == obj->size);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 398,
        "comment": ""
      },
      {
        "name": "test_binn_blob_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 743,
        "end_line": 758,
        "start_byte": 19375,
        "end_byte": 19812,
        "signature": "void test_binn_blob_operations()",
        "full_definition": "void test_binn_blob_operations() {\n    binn *list = binn_new(BINN_LIST, 0, NULL);\n    int blobsize = 150;\n    char *pblob = malloc(blobsize);\n    assert(pblob != NULL);\n    memset(pblob, 55, blobsize);\n\n    assert(binn_list_add(list, BINN_BLOB, pblob, blobsize) == TRUE);\n\n    char *ptr = binn_list_blob(list, 1, &blobsize);\n    assert(ptr != NULL);\n    assert(memcmp(ptr, pblob, blobsize) == 0);\n\n    free(pblob);\n    binn_free(list);\n}",
        "definition_length": 437,
        "comment": ""
      },
      {
        "name": "test_binn_string_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 760,
        "end_line": 772,
        "start_byte": 19814,
        "end_byte": 20191,
        "signature": "void test_binn_string_operations()",
        "full_definition": "void test_binn_string_operations() {\n    binn *obj = binn_new(BINN_OBJECT, 0, NULL);\n    const char *key = \"test_key\";\n    const char *value = \"test_value\";\n\n    assert(binn_object_set(obj, key, BINN_STRING, value, 0) == TRUE);\n\n    char *read_value = binn_object_str(obj, key);\n    assert(read_value != NULL);\n    assert(strcmp(read_value, value) == 0);\n\n    binn_free(obj);\n}",
        "definition_length": 377,
        "comment": ""
      },
      {
        "name": "test_binn_integer_operations",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 774,
        "end_line": 785,
        "start_byte": 20193,
        "end_byte": 20504,
        "signature": "void test_binn_integer_operations()",
        "full_definition": "void test_binn_integer_operations() {\n    binn *list = binn_new(BINN_LIST, 0, NULL);\n    int value = 123;\n\n    assert(binn_list_add(list, BINN_INT32, &value, 0) == TRUE);\n\n    int read_value;\n    assert(binn_list_get_int32(list, 1, &read_value) == TRUE);\n    assert(read_value == value);\n\n    binn_free(list);\n}",
        "definition_length": 311,
        "comment": ""
      },
      {
        "name": "test_create_and_add_values_no_compression",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 789,
        "end_line": 820,
        "start_byte": 20595,
        "end_byte": 21618,
        "signature": "void test_create_and_add_values_no_compression()",
        "full_definition": "void test_create_and_add_values_no_compression() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n\n    assert(list != INVALID_BINN);\n    assert(map != INVALID_BINN);\n    assert(obj != INVALID_BINN);\n\n    list->disable_int_compression = TRUE;\n    map->disable_int_compression = TRUE;\n    obj->disable_int_compression = TRUE;\n\n    // Add integer values\n    assert(binn_list_add_int32(list, 123) == TRUE);\n    assert(binn_map_set_int32(map, 1001, 456) == TRUE);\n    assert(binn_object_set_int32(obj, \"int\", 789) == TRUE);\n\n    // Add double values\n    assert(binn_list_add_double(list, 1.23) == TRUE);\n    assert(binn_map_set_double(map, 1002, 4.56) == TRUE);\n    assert(binn_object_set_double(obj, \"double\", 7.89) == TRUE);\n\n    // Add boolean values\n    assert(binn_list_add_bool(list, TRUE) == TRUE);\n    assert(binn_map_set_bool(map, 1003, TRUE) == TRUE);\n    assert(binn_object_set_bool(obj, \"bool\", TRUE) == TRUE);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 1023,
        "comment": "***********************************************************************************"
      },
      {
        "name": "test_create_and_add_values_with_compression",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 822,
        "end_line": 849,
        "start_byte": 21620,
        "end_byte": 22520,
        "signature": "void test_create_and_add_values_with_compression()",
        "full_definition": "void test_create_and_add_values_with_compression() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n\n    assert(list != INVALID_BINN);\n    assert(map != INVALID_BINN);\n    assert(obj != INVALID_BINN);\n\n    // Add integer values\n    assert(binn_list_add_int32(list, 123) == TRUE);\n    assert(binn_map_set_int32(map, 1001, 456) == TRUE);\n    assert(binn_object_set_int32(obj, \"int\", 789) == TRUE);\n\n    // Add double values\n    assert(binn_list_add_double(list, 1.23) == TRUE);\n    assert(binn_map_set_double(map, 1002, 4.56) == TRUE);\n    assert(binn_object_set_double(obj, \"double\", 7.89) == TRUE);\n\n    // Add boolean values\n    assert(binn_list_add_bool(list, TRUE) == TRUE);\n    assert(binn_map_set_bool(map, 1003, TRUE) == TRUE);\n    assert(binn_object_set_bool(obj, \"bool\", TRUE) == TRUE);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 900,
        "comment": ""
      },
      {
        "name": "test_add_strings_and_blobs_no_compression",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 851,
        "end_line": 883,
        "start_byte": 22522,
        "end_byte": 23518,
        "signature": "void test_add_strings_and_blobs_no_compression()",
        "full_definition": "void test_add_strings_and_blobs_no_compression() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n\n    char *str_list = \"test list\";\n    char *str_map = \"test map\";\n    char *str_obj = \"test object\";\n\n    int blobsize = 150;\n    char *pblob = malloc(blobsize);\n    assert(pblob != NULL);\n    memset(pblob, 55, blobsize);\n\n    list->disable_int_compression = TRUE;\n    map->disable_int_compression = TRUE;\n    obj->disable_int_compression = TRUE;\n\n    // Add string values\n    assert(binn_list_add_str(list, str_list) == TRUE);\n    assert(binn_map_set_str(map, 1004, str_map) == TRUE);\n    assert(binn_object_set_str(obj, \"text\", str_obj) == TRUE);\n\n    // Add blob values\n    assert(binn_list_add_blob(list, pblob, blobsize) == TRUE);\n    assert(binn_map_set_blob(map, 1005, pblob, blobsize) == TRUE);\n    assert(binn_object_set_blob(obj, \"blob\", pblob, blobsize) == TRUE);\n\n    free(pblob);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 996,
        "comment": ""
      },
      {
        "name": "test_add_strings_and_blobs_with_compression",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 885,
        "end_line": 913,
        "start_byte": 23520,
        "end_byte": 24393,
        "signature": "void test_add_strings_and_blobs_with_compression()",
        "full_definition": "void test_add_strings_and_blobs_with_compression() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n\n    char *str_list = \"test list\";\n    char *str_map = \"test map\";\n    char *str_obj = \"test object\";\n\n    int blobsize = 150;\n    char *pblob = malloc(blobsize);\n    assert(pblob != NULL);\n    memset(pblob, 55, blobsize);\n\n    // Add string values\n    assert(binn_list_add_str(list, str_list) == TRUE);\n    assert(binn_map_set_str(map, 1004, str_map) == TRUE);\n    assert(binn_object_set_str(obj, \"text\", str_obj) == TRUE);\n\n    // Add blob values\n    assert(binn_list_add_blob(list, pblob, blobsize) == TRUE);\n    assert(binn_map_set_blob(map, 1005, pblob, blobsize) == TRUE);\n    assert(binn_object_set_blob(obj, \"blob\", pblob, blobsize) == TRUE);\n\n    free(pblob);\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 873,
        "comment": ""
      },
      {
        "name": "test_read_values_no_compression",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 915,
        "end_line": 948,
        "start_byte": 24395,
        "end_byte": 25377,
        "signature": "void test_read_values_no_compression()",
        "full_definition": "void test_read_values_no_compression() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n\n    list->disable_int_compression = TRUE;\n    map->disable_int_compression = TRUE;\n    obj->disable_int_compression = TRUE;\n\n    assert(binn_list_add_int32(list, 123) == TRUE);\n    assert(binn_map_set_int32(map, 1001, 456) == TRUE);\n    assert(binn_object_set_int32(obj, \"int\", 789) == TRUE);\n\n    binn value;\n    memset(&value, 0, sizeof(binn));\n\n    // Read integer from list\n    assert(binn_list_get_value(list, 1, &value) == TRUE);\n    assert(value.vint == 123);\n\n    // Read integer from map\n    memset(&value, 0, sizeof(binn));\n    assert(binn_map_get_value(map, 1001, &value) == TRUE);\n    assert(value.vint == 456);\n\n    // Read integer from object\n    memset(&value, 0, sizeof(binn));\n    assert(binn_object_get_value(obj, \"int\", &value) == TRUE);\n    assert(value.vint == 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 982,
        "comment": ""
      },
      {
        "name": "test_read_values_with_compression",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 950,
        "end_line": 979,
        "start_byte": 25379,
        "end_byte": 26238,
        "signature": "void test_read_values_with_compression()",
        "full_definition": "void test_read_values_with_compression() {\n    binn *list = binn_list();\n    binn *map = binn_map();\n    binn *obj = binn_object();\n\n    assert(binn_list_add_int32(list, 123) == TRUE);\n    assert(binn_map_set_int32(map, 1001, 456) == TRUE);\n    assert(binn_object_set_int32(obj, \"int\", 789) == TRUE);\n\n    binn value;\n    memset(&value, 0, sizeof(binn));\n\n    // Read integer from list\n    assert(binn_list_get_value(list, 1, &value) == TRUE);\n    assert(value.vint == 123);\n\n    // Read integer from map\n    memset(&value, 0, sizeof(binn));\n    assert(binn_map_get_value(map, 1001, &value) == TRUE);\n    assert(value.vint == 456);\n\n    // Read integer from object\n    memset(&value, 0, sizeof(binn));\n    assert(binn_object_get_value(obj, \"int\", &value) == TRUE);\n    assert(value.vint == 789);\n\n    binn_free(list);\n    binn_free(map);\n    binn_free(obj);\n}",
        "definition_length": 859,
        "comment": ""
      },
      {
        "name": "main",
        "type": "definition",
        "return_type": "int",
        "parameters": [],
        "is_static": false,
        "start_line": 984,
        "end_line": 1031,
        "start_byte": 26330,
        "end_byte": 27471,
        "signature": "int main()",
        "full_definition": "int main() {\n\n  puts(\"\\nStarting the unit/regression tests...\\n\");\n\n  printf(\"sizeof(binn) = %ld\\n\\n\", sizeof(binn));\n\n  test_binn_version();\n\n  test_endianess();\n\n  test_int64();\n\n  test_floating_point_numbers();\n\n  test_calc_allocation();\n  test_invalid_binn_creation();\n  test_valid_binn_creation();\n  test_preallocated_binn_creation();\n  test_invalid_binn_operations();\n  test_valid_binn_operations();\n  test_binn_size_operations();\n  test_binn_blob_operations();\n  test_binn_string_operations();\n  test_binn_integer_operations();   \n\n  test_create_and_add_values_no_compression();\ntest_create_and_add_values_with_compression();\ntest_add_strings_and_blobs_no_compression();\ntest_add_strings_and_blobs_with_compression();\ntest_read_values_no_compression();\ntest_read_values_with_compression();\n\n  test_create_binn_structures();\n  test_preallocated_binn();\n  test_invalid_read_operations();\n  test_valid_add_operations();\n  test_read_keys();\n  test_binn_size_and_validation();\n  test_add_and_read_blob();\n  test_add_and_read_string();\n  test_add_and_read_integer();\n\n  test_invalid_binn();\n\n  puts(\"\\nAll tests pass! :)\\n\");\n  return 0;\n\n}",
        "definition_length": 1141,
        "comment": "***********************************************************************************"
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 19
      },
      {
        "text": "#include <stdlib.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 19,
        "end_byte": 39
      },
      {
        "text": "#include <memory.h>",
        "line": 3,
        "start_line": 3,
        "end_line": 4,
        "start_byte": 39,
        "end_byte": 59
      },
      {
        "text": "#include <string.h>",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 59,
        "end_byte": 79
      },
      {
        "text": "#include <math.h>  /* for fabs */",
        "line": 5,
        "start_line": 5,
        "end_line": 6,
        "start_byte": 79,
        "end_byte": 113
      },
      {
        "text": "#include <assert.h>",
        "line": 6,
        "start_line": 6,
        "end_line": 7,
        "start_byte": 113,
        "end_byte": 133
      },
      {
        "text": "#include \"binn.h\"",
        "line": 7,
        "start_line": 7,
        "end_line": 8,
        "start_byte": 133,
        "end_byte": 151
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef unsigned short int     u16;",
        "name": "u16",
        "line": 15,
        "start_line": 15,
        "end_line": 15,
        "start_byte": 362,
        "end_byte": 397,
        "comment": ""
      },
      {
        "text": "typedef unsigned int           u32;",
        "name": "u32",
        "line": 16,
        "start_line": 16,
        "end_line": 16,
        "start_byte": 398,
        "end_byte": 433,
        "comment": ""
      },
      {
        "text": "typedef unsigned long long int u64;",
        "name": "u64",
        "line": 17,
        "start_line": 17,
        "end_line": 17,
        "start_byte": 434,
        "end_byte": 469,
        "comment": ""
      }
    ],
    "macros": [
      {
        "text": "#define BINN_MAGIC            0x1F22B11F",
        "name": "BINN_MAGIC",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 152,
        "end_byte": 193,
        "comment": ""
      },
      {
        "text": "#define MAX_BINN_HEADER       9  // [1:type][4:size][4:count]",
        "name": "MAX_BINN_HEADER",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 194,
        "end_byte": 256,
        "comment": ""
      },
      {
        "text": "#define MIN_BINN_SIZE         3  // [1:type][1:size][1:count]",
        "name": "MIN_BINN_SIZE",
        "line": 12,
        "start_line": 12,
        "end_line": 13,
        "start_byte": 256,
        "end_byte": 318,
        "comment": ""
      },
      {
        "text": "#define CHUNK_SIZE            256  // 1024",
        "name": "CHUNK_SIZE",
        "line": 13,
        "start_line": 13,
        "end_line": 14,
        "start_byte": 318,
        "end_byte": 361,
        "comment": ""
      },
      {
        "text": "#define VERYSMALL  (1.0E-150)",
        "name": "VERYSMALL",
        "line": 241,
        "start_line": 241,
        "end_line": 242,
        "start_byte": 5845,
        "end_byte": 5875,
        "comment": "***********************************************************************************"
      },
      {
        "text": "#define EPSILON    (1.0E-8)",
        "name": "EPSILON",
        "line": 242,
        "start_line": 242,
        "end_line": 243,
        "start_byte": 5875,
        "end_byte": 5903,
        "comment": "***********************************************************************************"
      },
      {
        "text": "#define max(a,b)   (((a) > (b)) ? (a) : (b))",
        "name": "max",
        "line": 245,
        "start_line": 245,
        "end_line": 246,
        "start_byte": 5916,
        "end_byte": 5961,
        "comment": ""
      },
      {
        "text": "#define min(a,b)   (((a) < (b)) ? (a) : (b))",
        "name": "min",
        "line": 249,
        "start_line": 249,
        "end_line": 250,
        "start_byte": 5981,
        "end_byte": 6026,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 8884,
    "file_size": 27472
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-lil.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-lil.c",
    "parse_success": true,
    "functions": [
      {
        "name": "do_exit",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "lil_value_t val"
        ],
        "is_static": true,
        "start_line": 19,
        "end_line": 23,
        "start_byte": 368,
        "end_byte": 500,
        "signature": "static LILCALLBACK void do_exit(lil_t lil, lil_value_t val)",
        "full_definition": "static LILCALLBACK void do_exit(lil_t lil, lil_value_t val)\n{\n    test_running = 0;\n    test_exit_code = (int)lil_to_integer(val);\n}",
        "definition_length": 132,
        "comment": "Test callback function"
      },
      {
        "name": "do_system",
        "type": "definition",
        "return_type": "char",
        "parameters": [
          "size_t argc",
          "char** argv"
        ],
        "is_static": true,
        "start_line": 26,
        "end_line": 43,
        "start_byte": 551,
        "end_byte": 989,
        "signature": "static char* do_system(size_t argc, char** argv)",
        "full_definition": "static char* do_system(size_t argc, char** argv)\n{\n    #if defined(WIN32) || defined(WATCOMC)\n    return NULL;\n    #else\n    if (argc == 0) return NULL;\n    \n    // For testing, simulate some common commands\n    if (strcmp(argv[0], \"echo\") == 0 && argc > 1) {\n        char* result = malloc(strlen(argv[1]) + 2);\n        strcpy(result, argv[1]);\n        strcat(result, \"\\n\");\n        return result;\n    }\n    \n    return NULL;\n    #endif\n}",
        "definition_length": 438,
        "comment": "Test system function (simplified for testing)"
      },
      {
        "name": "fnc_writechar",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 46,
        "end_line": 51,
        "start_byte": 1018,
        "end_byte": 1203,
        "signature": "static LILCALLBACK lil_value_t fnc_writechar(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_writechar(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    if (!argc) return NULL;\n    printf(\"%c\", (char)lil_to_integer(argv[0]));\n    return NULL;\n}",
        "definition_length": 185,
        "comment": "Test writechar function"
      },
      {
        "name": "fnc_system",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 54,
        "end_line": 77,
        "start_byte": 1229,
        "end_byte": 1752,
        "signature": "static LILCALLBACK lil_value_t fnc_system(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_system(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    const char** sargv = malloc(sizeof(char*)*(argc + 1));\n    lil_value_t r = NULL;\n    char* rv;\n    size_t i;\n    \n    if (argc == 0) {\n        free(sargv);\n        return NULL;\n    }\n    \n    for (i=0; i<argc; i++)\n        sargv[i] = lil_to_string(argv[i]);\n    sargv[argc] = NULL;\n    \n    rv = do_system(argc, (char**)sargv);\n    if (rv) {\n        r = lil_alloc_string(rv);\n        free(rv);\n    }\n    free(sargv);\n    return r;\n}",
        "definition_length": 523,
        "comment": "Test system function"
      },
      {
        "name": "fnc_readline",
        "type": "definition",
        "return_type": "LILCALLBACK",
        "parameters": [
          "lil_t lil",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "is_static": true,
        "start_line": 80,
        "end_line": 83,
        "start_byte": 1819,
        "end_byte": 1952,
        "signature": "static LILCALLBACK lil_value_t fnc_readline(lil_t lil, size_t argc, lil_value_t* argv)",
        "full_definition": "static LILCALLBACK lil_value_t fnc_readline(lil_t lil, size_t argc, lil_value_t* argv)\n{\n    return lil_alloc_string(\"test_input\");\n}",
        "definition_length": 133,
        "comment": "Test readline function (returns predefined input for testing)"
      },
      {
        "name": "test_lil_creation_and_destruction",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 88,
        "end_line": 96,
        "start_byte": 2060,
        "end_byte": 2304,
        "signature": "void test_lil_creation_and_destruction()",
        "full_definition": "void test_lil_creation_and_destruction() {\n    printf(\"Testing LIL creation and destruction...\\n\");\n    \n    lil_t lil = lil_new();\n    assert(lil != NULL);\n    \n    lil_free(lil);\n    printf(\"✓ LIL creation and destruction test passed\\n\");\n}\n\n",
        "definition_length": 244,
        "comment": "*********************************************************************************** Test Cases"
      },
      {
        "name": "test_function_registration",
        "type": "definition",
        "return_type": "id t",
        "parameters": [],
        "is_static": false,
        "start_line": 98,
        "end_line": 111,
        "start_byte": 2304,
        "end_byte": 2710,
        "signature": "void test_function_registration()",
        "full_definition": "void test_function_registration() {\n    printf(\"Testing function registration...\\n\");\n    \n    lil_t lil = lil_new();\n    assert(lil != NULL);\n    \n    // Register test functions\n    lil_register(lil, \"writechar\", fnc_writechar);\n    lil_register(lil, \"system\", fnc_system);\n    lil_register(lil, \"readline\", fnc_readline);\n    \n    lil_free(lil);\n    printf(\"✓ Function registration test passed\\n\");\n}\n\nvo",
        "definition_length": 406,
        "comment": ""
      },
      {
        "name": "test_basic_parsing",
        "type": "definition",
        "return_type": "tes",
        "parameters": [],
        "is_static": false,
        "start_line": 113,
        "end_line": 145,
        "start_byte": 2708,
        "end_byte": 3721,
        "signature": "void test_basic_parsing()",
        "full_definition": "void test_basic_parsing() {\n    printf(\"Testing basic parsing...\\n\");\n    \n    lil_t lil = lil_new();\n    assert(lil != NULL);\n    \n    // Test simple expression\n    lil_value_t result = lil_parse(lil, \"expr 1 + 2\", 0, 1);\n    assert(result != NULL);\n    assert(lil_to_integer(result) == 3);\n    lil_free_value(result);\n    \n    // 使用更简单的字符串测试\n    result = lil_parse(lil, \"set test hello\", 0, 1);  // 不使用引号\n    if (result) {\n        lil_free_value(result);\n    }\n    \n    result = lil_parse(lil, \"$test\", 0, 1);\n    if (result) {\n        const char* str_result = lil_to_string(result);\n        if (str_result && strcmp(str_result, \"hello\") == 0) {\n            printf(\"✓ String variable test passed\\n\");\n        } else {\n            printf(\"String variable test failed: expected 'hello', got '%s'\\n\", \n                   str_result ? str_result : \"NULL\");\n        }\n        lil_free_value(result);\n    }\n    \n    lil_free(lil);\n    printf(\"✓ Basic parsing test passed\\n\");\n}\n\nvoid test_variable_operations() {\n    ",
        "definition_length": 1013,
        "comment": ""
      },
      {
        "name": "test_list_operations",
        "type": "definition",
        "return_type": "intf",
        "parameters": [],
        "is_static": false,
        "start_line": 147,
        "end_line": 167,
        "start_byte": 4366,
        "end_byte": 4406,
        "signature": "void test_list_operations()",
        "full_definition": "void test_list_operations() {\n    printf",
        "definition_length": 40,
        "comment": ""
      },
      {
        "name": "test_writechar_function",
        "type": "definition",
        "return_type": "Test",
        "parameters": [],
        "is_static": false,
        "start_line": 169,
        "end_line": 200,
        "start_byte": 5219,
        "end_byte": 5261,
        "signature": "void test_writechar_function()",
        "full_definition": "void test_writechar_function() {\n    print",
        "definition_length": 42,
        "comment": ""
      },
      {
        "name": "test_system_function",
        "type": "definition",
        "return_type": "\"Tes",
        "parameters": [],
        "is_static": false,
        "start_line": 202,
        "end_line": 218,
        "start_byte": 5702,
        "end_byte": 5746,
        "signature": "void test_system_function()",
        "full_definition": "void test_system_function() {\n    printf(\"Te",
        "definition_length": 44,
        "comment": ""
      },
      {
        "name": "if",
        "type": "definition",
        "return_type": "ing",
        "parameters": [],
        "is_static": false,
        "start_line": 220,
        "end_line": 238,
        "start_byte": 5981,
        "end_byte": 6258,
        "signature": "if (result)",
        "full_definition": "    if (result) {\n        const char* output = lil_to_string(result);\n        assert(strstr(output, \"hello\") != NULL);\n        lil_free_value(result);\n    }\n    \n    lil_free(lil);\n    printf(\"✓ System function test passed\\n\");\n}\n\nvoid test_readline_function() {\n    printf(\"Te",
        "definition_length": 277,
        "comment": ""
      },
      {
        "name": "test_exit_callback",
        "type": "definition",
        "return_type": "ing",
        "parameters": [],
        "is_static": false,
        "start_line": 240,
        "end_line": 256,
        "start_byte": 6714,
        "end_byte": 6762,
        "signature": "void test_exit_callback()",
        "full_definition": "void test_exit_callback() {\n    printf(\"Testing ",
        "definition_length": 48,
        "comment": ""
      },
      {
        "name": "test_error_handling",
        "type": "definition",
        "return_type": "it c",
        "parameters": [],
        "is_static": false,
        "start_line": 258,
        "end_line": 278,
        "start_byte": 7235,
        "end_byte": 7285,
        "signature": "void test_error_handling()",
        "full_definition": "void test_error_handling() {\n    printf(\"Testing e",
        "definition_length": 50,
        "comment": ""
      },
      {
        "name": "ndling...\\n\");\n    ",
        "type": "definition",
        "return_type": "or h",
        "parameters": [],
        "is_static": false,
        "start_line": 280,
        "end_line": 299,
        "start_byte": 7287,
        "end_byte": 7767,
        "signature": "or handling...\\n\");\n    \n    lil_t lil = lil_new();\n    assert(lil != NULL);\n    \n    // Test syntax error\n    lil_value_t result = lil_parse(lil, \"set [\", 0, 1);\n    lil_free_value(result);\n    \n    const char* err_msg;\n    size_t pos;\n    if (lil_error(lil, &err_msg, &pos))",
        "full_definition": "or handling...\\n\");\n    \n    lil_t lil = lil_new();\n    assert(lil != NULL);\n    \n    // Test syntax error\n    lil_value_t result = lil_parse(lil, \"set [\", 0, 1);\n    lil_free_value(result);\n    \n    const char* err_msg;\n    size_t pos;\n    if (lil_error(lil, &err_msg, &pos)) {\n        assert(err_msg != NULL);\n        assert(strlen(err_msg) > 0);\n    }\n    \n    lil_free(lil);\n    printf(\"✓ Error handling test passed\\n\");\n}\n\n\n\n\n\n/***********************************************",
        "definition_length": 480,
        "comment": ""
      },
      {
        "name": "/reg",
        "type": "definition",
        "return_type": "uni",
        "parameters": [],
        "is_static": false,
        "start_line": 307,
        "end_line": 323,
        "start_byte": 7862,
        "end_byte": 8318,
        "signature": "unit/regression tests...\\n\");\n\n    test_lil_creation_and_destruction();\n    test_function_registration();\n    test_basic_parsing();\n    test_variable_operations();\n    test_list_operations();\n    test_writechar_function();\n    test_system_function();\n    test_readline_function();\n    test_exit_callback();\n    test_error_handling();\n\n    puts(\"\\nAll LIL interpreter tests pass! :)\\n\");\n    return 0;\n}",
        "full_definition": "unit/regression tests...\\n\");\n\n    test_lil_creation_and_destruction();\n    test_function_registration();\n    test_basic_parsing();\n    test_variable_operations();\n    test_list_operations();\n    test_writechar_function();\n    test_system_function();\n    test_readline_function();\n    test_exit_callback();\n    test_error_handling();\n\n    puts(\"\\nAll LIL interpreter tests pass! :)\\n\");\n    return 0;\n}",
        "definition_length": 402,
        "comment": "********************************/\n\nint main() {\n    puts(\"\\nStarting the LIL interprete"
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 6,
        "start_line": 6,
        "end_line": 7,
        "start_byte": 99,
        "end_byte": 118
      },
      {
        "text": "#include <stdlib.h>",
        "line": 7,
        "start_line": 7,
        "end_line": 8,
        "start_byte": 118,
        "end_byte": 138
      },
      {
        "text": "#include <string.h>",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 138,
        "end_byte": 158
      },
      {
        "text": "#include <assert.h>",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 158,
        "end_byte": 178
      },
      {
        "text": "#include <unistd.h>",
        "line": 10,
        "start_line": 10,
        "end_line": 11,
        "start_byte": 178,
        "end_byte": 198
      },
      {
        "text": "#include \"lil.h\"",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 198,
        "end_byte": 215
      }
    ],
    "variables": [
      {
        "text": "static int test_running = 1;",
        "line": 14,
        "start_line": 14,
        "end_line": 14,
        "start_byte": 241,
        "end_byte": 269,
        "comment": "Global test variables"
      },
      {
        "text": "static int test_exit_code = 0;",
        "line": 15,
        "start_line": 15,
        "end_line": 15,
        "start_byte": 270,
        "end_byte": 300,
        "comment": "Global test variables"
      },
      {
        "text": "static char* last_system_output = NULL;",
        "line": 16,
        "start_line": 16,
        "end_line": 16,
        "start_byte": 301,
        "end_byte": 340,
        "comment": "Global test variables"
      }
    ],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 2366,
    "file_size": 8264
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-ht.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-ht.c",
    "parse_success": true,
    "functions": [
      {
        "name": "test_ht_create_and_destroy",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 7,
        "end_line": 12,
        "start_byte": 96,
        "end_byte": 247,
        "signature": "void test_ht_create_and_destroy()",
        "full_definition": "void test_ht_create_and_destroy() {\n    ht* table = ht_create();\n    assert(table != NULL);\n    assert(ht_length(table) == 0);\n    ht_destroy(table);\n}",
        "definition_length": 151,
        "comment": ""
      },
      {
        "name": "test_ht_set_and_get",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 14,
        "end_line": 42,
        "start_byte": 249,
        "end_byte": 1029,
        "signature": "void test_ht_set_and_get()",
        "full_definition": "void test_ht_set_and_get() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Insert a key-value pair\n    int value1 = 42;\n    const char* key1 = \"key1\";\n    assert(ht_set(table, key1, &value1) != NULL);\n\n    // Retrieve the value\n    int* retrieved_value = (int*)ht_get(table, key1);\n    assert(retrieved_value != NULL);\n    assert(*retrieved_value == value1);\n\n    // Insert another key-value pair\n    int value2 = 84;\n    const char* key2 = \"key2\";\n    assert(ht_set(table, key2, &value2) != NULL);\n\n    // Retrieve the second value\n    retrieved_value = (int*)ht_get(table, key2);\n    assert(retrieved_value != NULL);\n    assert(*retrieved_value == value2);\n\n    // Check the length of the hash table\n    assert(ht_length(table) == 2);\n\n    ht_destroy(table);\n}",
        "definition_length": 780,
        "comment": ""
      },
      {
        "name": "test_ht_update_value",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 44,
        "end_line": 66,
        "start_byte": 1031,
        "end_byte": 1648,
        "signature": "void test_ht_update_value()",
        "full_definition": "void test_ht_update_value() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Insert a key-value pair\n    int value1 = 42;\n    const char* key = \"key\";\n    assert(ht_set(table, key, &value1) != NULL);\n\n    // Update the value for the same key\n    int value2 = 84;\n    assert(ht_set(table, key, &value2) != NULL);\n\n    // Retrieve the updated value\n    int* retrieved_value = (int*)ht_get(table, key);\n    assert(retrieved_value != NULL);\n    assert(*retrieved_value == value2);\n\n    // Check the length of the hash table (should still be 1)\n    assert(ht_length(table) == 1);\n\n    ht_destroy(table);\n}",
        "definition_length": 617,
        "comment": ""
      },
      {
        "name": "test_ht_iterator",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 68,
        "end_line": 91,
        "start_byte": 1650,
        "end_byte": 2267,
        "signature": "void test_ht_iterator()",
        "full_definition": "void test_ht_iterator() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Insert multiple key-value pairs\n    int value1 = 1, value2 = 2, value3 = 3;\n    assert(ht_set(table, \"key1\", &value1) != NULL);\n    assert(ht_set(table, \"key2\", &value2) != NULL);\n    assert(ht_set(table, \"key3\", &value3) != NULL);\n\n    // Iterate through the hash table\n    hti it = ht_iterator(table);\n    int count = 0;\n    while (ht_next(&it)) {\n        assert(it.key != NULL);\n        assert(it.value != NULL);\n        count++;\n    }\n\n    // Ensure all items were iterated\n    assert(count == 3);\n\n    ht_destroy(table);\n}",
        "definition_length": 617,
        "comment": ""
      },
      {
        "name": "test_ht_memory_management",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 93,
        "end_line": 113,
        "start_byte": 2269,
        "end_byte": 2776,
        "signature": "void test_ht_memory_management()",
        "full_definition": "void test_ht_memory_management() {\n    ht* table = ht_create();\n    assert(table != NULL);\n\n    // Dynamically allocate memory for values\n    int* value1 = malloc(sizeof(int));\n    int* value2 = malloc(sizeof(int));\n    *value1 = 42;\n    *value2 = 84;\n\n    assert(ht_set(table, \"key1\", value1) != NULL);\n    assert(ht_set(table, \"key2\", value2) != NULL);\n\n    // Free values during iteration\n    hti it = ht_iterator(table);\n    while (ht_next(&it)) {\n        free(it.value);\n    }\n\n    ht_destroy(table);\n}",
        "definition_length": 507,
        "comment": ""
      },
      {
        "name": "main",
        "type": "definition",
        "return_type": "int",
        "parameters": [],
        "is_static": false,
        "start_line": 115,
        "end_line": 124,
        "start_byte": 2778,
        "end_byte": 2988,
        "signature": "int main()",
        "full_definition": "int main() {\n    test_ht_create_and_destroy();\n    test_ht_set_and_get();\n    test_ht_update_value();\n    test_ht_iterator();\n    test_ht_memory_management();\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "definition_length": 210,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <assert.h>",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 20
      },
      {
        "text": "#include <stdio.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 20,
        "end_byte": 39
      },
      {
        "text": "#include <stdlib.h>",
        "line": 3,
        "start_line": 3,
        "end_line": 4,
        "start_byte": 39,
        "end_byte": 59
      },
      {
        "text": "#include <string.h>",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 59,
        "end_byte": 79
      },
      {
        "text": "#include \"ht.h\"",
        "line": 5,
        "start_line": 5,
        "end_line": 6,
        "start_byte": 79,
        "end_byte": 95
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 977,
    "file_size": 2988
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-buffer.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-buffer.c",
    "parse_success": true,
    "functions": [
      {
        "name": "equal",
        "type": "definition",
        "return_type": "void",
        "parameters": [
          "char *a",
          "char *b"
        ],
        "is_static": false,
        "start_line": 14,
        "end_line": 23,
        "start_byte": 179,
        "end_byte": 360,
        "signature": "void\nequal(char *a, char *b)",
        "full_definition": "void\nequal(char *a, char *b) {\n  if (strcmp(a, b)) {\n    printf(\"\\n\");\n    printf(\"  expected: '%s'\\n\", a);\n    printf(\"    actual: '%s'\\n\", b);\n    printf(\"\\n\");\n    exit(1);\n  }\n}",
        "definition_length": 181,
        "comment": ""
      },
      {
        "name": "test_buffer_new",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 25,
        "end_line": 31,
        "start_byte": 362,
        "end_byte": 526,
        "signature": "void\ntest_buffer_new()",
        "full_definition": "void\ntest_buffer_new() {\n  buffer_t *buf = buffer_new();\n  assert(BUFFER_DEFAULT_SIZE == buffer_size(buf));\n  assert(0 == buffer_length(buf));\n  buffer_free(buf);\n}",
        "definition_length": 164,
        "comment": ""
      },
      {
        "name": "test_buffer_new_with_size",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 33,
        "end_line": 39,
        "start_byte": 528,
        "end_byte": 701,
        "signature": "void\ntest_buffer_new_with_size()",
        "full_definition": "void\ntest_buffer_new_with_size() {\n  buffer_t *buf = buffer_new_with_size(1024);\n  assert(1024 == buffer_size(buf));\n  assert(0 == buffer_length(buf));\n  buffer_free(buf);\n}",
        "definition_length": 173,
        "comment": ""
      },
      {
        "name": "test_buffer_append",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 41,
        "end_line": 49,
        "start_byte": 703,
        "end_byte": 972,
        "signature": "void\ntest_buffer_append()",
        "full_definition": "void\ntest_buffer_append() {\n  buffer_t *buf = buffer_new();\n  assert(0 == buffer_append(buf, \"Hello\"));\n  assert(0 == buffer_append(buf, \" World\"));\n  assert(strlen(\"Hello World\") == buffer_length(buf));\n  equal(\"Hello World\", buffer_string(buf));\n  buffer_free(buf);\n}",
        "definition_length": 269,
        "comment": ""
      },
      {
        "name": "test_buffer_append_n",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 51,
        "end_line": 59,
        "start_byte": 974,
        "end_byte": 1253,
        "signature": "void\ntest_buffer_append_n()",
        "full_definition": "void\ntest_buffer_append_n() {\n  buffer_t *buf = buffer_new();\n  assert(0 == buffer_append_n(buf, \"subway\", 3));\n  assert(0 == buffer_append_n(buf, \"marines\", 6));\n  assert(strlen(\"submarine\") == buffer_length(buf));\n  equal(\"submarine\", buffer_string(buf));\n  buffer_free(buf);\n}",
        "definition_length": 279,
        "comment": ""
      },
      {
        "name": "test_buffer_append__grow",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 61,
        "end_line": 74,
        "start_byte": 1255,
        "end_byte": 1682,
        "signature": "void\ntest_buffer_append__grow()",
        "full_definition": "void\ntest_buffer_append__grow() {\n  buffer_t *buf = buffer_new_with_size(10);\n  assert(0 == buffer_append(buf, \"Hello\"));\n  assert(0 == buffer_append(buf, \" tobi\"));\n  assert(0 == buffer_append(buf, \" was\"));\n  assert(0 == buffer_append(buf, \" here\"));\n\n  char *str = \"Hello tobi was here\";\n  equal(str, buffer_string(buf));\n  assert(1024 == buffer_size(buf));\n  assert(strlen(str) == buffer_length(buf));\n  buffer_free(buf);\n}",
        "definition_length": 427,
        "comment": ""
      },
      {
        "name": "test_buffer_prepend",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 76,
        "end_line": 84,
        "start_byte": 1684,
        "end_byte": 1955,
        "signature": "void\ntest_buffer_prepend()",
        "full_definition": "void\ntest_buffer_prepend() {\n  buffer_t *buf = buffer_new();\n  assert(0 == buffer_append(buf, \" World\"));\n  assert(0 == buffer_prepend(buf, \"Hello\"));\n  assert(strlen(\"Hello World\") == buffer_length(buf));\n  equal(\"Hello World\", buffer_string(buf));\n  buffer_free(buf);\n}",
        "definition_length": 271,
        "comment": ""
      },
      {
        "name": "test_buffer_slice",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 86,
        "end_line": 97,
        "start_byte": 1957,
        "end_byte": 2216,
        "signature": "void\ntest_buffer_slice()",
        "full_definition": "void\ntest_buffer_slice() {\n  buffer_t *buf = buffer_new();\n  buffer_append(buf, \"Tobi Ferret\");\n\n  buffer_t *a = buffer_slice(buf, 2, 8);\n  equal(\"Tobi Ferret\", buffer_string(buf));\n  equal(\"bi Fer\", buffer_string(a));\n\n  buffer_free(buf);\n  buffer_free(a);\n}",
        "definition_length": 259,
        "comment": ""
      },
      {
        "name": "test_buffer_slice__range_error",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 99,
        "end_line": 105,
        "start_byte": 2218,
        "end_byte": 2397,
        "signature": "void\ntest_buffer_slice__range_error()",
        "full_definition": "void\ntest_buffer_slice__range_error() {\n  buffer_t *buf = buffer_new_with_copy(\"Tobi Ferret\");\n  buffer_t *a = buffer_slice(buf, 10, 2);\n  assert(NULL == a);\n  buffer_free(buf);\n}",
        "definition_length": 179,
        "comment": ""
      },
      {
        "name": "test_buffer_slice__end",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 107,
        "end_line": 125,
        "start_byte": 2399,
        "end_byte": 2841,
        "signature": "void\ntest_buffer_slice__end()",
        "full_definition": "void\ntest_buffer_slice__end() {\n  buffer_t *buf = buffer_new_with_copy(\"Tobi Ferret\");\n\n  buffer_t *a = buffer_slice(buf, 5, -1);\n  equal(\"Tobi Ferret\", buffer_string(buf));\n  equal(\"Ferret\", buffer_string(a));\n\n  buffer_t *b = buffer_slice(buf, 5, -3);\n  equal(\"Ferr\", buffer_string(b));\n\n  buffer_t *c = buffer_slice(buf, 8, -1);\n  equal(\"ret\", buffer_string(c));\n\n  buffer_free(buf);\n  buffer_free(a);\n  buffer_free(b);\n  buffer_free(c);\n}",
        "definition_length": 442,
        "comment": ""
      },
      {
        "name": "test_buffer_slice__end_overflow",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 127,
        "end_line": 135,
        "start_byte": 2843,
        "end_byte": 3103,
        "signature": "void\ntest_buffer_slice__end_overflow()",
        "full_definition": "void\ntest_buffer_slice__end_overflow() {\n  buffer_t *buf = buffer_new_with_copy(\"Tobi Ferret\");\n  buffer_t *a = buffer_slice(buf, 5, 1000);\n  equal(\"Tobi Ferret\", buffer_string(buf));\n  equal(\"Ferret\", buffer_string(a));\n  buffer_free(a);\n  buffer_free(buf);\n}",
        "definition_length": 260,
        "comment": ""
      },
      {
        "name": "test_buffer_equals",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 137,
        "end_line": 149,
        "start_byte": 3105,
        "end_byte": 3369,
        "signature": "void\ntest_buffer_equals()",
        "full_definition": "void\ntest_buffer_equals() {\n  buffer_t *a = buffer_new_with_copy(\"Hello\");\n  buffer_t *b = buffer_new_with_copy(\"Hello\");\n\n  assert(1 == buffer_equals(a, b));\n\n  buffer_append(b, \" World\");\n  assert(0 == buffer_equals(a, b));\n\n  buffer_free(a);\n  buffer_free(b);\n}",
        "definition_length": 264,
        "comment": ""
      },
      {
        "name": "test_buffer_formatting",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 151,
        "end_line": 160,
        "start_byte": 3371,
        "end_byte": 3703,
        "signature": "void test_buffer_formatting()",
        "full_definition": "void test_buffer_formatting() {\n  buffer_t *buf = buffer_new();\n  int result = buffer_appendf(buf, \"%d %s\", 3, \"cow\");\n  assert(0 == result);\n  equal(\"3 cow\", buffer_string(buf));\n  result = buffer_appendf(buf, \" - 0x%08X\", 0xdeadbeef);\n  assert(0 == result);\n  equal(\"3 cow - 0xDEADBEEF\", buffer_string(buf));\n  buffer_free(buf);\n}",
        "definition_length": 332,
        "comment": ""
      },
      {
        "name": "test_buffer_indexof",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 162,
        "end_line": 176,
        "start_byte": 3705,
        "end_byte": 3987,
        "signature": "void\ntest_buffer_indexof()",
        "full_definition": "void\ntest_buffer_indexof() {\n  buffer_t *buf = buffer_new_with_copy(\"Tobi is a ferret\");\n\n  ssize_t i = buffer_indexof(buf, \"is\");\n  assert(5 == i);\n\n  i = buffer_indexof(buf, \"a\");\n  assert(8 == i);\n\n  i = buffer_indexof(buf, \"something\");\n  assert(-1 == i);\n\n  buffer_free(buf);\n}",
        "definition_length": 282,
        "comment": ""
      },
      {
        "name": "test_buffer_fill",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 178,
        "end_line": 186,
        "start_byte": 3989,
        "end_byte": 4179,
        "signature": "void\ntest_buffer_fill()",
        "full_definition": "void\ntest_buffer_fill() {\n  buffer_t *buf = buffer_new_with_copy(\"Hello\");\n  assert(5 == buffer_length(buf));\n\n  buffer_fill(buf, 0);\n  assert(0 == buffer_length(buf));\n  buffer_free(buf);\n}",
        "definition_length": 190,
        "comment": ""
      },
      {
        "name": "test_buffer_clear",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 188,
        "end_line": 196,
        "start_byte": 4181,
        "end_byte": 4370,
        "signature": "void\ntest_buffer_clear()",
        "full_definition": "void\ntest_buffer_clear() {\n  buffer_t *buf = buffer_new_with_copy(\"Hello\");\n  assert(5 == buffer_length(buf));\n\n  buffer_clear(buf);\n  assert(0 == buffer_length(buf));\n  buffer_free(buf);\n}",
        "definition_length": 189,
        "comment": ""
      },
      {
        "name": "test_buffer_trim",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 198,
        "end_line": 214,
        "start_byte": 4372,
        "end_byte": 4801,
        "signature": "void\ntest_buffer_trim()",
        "full_definition": "void\ntest_buffer_trim() {\n  buffer_t *buf = buffer_new_with_copy(\"  Hello\\n\\n \");\n  buffer_trim(buf);\n  equal(\"Hello\", buffer_string(buf));\n  buffer_free(buf);\n\n  buf = buffer_new_with_copy(\"  Hello\\n\\n \");\n  buffer_trim_left(buf);\n  equal(\"Hello\\n\\n \", buffer_string(buf));\n  buffer_free(buf);\n\n  buf = buffer_new_with_copy(\"  Hello\\n\\n \");\n  buffer_trim_right(buf);\n  equal(\"  Hello\", buffer_string(buf));\n  buffer_free(buf);\n}",
        "definition_length": 429,
        "comment": ""
      },
      {
        "name": "test_buffer_compact",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 216,
        "end_line": 230,
        "start_byte": 4803,
        "end_byte": 5171,
        "signature": "void\ntest_buffer_compact()",
        "full_definition": "void\ntest_buffer_compact() {\n  buffer_t *buf = buffer_new_with_copy(\"  Hello\\n\\n \");\n  buffer_trim(buf);\n  assert(5 == buffer_length(buf));\n  assert(10 == buffer_size(buf));\n\n  ssize_t removed = buffer_compact(buf);\n  assert(5 == removed);\n  assert(5 == buffer_length(buf));\n  assert(5 == buffer_size(buf));\n  equal(\"Hello\", buffer_string(buf));\n\n  buffer_free(buf);\n}",
        "definition_length": 368,
        "comment": ""
      },
      {
        "name": "test_buffer_prepend_issue_15",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 232,
        "end_line": 240,
        "start_byte": 5173,
        "end_byte": 5498,
        "signature": "void\ntest_buffer_prepend_issue_15()",
        "full_definition": "void\ntest_buffer_prepend_issue_15() {\n  buffer_t *file = buffer_new();\n  assert(0 == buffer_append(file, \"layout.bk.html\"));\n  assert(0 == buffer_prepend(file, \"./example/\"));\n  assert(strlen(\"./example/layout.bk.html\") == buffer_length(file));\n  equal(\"./example/layout.bk.html\", buffer_string(file));\n  buffer_free(file);\n}",
        "definition_length": 325,
        "comment": ""
      },
      {
        "name": "main",
        "type": "definition",
        "return_type": "int",
        "parameters": [],
        "is_static": false,
        "start_line": 242,
        "end_line": 264,
        "start_byte": 5500,
        "end_byte": 6057,
        "signature": "int\nmain()",
        "full_definition": "int\nmain(){\n  test_buffer_new();\n  test_buffer_new_with_size();\n  test_buffer_append();\n  test_buffer_append__grow();\n  test_buffer_append_n();\n  test_buffer_prepend();\n  test_buffer_slice();\n  test_buffer_slice__range_error();\n  test_buffer_slice__end();\n  test_buffer_slice__end_overflow();\n  test_buffer_equals();\n  test_buffer_formatting();\n  test_buffer_indexof();\n  test_buffer_fill();\n  test_buffer_clear();\n  test_buffer_trim();\n  test_buffer_compact();\n  test_buffer_prepend_issue_15();\n  printf(\"\\n  \\e[32m\\u2713 \\e[90mok\\e[0m\\n\\n\");\n  return 0;\n}",
        "definition_length": 557,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <assert.h>",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 79,
        "end_byte": 99
      },
      {
        "text": "#include <stdlib.h>",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 99,
        "end_byte": 119
      },
      {
        "text": "#include <stdio.h>",
        "line": 10,
        "start_line": 10,
        "end_line": 11,
        "start_byte": 119,
        "end_byte": 138
      },
      {
        "text": "#include <string.h>",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 138,
        "end_byte": 158
      },
      {
        "text": "#include \"buffer.h\"",
        "line": 12,
        "start_line": 12,
        "end_line": 13,
        "start_byte": 158,
        "end_byte": 178
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 2334,
    "file_size": 6058
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-urlparser.c": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/test/test-urlparser.c",
    "parse_success": true,
    "functions": [
      {
        "name": "test_parse_url",
        "type": "definition",
        "return_type": "void",
        "parameters": [],
        "is_static": false,
        "start_line": 7,
        "end_line": 65,
        "start_byte": 103,
        "end_byte": 2852,
        "signature": "void test_parse_url()",
        "full_definition": "void test_parse_url() {\n    URL_PARTS url_parts;\n\n    // Test case 1: Basic HTTP URL\n    assert(ParseURL(\"http://sullewarehouse.com/login\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"http\") == 0);\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strlen(url_parts.port) == 0); // No port specified\n    assert(strcmp(url_parts.path, \"/login\") == 0);\n    assert(strlen(url_parts.query) == 0); // No query\n    assert(strlen(url_parts.fragment) == 0); // No fragment\n\n    // Test case 2: HTTPS URL with port\n    assert(ParseURL(\"https://sullewarehouse.com:1000/login\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"https\") == 0);\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strcmp(url_parts.port, \"1000\") == 0);\n    assert(strcmp(url_parts.path, \"/login\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 3: URL with query parameters\n    assert(ParseURL(\"https://sullewarehouse.com:1000/api/get?username=myuser\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"https\") == 0);\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strcmp(url_parts.port, \"1000\") == 0);\n    assert(strcmp(url_parts.path, \"/api/get\") == 0);\n    assert(strcmp(url_parts.query, \"?username=myuser\") == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 4: URL without scheme\n    assert(ParseURL(\"sullewarehouse.com/register\", &url_parts));\n    assert(strlen(url_parts.scheme) == 0); // No scheme\n    assert(strcmp(url_parts.authority, \"sullewarehouse.com\") == 0);\n    assert(strlen(url_parts.port) == 0);\n    assert(strcmp(url_parts.path, \"/register\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 5: IPv6 URL\n    assert(ParseURL(\"http://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]/newpage\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"http\") == 0);\n    assert(strcmp(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\") == 0);\n    assert(strlen(url_parts.port) == 0);\n    assert(strcmp(url_parts.path, \"/newpage\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    // Test case 6: IPv6 URL with port\n    assert(ParseURL(\"https://[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:2678/blog\", &url_parts));\n    assert(strcmp(url_parts.scheme, \"https\") == 0);\n    assert(strcmp(url_parts.authority, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\") == 0);\n    assert(strcmp(url_parts.port, \"2678\") == 0);\n    assert(strcmp(url_parts.path, \"/blog\") == 0);\n    assert(strlen(url_parts.query) == 0);\n    assert(strlen(url_parts.fragment) == 0);\n\n    printf(\"All tests passed!\\n\");\n}",
        "definition_length": 2749,
        "comment": ""
      },
      {
        "name": "main",
        "type": "definition",
        "return_type": "int",
        "parameters": [],
        "is_static": false,
        "start_line": 67,
        "end_line": 70,
        "start_byte": 2854,
        "end_byte": 2904,
        "signature": "int main()",
        "full_definition": "int main() {\n    test_parse_url();\n    return 0;\n}",
        "definition_length": 50,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <assert.h>",
        "line": 1,
        "start_line": 1,
        "end_line": 2,
        "start_byte": 0,
        "end_byte": 20
      },
      {
        "text": "#include <stdio.h>",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 20,
        "end_byte": 39
      },
      {
        "text": "#include <stdlib.h>",
        "line": 3,
        "start_line": 3,
        "end_line": 4,
        "start_byte": 39,
        "end_byte": 59
      },
      {
        "text": "#include <string.h>",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 59,
        "end_byte": 79
      },
      {
        "text": "#include \"urlparser.h\"",
        "line": 5,
        "start_line": 5,
        "end_line": 6,
        "start_byte": 79,
        "end_byte": 102
      }
    ],
    "variables": [],
    "typedefs": [],
    "macros": [],
    "enums": [],
    "total_nodes": 985,
    "file_size": 2904
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/ht.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/ht.h",
    "parse_success": true,
    "functions": [
      {
        "name": "ht_create",
        "type": "declaration",
        "return_type": "ht",
        "parameters": [
          "void"
        ],
        "start_line": 13,
        "end_line": 13,
        "start_byte": 277,
        "end_byte": 297,
        "full_declaration": "ht* ht_create(void);",
        "declaration_length": 20,
        "comment": "Create hash table and return pointer to it, or NULL if out of memory."
      },
      {
        "name": "ht_destroy",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "ht* table"
        ],
        "start_line": 16,
        "end_line": 16,
        "start_byte": 366,
        "end_byte": 393,
        "full_declaration": "void ht_destroy(ht* table);",
        "declaration_length": 27,
        "comment": "Free memory allocated for hash table, including allocated keys."
      },
      {
        "name": "ht_get",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "ht* table",
          "const char* key"
        ],
        "start_line": 20,
        "end_line": 20,
        "start_byte": 527,
        "end_byte": 568,
        "full_declaration": "void* ht_get(ht* table, const char* key);",
        "declaration_length": 41,
        "comment": "Get item with given key (NUL-terminated) from hash table. Return value (which was set with ht_set), or NULL if key not found."
      },
      {
        "name": "ht_set",
        "type": "declaration",
        "return_type": "char",
        "parameters": [
          "ht* table",
          "const char* key",
          "void* value"
        ],
        "start_line": 26,
        "end_line": 26,
        "start_byte": 845,
        "end_byte": 905,
        "full_declaration": "const char* ht_set(ht* table, const char* key, void* value);",
        "declaration_length": 60,
        "comment": "be NULL). If not already present in table, key is copied to newly allocated memory (keys are freed automatically when ht_destroy is called). Return address of copied key, or NULL if out of memory."
      },
      {
        "name": "ht_length",
        "type": "declaration",
        "return_type": "size_t",
        "parameters": [
          "ht* table"
        ],
        "start_line": 29,
        "end_line": 29,
        "start_byte": 948,
        "end_byte": 976,
        "full_declaration": "size_t ht_length(ht* table);",
        "declaration_length": 28,
        "comment": "Return number of items in hash table."
      },
      {
        "name": "ht_iterator",
        "type": "declaration",
        "return_type": "hti",
        "parameters": [
          "ht* table"
        ],
        "start_line": 42,
        "end_line": 42,
        "start_byte": 1369,
        "end_byte": 1396,
        "full_declaration": "hti ht_iterator(ht* table);",
        "declaration_length": 27,
        "comment": "Return new hash table iterator (for use with ht_next)."
      },
      {
        "name": "ht_next",
        "type": "declaration",
        "return_type": "bool",
        "parameters": [
          "hti* it"
        ],
        "start_line": 47,
        "end_line": 47,
        "start_byte": 1593,
        "end_byte": 1615,
        "full_declaration": "bool ht_next(hti* it);",
        "declaration_length": 22,
        "comment": "Move iterator to next item in hash table, update iterator's key and value to current item, and return true. If there are no more items, return false. Don't call ht_set during iteration."
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdbool.h>",
        "line": 6,
        "start_line": 6,
        "end_line": 7,
        "start_byte": 69,
        "end_byte": 90
      },
      {
        "text": "#include <stddef.h>",
        "line": 7,
        "start_line": 7,
        "end_line": 8,
        "start_byte": 90,
        "end_byte": 110
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef struct ht ht;",
        "name": "ht",
        "line": 10,
        "start_line": 10,
        "end_line": 10,
        "start_byte": 181,
        "end_byte": 202,
        "comment": "Hash table structure: create with ht_create, free with ht_destroy."
      },
      {
        "text": "typedef struct {\n    const char* key;  // current key\n    void* value;      // current value\n\n    // Don't use these fields directly.\n    ht* _table;       // reference to hash table being iterated\n    size_t _index;    // current index into ht._entries\n} hti;",
        "name": "hti",
        "line": 32,
        "start_line": 32,
        "end_line": 39,
        "start_byte": 1049,
        "end_byte": 1309,
        "comment": "Hash table iterator: create with ht_iterator, iterate with ht_next."
      }
    ],
    "macros": [
      {
        "text": "#define _HT_H",
        "name": "_HT_H",
        "line": 4,
        "start_line": 4,
        "end_line": 5,
        "start_byte": 54,
        "end_byte": 68,
        "comment": "Simple hash table implemented in C."
      }
    ],
    "enums": [],
    "total_nodes": 194,
    "file_size": 1633
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/buffer.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/buffer.h",
    "parse_success": true,
    "functions": [
      {
        "name": "buffer_new",
        "type": "declaration",
        "return_type": "buffer_t",
        "parameters": [],
        "start_line": 33,
        "end_line": 34,
        "start_byte": 355,
        "end_byte": 379,
        "full_declaration": "buffer_t *\nbuffer_new();",
        "declaration_length": 24,
        "comment": "prototypes"
      },
      {
        "name": "buffer_new_with_size",
        "type": "declaration",
        "return_type": "buffer_t",
        "parameters": [
          "size_t n"
        ],
        "start_line": 36,
        "end_line": 37,
        "start_byte": 381,
        "end_byte": 423,
        "full_declaration": "buffer_t *\nbuffer_new_with_size(size_t n);",
        "declaration_length": 42,
        "comment": ""
      },
      {
        "name": "buffer_new_with_string",
        "type": "declaration",
        "return_type": "buffer_t",
        "parameters": [
          "char *str"
        ],
        "start_line": 39,
        "end_line": 40,
        "start_byte": 425,
        "end_byte": 470,
        "full_declaration": "buffer_t *\nbuffer_new_with_string(char *str);",
        "declaration_length": 45,
        "comment": ""
      },
      {
        "name": "buffer_new_with_string_length",
        "type": "declaration",
        "return_type": "buffer_t",
        "parameters": [
          "char *str",
          "size_t len"
        ],
        "start_line": 42,
        "end_line": 43,
        "start_byte": 472,
        "end_byte": 536,
        "full_declaration": "buffer_t *\nbuffer_new_with_string_length(char *str, size_t len);",
        "declaration_length": 64,
        "comment": ""
      },
      {
        "name": "buffer_new_with_copy",
        "type": "declaration",
        "return_type": "buffer_t",
        "parameters": [
          "char *str"
        ],
        "start_line": 45,
        "end_line": 46,
        "start_byte": 538,
        "end_byte": 581,
        "full_declaration": "buffer_t *\nbuffer_new_with_copy(char *str);",
        "declaration_length": 43,
        "comment": ""
      },
      {
        "name": "buffer_size",
        "type": "declaration",
        "return_type": "size_t",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 48,
        "end_line": 49,
        "start_byte": 583,
        "end_byte": 618,
        "full_declaration": "size_t\nbuffer_size(buffer_t *self);",
        "declaration_length": 35,
        "comment": ""
      },
      {
        "name": "buffer_length",
        "type": "declaration",
        "return_type": "size_t",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 51,
        "end_line": 52,
        "start_byte": 620,
        "end_byte": 657,
        "full_declaration": "size_t\nbuffer_length(buffer_t *self);",
        "declaration_length": 37,
        "comment": ""
      },
      {
        "name": "buffer_free",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 54,
        "end_line": 55,
        "start_byte": 659,
        "end_byte": 692,
        "full_declaration": "void\nbuffer_free(buffer_t *self);",
        "declaration_length": 33,
        "comment": ""
      },
      {
        "name": "buffer_prepend",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "char *str"
        ],
        "start_line": 57,
        "end_line": 58,
        "start_byte": 694,
        "end_byte": 740,
        "full_declaration": "int\nbuffer_prepend(buffer_t *self, char *str);",
        "declaration_length": 46,
        "comment": ""
      },
      {
        "name": "buffer_append",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "const char *str"
        ],
        "start_line": 60,
        "end_line": 61,
        "start_byte": 742,
        "end_byte": 793,
        "full_declaration": "int\nbuffer_append(buffer_t *self, const char *str);",
        "declaration_length": 51,
        "comment": ""
      },
      {
        "name": "buffer_appendf",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "const char *format"
        ],
        "start_line": 63,
        "end_line": 64,
        "start_byte": 795,
        "end_byte": 855,
        "full_declaration": "int\nbuffer_appendf(buffer_t *self, const char *format, ...);",
        "declaration_length": 60,
        "comment": ""
      },
      {
        "name": "buffer_append_n",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "const char *str",
          "size_t len"
        ],
        "start_line": 66,
        "end_line": 67,
        "start_byte": 857,
        "end_byte": 922,
        "full_declaration": "int\nbuffer_append_n(buffer_t *self, const char *str, size_t len);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "buffer_equals",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "buffer_t *self",
          "buffer_t *other"
        ],
        "start_line": 69,
        "end_line": 70,
        "start_byte": 924,
        "end_byte": 975,
        "full_declaration": "int\nbuffer_equals(buffer_t *self, buffer_t *other);",
        "declaration_length": 51,
        "comment": ""
      },
      {
        "name": "buffer_indexof",
        "type": "declaration",
        "return_type": "ssize_t",
        "parameters": [
          "buffer_t *self",
          "char *str"
        ],
        "start_line": 72,
        "end_line": 73,
        "start_byte": 977,
        "end_byte": 1027,
        "full_declaration": "ssize_t\nbuffer_indexof(buffer_t *self, char *str);",
        "declaration_length": 50,
        "comment": ""
      },
      {
        "name": "buffer_slice",
        "type": "declaration",
        "return_type": "buffer_t",
        "parameters": [
          "buffer_t *self",
          "size_t from",
          "ssize_t to"
        ],
        "start_line": 75,
        "end_line": 76,
        "start_byte": 1029,
        "end_byte": 1094,
        "full_declaration": "buffer_t *\nbuffer_slice(buffer_t *self, size_t from, ssize_t to);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "buffer_compact",
        "type": "declaration",
        "return_type": "ssize_t",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 78,
        "end_line": 79,
        "start_byte": 1096,
        "end_byte": 1135,
        "full_declaration": "ssize_t\nbuffer_compact(buffer_t *self);",
        "declaration_length": 39,
        "comment": ""
      },
      {
        "name": "buffer_fill",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "buffer_t *self",
          "int c"
        ],
        "start_line": 81,
        "end_line": 82,
        "start_byte": 1137,
        "end_byte": 1177,
        "full_declaration": "void\nbuffer_fill(buffer_t *self, int c);",
        "declaration_length": 40,
        "comment": ""
      },
      {
        "name": "buffer_clear",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 84,
        "end_line": 85,
        "start_byte": 1179,
        "end_byte": 1213,
        "full_declaration": "void\nbuffer_clear(buffer_t *self);",
        "declaration_length": 34,
        "comment": ""
      },
      {
        "name": "buffer_trim_left",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 87,
        "end_line": 88,
        "start_byte": 1215,
        "end_byte": 1253,
        "full_declaration": "void\nbuffer_trim_left(buffer_t *self);",
        "declaration_length": 38,
        "comment": ""
      },
      {
        "name": "buffer_trim_right",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 90,
        "end_line": 91,
        "start_byte": 1255,
        "end_byte": 1294,
        "full_declaration": "void\nbuffer_trim_right(buffer_t *self);",
        "declaration_length": 39,
        "comment": ""
      },
      {
        "name": "buffer_trim",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 93,
        "end_line": 94,
        "start_byte": 1296,
        "end_byte": 1329,
        "full_declaration": "void\nbuffer_trim(buffer_t *self);",
        "declaration_length": 33,
        "comment": ""
      },
      {
        "name": "buffer_print",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "buffer_t *self"
        ],
        "start_line": 96,
        "end_line": 97,
        "start_byte": 1331,
        "end_byte": 1365,
        "full_declaration": "void\nbuffer_print(buffer_t *self);",
        "declaration_length": 34,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <sys/types.h>",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 118,
        "end_byte": 141
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef struct {\n  size_t len;\n  char *alloc;\n  char *data;\n} buffer_t;",
        "name": "buffer_t",
        "line": 25,
        "start_line": 25,
        "end_line": 29,
        "start_byte": 267,
        "end_byte": 338,
        "comment": "* Buffer struct."
      }
    ],
    "macros": [
      {
        "text": "#define BUFFER_H 1",
        "name": "BUFFER_H",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 98,
        "end_byte": 117,
        "comment": ""
      },
      {
        "text": "#define BUFFER_DEFAULT_SIZE 64",
        "name": "BUFFER_DEFAULT_SIZE",
        "line": 18,
        "start_line": 18,
        "end_line": 19,
        "start_byte": 202,
        "end_byte": 233,
        "comment": "* Default buffer size."
      },
      {
        "text": "#define buffer_string(self) (self->data)",
        "name": "buffer_string",
        "line": 99,
        "start_line": 99,
        "end_line": 100,
        "start_byte": 1367,
        "end_byte": 1408,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 417,
    "file_size": 1416
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/quadtree.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/quadtree.h",
    "parse_success": true,
    "functions": [
      {
        "name": "quadtree_point_new",
        "type": "declaration",
        "return_type": "quadtree_point_t",
        "parameters": [
          "double x",
          "double y"
        ],
        "start_line": 42,
        "end_line": 43,
        "start_byte": 727,
        "end_byte": 784,
        "full_declaration": "quadtree_point_t*\nquadtree_point_new(double x, double y);",
        "declaration_length": 57,
        "comment": ""
      },
      {
        "name": "quadtree_point_free",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "quadtree_point_t *point"
        ],
        "start_line": 45,
        "end_line": 46,
        "start_byte": 786,
        "end_byte": 836,
        "full_declaration": "void\nquadtree_point_free(quadtree_point_t *point);",
        "declaration_length": 50,
        "comment": ""
      },
      {
        "name": "quadtree_bounds_new",
        "type": "declaration",
        "return_type": "quadtree_bounds_t",
        "parameters": [
          "void"
        ],
        "start_line": 49,
        "end_line": 50,
        "start_byte": 839,
        "end_byte": 884,
        "full_declaration": "quadtree_bounds_t*\nquadtree_bounds_new(void);",
        "declaration_length": 45,
        "comment": ""
      },
      {
        "name": "quadtree_bounds_extend",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "quadtree_bounds_t *bounds",
          "double x",
          "double y"
        ],
        "start_line": 52,
        "end_line": 53,
        "start_byte": 886,
        "end_byte": 961,
        "full_declaration": "void\nquadtree_bounds_extend(quadtree_bounds_t *bounds, double x, double y);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "quadtree_bounds_free",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "quadtree_bounds_t *bounds"
        ],
        "start_line": 55,
        "end_line": 56,
        "start_byte": 963,
        "end_byte": 1016,
        "full_declaration": "void\nquadtree_bounds_free(quadtree_bounds_t *bounds);",
        "declaration_length": 53,
        "comment": ""
      },
      {
        "name": "quadtree_node_new",
        "type": "declaration",
        "return_type": "quadtree_node_t",
        "parameters": [
          "void"
        ],
        "start_line": 59,
        "end_line": 60,
        "start_byte": 1019,
        "end_byte": 1060,
        "full_declaration": "quadtree_node_t*\nquadtree_node_new(void);",
        "declaration_length": 41,
        "comment": ""
      },
      {
        "name": "quadtree_node_free",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "quadtree_node_t *node",
          "void (*value_free)(void*)"
        ],
        "start_line": 62,
        "end_line": 63,
        "start_byte": 1062,
        "end_byte": 1136,
        "full_declaration": "void\nquadtree_node_free(quadtree_node_t *node, void (*value_free)(void*));",
        "declaration_length": 74,
        "comment": ""
      },
      {
        "name": "quadtree_node_ispointer",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *node"
        ],
        "start_line": 65,
        "end_line": 66,
        "start_byte": 1138,
        "end_byte": 1189,
        "full_declaration": "int\nquadtree_node_ispointer(quadtree_node_t *node);",
        "declaration_length": 51,
        "comment": ""
      },
      {
        "name": "quadtree_node_isempty",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *node"
        ],
        "start_line": 68,
        "end_line": 69,
        "start_byte": 1191,
        "end_byte": 1240,
        "full_declaration": "int\nquadtree_node_isempty(quadtree_node_t *node);",
        "declaration_length": 49,
        "comment": ""
      },
      {
        "name": "quadtree_node_isleaf",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "quadtree_node_t *node"
        ],
        "start_line": 71,
        "end_line": 72,
        "start_byte": 1242,
        "end_byte": 1290,
        "full_declaration": "int\nquadtree_node_isleaf(quadtree_node_t *node);",
        "declaration_length": 48,
        "comment": ""
      },
      {
        "name": "quadtree_node_reset",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "quadtree_node_t* node",
          "void (*key_free)(void*)"
        ],
        "start_line": 74,
        "end_line": 75,
        "start_byte": 1292,
        "end_byte": 1365,
        "full_declaration": "void\nquadtree_node_reset(quadtree_node_t* node, void (*key_free)(void*));",
        "declaration_length": 73,
        "comment": ""
      },
      {
        "name": "quadtree_node_with_bounds",
        "type": "declaration",
        "return_type": "quadtree_node_t",
        "parameters": [
          "double minx",
          "double miny",
          "double maxx",
          "double maxy"
        ],
        "start_line": 77,
        "end_line": 78,
        "start_byte": 1367,
        "end_byte": 1462,
        "full_declaration": "quadtree_node_t*\nquadtree_node_with_bounds(double minx, double miny, double maxx, double maxy);",
        "declaration_length": 95,
        "comment": ""
      },
      {
        "name": "quadtree_new",
        "type": "declaration",
        "return_type": "quadtree_t",
        "parameters": [
          "double minx",
          "double miny",
          "double maxx",
          "double maxy"
        ],
        "start_line": 80,
        "end_line": 81,
        "start_byte": 1464,
        "end_byte": 1541,
        "full_declaration": "quadtree_t*\nquadtree_new(double minx, double miny, double maxx, double maxy);",
        "declaration_length": 77,
        "comment": ""
      },
      {
        "name": "quadtree_free",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "quadtree_t *tree"
        ],
        "start_line": 83,
        "end_line": 84,
        "start_byte": 1543,
        "end_byte": 1580,
        "full_declaration": "void\nquadtree_free(quadtree_t *tree);",
        "declaration_length": 37,
        "comment": ""
      },
      {
        "name": "quadtree_search",
        "type": "declaration",
        "return_type": "quadtree_point_t",
        "parameters": [
          "quadtree_t *tree",
          "double x",
          "double y"
        ],
        "start_line": 86,
        "end_line": 87,
        "start_byte": 1582,
        "end_byte": 1654,
        "full_declaration": "quadtree_point_t*\nquadtree_search(quadtree_t *tree, double x, double y);",
        "declaration_length": 72,
        "comment": ""
      },
      {
        "name": "quadtree_insert",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "quadtree_t *tree",
          "double x",
          "double y",
          "void *key"
        ],
        "start_line": 89,
        "end_line": 90,
        "start_byte": 1656,
        "end_byte": 1725,
        "full_declaration": "int\nquadtree_insert(quadtree_t *tree, double x, double y, void *key);",
        "declaration_length": 69,
        "comment": ""
      },
      {
        "name": "quadtree_walk",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "quadtree_node_t *root",
          "void (*descent)(quadtree_node_t *node)",
          "void (*ascent)(quadtree_node_t *node)"
        ],
        "start_line": 92,
        "end_line": 95,
        "start_byte": 1727,
        "end_byte": 1876,
        "full_declaration": "void\nquadtree_walk(quadtree_node_t *root,\n              void (*descent)(quadtree_node_t *node),\n              void (*ascent)(quadtree_node_t *node));",
        "declaration_length": 149,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdlib.h>",
        "line": 10,
        "start_line": 10,
        "end_line": 11,
        "start_byte": 121,
        "end_byte": 141
      },
      {
        "text": "#include <math.h>",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 141,
        "end_byte": 159
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef struct quadtree_point {\n  double x;\n  double y;\n} quadtree_point_t;",
        "name": "quadtree_point_t",
        "line": 13,
        "start_line": 13,
        "end_line": 16,
        "start_byte": 160,
        "end_byte": 235,
        "comment": ""
      },
      {
        "text": "typedef struct quadtree_bounds {\n  quadtree_point_t *nw;\n  quadtree_point_t *se;\n  double width;\n  double height;\n} quadtree_bounds_t;",
        "name": "quadtree_bounds_t",
        "line": 18,
        "start_line": 18,
        "end_line": 23,
        "start_byte": 237,
        "end_byte": 371,
        "comment": ""
      },
      {
        "text": "typedef struct quadtree_node {\n  struct quadtree_node *ne;\n  struct quadtree_node *nw;\n  struct quadtree_node *se;\n  struct quadtree_node *sw;\n  quadtree_bounds_t *bounds;\n  quadtree_point_t  *point;\n  void *key;\n} quadtree_node_t;",
        "name": "quadtree_node_t",
        "line": 25,
        "start_line": 25,
        "end_line": 33,
        "start_byte": 373,
        "end_byte": 604,
        "comment": ""
      },
      {
        "text": "typedef struct quadtree {\n  quadtree_node_t *root;\n  void (*key_free)(void *key);\n  unsigned int length;\n} quadtree_t;",
        "name": "quadtree_t",
        "line": 35,
        "start_line": 35,
        "end_line": 39,
        "start_byte": 606,
        "end_byte": 724,
        "comment": ""
      }
    ],
    "macros": [
      {
        "text": "#define __QUADTREE_H__",
        "name": "__QUADTREE_H__",
        "line": 2,
        "start_line": 2,
        "end_line": 3,
        "start_byte": 23,
        "end_byte": 46,
        "comment": ""
      },
      {
        "text": "#define QUADTREE_VERSION \"0.0.1\"",
        "name": "QUADTREE_VERSION",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 87,
        "end_byte": 120,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 534,
    "file_size": 1915
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/urlparser.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/urlparser.h",
    "parse_success": true,
    "functions": [
      {
        "name": "ParseURL",
        "type": "declaration",
        "return_type": "bool",
        "parameters": [
          "char* URL",
          "URL_PARTS* pURL_Parts"
        ],
        "start_line": 45,
        "end_line": 45,
        "start_byte": 1105,
        "end_byte": 1153,
        "full_declaration": "bool ParseURL(char* URL, URL_PARTS* pURL_Parts);",
        "declaration_length": 48,
        "comment": "@URL: The URL string the parse @pURL_Parts: A pointer to a URL_PARTS struct to fill @return: true on success, false otherwise"
      },
      {
        "name": "PrintURL",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "struct URL_PARTS* pURL_Parts"
        ],
        "start_line": 51,
        "end_line": 51,
        "start_byte": 1360,
        "end_byte": 1404,
        "full_declaration": "void PrintURL(struct URL_PARTS* pURL_Parts);",
        "declaration_length": 44,
        "comment": "This function prints each part of a URL_PARTS struct individually, and the entire URL on a single line. For testing purposes only @pURL_Parts: A pointer to a URL_PARTS struct to print"
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdio.h>",
        "line": 13,
        "start_line": 13,
        "end_line": 14,
        "start_byte": 240,
        "end_byte": 259
      },
      {
        "text": "#include <stdlib.h>",
        "line": 14,
        "start_line": 14,
        "end_line": 15,
        "start_byte": 259,
        "end_byte": 279
      },
      {
        "text": "#include <string.h>",
        "line": 15,
        "start_line": 15,
        "end_line": 16,
        "start_byte": 279,
        "end_byte": 299
      },
      {
        "text": "#include <stdbool.h>",
        "line": 16,
        "start_line": 16,
        "end_line": 17,
        "start_byte": 299,
        "end_byte": 320
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef struct URL_PARTS {\n    char scheme[MAX_URL_SCHEME_LEN];\n    char authority[MAX_URL_AUTHORITY_LEN];\n    char port[MAX_URL_PORT_LEN];\n    char path[MAX_URL_PATH_LEN];\n    char query[MAX_URL_QUERY_LEN];\n    char fragment[MAX_URL_FRAGMENT_LEN];\n} URL_PARTS;",
        "name": "URL_PARTS",
        "line": 31,
        "start_line": 31,
        "end_line": 38,
        "start_byte": 658,
        "end_byte": 919,
        "comment": "Maximum fragment length"
      }
    ],
    "macros": [
      {
        "text": "#define URL_PARSER_H",
        "name": "URL_PARSER_H",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 218,
        "end_byte": 239,
        "comment": ""
      },
      {
        "text": "#define MAX_URL_SCHEME_LEN 32",
        "name": "MAX_URL_SCHEME_LEN",
        "line": 19,
        "start_line": 19,
        "end_line": 20,
        "start_byte": 346,
        "end_byte": 376,
        "comment": "Maximum scheme length"
      },
      {
        "text": "#define MAX_URL_AUTHORITY_LEN 512",
        "name": "MAX_URL_AUTHORITY_LEN",
        "line": 21,
        "start_line": 21,
        "end_line": 22,
        "start_byte": 404,
        "end_byte": 438,
        "comment": "Maximum scheme length Maximum authority length"
      },
      {
        "text": "#define MAX_URL_PORT_LEN 64",
        "name": "MAX_URL_PORT_LEN",
        "line": 23,
        "start_line": 23,
        "end_line": 24,
        "start_byte": 461,
        "end_byte": 489,
        "comment": "Maximum authority length Maximum port length"
      },
      {
        "text": "#define MAX_URL_PATH_LEN 1024",
        "name": "MAX_URL_PATH_LEN",
        "line": 25,
        "start_line": 25,
        "end_line": 26,
        "start_byte": 512,
        "end_byte": 542,
        "comment": "Maximum port length Maximum path length"
      },
      {
        "text": "#define MAX_URL_QUERY_LEN 1024",
        "name": "MAX_URL_QUERY_LEN",
        "line": 27,
        "start_line": 27,
        "end_line": 28,
        "start_byte": 566,
        "end_byte": 597,
        "comment": "Maximum path length Maximum query length"
      },
      {
        "text": "#define MAX_URL_FRAGMENT_LEN 256",
        "name": "MAX_URL_FRAGMENT_LEN",
        "line": 29,
        "start_line": 29,
        "end_line": 30,
        "start_byte": 624,
        "end_byte": 657,
        "comment": "Maximum query length Maximum fragment length"
      }
    ],
    "enums": [],
    "total_nodes": 160,
    "file_size": 1430
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/lil.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/lil.h",
    "parse_success": true,
    "functions": [
      {
        "name": "lil_new",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "void"
        ],
        "start_line": 91,
        "end_line": 91,
        "start_byte": 3205,
        "end_byte": 3232,
        "full_declaration": "LILAPI lil_t lil_new(void);",
        "declaration_length": 27,
        "comment": ""
      },
      {
        "name": "lil_free",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil"
        ],
        "start_line": 92,
        "end_line": 92,
        "start_byte": 3233,
        "end_byte": 3265,
        "full_declaration": "LILAPI void lil_free(lil_t lil);",
        "declaration_length": 32,
        "comment": ""
      },
      {
        "name": "lil_register",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* name",
          "lil_func_proc_t proc"
        ],
        "start_line": 94,
        "end_line": 94,
        "start_byte": 3267,
        "end_byte": 3342,
        "full_declaration": "LILAPI int lil_register(lil_t lil, const char* name, lil_func_proc_t proc);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "lil_parse",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* code",
          "size_t codelen",
          "int funclevel"
        ],
        "start_line": 96,
        "end_line": 96,
        "start_byte": 3344,
        "end_byte": 3433,
        "full_declaration": "LILAPI lil_value_t lil_parse(lil_t lil, const char* code, size_t codelen, int funclevel);",
        "declaration_length": 89,
        "comment": ""
      },
      {
        "name": "lil_parse_value",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "lil_value_t val",
          "int funclevel"
        ],
        "start_line": 97,
        "end_line": 97,
        "start_byte": 3434,
        "end_byte": 3512,
        "full_declaration": "LILAPI lil_value_t lil_parse_value(lil_t lil, lil_value_t val, int funclevel);",
        "declaration_length": 78,
        "comment": ""
      },
      {
        "name": "lil_call",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* funcname",
          "size_t argc",
          "lil_value_t* argv"
        ],
        "start_line": 98,
        "end_line": 98,
        "start_byte": 3513,
        "end_byte": 3606,
        "full_declaration": "LILAPI lil_value_t lil_call(lil_t lil, const char* funcname, size_t argc, lil_value_t* argv);",
        "declaration_length": 93,
        "comment": ""
      },
      {
        "name": "lil_callback",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "int cb",
          "lil_callback_proc_t proc"
        ],
        "start_line": 100,
        "end_line": 100,
        "start_byte": 3608,
        "end_byte": 3678,
        "full_declaration": "LILAPI void lil_callback(lil_t lil, int cb, lil_callback_proc_t proc);",
        "declaration_length": 70,
        "comment": ""
      },
      {
        "name": "lil_set_error",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* msg"
        ],
        "start_line": 102,
        "end_line": 102,
        "start_byte": 3680,
        "end_byte": 3734,
        "full_declaration": "LILAPI void lil_set_error(lil_t lil, const char* msg);",
        "declaration_length": 54,
        "comment": ""
      },
      {
        "name": "lil_set_error_at",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "size_t pos",
          "const char* msg"
        ],
        "start_line": 103,
        "end_line": 103,
        "start_byte": 3735,
        "end_byte": 3804,
        "full_declaration": "LILAPI void lil_set_error_at(lil_t lil, size_t pos, const char* msg);",
        "declaration_length": 69,
        "comment": ""
      },
      {
        "name": "lil_error",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char** msg",
          "size_t* pos"
        ],
        "start_line": 104,
        "end_line": 104,
        "start_byte": 3805,
        "end_byte": 3868,
        "full_declaration": "LILAPI int lil_error(lil_t lil, const char** msg, size_t* pos);",
        "declaration_length": 63,
        "comment": ""
      },
      {
        "name": "lil_to_string",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val"
        ],
        "start_line": 106,
        "end_line": 106,
        "start_byte": 3870,
        "end_byte": 3920,
        "full_declaration": "LILAPI const char* lil_to_string(lil_value_t val);",
        "declaration_length": 50,
        "comment": ""
      },
      {
        "name": "lil_to_double",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val"
        ],
        "start_line": 107,
        "end_line": 107,
        "start_byte": 3921,
        "end_byte": 3966,
        "full_declaration": "LILAPI double lil_to_double(lil_value_t val);",
        "declaration_length": 45,
        "comment": ""
      },
      {
        "name": "lil_to_integer",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val"
        ],
        "start_line": 108,
        "end_line": 108,
        "start_byte": 3967,
        "end_byte": 4015,
        "full_declaration": "LILAPI lilint_t lil_to_integer(lil_value_t val);",
        "declaration_length": 48,
        "comment": ""
      },
      {
        "name": "lil_to_boolean",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val"
        ],
        "start_line": 109,
        "end_line": 109,
        "start_byte": 4016,
        "end_byte": 4059,
        "full_declaration": "LILAPI int lil_to_boolean(lil_value_t val);",
        "declaration_length": 43,
        "comment": ""
      },
      {
        "name": "lil_alloc_string",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "const char* str"
        ],
        "start_line": 111,
        "end_line": 111,
        "start_byte": 4061,
        "end_byte": 4114,
        "full_declaration": "LILAPI lil_value_t lil_alloc_string(const char* str);",
        "declaration_length": 53,
        "comment": ""
      },
      {
        "name": "lil_alloc_double",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "double num"
        ],
        "start_line": 112,
        "end_line": 112,
        "start_byte": 4115,
        "end_byte": 4163,
        "full_declaration": "LILAPI lil_value_t lil_alloc_double(double num);",
        "declaration_length": 48,
        "comment": ""
      },
      {
        "name": "lil_alloc_integer",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lilint_t num"
        ],
        "start_line": 113,
        "end_line": 113,
        "start_byte": 4164,
        "end_byte": 4215,
        "full_declaration": "LILAPI lil_value_t lil_alloc_integer(lilint_t num);",
        "declaration_length": 51,
        "comment": ""
      },
      {
        "name": "lil_free_value",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val"
        ],
        "start_line": 114,
        "end_line": 114,
        "start_byte": 4216,
        "end_byte": 4260,
        "full_declaration": "LILAPI void lil_free_value(lil_value_t val);",
        "declaration_length": 44,
        "comment": ""
      },
      {
        "name": "lil_clone_value",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t src"
        ],
        "start_line": 116,
        "end_line": 116,
        "start_byte": 4262,
        "end_byte": 4314,
        "full_declaration": "LILAPI lil_value_t lil_clone_value(lil_value_t src);",
        "declaration_length": 52,
        "comment": ""
      },
      {
        "name": "lil_append_char",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val",
          "char ch"
        ],
        "start_line": 117,
        "end_line": 117,
        "start_byte": 4315,
        "end_byte": 4368,
        "full_declaration": "LILAPI int lil_append_char(lil_value_t val, char ch);",
        "declaration_length": 53,
        "comment": ""
      },
      {
        "name": "lil_append_string",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val",
          "const char* s"
        ],
        "start_line": 118,
        "end_line": 118,
        "start_byte": 4369,
        "end_byte": 4430,
        "full_declaration": "LILAPI int lil_append_string(lil_value_t val, const char* s);",
        "declaration_length": 61,
        "comment": ""
      },
      {
        "name": "lil_append_val",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t val",
          "lil_value_t v"
        ],
        "start_line": 119,
        "end_line": 119,
        "start_byte": 4431,
        "end_byte": 4489,
        "full_declaration": "LILAPI int lil_append_val(lil_value_t val, lil_value_t v);",
        "declaration_length": 58,
        "comment": ""
      },
      {
        "name": "lil_free_list",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_list_t list"
        ],
        "start_line": 122,
        "end_line": 122,
        "start_byte": 4531,
        "end_byte": 4574,
        "full_declaration": "LILAPI void lil_free_list(lil_list_t list);",
        "declaration_length": 43,
        "comment": ""
      },
      {
        "name": "lil_list_append",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_list_t list",
          "lil_value_t val"
        ],
        "start_line": 123,
        "end_line": 123,
        "start_byte": 4575,
        "end_byte": 4637,
        "full_declaration": "LILAPI void lil_list_append(lil_list_t list, lil_value_t val);",
        "declaration_length": 62,
        "comment": ""
      },
      {
        "name": "lil_list_size",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_list_t list"
        ],
        "start_line": 124,
        "end_line": 124,
        "start_byte": 4638,
        "end_byte": 4683,
        "full_declaration": "LILAPI size_t lil_list_size(lil_list_t list);",
        "declaration_length": 45,
        "comment": ""
      },
      {
        "name": "lil_list_get",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_list_t list",
          "size_t index"
        ],
        "start_line": 125,
        "end_line": 125,
        "start_byte": 4684,
        "end_byte": 4747,
        "full_declaration": "LILAPI lil_value_t lil_list_get(lil_list_t list, size_t index);",
        "declaration_length": 63,
        "comment": ""
      },
      {
        "name": "lil_list_to_value",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_list_t list",
          "int do_escape"
        ],
        "start_line": 126,
        "end_line": 126,
        "start_byte": 4748,
        "end_byte": 4817,
        "full_declaration": "LILAPI lil_value_t lil_list_to_value(lil_list_t list, int do_escape);",
        "declaration_length": 69,
        "comment": ""
      },
      {
        "name": "lil_subst_to_list",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "lil_value_t code"
        ],
        "start_line": 128,
        "end_line": 128,
        "start_byte": 4819,
        "end_byte": 4884,
        "full_declaration": "LILAPI lil_list_t lil_subst_to_list(lil_t lil, lil_value_t code);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "lil_subst_to_value",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "lil_value_t code"
        ],
        "start_line": 129,
        "end_line": 129,
        "start_byte": 4885,
        "end_byte": 4952,
        "full_declaration": "LILAPI lil_value_t lil_subst_to_value(lil_t lil, lil_value_t code);",
        "declaration_length": 67,
        "comment": ""
      },
      {
        "name": "lil_alloc_env",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_env_t parent"
        ],
        "start_line": 131,
        "end_line": 131,
        "start_byte": 4954,
        "end_byte": 5003,
        "full_declaration": "LILAPI lil_env_t lil_alloc_env(lil_env_t parent);",
        "declaration_length": 49,
        "comment": ""
      },
      {
        "name": "lil_free_env",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_env_t env"
        ],
        "start_line": 132,
        "end_line": 132,
        "start_byte": 5004,
        "end_byte": 5044,
        "full_declaration": "LILAPI void lil_free_env(lil_env_t env);",
        "declaration_length": 40,
        "comment": ""
      },
      {
        "name": "lil_push_env",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil"
        ],
        "start_line": 133,
        "end_line": 133,
        "start_byte": 5045,
        "end_byte": 5086,
        "full_declaration": "LILAPI lil_env_t lil_push_env(lil_t lil);",
        "declaration_length": 41,
        "comment": ""
      },
      {
        "name": "lil_pop_env",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil"
        ],
        "start_line": 134,
        "end_line": 134,
        "start_byte": 5087,
        "end_byte": 5122,
        "full_declaration": "LILAPI void lil_pop_env(lil_t lil);",
        "declaration_length": 35,
        "comment": ""
      },
      {
        "name": "lil_set_var",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* name",
          "lil_value_t val",
          "int local"
        ],
        "start_line": 136,
        "end_line": 136,
        "start_byte": 5124,
        "end_byte": 5210,
        "full_declaration": "LILAPI lil_var_t lil_set_var(lil_t lil, const char* name, lil_value_t val, int local);",
        "declaration_length": 86,
        "comment": ""
      },
      {
        "name": "lil_get_var",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* name"
        ],
        "start_line": 137,
        "end_line": 137,
        "start_byte": 5211,
        "end_byte": 5271,
        "full_declaration": "LILAPI lil_value_t lil_get_var(lil_t lil, const char* name);",
        "declaration_length": 60,
        "comment": ""
      },
      {
        "name": "lil_get_var_or",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* name",
          "lil_value_t defvalue"
        ],
        "start_line": 138,
        "end_line": 138,
        "start_byte": 5272,
        "end_byte": 5357,
        "full_declaration": "LILAPI lil_value_t lil_get_var_or(lil_t lil, const char* name, lil_value_t defvalue);",
        "declaration_length": 85,
        "comment": ""
      },
      {
        "name": "lil_eval_expr",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "lil_value_t code"
        ],
        "start_line": 140,
        "end_line": 140,
        "start_byte": 5359,
        "end_byte": 5421,
        "full_declaration": "LILAPI lil_value_t lil_eval_expr(lil_t lil, lil_value_t code);",
        "declaration_length": 62,
        "comment": ""
      },
      {
        "name": "lil_unused_name",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* part"
        ],
        "start_line": 141,
        "end_line": 141,
        "start_byte": 5422,
        "end_byte": 5486,
        "full_declaration": "LILAPI lil_value_t lil_unused_name(lil_t lil, const char* part);",
        "declaration_length": 64,
        "comment": ""
      },
      {
        "name": "lil_arg",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_value_t* argv",
          "size_t index"
        ],
        "start_line": 143,
        "end_line": 143,
        "start_byte": 5488,
        "end_byte": 5548,
        "full_declaration": "LILAPI lil_value_t lil_arg(lil_value_t* argv, size_t index);",
        "declaration_length": 60,
        "comment": ""
      },
      {
        "name": "lil_set_data",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "void* data"
        ],
        "start_line": 145,
        "end_line": 145,
        "start_byte": 5550,
        "end_byte": 5598,
        "full_declaration": "LILAPI void lil_set_data(lil_t lil, void* data);",
        "declaration_length": 48,
        "comment": ""
      },
      {
        "name": "lil_get_data",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil"
        ],
        "start_line": 146,
        "end_line": 146,
        "start_byte": 5599,
        "end_byte": 5636,
        "full_declaration": "LILAPI void* lil_get_data(lil_t lil);",
        "declaration_length": 37,
        "comment": ""
      },
      {
        "name": "lil_embedded",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* code",
          "unsigned int flags"
        ],
        "start_line": 148,
        "end_line": 148,
        "start_byte": 5638,
        "end_byte": 5713,
        "full_declaration": "LILAPI char* lil_embedded(lil_t lil, const char* code, unsigned int flags);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "lil_freemem",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "void* ptr"
        ],
        "start_line": 149,
        "end_line": 149,
        "start_byte": 5714,
        "end_byte": 5749,
        "full_declaration": "LILAPI void lil_freemem(void* ptr);",
        "declaration_length": 35,
        "comment": ""
      },
      {
        "name": "lil_write",
        "type": "declaration",
        "return_type": "LILAPI",
        "parameters": [
          "lil_t lil",
          "const char* msg"
        ],
        "start_line": 151,
        "end_line": 151,
        "start_byte": 5751,
        "end_byte": 5801,
        "full_declaration": "LILAPI void lil_write(lil_t lil, const char* msg);",
        "declaration_length": 50,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdint.h>",
        "line": 66,
        "start_line": 66,
        "end_line": 67,
        "start_byte": 1964,
        "end_byte": 1984
      },
      {
        "text": "#include <inttypes.h>",
        "line": 67,
        "start_line": 67,
        "end_line": 68,
        "start_byte": 1984,
        "end_byte": 2006
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef long long int lilint_t;",
        "name": "lilint_t",
        "line": 58,
        "start_line": 58,
        "end_line": 58,
        "start_byte": 1793,
        "end_byte": 1824,
        "comment": ""
      },
      {
        "text": "typedef __int64 lilint_t;",
        "name": "lilint_t",
        "line": 62,
        "start_line": 62,
        "end_line": 62,
        "start_byte": 1880,
        "end_byte": 1905,
        "comment": ""
      },
      {
        "text": "typedef int64_t lilint_t;",
        "name": "lilint_t",
        "line": 68,
        "start_line": 68,
        "end_line": 68,
        "start_byte": 2006,
        "end_byte": 2031,
        "comment": ""
      },
      {
        "text": "typedef struct _lil_value_t* lil_value_t;",
        "name": "lil_value_t",
        "line": 74,
        "start_line": 74,
        "end_line": 74,
        "start_byte": 2086,
        "end_byte": 2127,
        "comment": ""
      },
      {
        "text": "typedef struct _lil_func_t* lil_func_t;",
        "name": "lil_func_t",
        "line": 75,
        "start_line": 75,
        "end_line": 75,
        "start_byte": 2128,
        "end_byte": 2167,
        "comment": ""
      },
      {
        "text": "typedef struct _lil_var_t* lil_var_t;",
        "name": "lil_var_t",
        "line": 76,
        "start_line": 76,
        "end_line": 76,
        "start_byte": 2168,
        "end_byte": 2205,
        "comment": ""
      },
      {
        "text": "typedef struct _lil_env_t* lil_env_t;",
        "name": "lil_env_t",
        "line": 77,
        "start_line": 77,
        "end_line": 77,
        "start_byte": 2206,
        "end_byte": 2243,
        "comment": ""
      },
      {
        "text": "typedef struct _lil_list_t* lil_list_t;",
        "name": "lil_list_t",
        "line": 78,
        "start_line": 78,
        "end_line": 78,
        "start_byte": 2244,
        "end_byte": 2283,
        "comment": ""
      },
      {
        "text": "typedef struct _lil_t* lil_t;",
        "name": "lil_t",
        "line": 79,
        "start_line": 79,
        "end_line": 79,
        "start_byte": 2284,
        "end_byte": 2313,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK lil_value_t (*lil_func_proc_t)(lil_t lil, size_t argc, lil_value_t* argv);",
        "name": "lil_value_t",
        "line": 80,
        "start_line": 80,
        "end_line": 80,
        "start_byte": 2314,
        "end_byte": 2408,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK void (*lil_exit_callback_proc_t)(lil_t lil, lil_value_t arg);",
        "name": "lil_value_t",
        "line": 81,
        "start_line": 81,
        "end_line": 81,
        "start_byte": 2409,
        "end_byte": 2490,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK void (*lil_write_callback_proc_t)(lil_t lil, const char* msg);",
        "name": "lil_t",
        "line": 82,
        "start_line": 82,
        "end_line": 82,
        "start_byte": 2491,
        "end_byte": 2573,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK char* (*lil_read_callback_proc_t)(lil_t lil, const char* name);",
        "name": "lil_t",
        "line": 83,
        "start_line": 83,
        "end_line": 83,
        "start_byte": 2574,
        "end_byte": 2657,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK char* (*lil_source_callback_proc_t)(lil_t lil, const char* name);",
        "name": "lil_t",
        "line": 84,
        "start_line": 84,
        "end_line": 84,
        "start_byte": 2658,
        "end_byte": 2743,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK void (*lil_store_callback_proc_t)(lil_t lil, const char* name, const char* data);",
        "name": "lil_t",
        "line": 85,
        "start_line": 85,
        "end_line": 85,
        "start_byte": 2744,
        "end_byte": 2845,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK void (*lil_error_callback_proc_t)(lil_t lil, size_t pos, const char* msg);",
        "name": "lil_t",
        "line": 86,
        "start_line": 86,
        "end_line": 86,
        "start_byte": 2846,
        "end_byte": 2940,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK int (*lil_setvar_callback_proc_t)(lil_t lil, const char* name, lil_value_t* value);",
        "name": "lil_value_t",
        "line": 87,
        "start_line": 87,
        "end_line": 87,
        "start_byte": 2941,
        "end_byte": 3044,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK int (*lil_getvar_callback_proc_t)(lil_t lil, const char* name, lil_value_t* value);",
        "name": "lil_value_t",
        "line": 88,
        "start_line": 88,
        "end_line": 88,
        "start_byte": 3045,
        "end_byte": 3148,
        "comment": ""
      },
      {
        "text": "typedef LILCALLBACK void (*lil_callback_proc_t)(void);",
        "name": "lil_callback_proc_t",
        "line": 89,
        "start_line": 89,
        "end_line": 89,
        "start_byte": 3149,
        "end_byte": 3203,
        "comment": ""
      }
    ],
    "macros": [
      {
        "text": "#define __LIL_H_INCLUDED__",
        "name": "__LIL_H_INCLUDED__",
        "line": 25,
        "start_line": 25,
        "end_line": 26,
        "start_byte": 1042,
        "end_byte": 1069,
        "comment": "* LIL - Little Interpreted Language\n * Copyright (C) 2010-2013 Kostas Michalopoulos\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n *\n * 1. The origin of this software must not be misrepresented; you must not\n *    claim that you wrote the original software. If you use this software\n *    in a product, an acknowledgment in the product documentation would be\n *    appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n *    misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n *\n * Kostas Michalopoulos <badsector@runtimelegend.com>"
      },
      {
        "text": "#define LIL_VERSION_STRING \"0.1\"",
        "name": "LIL_VERSION_STRING",
        "line": 27,
        "start_line": 27,
        "end_line": 28,
        "start_byte": 1070,
        "end_byte": 1103,
        "comment": ""
      },
      {
        "text": "#define LIL_SETVAR_GLOBAL 0",
        "name": "LIL_SETVAR_GLOBAL",
        "line": 29,
        "start_line": 29,
        "end_line": 30,
        "start_byte": 1104,
        "end_byte": 1132,
        "comment": ""
      },
      {
        "text": "#define LIL_SETVAR_LOCAL 1",
        "name": "LIL_SETVAR_LOCAL",
        "line": 30,
        "start_line": 30,
        "end_line": 31,
        "start_byte": 1132,
        "end_byte": 1159,
        "comment": ""
      },
      {
        "text": "#define LIL_SETVAR_LOCAL_NEW 2",
        "name": "LIL_SETVAR_LOCAL_NEW",
        "line": 31,
        "start_line": 31,
        "end_line": 32,
        "start_byte": 1159,
        "end_byte": 1190,
        "comment": ""
      },
      {
        "text": "#define LIL_SETVAR_LOCAL_ONLY 3",
        "name": "LIL_SETVAR_LOCAL_ONLY",
        "line": 32,
        "start_line": 32,
        "end_line": 33,
        "start_byte": 1190,
        "end_byte": 1222,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_EXIT 0",
        "name": "LIL_CALLBACK_EXIT",
        "line": 34,
        "start_line": 34,
        "end_line": 35,
        "start_byte": 1223,
        "end_byte": 1251,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_WRITE 1",
        "name": "LIL_CALLBACK_WRITE",
        "line": 35,
        "start_line": 35,
        "end_line": 36,
        "start_byte": 1251,
        "end_byte": 1280,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_READ 2",
        "name": "LIL_CALLBACK_READ",
        "line": 36,
        "start_line": 36,
        "end_line": 37,
        "start_byte": 1280,
        "end_byte": 1308,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_STORE 3",
        "name": "LIL_CALLBACK_STORE",
        "line": 37,
        "start_line": 37,
        "end_line": 38,
        "start_byte": 1308,
        "end_byte": 1337,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_SOURCE 4",
        "name": "LIL_CALLBACK_SOURCE",
        "line": 38,
        "start_line": 38,
        "end_line": 39,
        "start_byte": 1337,
        "end_byte": 1367,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_ERROR 5",
        "name": "LIL_CALLBACK_ERROR",
        "line": 39,
        "start_line": 39,
        "end_line": 40,
        "start_byte": 1367,
        "end_byte": 1396,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_SETVAR 6",
        "name": "LIL_CALLBACK_SETVAR",
        "line": 40,
        "start_line": 40,
        "end_line": 41,
        "start_byte": 1396,
        "end_byte": 1426,
        "comment": ""
      },
      {
        "text": "#define LIL_CALLBACK_GETVAR 7",
        "name": "LIL_CALLBACK_GETVAR",
        "line": 41,
        "start_line": 41,
        "end_line": 42,
        "start_byte": 1426,
        "end_byte": 1456,
        "comment": ""
      },
      {
        "text": "#define LIL_EMBED_NOFLAGS 0x0000",
        "name": "LIL_EMBED_NOFLAGS",
        "line": 43,
        "start_line": 43,
        "end_line": 44,
        "start_byte": 1457,
        "end_byte": 1490,
        "comment": ""
      },
      {
        "text": "#define LILAPI __declspec(dllexport __stdcall)",
        "name": "LILAPI",
        "line": 47,
        "start_line": 47,
        "end_line": 48,
        "start_byte": 1572,
        "end_byte": 1619,
        "comment": ""
      },
      {
        "text": "#define LILAPI __declspec(dllimport __stdcall)",
        "name": "LILAPI",
        "line": 49,
        "start_line": 49,
        "end_line": 50,
        "start_byte": 1625,
        "end_byte": 1672,
        "comment": ""
      },
      {
        "text": "#define LILCALLBACK __declspec(__stdcall)",
        "name": "LILCALLBACK",
        "line": 51,
        "start_line": 51,
        "end_line": 52,
        "start_byte": 1679,
        "end_byte": 1721,
        "comment": ""
      },
      {
        "text": "#define LILAPI",
        "name": "LILAPI",
        "line": 53,
        "start_line": 53,
        "end_line": 54,
        "start_byte": 1727,
        "end_byte": 1742,
        "comment": ""
      },
      {
        "text": "#define LILCALLBACK",
        "name": "LILCALLBACK",
        "line": 54,
        "start_line": 54,
        "end_line": 55,
        "start_byte": 1742,
        "end_byte": 1762,
        "comment": ""
      },
      {
        "text": "#define LILINT_PRINTF \"%lli\"",
        "name": "LILINT_PRINTF",
        "line": 59,
        "start_line": 59,
        "end_line": 60,
        "start_byte": 1825,
        "end_byte": 1854,
        "comment": ""
      },
      {
        "text": "#define LILINT_PRINTF \"%I64i\"",
        "name": "LILINT_PRINTF",
        "line": 63,
        "start_line": 63,
        "end_line": 64,
        "start_byte": 1906,
        "end_byte": 1936,
        "comment": ""
      },
      {
        "text": "#define LILINT_PRINTF \"%\"PRIi64",
        "name": "LILINT_PRINTF",
        "line": 69,
        "start_line": 69,
        "end_line": 70,
        "start_byte": 2032,
        "end_byte": 2064,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 1331,
    "file_size": 5810
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/bst.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/bst.h",
    "parse_success": true,
    "functions": [
      {
        "name": "bst_create",
        "type": "declaration",
        "return_type": "",
        "parameters": [],
        "start_line": 16,
        "end_line": 16,
        "start_byte": 250,
        "end_byte": 275,
        "full_declaration": "struct bst* bst_create();",
        "declaration_length": 25,
        "comment": "* Creates a new, empty binary search tree and returns a pointer to it."
      },
      {
        "name": "bst_free",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "struct bst* bst"
        ],
        "start_line": 24,
        "end_line": 24,
        "start_byte": 405,
        "end_byte": 436,
        "full_declaration": "void bst_free(struct bst* bst);",
        "declaration_length": 31,
        "comment": "* Free the memory associated with a binary search tree.\n *\n * Params:\n *   bst - the binary search tree to be destroyed"
      },
      {
        "name": "bst_isempty",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "struct bst* bst"
        ],
        "start_line": 32,
        "end_line": 32,
        "start_byte": 596,
        "end_byte": 629,
        "full_declaration": "int bst_isempty(struct bst* bst);",
        "declaration_length": 33,
        "comment": "* Returns 1 if the given binary search tree is empty or 0 otherwise.\n *\n * Params:\n *   bst - the binary search tree whose emptiness is to be checked"
      },
      {
        "name": "bst_insert",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "int val",
          "struct bst* bst"
        ],
        "start_line": 41,
        "end_line": 41,
        "start_byte": 823,
        "end_byte": 865,
        "full_declaration": "void bst_insert(int val, struct bst* bst);",
        "declaration_length": 42,
        "comment": "* Inserts a given value into an existing binary search tree.\n *\n * Params:\n *   val - the value to be inserted into the tree\n *   bst - the binary search tree into which to insert val"
      },
      {
        "name": "bst_remove",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "int val",
          "struct bst* bst"
        ],
        "start_line": 52,
        "end_line": 52,
        "start_byte": 1154,
        "end_byte": 1196,
        "full_declaration": "void bst_remove(int val, struct bst* bst);",
        "declaration_length": 42,
        "comment": "* Removes a given value from an existing binary search tree.  If the\n * specified value is not contained in the specified tree, the tree is not\n * modified.\n *\n * Params:\n *   val - the value to be removed from the tree\n *   bst - the binary search tree from which to remove val"
      },
      {
        "name": "bst_contains",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "int val",
          "struct bst* bst"
        ],
        "start_line": 64,
        "end_line": 64,
        "start_byte": 1457,
        "end_byte": 1500,
        "full_declaration": "int bst_contains(int val, struct bst* bst);",
        "declaration_length": 43,
        "comment": "* Determines whether a binary search tree contains a given value.\n *\n * Params:\n *   val - the value to be found in the tree\n *   bst - the binary search tree in which to search for val\n *\n * Return:\n *   Returns 1 if bst contains val or 0 otherwise."
      }
    ],
    "structs": [
      {
        "name": "bst",
        "start_line": 11,
        "end_line": 11,
        "start_byte": 158,
        "end_byte": 168,
        "full_definition": "struct bst",
        "fields": [],
        "definition_length": 10,
        "comment": "* Structure used to represent a binary search tree."
      }
    ],
    "includes": [],
    "variables": [],
    "typedefs": [],
    "macros": [
      {
        "text": "#define __BST_H",
        "name": "__BST_H",
        "line": 6,
        "start_line": 6,
        "end_line": 7,
        "start_byte": 81,
        "end_byte": 97,
        "comment": "* A definition for a binary search tree implementation."
      }
    ],
    "enums": [],
    "total_nodes": 119,
    "file_size": 1510
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/rgba.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/rgba.h",
    "parse_success": true,
    "functions": [
      {
        "name": "rgba_new",
        "type": "declaration",
        "return_type": "rgba_t",
        "parameters": [
          "uint32_t rgba"
        ],
        "start_line": 23,
        "end_line": 24,
        "start_byte": 215,
        "end_byte": 246,
        "full_declaration": "rgba_t\nrgba_new(uint32_t rgba);",
        "declaration_length": 31,
        "comment": "protos"
      },
      {
        "name": "rgba_from_string",
        "type": "declaration",
        "return_type": "uint32_t",
        "parameters": [
          "const char *str",
          "short *ok"
        ],
        "start_line": 26,
        "end_line": 27,
        "start_byte": 248,
        "end_byte": 302,
        "full_declaration": "uint32_t\nrgba_from_string(const char *str, short *ok);",
        "declaration_length": 54,
        "comment": ""
      },
      {
        "name": "rgba_to_string",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "rgba_t rgba",
          "char *buf",
          "size_t len"
        ],
        "start_line": 29,
        "end_line": 30,
        "start_byte": 304,
        "end_byte": 360,
        "full_declaration": "void\nrgba_to_string(rgba_t rgba, char *buf, size_t len);",
        "declaration_length": 56,
        "comment": ""
      },
      {
        "name": "rgba_inspect",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "uint32_t rgba"
        ],
        "start_line": 32,
        "end_line": 33,
        "start_byte": 362,
        "end_byte": 395,
        "full_declaration": "void\nrgba_inspect(uint32_t rgba);",
        "declaration_length": 33,
        "comment": ""
      }
    ],
    "structs": [],
    "includes": [
      {
        "text": "#include <stdint.h>",
        "line": 11,
        "start_line": 11,
        "end_line": 12,
        "start_byte": 110,
        "end_byte": 130
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef struct {\n  double r, g, b, a;\n} rgba_t;",
        "name": "rgba_t",
        "line": 17,
        "start_line": 17,
        "end_line": 19,
        "start_byte": 155,
        "end_byte": 202,
        "comment": "* RGBA struct."
      }
    ],
    "macros": [
      {
        "text": "#define RGBA_H",
        "name": "RGBA_H",
        "line": 9,
        "start_line": 9,
        "end_line": 10,
        "start_byte": 94,
        "end_byte": 109,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 103,
    "file_size": 416
  },
  "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/binn.h": {
    "file_path": "/home/mins/MinsC2Rust/benchmarks/crown/Input/src/binn.h",
    "parse_success": true,
    "functions": [
      {
        "name": "binn_version",
        "type": "declaration",
        "return_type": "char",
        "parameters": [],
        "start_line": 253,
        "end_line": 253,
        "start_byte": 7225,
        "end_byte": 7256,
        "full_declaration": "char * APIENTRY binn_version();",
        "declaration_length": 31,
        "comment": "--- GENERAL FUNCTIONS  ----------------------------------------------------------"
      },
      {
        "name": "binn_set_alloc_functions",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "void* (*new_malloc)(size_t)",
          "void* (*new_realloc)(void*,size_t)",
          "void (*new_free)(void*)"
        ],
        "start_line": 255,
        "end_line": 255,
        "start_byte": 7258,
        "end_byte": 7389,
        "full_declaration": "void   APIENTRY binn_set_alloc_functions(void* (*new_malloc)(size_t), void* (*new_realloc)(void*,size_t), void (*new_free)(void*));",
        "declaration_length": 131,
        "comment": ""
      },
      {
        "name": "binn_create_type",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "int storage_type",
          "int data_type_index"
        ],
        "start_line": 257,
        "end_line": 257,
        "start_byte": 7391,
        "end_byte": 7463,
        "full_declaration": "int    APIENTRY binn_create_type(int storage_type, int data_type_index);",
        "declaration_length": 72,
        "comment": ""
      },
      {
        "name": "binn_get_type_info",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "int long_type",
          "int *pstorage_type",
          "int *pextra_type"
        ],
        "start_line": 258,
        "end_line": 258,
        "start_byte": 7464,
        "end_byte": 7552,
        "full_declaration": "BOOL   APIENTRY binn_get_type_info(int long_type, int *pstorage_type, int *pextra_type);",
        "declaration_length": 88,
        "comment": ""
      },
      {
        "name": "binn_get_write_storage",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "int type"
        ],
        "start_line": 260,
        "end_line": 260,
        "start_byte": 7554,
        "end_byte": 7603,
        "full_declaration": "int    APIENTRY binn_get_write_storage(int type);",
        "declaration_length": 49,
        "comment": ""
      },
      {
        "name": "binn_get_read_storage",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "int type"
        ],
        "start_line": 261,
        "end_line": 261,
        "start_byte": 7604,
        "end_byte": 7652,
        "full_declaration": "int    APIENTRY binn_get_read_storage(int type);",
        "declaration_length": 48,
        "comment": ""
      },
      {
        "name": "binn_is_container",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *item"
        ],
        "start_line": 263,
        "end_line": 263,
        "start_byte": 7654,
        "end_byte": 7700,
        "full_declaration": "BOOL   APIENTRY binn_is_container(binn *item);",
        "declaration_length": 46,
        "comment": ""
      },
      {
        "name": "binn_create",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *item",
          "int type",
          "int size",
          "void *buffer"
        ],
        "start_line": 275,
        "end_line": 275,
        "start_byte": 8051,
        "end_byte": 8123,
        "full_declaration": "BOOL APIENTRY binn_create(binn *item, int type, int size, void *buffer);",
        "declaration_length": 72,
        "comment": "create a new binn storing the structure on the stack"
      },
      {
        "name": "binn_create_list",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *list"
        ],
        "start_line": 276,
        "end_line": 276,
        "start_byte": 8124,
        "end_byte": 8167,
        "full_declaration": "BOOL APIENTRY binn_create_list(binn *list);",
        "declaration_length": 43,
        "comment": "create a new binn storing the structure on the stack"
      },
      {
        "name": "binn_create_map",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *map"
        ],
        "start_line": 277,
        "end_line": 277,
        "start_byte": 8168,
        "end_byte": 8209,
        "full_declaration": "BOOL APIENTRY binn_create_map(binn *map);",
        "declaration_length": 41,
        "comment": "create a new binn storing the structure on the stack"
      },
      {
        "name": "binn_create_object",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *object"
        ],
        "start_line": 278,
        "end_line": 278,
        "start_byte": 8210,
        "end_byte": 8257,
        "full_declaration": "BOOL APIENTRY binn_create_object(binn *object);",
        "declaration_length": 47,
        "comment": ""
      },
      {
        "name": "binn_list_add_new",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *list",
          "binn *value"
        ],
        "start_line": 284,
        "end_line": 284,
        "start_byte": 8349,
        "end_byte": 8406,
        "full_declaration": "BOOL APIENTRY binn_list_add_new(binn *list, binn *value);",
        "declaration_length": 57,
        "comment": ""
      },
      {
        "name": "binn_map_set_new",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *map",
          "int id",
          "binn *value"
        ],
        "start_line": 285,
        "end_line": 285,
        "start_byte": 8407,
        "end_byte": 8470,
        "full_declaration": "BOOL APIENTRY binn_map_set_new(binn *map, int id, binn *value);",
        "declaration_length": 63,
        "comment": ""
      },
      {
        "name": "binn_object_set_new",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *obj",
          "const char *key",
          "binn *value"
        ],
        "start_line": 286,
        "end_line": 286,
        "start_byte": 8471,
        "end_byte": 8546,
        "full_declaration": "BOOL APIENTRY binn_object_set_new(binn *obj, const char *key, binn *value);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "binn_list_add",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *list",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "start_line": 291,
        "end_line": 291,
        "start_byte": 8572,
        "end_byte": 8648,
        "full_declaration": "BOOL   APIENTRY binn_list_add(binn *list, int type, void *pvalue, int size);",
        "declaration_length": 76,
        "comment": "extended interface"
      },
      {
        "name": "binn_map_set",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *map",
          "int id",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "start_line": 292,
        "end_line": 292,
        "start_byte": 8649,
        "end_byte": 8731,
        "full_declaration": "BOOL   APIENTRY binn_map_set(binn *map, int id, int type, void *pvalue, int size);",
        "declaration_length": 82,
        "comment": "extended interface"
      },
      {
        "name": "binn_object_set",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *obj",
          "const char *key",
          "int type",
          "void *pvalue",
          "int size"
        ],
        "start_line": 293,
        "end_line": 293,
        "start_byte": 8732,
        "end_byte": 8826,
        "full_declaration": "BOOL   APIENTRY binn_object_set(binn *obj, const char *key, int type, void *pvalue, int size);",
        "declaration_length": 94,
        "comment": ""
      },
      {
        "name": "binn_free",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "binn *item"
        ],
        "start_line": 298,
        "end_line": 298,
        "start_byte": 8848,
        "end_byte": 8886,
        "full_declaration": "void   APIENTRY binn_free(binn *item);",
        "declaration_length": 38,
        "comment": "release memory"
      },
      {
        "name": "binn_release",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "binn *item"
        ],
        "start_line": 299,
        "end_line": 299,
        "start_byte": 8887,
        "end_byte": 8928,
        "full_declaration": "void * APIENTRY binn_release(binn *item);",
        "declaration_length": 41,
        "comment": "release memory"
      },
      {
        "name": "binn_int8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "signed char value"
        ],
        "is_static": false,
        "start_line": 306,
        "end_line": 308,
        "start_byte": 9233,
        "end_byte": 9335,
        "signature": "ALWAYS_INLINE binn * binn_int8(signed char value)",
        "full_definition": "ALWAYS_INLINE binn * binn_int8(signed char value) {\n  return binn_value(BINN_INT8, &value, 0, NULL);\n}",
        "definition_length": 102,
        "comment": ""
      },
      {
        "name": "binn_int16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "short value"
        ],
        "is_static": false,
        "start_line": 309,
        "end_line": 311,
        "start_byte": 9336,
        "end_byte": 9434,
        "signature": "ALWAYS_INLINE binn * binn_int16(short value)",
        "full_definition": "ALWAYS_INLINE binn * binn_int16(short value) {\n  return binn_value(BINN_INT16, &value, 0, NULL);\n}",
        "definition_length": 98,
        "comment": ""
      },
      {
        "name": "binn_int32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "int value"
        ],
        "is_static": false,
        "start_line": 312,
        "end_line": 314,
        "start_byte": 9435,
        "end_byte": 9531,
        "signature": "ALWAYS_INLINE binn * binn_int32(int value)",
        "full_definition": "ALWAYS_INLINE binn * binn_int32(int value) {\n  return binn_value(BINN_INT32, &value, 0, NULL);\n}",
        "definition_length": 96,
        "comment": ""
      },
      {
        "name": "binn_int64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "int64 value"
        ],
        "is_static": false,
        "start_line": 315,
        "end_line": 317,
        "start_byte": 9532,
        "end_byte": 9630,
        "signature": "ALWAYS_INLINE binn * binn_int64(int64 value)",
        "full_definition": "ALWAYS_INLINE binn * binn_int64(int64 value) {\n  return binn_value(BINN_INT64, &value, 0, NULL);\n}",
        "definition_length": 98,
        "comment": ""
      },
      {
        "name": "binn_uint8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "unsigned char value"
        ],
        "is_static": false,
        "start_line": 318,
        "end_line": 320,
        "start_byte": 9631,
        "end_byte": 9737,
        "signature": "ALWAYS_INLINE binn * binn_uint8(unsigned char value)",
        "full_definition": "ALWAYS_INLINE binn * binn_uint8(unsigned char value) {\n  return binn_value(BINN_UINT8, &value, 0, NULL);\n}",
        "definition_length": 106,
        "comment": ""
      },
      {
        "name": "binn_uint16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "unsigned short value"
        ],
        "is_static": false,
        "start_line": 321,
        "end_line": 323,
        "start_byte": 9738,
        "end_byte": 9847,
        "signature": "ALWAYS_INLINE binn * binn_uint16(unsigned short value)",
        "full_definition": "ALWAYS_INLINE binn * binn_uint16(unsigned short value) {\n  return binn_value(BINN_UINT16, &value, 0, NULL);\n}",
        "definition_length": 109,
        "comment": ""
      },
      {
        "name": "binn_uint32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "unsigned int value"
        ],
        "is_static": false,
        "start_line": 324,
        "end_line": 326,
        "start_byte": 9848,
        "end_byte": 9955,
        "signature": "ALWAYS_INLINE binn * binn_uint32(unsigned int value)",
        "full_definition": "ALWAYS_INLINE binn * binn_uint32(unsigned int value) {\n  return binn_value(BINN_UINT32, &value, 0, NULL);\n}",
        "definition_length": 107,
        "comment": ""
      },
      {
        "name": "binn_uint64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "uint64 value"
        ],
        "is_static": false,
        "start_line": 327,
        "end_line": 329,
        "start_byte": 9956,
        "end_byte": 10057,
        "signature": "ALWAYS_INLINE binn * binn_uint64(uint64 value)",
        "full_definition": "ALWAYS_INLINE binn * binn_uint64(uint64 value) {\n  return binn_value(BINN_UINT64, &value, 0, NULL);\n}",
        "definition_length": 101,
        "comment": ""
      },
      {
        "name": "binn_float",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "float value"
        ],
        "is_static": false,
        "start_line": 330,
        "end_line": 332,
        "start_byte": 10058,
        "end_byte": 10156,
        "signature": "ALWAYS_INLINE binn * binn_float(float value)",
        "full_definition": "ALWAYS_INLINE binn * binn_float(float value) {\n  return binn_value(BINN_FLOAT, &value, 0, NULL);\n}",
        "definition_length": 98,
        "comment": ""
      },
      {
        "name": "binn_double",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "double value"
        ],
        "is_static": false,
        "start_line": 333,
        "end_line": 335,
        "start_byte": 10157,
        "end_byte": 10258,
        "signature": "ALWAYS_INLINE binn * binn_double(double value)",
        "full_definition": "ALWAYS_INLINE binn * binn_double(double value) {\n  return binn_value(BINN_DOUBLE, &value, 0, NULL);\n}",
        "definition_length": 101,
        "comment": ""
      },
      {
        "name": "binn_bool",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "BOOL value"
        ],
        "is_static": false,
        "start_line": 336,
        "end_line": 338,
        "start_byte": 10259,
        "end_byte": 10354,
        "signature": "ALWAYS_INLINE binn * binn_bool(BOOL value)",
        "full_definition": "ALWAYS_INLINE binn * binn_bool(BOOL value) {\n  return binn_value(BINN_BOOL, &value, 0, NULL);\n}",
        "definition_length": 95,
        "comment": ""
      },
      {
        "name": "binn_null",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [],
        "is_static": false,
        "start_line": 339,
        "end_line": 341,
        "start_byte": 10355,
        "end_byte": 10438,
        "signature": "ALWAYS_INLINE binn * binn_null()",
        "full_definition": "ALWAYS_INLINE binn * binn_null() {\n  return binn_value(BINN_NULL, NULL, 0, NULL);\n}",
        "definition_length": 83,
        "comment": ""
      },
      {
        "name": "binn_string",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "char *str",
          "binn_mem_free freefn"
        ],
        "is_static": false,
        "start_line": 342,
        "end_line": 344,
        "start_byte": 10439,
        "end_byte": 10558,
        "signature": "ALWAYS_INLINE binn * binn_string(char *str, binn_mem_free freefn)",
        "full_definition": "ALWAYS_INLINE binn * binn_string(char *str, binn_mem_free freefn) {\n  return binn_value(BINN_STRING, str, 0, freefn);\n}",
        "definition_length": 119,
        "comment": ""
      },
      {
        "name": "binn_blob",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "void *ptr",
          "int size",
          "binn_mem_free freefn"
        ],
        "is_static": false,
        "start_line": 345,
        "end_line": 347,
        "start_byte": 10559,
        "end_byte": 10687,
        "signature": "ALWAYS_INLINE binn * binn_blob(void *ptr, int size, binn_mem_free freefn)",
        "full_definition": "ALWAYS_INLINE binn * binn_blob(void *ptr, int size, binn_mem_free freefn) {\n  return binn_value(BINN_BLOB, ptr, size, freefn);\n}",
        "definition_length": 128,
        "comment": ""
      },
      {
        "name": "binn_ptr",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *ptr"
        ],
        "start_line": 353,
        "end_line": 353,
        "start_byte": 10863,
        "end_byte": 10905,
        "full_declaration": "void * APIENTRY binn_ptr(const void *ptr);",
        "declaration_length": 42,
        "comment": "--- READ FUNCTIONS  ------------------------------------------------------------- these functions accept pointer to the binn structure and pointer to the binn buffer"
      },
      {
        "name": "binn_size",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "const void *ptr"
        ],
        "start_line": 354,
        "end_line": 354,
        "start_byte": 10906,
        "end_byte": 10949,
        "full_declaration": "int    APIENTRY binn_size(const void *ptr);",
        "declaration_length": 43,
        "comment": "these functions accept pointer to the binn structure and pointer to the binn buffer"
      },
      {
        "name": "binn_type",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "const void *ptr"
        ],
        "start_line": 355,
        "end_line": 355,
        "start_byte": 10950,
        "end_byte": 10993,
        "full_declaration": "int    APIENTRY binn_type(const void *ptr);",
        "declaration_length": 43,
        "comment": "these functions accept pointer to the binn structure and pointer to the binn buffer"
      },
      {
        "name": "binn_count",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "const void *ptr"
        ],
        "start_line": 356,
        "end_line": 356,
        "start_byte": 10994,
        "end_byte": 11038,
        "full_declaration": "int    APIENTRY binn_count(const void *ptr);",
        "declaration_length": 44,
        "comment": ""
      },
      {
        "name": "binn_is_valid",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int *ptype",
          "int *pcount",
          "int *psize"
        ],
        "start_line": 358,
        "end_line": 358,
        "start_byte": 11040,
        "end_byte": 11124,
        "full_declaration": "BOOL   APIENTRY binn_is_valid(const void *ptr, int *ptype, int *pcount, int *psize);",
        "declaration_length": 84,
        "comment": ""
      },
      {
        "name": "binn_is_valid_ex",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr",
          "int *ptype",
          "int *pcount",
          "int *psize"
        ],
        "start_line": 365,
        "end_line": 365,
        "start_byte": 11357,
        "end_byte": 11444,
        "full_declaration": "BOOL   APIENTRY binn_is_valid_ex(const void *ptr, int *ptype, int *pcount, int *psize);",
        "declaration_length": 87,
        "comment": "the function returns the values (type, count and size) and they don't need to be\n   initialized. these values are read from the buffer. example:\n\n   int type, count, size;\n   result = binn_is_valid(ptr, &type, &count, &size);"
      },
      {
        "name": "binn_is_struct",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *ptr"
        ],
        "start_line": 374,
        "end_line": 374,
        "start_byte": 11771,
        "end_byte": 11819,
        "full_declaration": "BOOL   APIENTRY binn_is_struct(const void *ptr);",
        "declaration_length": 48,
        "comment": "if some value is informed (type, count or size) then the function will check if \n   the value returned from the serialized data matches the informed value. otherwise\n   the values must be initialized to zero. example:\n\n   int type=0, count=0, size = known_size;\n   result = binn_is_valid_ex(ptr, &type, &count, &size);"
      },
      {
        "name": "binn_load",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *data",
          "binn *item"
        ],
        "start_line": 381,
        "end_line": 381,
        "start_byte": 12047,
        "end_byte": 12103,
        "full_declaration": "BOOL   APIENTRY binn_load(const void *data, binn *item);",
        "declaration_length": 56,
        "comment": "allocated - unsecure allocated - secure"
      },
      {
        "name": "binn_load_ex",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *data",
          "int size",
          "binn *value"
        ],
        "start_line": 382,
        "end_line": 382,
        "start_byte": 12128,
        "end_byte": 12198,
        "full_declaration": "BOOL   APIENTRY binn_load_ex(const void *data, int size, binn *value);",
        "declaration_length": 70,
        "comment": "allocated - unsecure allocated - secure on stack - unsecure"
      },
      {
        "name": "binn_list_int8",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 387,
        "end_line": 387,
        "start_byte": 12279,
        "end_byte": 12345,
        "full_declaration": "signed char    APIENTRY binn_list_int8(const void *list, int pos);",
        "declaration_length": 66,
        "comment": "easiest interface to use, but don't check if the value is there"
      },
      {
        "name": "binn_list_int16",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 388,
        "end_line": 388,
        "start_byte": 12346,
        "end_byte": 12413,
        "full_declaration": "short          APIENTRY binn_list_int16(const void *list, int pos);",
        "declaration_length": 67,
        "comment": "easiest interface to use, but don't check if the value is there"
      },
      {
        "name": "binn_list_int32",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 389,
        "end_line": 389,
        "start_byte": 12414,
        "end_byte": 12481,
        "full_declaration": "int            APIENTRY binn_list_int32(const void *list, int pos);",
        "declaration_length": 67,
        "comment": ""
      },
      {
        "name": "binn_list_int64",
        "type": "declaration",
        "return_type": "int64",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 390,
        "end_line": 390,
        "start_byte": 12482,
        "end_byte": 12549,
        "full_declaration": "int64          APIENTRY binn_list_int64(const void *list, int pos);",
        "declaration_length": 67,
        "comment": ""
      },
      {
        "name": "binn_list_uint8",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 391,
        "end_line": 391,
        "start_byte": 12550,
        "end_byte": 12617,
        "full_declaration": "unsigned char  APIENTRY binn_list_uint8(const void *list, int pos);",
        "declaration_length": 67,
        "comment": ""
      },
      {
        "name": "binn_list_uint16",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 392,
        "end_line": 392,
        "start_byte": 12618,
        "end_byte": 12686,
        "full_declaration": "unsigned short APIENTRY binn_list_uint16(const void *list, int pos);",
        "declaration_length": 68,
        "comment": ""
      },
      {
        "name": "binn_list_uint32",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 393,
        "end_line": 393,
        "start_byte": 12687,
        "end_byte": 12755,
        "full_declaration": "unsigned int   APIENTRY binn_list_uint32(const void *list, int pos);",
        "declaration_length": 68,
        "comment": ""
      },
      {
        "name": "binn_list_uint64",
        "type": "declaration",
        "return_type": "uint64",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 394,
        "end_line": 394,
        "start_byte": 12756,
        "end_byte": 12824,
        "full_declaration": "uint64         APIENTRY binn_list_uint64(const void *list, int pos);",
        "declaration_length": 68,
        "comment": ""
      },
      {
        "name": "binn_list_float",
        "type": "declaration",
        "return_type": "float",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 395,
        "end_line": 395,
        "start_byte": 12825,
        "end_byte": 12892,
        "full_declaration": "float          APIENTRY binn_list_float(const void *list, int pos);",
        "declaration_length": 67,
        "comment": ""
      },
      {
        "name": "binn_list_double",
        "type": "declaration",
        "return_type": "double",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 396,
        "end_line": 396,
        "start_byte": 12893,
        "end_byte": 12961,
        "full_declaration": "double         APIENTRY binn_list_double(const void *list, int pos);",
        "declaration_length": 68,
        "comment": ""
      },
      {
        "name": "binn_list_bool",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 397,
        "end_line": 397,
        "start_byte": 12962,
        "end_byte": 13028,
        "full_declaration": "BOOL           APIENTRY binn_list_bool(const void *list, int pos);",
        "declaration_length": 66,
        "comment": ""
      },
      {
        "name": "binn_list_null",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 398,
        "end_line": 398,
        "start_byte": 13029,
        "end_byte": 13095,
        "full_declaration": "BOOL           APIENTRY binn_list_null(const void *list, int pos);",
        "declaration_length": 66,
        "comment": ""
      },
      {
        "name": "binn_list_str",
        "type": "declaration",
        "return_type": "char",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 399,
        "end_line": 399,
        "start_byte": 13096,
        "end_byte": 13161,
        "full_declaration": "char *         APIENTRY binn_list_str(const void *list, int pos);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "binn_list_blob",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos",
          "int *psize"
        ],
        "start_line": 400,
        "end_line": 400,
        "start_byte": 13162,
        "end_byte": 13240,
        "full_declaration": "void *         APIENTRY binn_list_blob(const void *list, int pos, int *psize);",
        "declaration_length": 78,
        "comment": ""
      },
      {
        "name": "binn_list_list",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 401,
        "end_line": 401,
        "start_byte": 13241,
        "end_byte": 13307,
        "full_declaration": "void *         APIENTRY binn_list_list(const void *list, int pos);",
        "declaration_length": 66,
        "comment": ""
      },
      {
        "name": "binn_list_map",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 402,
        "end_line": 402,
        "start_byte": 13308,
        "end_byte": 13373,
        "full_declaration": "void *         APIENTRY binn_list_map(const void *list, int pos);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "binn_list_object",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos"
        ],
        "start_line": 403,
        "end_line": 403,
        "start_byte": 13374,
        "end_byte": 13442,
        "full_declaration": "void *         APIENTRY binn_list_object(const void *list, int pos);",
        "declaration_length": 68,
        "comment": ""
      },
      {
        "name": "binn_map_int8",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 405,
        "end_line": 405,
        "start_byte": 13444,
        "end_byte": 13507,
        "full_declaration": "signed char    APIENTRY binn_map_int8(const void *map, int id);",
        "declaration_length": 63,
        "comment": ""
      },
      {
        "name": "binn_map_int16",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 406,
        "end_line": 406,
        "start_byte": 13508,
        "end_byte": 13572,
        "full_declaration": "short          APIENTRY binn_map_int16(const void *map, int id);",
        "declaration_length": 64,
        "comment": ""
      },
      {
        "name": "binn_map_int32",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 407,
        "end_line": 407,
        "start_byte": 13573,
        "end_byte": 13637,
        "full_declaration": "int            APIENTRY binn_map_int32(const void *map, int id);",
        "declaration_length": 64,
        "comment": ""
      },
      {
        "name": "binn_map_int64",
        "type": "declaration",
        "return_type": "int64",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 408,
        "end_line": 408,
        "start_byte": 13638,
        "end_byte": 13702,
        "full_declaration": "int64          APIENTRY binn_map_int64(const void *map, int id);",
        "declaration_length": 64,
        "comment": ""
      },
      {
        "name": "binn_map_uint8",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 409,
        "end_line": 409,
        "start_byte": 13703,
        "end_byte": 13767,
        "full_declaration": "unsigned char  APIENTRY binn_map_uint8(const void *map, int id);",
        "declaration_length": 64,
        "comment": ""
      },
      {
        "name": "binn_map_uint16",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 410,
        "end_line": 410,
        "start_byte": 13768,
        "end_byte": 13833,
        "full_declaration": "unsigned short APIENTRY binn_map_uint16(const void *map, int id);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "binn_map_uint32",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 411,
        "end_line": 411,
        "start_byte": 13834,
        "end_byte": 13899,
        "full_declaration": "unsigned int   APIENTRY binn_map_uint32(const void *map, int id);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "binn_map_uint64",
        "type": "declaration",
        "return_type": "uint64",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 412,
        "end_line": 412,
        "start_byte": 13900,
        "end_byte": 13965,
        "full_declaration": "uint64         APIENTRY binn_map_uint64(const void *map, int id);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "binn_map_float",
        "type": "declaration",
        "return_type": "float",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 413,
        "end_line": 413,
        "start_byte": 13966,
        "end_byte": 14030,
        "full_declaration": "float          APIENTRY binn_map_float(const void *map, int id);",
        "declaration_length": 64,
        "comment": ""
      },
      {
        "name": "binn_map_double",
        "type": "declaration",
        "return_type": "double",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 414,
        "end_line": 414,
        "start_byte": 14031,
        "end_byte": 14096,
        "full_declaration": "double         APIENTRY binn_map_double(const void *map, int id);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "binn_map_bool",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 415,
        "end_line": 415,
        "start_byte": 14097,
        "end_byte": 14160,
        "full_declaration": "BOOL           APIENTRY binn_map_bool(const void *map, int id);",
        "declaration_length": 63,
        "comment": ""
      },
      {
        "name": "binn_map_null",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 416,
        "end_line": 416,
        "start_byte": 14161,
        "end_byte": 14224,
        "full_declaration": "BOOL           APIENTRY binn_map_null(const void *map, int id);",
        "declaration_length": 63,
        "comment": ""
      },
      {
        "name": "binn_map_str",
        "type": "declaration",
        "return_type": "char",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 417,
        "end_line": 417,
        "start_byte": 14225,
        "end_byte": 14287,
        "full_declaration": "char *         APIENTRY binn_map_str(const void *map, int id);",
        "declaration_length": 62,
        "comment": ""
      },
      {
        "name": "binn_map_blob",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id",
          "int *psize"
        ],
        "start_line": 418,
        "end_line": 418,
        "start_byte": 14288,
        "end_byte": 14363,
        "full_declaration": "void *         APIENTRY binn_map_blob(const void *map, int id, int *psize);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "binn_map_list",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 419,
        "end_line": 419,
        "start_byte": 14364,
        "end_byte": 14427,
        "full_declaration": "void *         APIENTRY binn_map_list(const void *map, int id);",
        "declaration_length": 63,
        "comment": ""
      },
      {
        "name": "binn_map_map",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 420,
        "end_line": 420,
        "start_byte": 14428,
        "end_byte": 14490,
        "full_declaration": "void *         APIENTRY binn_map_map(const void *map, int id);",
        "declaration_length": 62,
        "comment": ""
      },
      {
        "name": "binn_map_object",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id"
        ],
        "start_line": 421,
        "end_line": 421,
        "start_byte": 14491,
        "end_byte": 14556,
        "full_declaration": "void *         APIENTRY binn_map_object(const void *map, int id);",
        "declaration_length": 65,
        "comment": ""
      },
      {
        "name": "binn_object_int8",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 423,
        "end_line": 423,
        "start_byte": 14558,
        "end_byte": 14633,
        "full_declaration": "signed char    APIENTRY binn_object_int8(const void *obj, const char *key);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "binn_object_int16",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 424,
        "end_line": 424,
        "start_byte": 14634,
        "end_byte": 14710,
        "full_declaration": "short          APIENTRY binn_object_int16(const void *obj, const char *key);",
        "declaration_length": 76,
        "comment": ""
      },
      {
        "name": "binn_object_int32",
        "type": "declaration",
        "return_type": "int",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 425,
        "end_line": 425,
        "start_byte": 14711,
        "end_byte": 14787,
        "full_declaration": "int            APIENTRY binn_object_int32(const void *obj, const char *key);",
        "declaration_length": 76,
        "comment": ""
      },
      {
        "name": "binn_object_int64",
        "type": "declaration",
        "return_type": "int64",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 426,
        "end_line": 426,
        "start_byte": 14788,
        "end_byte": 14864,
        "full_declaration": "int64          APIENTRY binn_object_int64(const void *obj, const char *key);",
        "declaration_length": 76,
        "comment": ""
      },
      {
        "name": "binn_object_uint8",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 427,
        "end_line": 427,
        "start_byte": 14865,
        "end_byte": 14941,
        "full_declaration": "unsigned char  APIENTRY binn_object_uint8(const void *obj, const char *key);",
        "declaration_length": 76,
        "comment": ""
      },
      {
        "name": "binn_object_uint16",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 428,
        "end_line": 428,
        "start_byte": 14942,
        "end_byte": 15019,
        "full_declaration": "unsigned short APIENTRY binn_object_uint16(const void *obj, const char *key);",
        "declaration_length": 77,
        "comment": ""
      },
      {
        "name": "binn_object_uint32",
        "type": "declaration",
        "return_type": "",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 429,
        "end_line": 429,
        "start_byte": 15020,
        "end_byte": 15097,
        "full_declaration": "unsigned int   APIENTRY binn_object_uint32(const void *obj, const char *key);",
        "declaration_length": 77,
        "comment": ""
      },
      {
        "name": "binn_object_uint64",
        "type": "declaration",
        "return_type": "uint64",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 430,
        "end_line": 430,
        "start_byte": 15098,
        "end_byte": 15175,
        "full_declaration": "uint64         APIENTRY binn_object_uint64(const void *obj, const char *key);",
        "declaration_length": 77,
        "comment": ""
      },
      {
        "name": "binn_object_float",
        "type": "declaration",
        "return_type": "float",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 431,
        "end_line": 431,
        "start_byte": 15176,
        "end_byte": 15252,
        "full_declaration": "float          APIENTRY binn_object_float(const void *obj, const char *key);",
        "declaration_length": 76,
        "comment": ""
      },
      {
        "name": "binn_object_double",
        "type": "declaration",
        "return_type": "double",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 432,
        "end_line": 432,
        "start_byte": 15253,
        "end_byte": 15330,
        "full_declaration": "double         APIENTRY binn_object_double(const void *obj, const char *key);",
        "declaration_length": 77,
        "comment": ""
      },
      {
        "name": "binn_object_bool",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 433,
        "end_line": 433,
        "start_byte": 15331,
        "end_byte": 15406,
        "full_declaration": "BOOL           APIENTRY binn_object_bool(const void *obj, const char *key);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "binn_object_null",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 434,
        "end_line": 434,
        "start_byte": 15407,
        "end_byte": 15482,
        "full_declaration": "BOOL           APIENTRY binn_object_null(const void *obj, const char *key);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "binn_object_str",
        "type": "declaration",
        "return_type": "char",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 435,
        "end_line": 435,
        "start_byte": 15483,
        "end_byte": 15557,
        "full_declaration": "char *         APIENTRY binn_object_str(const void *obj, const char *key);",
        "declaration_length": 74,
        "comment": ""
      },
      {
        "name": "binn_object_blob",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key",
          "int *psize"
        ],
        "start_line": 436,
        "end_line": 436,
        "start_byte": 15558,
        "end_byte": 15645,
        "full_declaration": "void *         APIENTRY binn_object_blob(const void *obj, const char *key, int *psize);",
        "declaration_length": 87,
        "comment": ""
      },
      {
        "name": "binn_object_list",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 437,
        "end_line": 437,
        "start_byte": 15646,
        "end_byte": 15721,
        "full_declaration": "void *         APIENTRY binn_object_list(const void *obj, const char *key);",
        "declaration_length": 75,
        "comment": ""
      },
      {
        "name": "binn_object_map",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 438,
        "end_line": 438,
        "start_byte": 15722,
        "end_byte": 15796,
        "full_declaration": "void *         APIENTRY binn_object_map(const void *obj, const char *key);",
        "declaration_length": 74,
        "comment": ""
      },
      {
        "name": "binn_object_object",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key"
        ],
        "start_line": 439,
        "end_line": 439,
        "start_byte": 15797,
        "end_byte": 15874,
        "full_declaration": "void *         APIENTRY binn_object_object(const void *obj, const char *key);",
        "declaration_length": 77,
        "comment": ""
      },
      {
        "name": "binn_list_get_value",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *list",
          "int pos",
          "binn *value"
        ],
        "start_line": 448,
        "end_line": 448,
        "start_byte": 16258,
        "end_byte": 16332,
        "full_declaration": "BOOL APIENTRY binn_list_get_value(const void *list, int pos, binn *value);",
        "declaration_length": 74,
        "comment": "read the value to a binn structure on the stack"
      },
      {
        "name": "binn_map_get_value",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *map",
          "int id",
          "binn *value"
        ],
        "start_line": 449,
        "end_line": 449,
        "start_byte": 16333,
        "end_byte": 16404,
        "full_declaration": "BOOL APIENTRY binn_map_get_value(const void *map, int id, binn *value);",
        "declaration_length": 71,
        "comment": "read the value to a binn structure on the stack"
      },
      {
        "name": "binn_object_get_value",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *obj",
          "const char *key",
          "binn *value"
        ],
        "start_line": 450,
        "end_line": 450,
        "start_byte": 16405,
        "end_byte": 16488,
        "full_declaration": "BOOL APIENTRY binn_object_get_value(const void *obj, const char *key, binn *value);",
        "declaration_length": 83,
        "comment": "read the value to a binn structure on the stack"
      },
      {
        "name": "binn_list_get",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *list",
          "int pos",
          "int type",
          "void *pvalue",
          "int *psize"
        ],
        "start_line": 453,
        "end_line": 453,
        "start_byte": 16548,
        "end_byte": 16639,
        "full_declaration": "BOOL APIENTRY binn_list_get(const void *list, int pos, int type, void *pvalue, int *psize);",
        "declaration_length": 91,
        "comment": "single interface - these functions check the data type"
      },
      {
        "name": "binn_map_get",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *map",
          "int id",
          "int type",
          "void *pvalue",
          "int *psize"
        ],
        "start_line": 454,
        "end_line": 454,
        "start_byte": 16640,
        "end_byte": 16728,
        "full_declaration": "BOOL APIENTRY binn_map_get(const void *map, int id, int type, void *pvalue, int *psize);",
        "declaration_length": 88,
        "comment": "single interface - these functions check the data type"
      },
      {
        "name": "binn_object_get",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *obj",
          "const char *key",
          "int type",
          "void *pvalue",
          "int *psize"
        ],
        "start_line": 455,
        "end_line": 455,
        "start_byte": 16729,
        "end_byte": 16829,
        "full_declaration": "BOOL APIENTRY binn_object_get(const void *obj, const char *key, int type, void *pvalue, int *psize);",
        "declaration_length": 100,
        "comment": "single interface - these functions check the data type"
      },
      {
        "name": "binn_list_read",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *list",
          "int pos",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 461,
        "end_line": 461,
        "start_byte": 17161,
        "end_byte": 17243,
        "full_declaration": "void * APIENTRY binn_list_read(const void *list, int pos, int *ptype, int *psize);",
        "declaration_length": 82,
        "comment": "they are thread-safe on big-endian devices on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_map_read",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *map",
          "int id",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 462,
        "end_line": 462,
        "start_byte": 17244,
        "end_byte": 17323,
        "full_declaration": "void * APIENTRY binn_map_read(const void *map, int id, int *ptype, int *psize);",
        "declaration_length": 79,
        "comment": "on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_object_read",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *obj",
          "const char *key",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 463,
        "end_line": 463,
        "start_byte": 17324,
        "end_byte": 17415,
        "full_declaration": "void * APIENTRY binn_object_read(const void *obj, const char *key, int *ptype, int *psize);",
        "declaration_length": 91,
        "comment": "the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_map_get_pair",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *map",
          "int pos",
          "int *pid",
          "binn *value"
        ],
        "start_line": 471,
        "end_line": 471,
        "start_byte": 17507,
        "end_byte": 17588,
        "full_declaration": "BOOL APIENTRY binn_map_get_pair(const void *map, int pos, int *pid, binn *value);",
        "declaration_length": 81,
        "comment": "these functions use base 1 in the 'pos' argument on stack"
      },
      {
        "name": "binn_object_get_pair",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "const void *obj",
          "int pos",
          "char *pkey",
          "binn *value"
        ],
        "start_line": 472,
        "end_line": 472,
        "start_byte": 17589,
        "end_byte": 17675,
        "full_declaration": "BOOL APIENTRY binn_object_get_pair(const void *obj, int pos, char *pkey, binn *value);",
        "declaration_length": 86,
        "comment": "on stack"
      },
      {
        "name": "binn_map_read_pair",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *ptr",
          "int pos",
          "int *pid",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 482,
        "end_line": 482,
        "start_byte": 18256,
        "end_byte": 18351,
        "full_declaration": "void * APIENTRY binn_map_read_pair(const void *ptr, int pos, int *pid, int *ptype, int *psize);",
        "declaration_length": 95,
        "comment": "they are thread-safe on big-endian devices on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_object_read_pair",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "const void *ptr",
          "int pos",
          "char *pkey",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 483,
        "end_line": 483,
        "start_byte": 18352,
        "end_byte": 18452,
        "full_declaration": "void * APIENTRY binn_object_read_pair(const void *ptr, int pos, char *pkey, int *ptype, int *psize);",
        "declaration_length": 100,
        "comment": "on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_iter_init",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "const void *pbuf",
          "int type"
        ],
        "start_line": 496,
        "end_line": 496,
        "start_byte": 18638,
        "end_byte": 18714,
        "full_declaration": "BOOL   APIENTRY binn_iter_init(binn_iter *iter, const void *pbuf, int type);",
        "declaration_length": 76,
        "comment": ""
      },
      {
        "name": "binn_list_next",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "binn *value"
        ],
        "start_line": 504,
        "end_line": 504,
        "start_byte": 18978,
        "end_byte": 19039,
        "full_declaration": "BOOL   APIENTRY binn_list_next(binn_iter *iter, binn *value);",
        "declaration_length": 61,
        "comment": "the key must be declared as: char key[256]; on stack"
      },
      {
        "name": "binn_map_next",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "int *pid",
          "binn *value"
        ],
        "start_line": 505,
        "end_line": 505,
        "start_byte": 19040,
        "end_byte": 19110,
        "full_declaration": "BOOL   APIENTRY binn_map_next(binn_iter *iter, int *pid, binn *value);",
        "declaration_length": 70,
        "comment": "on stack"
      },
      {
        "name": "binn_object_next",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn_iter *iter",
          "char *pkey",
          "binn *value"
        ],
        "start_line": 506,
        "end_line": 506,
        "start_byte": 19111,
        "end_byte": 19186,
        "full_declaration": "BOOL   APIENTRY binn_object_next(binn_iter *iter, char *pkey, binn *value);",
        "declaration_length": 75,
        "comment": "on stack"
      },
      {
        "name": "binn_list_read_next",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "binn_iter *iter",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 512,
        "end_line": 512,
        "start_byte": 19566,
        "end_byte": 19643,
        "full_declaration": "void * APIENTRY binn_list_read_next(binn_iter *iter, int *ptype, int *psize);",
        "declaration_length": 77,
        "comment": "they are thread-safe on big-endian devices on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_map_read_next",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "binn_iter *iter",
          "int *pid",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 513,
        "end_line": 513,
        "start_byte": 19644,
        "end_byte": 19730,
        "full_declaration": "void * APIENTRY binn_map_read_next(binn_iter *iter, int *pid, int *ptype, int *psize);",
        "declaration_length": 86,
        "comment": "on little-endian devices they are thread-safe only to return pointers to list, map, object, blob and strings the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_object_read_next",
        "type": "declaration",
        "return_type": "void",
        "parameters": [
          "binn_iter *iter",
          "char *pkey",
          "int *ptype",
          "int *psize"
        ],
        "start_line": 514,
        "end_line": 514,
        "start_byte": 19731,
        "end_byte": 19822,
        "full_declaration": "void * APIENTRY binn_object_read_next(binn_iter *iter, char *pkey, int *ptype, int *psize);",
        "declaration_length": 91,
        "comment": "the returned pointer to 16, 32 and 64 bits values must be used only by single-threaded applications"
      },
      {
        "name": "binn_set_string",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *item",
          "char *str",
          "binn_mem_free pfree"
        ],
        "start_line": 540,
        "end_line": 540,
        "start_byte": 21389,
        "end_byte": 21463,
        "full_declaration": "BOOL APIENTRY binn_set_string(binn *item, char *str, binn_mem_free pfree);",
        "declaration_length": 74,
        "comment": "#define binn_set_string(item,str,pfree)    do { (item)->type = BINN_STRING; (item)->ptr = str; (item)->freefn = pfree; } while (0) #define binn_set_blob(item,ptr,size,pfree) do { (item)->type = BINN_BLOB;   (item)->ptr = ptr; (item)->freefn = pfree; (item)->size = size; } while (0)"
      },
      {
        "name": "binn_set_blob",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *item",
          "void *ptr",
          "int size",
          "binn_mem_free pfree"
        ],
        "start_line": 541,
        "end_line": 541,
        "start_byte": 21464,
        "end_byte": 21546,
        "full_declaration": "BOOL APIENTRY binn_set_blob(binn *item, void *ptr, int size, binn_mem_free pfree);",
        "declaration_length": 82,
        "comment": "#define binn_set_string(item,str,pfree)    do { (item)->type = BINN_STRING; (item)->ptr = str; (item)->freefn = pfree; } while (0) #define binn_set_blob(item,ptr,size,pfree) do { (item)->type = BINN_BLOB;   (item)->ptr = ptr; (item)->freefn = pfree; (item)->size = size; } while (0)"
      },
      {
        "name": "binn_list_add_int8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "signed char value"
        ],
        "is_static": false,
        "start_line": 593,
        "end_line": 595,
        "start_byte": 23342,
        "end_byte": 23466,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_int8(binn *list, signed char value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_int8(binn *list, signed char value) {\n  return binn_list_add(list, BINN_INT8, &value, 0);\n}",
        "definition_length": 124,
        "comment": "** SET FUNCTIONS ****************************************************************** ***********************************************************************************"
      },
      {
        "name": "binn_list_add_int16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "short value"
        ],
        "is_static": false,
        "start_line": 596,
        "end_line": 598,
        "start_byte": 23467,
        "end_byte": 23587,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_int16(binn *list, short value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_int16(binn *list, short value) {\n  return binn_list_add(list, BINN_INT16, &value, 0);\n}",
        "definition_length": 120,
        "comment": ""
      },
      {
        "name": "binn_list_add_int32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "int value"
        ],
        "is_static": false,
        "start_line": 599,
        "end_line": 601,
        "start_byte": 23588,
        "end_byte": 23706,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_int32(binn *list, int value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_int32(binn *list, int value) {\n  return binn_list_add(list, BINN_INT32, &value, 0);\n}",
        "definition_length": 118,
        "comment": ""
      },
      {
        "name": "binn_list_add_int64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "int64 value"
        ],
        "is_static": false,
        "start_line": 602,
        "end_line": 604,
        "start_byte": 23707,
        "end_byte": 23827,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_int64(binn *list, int64 value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_int64(binn *list, int64 value) {\n  return binn_list_add(list, BINN_INT64, &value, 0);\n}",
        "definition_length": 120,
        "comment": ""
      },
      {
        "name": "binn_list_add_uint8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "unsigned char value"
        ],
        "is_static": false,
        "start_line": 605,
        "end_line": 607,
        "start_byte": 23828,
        "end_byte": 23956,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_uint8(binn *list, unsigned char value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_uint8(binn *list, unsigned char value) {\n  return binn_list_add(list, BINN_UINT8, &value, 0);\n}",
        "definition_length": 128,
        "comment": ""
      },
      {
        "name": "binn_list_add_uint16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "unsigned short value"
        ],
        "is_static": false,
        "start_line": 608,
        "end_line": 610,
        "start_byte": 23957,
        "end_byte": 24088,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_uint16(binn *list, unsigned short value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_uint16(binn *list, unsigned short value) {\n  return binn_list_add(list, BINN_UINT16, &value, 0);\n}",
        "definition_length": 131,
        "comment": ""
      },
      {
        "name": "binn_list_add_uint32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "unsigned int value"
        ],
        "is_static": false,
        "start_line": 611,
        "end_line": 613,
        "start_byte": 24089,
        "end_byte": 24218,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_uint32(binn *list, unsigned int value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_uint32(binn *list, unsigned int value) {\n  return binn_list_add(list, BINN_UINT32, &value, 0);\n}",
        "definition_length": 129,
        "comment": ""
      },
      {
        "name": "binn_list_add_uint64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "uint64 value"
        ],
        "is_static": false,
        "start_line": 614,
        "end_line": 616,
        "start_byte": 24219,
        "end_byte": 24342,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_uint64(binn *list, uint64 value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_uint64(binn *list, uint64 value) {\n  return binn_list_add(list, BINN_UINT64, &value, 0);\n}",
        "definition_length": 123,
        "comment": ""
      },
      {
        "name": "binn_list_add_float",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "float value"
        ],
        "is_static": false,
        "start_line": 617,
        "end_line": 619,
        "start_byte": 24343,
        "end_byte": 24465,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_float(binn *list, float value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_float(binn *list, float value) {\n  return binn_list_add(list, BINN_FLOAT32, &value, 0);\n}",
        "definition_length": 122,
        "comment": ""
      },
      {
        "name": "binn_list_add_double",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "double value"
        ],
        "is_static": false,
        "start_line": 620,
        "end_line": 622,
        "start_byte": 24466,
        "end_byte": 24590,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_double(binn *list, double value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_double(binn *list, double value) {\n  return binn_list_add(list, BINN_FLOAT64, &value, 0);\n}",
        "definition_length": 124,
        "comment": ""
      },
      {
        "name": "binn_list_add_bool",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "BOOL value"
        ],
        "is_static": false,
        "start_line": 623,
        "end_line": 625,
        "start_byte": 24591,
        "end_byte": 24708,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_bool(binn *list, BOOL value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_bool(binn *list, BOOL value) {\n  return binn_list_add(list, BINN_BOOL, &value, 0);\n}",
        "definition_length": 117,
        "comment": ""
      },
      {
        "name": "binn_list_add_null",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list"
        ],
        "is_static": false,
        "start_line": 626,
        "end_line": 628,
        "start_byte": 24709,
        "end_byte": 24812,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_null(binn *list)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_null(binn *list) {\n  return binn_list_add(list, BINN_NULL, NULL, 0);\n}",
        "definition_length": 103,
        "comment": ""
      },
      {
        "name": "binn_list_add_str",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "char *str"
        ],
        "is_static": false,
        "start_line": 629,
        "end_line": 631,
        "start_byte": 24813,
        "end_byte": 24927,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_str(binn *list, char *str)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_str(binn *list, char *str) {\n  return binn_list_add(list, BINN_STRING, str, 0);\n}",
        "definition_length": 114,
        "comment": ""
      },
      {
        "name": "binn_list_add_blob",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "void *ptr",
          "int size"
        ],
        "is_static": false,
        "start_line": 632,
        "end_line": 634,
        "start_byte": 24928,
        "end_byte": 25054,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_blob(binn *list, void *ptr, int size)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_blob(binn *list, void *ptr, int size) {\n  return binn_list_add(list, BINN_BLOB, ptr, size);\n}",
        "definition_length": 126,
        "comment": ""
      },
      {
        "name": "binn_list_add_list",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "void *list2"
        ],
        "is_static": false,
        "start_line": 635,
        "end_line": 637,
        "start_byte": 25055,
        "end_byte": 25197,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_list(binn *list, void *list2)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_list(binn *list, void *list2) {\n  return binn_list_add(list, BINN_LIST, binn_ptr(list2), binn_size(list2));\n}",
        "definition_length": 142,
        "comment": ""
      },
      {
        "name": "binn_list_add_map",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "void *map"
        ],
        "is_static": false,
        "start_line": 638,
        "end_line": 640,
        "start_byte": 25198,
        "end_byte": 25332,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_map(binn *list, void *map)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_map(binn *list, void *map) {\n  return binn_list_add(list, BINN_MAP, binn_ptr(map), binn_size(map));\n}",
        "definition_length": 134,
        "comment": ""
      },
      {
        "name": "binn_list_add_object",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "void *obj"
        ],
        "is_static": false,
        "start_line": 641,
        "end_line": 643,
        "start_byte": 25333,
        "end_byte": 25473,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_object(binn *list, void *obj)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_object(binn *list, void *obj) {\n  return binn_list_add(list, BINN_OBJECT, binn_ptr(obj), binn_size(obj));\n}",
        "definition_length": 140,
        "comment": ""
      },
      {
        "name": "binn_list_add_value",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *list",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 644,
        "end_line": 646,
        "start_byte": 25474,
        "end_byte": 25619,
        "signature": "ALWAYS_INLINE BOOL binn_list_add_value(binn *list, binn *value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_add_value(binn *list, binn *value) {\n  return binn_list_add(list, value->type, binn_ptr(value), binn_size(value));\n}",
        "definition_length": 145,
        "comment": ""
      },
      {
        "name": "binn_map_set_int8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "signed char value"
        ],
        "is_static": false,
        "start_line": 650,
        "end_line": 652,
        "start_byte": 25710,
        "end_byte": 25842,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_int8(binn *map, int id, signed char value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_int8(binn *map, int id, signed char value) {\n  return binn_map_set(map, id, BINN_INT8, &value, 0);\n}",
        "definition_length": 132,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_map_set_int16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "short value"
        ],
        "is_static": false,
        "start_line": 653,
        "end_line": 655,
        "start_byte": 25843,
        "end_byte": 25971,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_int16(binn *map, int id, short value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_int16(binn *map, int id, short value) {\n  return binn_map_set(map, id, BINN_INT16, &value, 0);\n}",
        "definition_length": 128,
        "comment": ""
      },
      {
        "name": "binn_map_set_int32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "int value"
        ],
        "is_static": false,
        "start_line": 656,
        "end_line": 658,
        "start_byte": 25972,
        "end_byte": 26098,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_int32(binn *map, int id, int value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_int32(binn *map, int id, int value) {\n  return binn_map_set(map, id, BINN_INT32, &value, 0);\n}",
        "definition_length": 126,
        "comment": ""
      },
      {
        "name": "binn_map_set_int64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "int64 value"
        ],
        "is_static": false,
        "start_line": 659,
        "end_line": 661,
        "start_byte": 26099,
        "end_byte": 26227,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_int64(binn *map, int id, int64 value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_int64(binn *map, int id, int64 value) {\n  return binn_map_set(map, id, BINN_INT64, &value, 0);\n}",
        "definition_length": 128,
        "comment": ""
      },
      {
        "name": "binn_map_set_uint8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "unsigned char value"
        ],
        "is_static": false,
        "start_line": 662,
        "end_line": 664,
        "start_byte": 26228,
        "end_byte": 26364,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_uint8(binn *map, int id, unsigned char value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_uint8(binn *map, int id, unsigned char value) {\n  return binn_map_set(map, id, BINN_UINT8, &value, 0);\n}",
        "definition_length": 136,
        "comment": ""
      },
      {
        "name": "binn_map_set_uint16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "unsigned short value"
        ],
        "is_static": false,
        "start_line": 665,
        "end_line": 667,
        "start_byte": 26365,
        "end_byte": 26504,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_uint16(binn *map, int id, unsigned short value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_uint16(binn *map, int id, unsigned short value) {\n  return binn_map_set(map, id, BINN_UINT16, &value, 0);\n}",
        "definition_length": 139,
        "comment": ""
      },
      {
        "name": "binn_map_set_uint32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "unsigned int value"
        ],
        "is_static": false,
        "start_line": 668,
        "end_line": 670,
        "start_byte": 26505,
        "end_byte": 26642,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_uint32(binn *map, int id, unsigned int value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_uint32(binn *map, int id, unsigned int value) {\n  return binn_map_set(map, id, BINN_UINT32, &value, 0);\n}",
        "definition_length": 137,
        "comment": ""
      },
      {
        "name": "binn_map_set_uint64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "uint64 value"
        ],
        "is_static": false,
        "start_line": 671,
        "end_line": 673,
        "start_byte": 26643,
        "end_byte": 26774,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_uint64(binn *map, int id, uint64 value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_uint64(binn *map, int id, uint64 value) {\n  return binn_map_set(map, id, BINN_UINT64, &value, 0);\n}",
        "definition_length": 131,
        "comment": ""
      },
      {
        "name": "binn_map_set_float",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "float value"
        ],
        "is_static": false,
        "start_line": 674,
        "end_line": 676,
        "start_byte": 26775,
        "end_byte": 26905,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_float(binn *map, int id, float value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_float(binn *map, int id, float value) {\n  return binn_map_set(map, id, BINN_FLOAT32, &value, 0);\n}",
        "definition_length": 130,
        "comment": ""
      },
      {
        "name": "binn_map_set_double",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "double value"
        ],
        "is_static": false,
        "start_line": 677,
        "end_line": 679,
        "start_byte": 26906,
        "end_byte": 27038,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_double(binn *map, int id, double value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_double(binn *map, int id, double value) {\n  return binn_map_set(map, id, BINN_FLOAT64, &value, 0);\n}",
        "definition_length": 132,
        "comment": ""
      },
      {
        "name": "binn_map_set_bool",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "BOOL value"
        ],
        "is_static": false,
        "start_line": 680,
        "end_line": 682,
        "start_byte": 27039,
        "end_byte": 27164,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_bool(binn *map, int id, BOOL value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_bool(binn *map, int id, BOOL value) {\n  return binn_map_set(map, id, BINN_BOOL, &value, 0);\n}",
        "definition_length": 125,
        "comment": ""
      },
      {
        "name": "binn_map_set_null",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id"
        ],
        "is_static": false,
        "start_line": 683,
        "end_line": 685,
        "start_byte": 27165,
        "end_byte": 27276,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_null(binn *map, int id)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_null(binn *map, int id) {\n  return binn_map_set(map, id, BINN_NULL, NULL, 0);\n}",
        "definition_length": 111,
        "comment": ""
      },
      {
        "name": "binn_map_set_str",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "char *str"
        ],
        "is_static": false,
        "start_line": 686,
        "end_line": 688,
        "start_byte": 27277,
        "end_byte": 27399,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_str(binn *map, int id, char *str)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_str(binn *map, int id, char *str) {\n  return binn_map_set(map, id, BINN_STRING, str, 0);\n}",
        "definition_length": 122,
        "comment": ""
      },
      {
        "name": "binn_map_set_blob",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "void *ptr",
          "int size"
        ],
        "is_static": false,
        "start_line": 689,
        "end_line": 691,
        "start_byte": 27400,
        "end_byte": 27534,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_blob(binn *map, int id, void *ptr, int size) {\n  return binn_map_set(map, id, BINN_BLOB, ptr, size);\n}",
        "definition_length": 134,
        "comment": ""
      },
      {
        "name": "binn_map_set_list",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "void *list"
        ],
        "is_static": false,
        "start_line": 692,
        "end_line": 694,
        "start_byte": 27535,
        "end_byte": 27682,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_list(binn *map, int id, void *list)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_list(binn *map, int id, void *list) {\n  return binn_map_set(map, id, BINN_LIST, binn_ptr(list), binn_size(list));\n}",
        "definition_length": 147,
        "comment": ""
      },
      {
        "name": "binn_map_set_map",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "void *map2"
        ],
        "is_static": false,
        "start_line": 695,
        "end_line": 697,
        "start_byte": 27683,
        "end_byte": 27828,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_map(binn *map, int id, void *map2)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_map(binn *map, int id, void *map2) {\n  return binn_map_set(map, id, BINN_MAP, binn_ptr(map2), binn_size(map2));\n}",
        "definition_length": 145,
        "comment": ""
      },
      {
        "name": "binn_map_set_object",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "void *obj"
        ],
        "is_static": false,
        "start_line": 698,
        "end_line": 700,
        "start_byte": 27829,
        "end_byte": 27977,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_object(binn *map, int id, void *obj)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_object(binn *map, int id, void *obj) {\n  return binn_map_set(map, id, BINN_OBJECT, binn_ptr(obj), binn_size(obj));\n}",
        "definition_length": 148,
        "comment": ""
      },
      {
        "name": "binn_map_set_value",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *map",
          "int id",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 701,
        "end_line": 703,
        "start_byte": 27978,
        "end_byte": 28131,
        "signature": "ALWAYS_INLINE BOOL binn_map_set_value(binn *map, int id, binn *value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_set_value(binn *map, int id, binn *value) {\n  return binn_map_set(map, id, value->type, binn_ptr(value), binn_size(value));\n}",
        "definition_length": 153,
        "comment": ""
      },
      {
        "name": "binn_object_set_int8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "signed char value"
        ],
        "is_static": false,
        "start_line": 707,
        "end_line": 709,
        "start_byte": 28222,
        "end_byte": 28370,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_int8(binn *obj, const char *key, signed char value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_int8(binn *obj, const char *key, signed char value) {\n  return binn_object_set(obj, key, BINN_INT8, &value, 0);\n}",
        "definition_length": 148,
        "comment": "***********************************************************************************"
      },
      {
        "name": "binn_object_set_int16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "short value"
        ],
        "is_static": false,
        "start_line": 710,
        "end_line": 712,
        "start_byte": 28371,
        "end_byte": 28515,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_int16(binn *obj, const char *key, short value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_int16(binn *obj, const char *key, short value) {\n  return binn_object_set(obj, key, BINN_INT16, &value, 0);\n}",
        "definition_length": 144,
        "comment": ""
      },
      {
        "name": "binn_object_set_int32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "int value"
        ],
        "is_static": false,
        "start_line": 713,
        "end_line": 715,
        "start_byte": 28516,
        "end_byte": 28658,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_int32(binn *obj, const char *key, int value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_int32(binn *obj, const char *key, int value) {\n  return binn_object_set(obj, key, BINN_INT32, &value, 0);\n}",
        "definition_length": 142,
        "comment": ""
      },
      {
        "name": "binn_object_set_int64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "int64 value"
        ],
        "is_static": false,
        "start_line": 716,
        "end_line": 718,
        "start_byte": 28659,
        "end_byte": 28803,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_int64(binn *obj, const char *key, int64 value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_int64(binn *obj, const char *key, int64 value) {\n  return binn_object_set(obj, key, BINN_INT64, &value, 0);\n}",
        "definition_length": 144,
        "comment": ""
      },
      {
        "name": "binn_object_set_uint8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "unsigned char value"
        ],
        "is_static": false,
        "start_line": 719,
        "end_line": 721,
        "start_byte": 28804,
        "end_byte": 28956,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_uint8(binn *obj, const char *key, unsigned char value) {\n  return binn_object_set(obj, key, BINN_UINT8, &value, 0);\n}",
        "definition_length": 152,
        "comment": ""
      },
      {
        "name": "binn_object_set_uint16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "unsigned short value"
        ],
        "is_static": false,
        "start_line": 722,
        "end_line": 724,
        "start_byte": 28957,
        "end_byte": 29112,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_uint16(binn *obj, const char *key, unsigned short value) {\n  return binn_object_set(obj, key, BINN_UINT16, &value, 0);\n}",
        "definition_length": 155,
        "comment": ""
      },
      {
        "name": "binn_object_set_uint32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "unsigned int value"
        ],
        "is_static": false,
        "start_line": 725,
        "end_line": 727,
        "start_byte": 29113,
        "end_byte": 29266,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_uint32(binn *obj, const char *key, unsigned int value) {\n  return binn_object_set(obj, key, BINN_UINT32, &value, 0);\n}",
        "definition_length": 153,
        "comment": ""
      },
      {
        "name": "binn_object_set_uint64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "uint64 value"
        ],
        "is_static": false,
        "start_line": 728,
        "end_line": 730,
        "start_byte": 29267,
        "end_byte": 29414,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_uint64(binn *obj, const char *key, uint64 value) {\n  return binn_object_set(obj, key, BINN_UINT64, &value, 0);\n}",
        "definition_length": 147,
        "comment": ""
      },
      {
        "name": "binn_object_set_float",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "float value"
        ],
        "is_static": false,
        "start_line": 731,
        "end_line": 733,
        "start_byte": 29415,
        "end_byte": 29561,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_float(binn *obj, const char *key, float value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_float(binn *obj, const char *key, float value) {\n  return binn_object_set(obj, key, BINN_FLOAT32, &value, 0);\n}",
        "definition_length": 146,
        "comment": ""
      },
      {
        "name": "binn_object_set_double",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "double value"
        ],
        "is_static": false,
        "start_line": 734,
        "end_line": 736,
        "start_byte": 29562,
        "end_byte": 29710,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_double(binn *obj, const char *key, double value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_double(binn *obj, const char *key, double value) {\n  return binn_object_set(obj, key, BINN_FLOAT64, &value, 0);\n}",
        "definition_length": 148,
        "comment": ""
      },
      {
        "name": "binn_object_set_bool",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "BOOL value"
        ],
        "is_static": false,
        "start_line": 737,
        "end_line": 739,
        "start_byte": 29711,
        "end_byte": 29852,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_bool(binn *obj, const char *key, BOOL value) {\n  return binn_object_set(obj, key, BINN_BOOL, &value, 0);\n}",
        "definition_length": 141,
        "comment": ""
      },
      {
        "name": "binn_object_set_null",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key"
        ],
        "is_static": false,
        "start_line": 740,
        "end_line": 742,
        "start_byte": 29853,
        "end_byte": 29980,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_null(binn *obj, const char *key)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_null(binn *obj, const char *key) {\n  return binn_object_set(obj, key, BINN_NULL, NULL, 0);\n}",
        "definition_length": 127,
        "comment": ""
      },
      {
        "name": "binn_object_set_str",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "char *str"
        ],
        "is_static": false,
        "start_line": 743,
        "end_line": 745,
        "start_byte": 29981,
        "end_byte": 30119,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_str(binn *obj, const char *key, char *str)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_str(binn *obj, const char *key, char *str) {\n  return binn_object_set(obj, key, BINN_STRING, str, 0);\n}",
        "definition_length": 138,
        "comment": ""
      },
      {
        "name": "binn_object_set_blob",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "void *ptr",
          "int size"
        ],
        "is_static": false,
        "start_line": 746,
        "end_line": 748,
        "start_byte": 30120,
        "end_byte": 30270,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_blob(binn *obj, const char *key, void *ptr, int size) {\n  return binn_object_set(obj, key, BINN_BLOB, ptr, size);\n}",
        "definition_length": 150,
        "comment": ""
      },
      {
        "name": "binn_object_set_list",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "void *list"
        ],
        "is_static": false,
        "start_line": 749,
        "end_line": 751,
        "start_byte": 30271,
        "end_byte": 30434,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_list(binn *obj, const char *key, void *list)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_list(binn *obj, const char *key, void *list) {\n  return binn_object_set(obj, key, BINN_LIST, binn_ptr(list), binn_size(list));\n}",
        "definition_length": 163,
        "comment": ""
      },
      {
        "name": "binn_object_set_map",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "void *map"
        ],
        "is_static": false,
        "start_line": 752,
        "end_line": 754,
        "start_byte": 30435,
        "end_byte": 30593,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_map(binn *obj, const char *key, void *map)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_map(binn *obj, const char *key, void *map) {\n  return binn_object_set(obj, key, BINN_MAP, binn_ptr(map), binn_size(map));\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "binn_object_set_object",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "void *obj2"
        ],
        "is_static": false,
        "start_line": 755,
        "end_line": 757,
        "start_byte": 30594,
        "end_byte": 30761,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_object(binn *obj, const char *key, void *obj2)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_object(binn *obj, const char *key, void *obj2) {\n  return binn_object_set(obj, key, BINN_OBJECT, binn_ptr(obj2), binn_size(obj2));\n}",
        "definition_length": 167,
        "comment": ""
      },
      {
        "name": "binn_object_set_value",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "binn *obj",
          "const char *key",
          "binn *value"
        ],
        "is_static": false,
        "start_line": 758,
        "end_line": 760,
        "start_byte": 30762,
        "end_byte": 30931,
        "signature": "ALWAYS_INLINE BOOL binn_object_set_value(binn *obj, const char *key, binn *value)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_set_value(binn *obj, const char *key, binn *value) {\n  return binn_object_set(obj, key, value->type, binn_ptr(value), binn_size(value));\n}",
        "definition_length": 169,
        "comment": ""
      },
      {
        "name": "binn_list_get_int8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "signed char *pvalue"
        ],
        "is_static": false,
        "start_line": 766,
        "end_line": 768,
        "start_byte": 31198,
        "end_byte": 31347,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_int8(const void *list, int pos, signed char *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_int8(const void *list, int pos, signed char *pvalue) {\n  return binn_list_get(list, pos, BINN_INT8, pvalue, NULL);\n}",
        "definition_length": 149,
        "comment": "** GET FUNCTIONS ****************************************************************** ***********************************************************************************"
      },
      {
        "name": "binn_list_get_int16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "short *pvalue"
        ],
        "is_static": false,
        "start_line": 769,
        "end_line": 771,
        "start_byte": 31348,
        "end_byte": 31493,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_int16(const void *list, int pos, short *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_int16(const void *list, int pos, short *pvalue) {\n  return binn_list_get(list, pos, BINN_INT16, pvalue, NULL);\n}",
        "definition_length": 145,
        "comment": ""
      },
      {
        "name": "binn_list_get_int32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "int *pvalue"
        ],
        "is_static": false,
        "start_line": 772,
        "end_line": 774,
        "start_byte": 31494,
        "end_byte": 31637,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_int32(const void *list, int pos, int *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_int32(const void *list, int pos, int *pvalue) {\n  return binn_list_get(list, pos, BINN_INT32, pvalue, NULL);\n}",
        "definition_length": 143,
        "comment": ""
      },
      {
        "name": "binn_list_get_int64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "int64 *pvalue"
        ],
        "is_static": false,
        "start_line": 775,
        "end_line": 777,
        "start_byte": 31638,
        "end_byte": 31783,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_int64(const void *list, int pos, int64 *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_int64(const void *list, int pos, int64 *pvalue) {\n  return binn_list_get(list, pos, BINN_INT64, pvalue, NULL);\n}",
        "definition_length": 145,
        "comment": ""
      },
      {
        "name": "binn_list_get_uint8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "unsigned char *pvalue"
        ],
        "is_static": false,
        "start_line": 778,
        "end_line": 780,
        "start_byte": 31784,
        "end_byte": 31937,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_uint8(const void *list, int pos, unsigned char *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_uint8(const void *list, int pos, unsigned char *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT8, pvalue, NULL);\n}",
        "definition_length": 153,
        "comment": ""
      },
      {
        "name": "binn_list_get_uint16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "unsigned short *pvalue"
        ],
        "is_static": false,
        "start_line": 781,
        "end_line": 783,
        "start_byte": 31938,
        "end_byte": 32094,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_uint16(const void *list, int pos, unsigned short *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_uint16(const void *list, int pos, unsigned short *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT16, pvalue, NULL);\n}",
        "definition_length": 156,
        "comment": ""
      },
      {
        "name": "binn_list_get_uint32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "unsigned int *pvalue"
        ],
        "is_static": false,
        "start_line": 784,
        "end_line": 786,
        "start_byte": 32095,
        "end_byte": 32249,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_uint32(const void *list, int pos, unsigned int *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_uint32(const void *list, int pos, unsigned int *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT32, pvalue, NULL);\n}",
        "definition_length": 154,
        "comment": ""
      },
      {
        "name": "binn_list_get_uint64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "uint64 *pvalue"
        ],
        "is_static": false,
        "start_line": 787,
        "end_line": 789,
        "start_byte": 32250,
        "end_byte": 32398,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_uint64(const void *list, int pos, uint64 *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_uint64(const void *list, int pos, uint64 *pvalue) {\n  return binn_list_get(list, pos, BINN_UINT64, pvalue, NULL);\n}",
        "definition_length": 148,
        "comment": ""
      },
      {
        "name": "binn_list_get_float",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "float *pvalue"
        ],
        "is_static": false,
        "start_line": 790,
        "end_line": 792,
        "start_byte": 32399,
        "end_byte": 32546,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_float(const void *list, int pos, float *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_float(const void *list, int pos, float *pvalue) {\n  return binn_list_get(list, pos, BINN_FLOAT32, pvalue, NULL);\n}",
        "definition_length": 147,
        "comment": ""
      },
      {
        "name": "binn_list_get_double",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "double *pvalue"
        ],
        "is_static": false,
        "start_line": 793,
        "end_line": 795,
        "start_byte": 32547,
        "end_byte": 32696,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_double(const void *list, int pos, double *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_double(const void *list, int pos, double *pvalue) {\n  return binn_list_get(list, pos, BINN_FLOAT64, pvalue, NULL);\n}",
        "definition_length": 149,
        "comment": ""
      },
      {
        "name": "binn_list_get_bool",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "BOOL *pvalue"
        ],
        "is_static": false,
        "start_line": 796,
        "end_line": 798,
        "start_byte": 32697,
        "end_byte": 32839,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_bool(const void *list, int pos, BOOL *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_bool(const void *list, int pos, BOOL *pvalue) {\n  return binn_list_get(list, pos, BINN_BOOL, pvalue, NULL);\n}",
        "definition_length": 142,
        "comment": ""
      },
      {
        "name": "binn_list_get_str",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "char **pvalue"
        ],
        "is_static": false,
        "start_line": 799,
        "end_line": 801,
        "start_byte": 32840,
        "end_byte": 32984,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_str(const void *list, int pos, char **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_str(const void *list, int pos, char **pvalue) {\n  return binn_list_get(list, pos, BINN_STRING, pvalue, NULL);\n}",
        "definition_length": 144,
        "comment": ""
      },
      {
        "name": "binn_list_get_blob",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "void **pvalue",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 802,
        "end_line": 804,
        "start_byte": 32985,
        "end_byte": 33141,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_blob(const void *list, int pos, void **pvalue, int *psize)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_blob(const void *list, int pos, void **pvalue, int *psize) {\n  return binn_list_get(list, pos, BINN_BLOB, pvalue, psize);\n}",
        "definition_length": 156,
        "comment": ""
      },
      {
        "name": "binn_list_get_list",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 805,
        "end_line": 807,
        "start_byte": 33142,
        "end_byte": 33285,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_list(const void *list, int pos, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_list(const void *list, int pos, void **pvalue) {\n  return binn_list_get(list, pos, BINN_LIST, pvalue, NULL);\n}",
        "definition_length": 143,
        "comment": ""
      },
      {
        "name": "binn_list_get_map",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 808,
        "end_line": 810,
        "start_byte": 33286,
        "end_byte": 33427,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_map(const void *list, int pos, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_map(const void *list, int pos, void **pvalue) {\n  return binn_list_get(list, pos, BINN_MAP, pvalue, NULL);\n}",
        "definition_length": 141,
        "comment": ""
      },
      {
        "name": "binn_list_get_object",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *list",
          "int pos",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 811,
        "end_line": 813,
        "start_byte": 33428,
        "end_byte": 33575,
        "signature": "ALWAYS_INLINE BOOL binn_list_get_object(const void *list, int pos, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_list_get_object(const void *list, int pos, void **pvalue) {\n  return binn_list_get(list, pos, BINN_OBJECT, pvalue, NULL);\n}",
        "definition_length": 147,
        "comment": ""
      },
      {
        "name": "binn_map_get_int8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "signed char *pvalue"
        ],
        "is_static": false,
        "start_line": 817,
        "end_line": 819,
        "start_byte": 33656,
        "end_byte": 33799,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_int8(const void *map, int id, signed char *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_int8(const void *map, int id, signed char *pvalue) {\n  return binn_map_get(map, id, BINN_INT8, pvalue, NULL);\n}",
        "definition_length": 143,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_map_get_int16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "short *pvalue"
        ],
        "is_static": false,
        "start_line": 820,
        "end_line": 822,
        "start_byte": 33800,
        "end_byte": 33939,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_int16(const void *map, int id, short *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_int16(const void *map, int id, short *pvalue) {\n  return binn_map_get(map, id, BINN_INT16, pvalue, NULL);\n}",
        "definition_length": 139,
        "comment": ""
      },
      {
        "name": "binn_map_get_int32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "int *pvalue"
        ],
        "is_static": false,
        "start_line": 823,
        "end_line": 825,
        "start_byte": 33940,
        "end_byte": 34077,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_int32(const void *map, int id, int *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_int32(const void *map, int id, int *pvalue) {\n  return binn_map_get(map, id, BINN_INT32, pvalue, NULL);\n}",
        "definition_length": 137,
        "comment": ""
      },
      {
        "name": "binn_map_get_int64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "int64 *pvalue"
        ],
        "is_static": false,
        "start_line": 826,
        "end_line": 828,
        "start_byte": 34078,
        "end_byte": 34217,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_int64(const void *map, int id, int64 *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_int64(const void *map, int id, int64 *pvalue) {\n  return binn_map_get(map, id, BINN_INT64, pvalue, NULL);\n}",
        "definition_length": 139,
        "comment": ""
      },
      {
        "name": "binn_map_get_uint8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "unsigned char *pvalue"
        ],
        "is_static": false,
        "start_line": 829,
        "end_line": 831,
        "start_byte": 34218,
        "end_byte": 34365,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_uint8(const void *map, int id, unsigned char *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_uint8(const void *map, int id, unsigned char *pvalue) {\n  return binn_map_get(map, id, BINN_UINT8, pvalue, NULL);\n}",
        "definition_length": 147,
        "comment": ""
      },
      {
        "name": "binn_map_get_uint16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "unsigned short *pvalue"
        ],
        "is_static": false,
        "start_line": 832,
        "end_line": 834,
        "start_byte": 34366,
        "end_byte": 34516,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_uint16(const void *map, int id, unsigned short *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_uint16(const void *map, int id, unsigned short *pvalue) {\n  return binn_map_get(map, id, BINN_UINT16, pvalue, NULL);\n}",
        "definition_length": 150,
        "comment": ""
      },
      {
        "name": "binn_map_get_uint32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "unsigned int *pvalue"
        ],
        "is_static": false,
        "start_line": 835,
        "end_line": 837,
        "start_byte": 34517,
        "end_byte": 34665,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_uint32(const void *map, int id, unsigned int *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_uint32(const void *map, int id, unsigned int *pvalue) {\n  return binn_map_get(map, id, BINN_UINT32, pvalue, NULL);\n}",
        "definition_length": 148,
        "comment": ""
      },
      {
        "name": "binn_map_get_uint64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "uint64 *pvalue"
        ],
        "is_static": false,
        "start_line": 838,
        "end_line": 840,
        "start_byte": 34666,
        "end_byte": 34808,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_uint64(const void *map, int id, uint64 *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_uint64(const void *map, int id, uint64 *pvalue) {\n  return binn_map_get(map, id, BINN_UINT64, pvalue, NULL);\n}",
        "definition_length": 142,
        "comment": ""
      },
      {
        "name": "binn_map_get_float",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "float *pvalue"
        ],
        "is_static": false,
        "start_line": 841,
        "end_line": 843,
        "start_byte": 34809,
        "end_byte": 34950,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_float(const void *map, int id, float *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_float(const void *map, int id, float *pvalue) {\n  return binn_map_get(map, id, BINN_FLOAT32, pvalue, NULL);\n}",
        "definition_length": 141,
        "comment": ""
      },
      {
        "name": "binn_map_get_double",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "double *pvalue"
        ],
        "is_static": false,
        "start_line": 844,
        "end_line": 846,
        "start_byte": 34951,
        "end_byte": 35094,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_double(const void *map, int id, double *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_double(const void *map, int id, double *pvalue) {\n  return binn_map_get(map, id, BINN_FLOAT64, pvalue, NULL);\n}",
        "definition_length": 143,
        "comment": ""
      },
      {
        "name": "binn_map_get_bool",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "BOOL *pvalue"
        ],
        "is_static": false,
        "start_line": 847,
        "end_line": 849,
        "start_byte": 35095,
        "end_byte": 35231,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_bool(const void *map, int id, BOOL *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_bool(const void *map, int id, BOOL *pvalue) {\n  return binn_map_get(map, id, BINN_BOOL, pvalue, NULL);\n}",
        "definition_length": 136,
        "comment": ""
      },
      {
        "name": "binn_map_get_str",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "char **pvalue"
        ],
        "is_static": false,
        "start_line": 850,
        "end_line": 852,
        "start_byte": 35232,
        "end_byte": 35370,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_str(const void *map, int id, char **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_str(const void *map, int id, char **pvalue) {\n  return binn_map_get(map, id, BINN_STRING, pvalue, NULL);\n}",
        "definition_length": 138,
        "comment": ""
      },
      {
        "name": "binn_map_get_blob",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "void **pvalue",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 853,
        "end_line": 855,
        "start_byte": 35371,
        "end_byte": 35521,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_blob(const void *map, int id, void **pvalue, int *psize)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_blob(const void *map, int id, void **pvalue, int *psize) {\n  return binn_map_get(map, id, BINN_BLOB, pvalue, psize);\n}",
        "definition_length": 150,
        "comment": ""
      },
      {
        "name": "binn_map_get_list",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 856,
        "end_line": 858,
        "start_byte": 35522,
        "end_byte": 35659,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_list(const void *map, int id, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_list(const void *map, int id, void **pvalue) {\n  return binn_map_get(map, id, BINN_LIST, pvalue, NULL);\n}",
        "definition_length": 137,
        "comment": ""
      },
      {
        "name": "binn_map_get_map",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 859,
        "end_line": 861,
        "start_byte": 35660,
        "end_byte": 35795,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_map(const void *map, int id, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_map(const void *map, int id, void **pvalue) {\n  return binn_map_get(map, id, BINN_MAP, pvalue, NULL);\n}",
        "definition_length": 135,
        "comment": ""
      },
      {
        "name": "binn_map_get_object",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *map",
          "int id",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 862,
        "end_line": 864,
        "start_byte": 35796,
        "end_byte": 35937,
        "signature": "ALWAYS_INLINE BOOL binn_map_get_object(const void *map, int id, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_map_get_object(const void *map, int id, void **pvalue) {\n  return binn_map_get(map, id, BINN_OBJECT, pvalue, NULL);\n}",
        "definition_length": 141,
        "comment": ""
      },
      {
        "name": "binn_object_get_int8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "signed char *pvalue"
        ],
        "is_static": false,
        "start_line": 871,
        "end_line": 873,
        "start_byte": 36095,
        "end_byte": 36254,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_int8(const void *obj, const char *key, signed char *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_int8(const void *obj, const char *key, signed char *pvalue) {\n  return binn_object_get(obj, key, BINN_INT8, pvalue, NULL);\n}",
        "definition_length": 159,
        "comment": "usage: if (binn_object_get_int32(obj, \"key\", &value) == FALSE) xxx;"
      },
      {
        "name": "binn_object_get_int16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "short *pvalue"
        ],
        "is_static": false,
        "start_line": 874,
        "end_line": 876,
        "start_byte": 36255,
        "end_byte": 36410,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_int16(const void *obj, const char *key, short *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_int16(const void *obj, const char *key, short *pvalue) {\n  return binn_object_get(obj, key, BINN_INT16, pvalue, NULL);\n}",
        "definition_length": 155,
        "comment": ""
      },
      {
        "name": "binn_object_get_int32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "int *pvalue"
        ],
        "is_static": false,
        "start_line": 877,
        "end_line": 879,
        "start_byte": 36411,
        "end_byte": 36564,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_int32(const void *obj, const char *key, int *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_int32(const void *obj, const char *key, int *pvalue) {\n  return binn_object_get(obj, key, BINN_INT32, pvalue, NULL);\n}",
        "definition_length": 153,
        "comment": ""
      },
      {
        "name": "binn_object_get_int64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "int64 *pvalue"
        ],
        "is_static": false,
        "start_line": 880,
        "end_line": 882,
        "start_byte": 36565,
        "end_byte": 36720,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_int64(const void *obj, const char *key, int64 *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_int64(const void *obj, const char *key, int64 *pvalue) {\n  return binn_object_get(obj, key, BINN_INT64, pvalue, NULL);\n}",
        "definition_length": 155,
        "comment": ""
      },
      {
        "name": "binn_object_get_uint8",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "unsigned char *pvalue"
        ],
        "is_static": false,
        "start_line": 883,
        "end_line": 885,
        "start_byte": 36721,
        "end_byte": 36884,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_uint8(const void *obj, const char *key, unsigned char *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_uint8(const void *obj, const char *key, unsigned char *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT8, pvalue, NULL);\n}",
        "definition_length": 163,
        "comment": ""
      },
      {
        "name": "binn_object_get_uint16",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "unsigned short *pvalue"
        ],
        "is_static": false,
        "start_line": 886,
        "end_line": 888,
        "start_byte": 36885,
        "end_byte": 37051,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_uint16(const void *obj, const char *key, unsigned short *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_uint16(const void *obj, const char *key, unsigned short *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT16, pvalue, NULL);\n}",
        "definition_length": 166,
        "comment": ""
      },
      {
        "name": "binn_object_get_uint32",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "unsigned int *pvalue"
        ],
        "is_static": false,
        "start_line": 889,
        "end_line": 891,
        "start_byte": 37052,
        "end_byte": 37216,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_uint32(const void *obj, const char *key, unsigned int *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_uint32(const void *obj, const char *key, unsigned int *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT32, pvalue, NULL);\n}",
        "definition_length": 164,
        "comment": ""
      },
      {
        "name": "binn_object_get_uint64",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "uint64 *pvalue"
        ],
        "is_static": false,
        "start_line": 892,
        "end_line": 894,
        "start_byte": 37217,
        "end_byte": 37375,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_uint64(const void *obj, const char *key, uint64 *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_uint64(const void *obj, const char *key, uint64 *pvalue) {\n  return binn_object_get(obj, key, BINN_UINT64, pvalue, NULL);\n}",
        "definition_length": 158,
        "comment": ""
      },
      {
        "name": "binn_object_get_float",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "float *pvalue"
        ],
        "is_static": false,
        "start_line": 895,
        "end_line": 897,
        "start_byte": 37376,
        "end_byte": 37533,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_float(const void *obj, const char *key, float *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_float(const void *obj, const char *key, float *pvalue) {\n  return binn_object_get(obj, key, BINN_FLOAT32, pvalue, NULL);\n}",
        "definition_length": 157,
        "comment": ""
      },
      {
        "name": "binn_object_get_double",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "double *pvalue"
        ],
        "is_static": false,
        "start_line": 898,
        "end_line": 900,
        "start_byte": 37534,
        "end_byte": 37693,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_double(const void *obj, const char *key, double *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_double(const void *obj, const char *key, double *pvalue) {\n  return binn_object_get(obj, key, BINN_FLOAT64, pvalue, NULL);\n}",
        "definition_length": 159,
        "comment": ""
      },
      {
        "name": "binn_object_get_bool",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "BOOL *pvalue"
        ],
        "is_static": false,
        "start_line": 901,
        "end_line": 903,
        "start_byte": 37694,
        "end_byte": 37846,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_bool(const void *obj, const char *key, BOOL *pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_bool(const void *obj, const char *key, BOOL *pvalue) {\n  return binn_object_get(obj, key, BINN_BOOL, pvalue, NULL);\n}",
        "definition_length": 152,
        "comment": ""
      },
      {
        "name": "binn_object_get_str",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "char **pvalue"
        ],
        "is_static": false,
        "start_line": 904,
        "end_line": 906,
        "start_byte": 37847,
        "end_byte": 38001,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_str(const void *obj, const char *key, char **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_str(const void *obj, const char *key, char **pvalue) {\n  return binn_object_get(obj, key, BINN_STRING, pvalue, NULL);\n}",
        "definition_length": 154,
        "comment": ""
      },
      {
        "name": "binn_object_get_blob",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "void **pvalue",
          "int *psize"
        ],
        "is_static": false,
        "start_line": 907,
        "end_line": 909,
        "start_byte": 38002,
        "end_byte": 38168,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_blob(const void *obj, const char *key, void **pvalue, int *psize)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_blob(const void *obj, const char *key, void **pvalue, int *psize) {\n  return binn_object_get(obj, key, BINN_BLOB, pvalue, psize);\n}",
        "definition_length": 166,
        "comment": ""
      },
      {
        "name": "binn_object_get_list",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 910,
        "end_line": 912,
        "start_byte": 38169,
        "end_byte": 38322,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_list(const void *obj, const char *key, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_list(const void *obj, const char *key, void **pvalue) {\n  return binn_object_get(obj, key, BINN_LIST, pvalue, NULL);\n}",
        "definition_length": 153,
        "comment": ""
      },
      {
        "name": "binn_object_get_map",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 913,
        "end_line": 915,
        "start_byte": 38323,
        "end_byte": 38474,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_map(const void *obj, const char *key, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_map(const void *obj, const char *key, void **pvalue) {\n  return binn_object_get(obj, key, BINN_MAP, pvalue, NULL);\n}",
        "definition_length": 151,
        "comment": ""
      },
      {
        "name": "binn_object_get_object",
        "type": "definition",
        "return_type": "ALWAYS_INLINE",
        "parameters": [
          "const void *obj",
          "const char *key",
          "void **pvalue"
        ],
        "is_static": false,
        "start_line": 916,
        "end_line": 918,
        "start_byte": 38475,
        "end_byte": 38632,
        "signature": "ALWAYS_INLINE BOOL binn_object_get_object(const void *obj, const char *key, void **pvalue)",
        "full_definition": "ALWAYS_INLINE BOOL binn_object_get_object(const void *obj, const char *key, void **pvalue) {\n  return binn_object_get(obj, key, BINN_OBJECT, pvalue, NULL);\n}",
        "definition_length": 157,
        "comment": ""
      },
      {
        "name": "binn_get_int32",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "int *pint"
        ],
        "start_line": 922,
        "end_line": 922,
        "start_byte": 38713,
        "end_byte": 38768,
        "full_declaration": "BOOL   APIENTRY binn_get_int32(binn *value, int *pint);",
        "declaration_length": 55,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_get_int64",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "int64 *pint"
        ],
        "start_line": 923,
        "end_line": 923,
        "start_byte": 38769,
        "end_byte": 38826,
        "full_declaration": "BOOL   APIENTRY binn_get_int64(binn *value, int64 *pint);",
        "declaration_length": 57,
        "comment": "*************************************************************************"
      },
      {
        "name": "binn_get_double",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "double *pfloat"
        ],
        "start_line": 924,
        "end_line": 924,
        "start_byte": 38827,
        "end_byte": 38888,
        "full_declaration": "BOOL   APIENTRY binn_get_double(binn *value, double *pfloat);",
        "declaration_length": 61,
        "comment": ""
      },
      {
        "name": "binn_get_bool",
        "type": "declaration",
        "return_type": "BOOL",
        "parameters": [
          "binn *value",
          "BOOL *pbool"
        ],
        "start_line": 925,
        "end_line": 925,
        "start_byte": 38889,
        "end_byte": 38945,
        "full_declaration": "BOOL   APIENTRY binn_get_bool(binn *value, BOOL *pbool);",
        "declaration_length": 56,
        "comment": ""
      },
      {
        "name": "binn_get_str",
        "type": "declaration",
        "return_type": "char",
        "parameters": [
          "binn *value"
        ],
        "start_line": 926,
        "end_line": 926,
        "start_byte": 38946,
        "end_byte": 38988,
        "full_declaration": "char * APIENTRY binn_get_str(binn *value);",
        "declaration_length": 42,
        "comment": ""
      }
    ],
    "structs": [
      {
        "name": "binn_struct",
        "start_line": 203,
        "end_line": 245,
        "start_byte": 5885,
        "end_byte": 7100,
        "full_definition": "struct binn_struct {\n  int    header;     // this struct header holds the magic number (BINN_MAGIC) that identifies this memory block as a binn structure\n  BOOL   allocated;  // the struct can be allocated using malloc_fn() or can be on the stack\n  BOOL   writable;   // did it was create for writing? it can use the pbuf if not unified with ptr\n  BOOL   dirty;      // the container header is not written to the buffer\n  //\n  void  *pbuf;       // use *ptr below?\n  BOOL   pre_allocated;\n  int    alloc_size;\n  int    used_size;\n  //\n  int    type;\n  void  *ptr;\n  int    size;\n  int    count;\n  //\n  binn_mem_free freefn;  // used only when type == BINN_STRING or BINN_BLOB\n  //\n  union {\n    signed char    vint8;\n    signed short   vint16;\n    signed int     vint32;\n    int64          vint64;\n    unsigned char  vuint8;\n    unsigned short vuint16;\n    unsigned int   vuint32;\n    uint64         vuint64;\n    //\n    signed char    vchar;\n    unsigned char  vuchar;\n    signed short   vshort;\n    unsigned short vushort;\n    signed int     vint;\n    unsigned int   vuint;\n    //\n    float          vfloat;\n    double         vdouble;\n    //\n    BOOL           vbool;\n  };\n  //\n  BOOL   disable_int_compression;\n}",
        "fields": [
          {
            "text": "int    header;",
            "line": 204,
            "start_line": 204,
            "end_line": 204,
            "start_byte": 5908,
            "end_byte": 5922
          },
          {
            "text": "BOOL   allocated;",
            "line": 205,
            "start_line": 205,
            "end_line": 205,
            "start_byte": 6041,
            "end_byte": 6058
          },
          {
            "text": "BOOL   writable;",
            "line": 206,
            "start_line": 206,
            "end_line": 206,
            "start_byte": 6134,
            "end_byte": 6150
          },
          {
            "text": "BOOL   dirty;",
            "line": 207,
            "start_line": 207,
            "end_line": 207,
            "start_byte": 6233,
            "end_byte": 6246
          },
          {
            "text": "void  *pbuf;",
            "line": 209,
            "start_line": 209,
            "end_line": 209,
            "start_byte": 6312,
            "end_byte": 6324
          },
          {
            "text": "BOOL   pre_allocated;",
            "line": 210,
            "start_line": 210,
            "end_line": 210,
            "start_byte": 6352,
            "end_byte": 6373
          },
          {
            "text": "int    alloc_size;",
            "line": 211,
            "start_line": 211,
            "end_line": 211,
            "start_byte": 6376,
            "end_byte": 6394
          },
          {
            "text": "int    used_size;",
            "line": 212,
            "start_line": 212,
            "end_line": 212,
            "start_byte": 6397,
            "end_byte": 6414
          },
          {
            "text": "int    type;",
            "line": 214,
            "start_line": 214,
            "end_line": 214,
            "start_byte": 6422,
            "end_byte": 6434
          },
          {
            "text": "void  *ptr;",
            "line": 215,
            "start_line": 215,
            "end_line": 215,
            "start_byte": 6437,
            "end_byte": 6448
          },
          {
            "text": "int    size;",
            "line": 216,
            "start_line": 216,
            "end_line": 216,
            "start_byte": 6451,
            "end_byte": 6463
          },
          {
            "text": "int    count;",
            "line": 217,
            "start_line": 217,
            "end_line": 217,
            "start_byte": 6466,
            "end_byte": 6479
          },
          {
            "text": "binn_mem_free freefn;",
            "line": 219,
            "start_line": 219,
            "end_line": 219,
            "start_byte": 6487,
            "end_byte": 6508
          },
          {
            "text": "union {\n    signed char    vint8;\n    signed short   vint16;\n    signed int     vint32;\n    int64          vint64;\n    unsigned char  vuint8;\n    unsigned short vuint16;\n    unsigned int   vuint32;\n    uint64         vuint64;\n    //\n    signed char    vchar;\n    unsigned char  vuchar;\n    signed short   vshort;\n    unsigned short vushort;\n    signed int     vint;\n    unsigned int   vuint;\n    //\n    float          vfloat;\n    double         vdouble;\n    //\n    BOOL           vbool;\n  };",
            "line": 221,
            "start_line": 221,
            "end_line": 242,
            "start_byte": 6568,
            "end_byte": 7059
          },
          {
            "text": "signed char    vint8;",
            "line": 222,
            "start_line": 222,
            "end_line": 222,
            "start_byte": 6580,
            "end_byte": 6601
          },
          {
            "text": "signed short   vint16;",
            "line": 223,
            "start_line": 223,
            "end_line": 223,
            "start_byte": 6606,
            "end_byte": 6628
          },
          {
            "text": "signed int     vint32;",
            "line": 224,
            "start_line": 224,
            "end_line": 224,
            "start_byte": 6633,
            "end_byte": 6655
          },
          {
            "text": "int64          vint64;",
            "line": 225,
            "start_line": 225,
            "end_line": 225,
            "start_byte": 6660,
            "end_byte": 6682
          },
          {
            "text": "unsigned char  vuint8;",
            "line": 226,
            "start_line": 226,
            "end_line": 226,
            "start_byte": 6687,
            "end_byte": 6709
          },
          {
            "text": "unsigned short vuint16;",
            "line": 227,
            "start_line": 227,
            "end_line": 227,
            "start_byte": 6714,
            "end_byte": 6737
          },
          {
            "text": "unsigned int   vuint32;",
            "line": 228,
            "start_line": 228,
            "end_line": 228,
            "start_byte": 6742,
            "end_byte": 6765
          },
          {
            "text": "uint64         vuint64;",
            "line": 229,
            "start_line": 229,
            "end_line": 229,
            "start_byte": 6770,
            "end_byte": 6793
          },
          {
            "text": "signed char    vchar;",
            "line": 231,
            "start_line": 231,
            "end_line": 231,
            "start_byte": 6805,
            "end_byte": 6826
          },
          {
            "text": "unsigned char  vuchar;",
            "line": 232,
            "start_line": 232,
            "end_line": 232,
            "start_byte": 6831,
            "end_byte": 6853
          },
          {
            "text": "signed short   vshort;",
            "line": 233,
            "start_line": 233,
            "end_line": 233,
            "start_byte": 6858,
            "end_byte": 6880
          },
          {
            "text": "unsigned short vushort;",
            "line": 234,
            "start_line": 234,
            "end_line": 234,
            "start_byte": 6885,
            "end_byte": 6908
          },
          {
            "text": "signed int     vint;",
            "line": 235,
            "start_line": 235,
            "end_line": 235,
            "start_byte": 6913,
            "end_byte": 6933
          },
          {
            "text": "unsigned int   vuint;",
            "line": 236,
            "start_line": 236,
            "end_line": 236,
            "start_byte": 6938,
            "end_byte": 6959
          },
          {
            "text": "float          vfloat;",
            "line": 238,
            "start_line": 238,
            "end_line": 238,
            "start_byte": 6971,
            "end_byte": 6993
          },
          {
            "text": "double         vdouble;",
            "line": 239,
            "start_line": 239,
            "end_line": 239,
            "start_byte": 6998,
            "end_byte": 7021
          },
          {
            "text": "BOOL           vbool;",
            "line": 241,
            "start_line": 241,
            "end_line": 241,
            "start_byte": 7033,
            "end_byte": 7054
          },
          {
            "text": "BOOL   disable_int_compression;",
            "line": 244,
            "start_line": 244,
            "end_line": 244,
            "start_byte": 7067,
            "end_byte": 7098
          }
        ],
        "definition_length": 1215,
        "comment": "--- BINN STRUCTURE --------------------------------------------------------------"
      }
    ],
    "includes": [
      {
        "text": "#include <stddef.h>",
        "line": 14,
        "start_line": 14,
        "end_line": 15,
        "start_byte": 345,
        "end_byte": 365
      }
    ],
    "variables": [],
    "typedefs": [
      {
        "text": "typedef int BOOL;",
        "name": "BOOL",
        "line": 35,
        "start_line": 35,
        "end_line": 35,
        "start_byte": 616,
        "end_byte": 633,
        "comment": ""
      },
      {
        "text": "typedef __int64 int64;",
        "name": "int64",
        "line": 60,
        "start_line": 60,
        "end_line": 60,
        "start_byte": 1128,
        "end_byte": 1150,
        "comment": ""
      },
      {
        "text": "typedef unsigned __int64 uint64;",
        "name": "uint64",
        "line": 61,
        "start_line": 61,
        "end_line": 61,
        "start_byte": 1153,
        "end_byte": 1185,
        "comment": ""
      },
      {
        "text": "typedef long long int int64;",
        "name": "int64",
        "line": 63,
        "start_line": 63,
        "end_line": 63,
        "start_byte": 1194,
        "end_byte": 1222,
        "comment": ""
      },
      {
        "text": "typedef unsigned long long int uint64;",
        "name": "uint64",
        "line": 64,
        "start_line": 64,
        "end_line": 64,
        "start_byte": 1225,
        "end_byte": 1263,
        "comment": ""
      },
      {
        "text": "typedef void (*binn_mem_free)(void*);",
        "name": "binn_mem_free",
        "line": 195,
        "start_line": 195,
        "end_line": 195,
        "start_byte": 5669,
        "end_byte": 5706,
        "comment": ""
      },
      {
        "text": "typedef struct binn_struct binn;",
        "name": "binn",
        "line": 247,
        "start_line": 247,
        "end_line": 247,
        "start_byte": 7103,
        "end_byte": 7135,
        "comment": ""
      },
      {
        "text": "typedef struct binn_iter_struct {\n    unsigned char *pnext;\n    unsigned char *plimit;\n    int   type;\n    int   count;\n    int   current;\n} binn_iter;",
        "name": "binn_iter",
        "line": 488,
        "start_line": 488,
        "end_line": 494,
        "start_byte": 18485,
        "end_byte": 18636,
        "comment": "SEQUENTIAL READ FUNCTIONS"
      }
    ],
    "macros": [
      {
        "text": "#define BINN_H",
        "name": "BINN_H",
        "line": 8,
        "start_line": 8,
        "end_line": 9,
        "start_byte": 289,
        "end_byte": 304,
        "comment": "'Link Time Code Generation' (/LTCG) linker option to be enabled too"
      },
      {
        "text": "#define BINN_VERSION \"3.0.0\"  /* using semantic versioning */",
        "name": "BINN_VERSION",
        "line": 16,
        "start_line": 16,
        "end_line": 17,
        "start_byte": 366,
        "end_byte": 428,
        "comment": ""
      },
      {
        "text": "#define NULL    0",
        "name": "NULL",
        "line": 20,
        "start_line": 20,
        "end_line": 21,
        "start_byte": 461,
        "end_byte": 479,
        "comment": ""
      },
      {
        "text": "#define NULL    ((void *)0)",
        "name": "NULL",
        "line": 22,
        "start_line": 22,
        "end_line": 23,
        "start_byte": 485,
        "end_byte": 513,
        "comment": ""
      },
      {
        "text": "#define TRUE  1",
        "name": "TRUE",
        "line": 27,
        "start_line": 27,
        "end_line": 28,
        "start_byte": 541,
        "end_byte": 557,
        "comment": ""
      },
      {
        "text": "#define FALSE 0",
        "name": "FALSE",
        "line": 31,
        "start_line": 31,
        "end_line": 32,
        "start_byte": 579,
        "end_byte": 595,
        "comment": ""
      },
      {
        "text": "#define APIENTRY __stdcall",
        "name": "APIENTRY",
        "line": 40,
        "start_line": 40,
        "end_line": 41,
        "start_byte": 676,
        "end_byte": 703,
        "comment": ""
      },
      {
        "text": "#define APIENTRY \n #endif",
        "name": "APIENTRY",
        "line": 43,
        "start_line": 43,
        "end_line": 45,
        "start_byte": 758,
        "end_byte": 784,
        "comment": "#define APIENTRY __attribute__((stdcall))"
      },
      {
        "text": "#define BINN_PRIVATE \n\n#ifdef _MSC_VER",
        "name": "BINN_PRIVATE",
        "line": 47,
        "start_line": 47,
        "end_line": 50,
        "start_byte": 792,
        "end_byte": 831,
        "comment": ""
      },
      {
        "text": "#define INLINE         __inline",
        "name": "INLINE",
        "line": 50,
        "start_line": 50,
        "end_line": 51,
        "start_byte": 833,
        "end_byte": 865,
        "comment": ""
      },
      {
        "text": "#define ALWAYS_INLINE  __forceinline",
        "name": "ALWAYS_INLINE",
        "line": 51,
        "start_line": 51,
        "end_line": 52,
        "start_byte": 867,
        "end_byte": 904,
        "comment": ""
      },
      {
        "text": "#define INLINE         static inline",
        "name": "INLINE",
        "line": 54,
        "start_line": 54,
        "end_line": 55,
        "start_byte": 981,
        "end_byte": 1018,
        "comment": "you can change to 'extern inline' if using the gcc option -flto"
      },
      {
        "text": "#define ALWAYS_INLINE  static inline",
        "name": "ALWAYS_INLINE",
        "line": 55,
        "start_line": 55,
        "end_line": 56,
        "start_byte": 1020,
        "end_byte": 1057,
        "comment": "you can change to 'extern inline' if using the gcc option -flto"
      },
      {
        "text": "#define INT64_FORMAT  \"I64i\"",
        "name": "INT64_FORMAT",
        "line": 69,
        "start_line": 69,
        "end_line": 70,
        "start_byte": 1293,
        "end_byte": 1322,
        "comment": ""
      },
      {
        "text": "#define UINT64_FORMAT \"I64u\"",
        "name": "UINT64_FORMAT",
        "line": 70,
        "start_line": 70,
        "end_line": 71,
        "start_byte": 1322,
        "end_byte": 1351,
        "comment": ""
      },
      {
        "text": "#define INT64_HEX_FORMAT  \"I64x\"",
        "name": "INT64_HEX_FORMAT",
        "line": 71,
        "start_line": 71,
        "end_line": 72,
        "start_byte": 1351,
        "end_byte": 1384,
        "comment": ""
      },
      {
        "text": "#define INT64_FORMAT  \"lli\"",
        "name": "INT64_FORMAT",
        "line": 73,
        "start_line": 73,
        "end_line": 74,
        "start_byte": 1390,
        "end_byte": 1418,
        "comment": ""
      },
      {
        "text": "#define UINT64_FORMAT \"llu\"",
        "name": "UINT64_FORMAT",
        "line": 74,
        "start_line": 74,
        "end_line": 75,
        "start_byte": 1418,
        "end_byte": 1446,
        "comment": ""
      },
      {
        "text": "#define INT64_HEX_FORMAT  \"llx\"",
        "name": "INT64_HEX_FORMAT",
        "line": 75,
        "start_line": 75,
        "end_line": 76,
        "start_byte": 1446,
        "end_byte": 1478,
        "comment": ""
      },
      {
        "text": "#define INVALID_BINN         0",
        "name": "INVALID_BINN",
        "line": 81,
        "start_line": 81,
        "end_line": 82,
        "start_byte": 1548,
        "end_byte": 1579,
        "comment": "BINN CONSTANTS  ----------------------------------------"
      },
      {
        "text": "#define BINN_STORAGE_NOBYTES   0x00",
        "name": "BINN_STORAGE_NOBYTES",
        "line": 85,
        "start_line": 85,
        "end_line": 86,
        "start_byte": 1641,
        "end_byte": 1677,
        "comment": "Storage Data Types  ------------------------------------"
      },
      {
        "text": "#define BINN_STORAGE_BYTE      0x20  //  8 bits",
        "name": "BINN_STORAGE_BYTE",
        "line": 86,
        "start_line": 86,
        "end_line": 87,
        "start_byte": 1677,
        "end_byte": 1725,
        "comment": "Storage Data Types  ------------------------------------"
      },
      {
        "text": "#define BINN_STORAGE_WORD      0x40  // 16 bits -- the endianess (byte order) is automatically corrected",
        "name": "BINN_STORAGE_WORD",
        "line": 87,
        "start_line": 87,
        "end_line": 88,
        "start_byte": 1725,
        "end_byte": 1830,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_DWORD     0x60  // 32 bits -- the endianess (byte order) is automatically corrected",
        "name": "BINN_STORAGE_DWORD",
        "line": 88,
        "start_line": 88,
        "end_line": 89,
        "start_byte": 1830,
        "end_byte": 1935,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_QWORD     0x80  // 64 bits -- the endianess (byte order) is automatically corrected",
        "name": "BINN_STORAGE_QWORD",
        "line": 89,
        "start_line": 89,
        "end_line": 90,
        "start_byte": 1935,
        "end_byte": 2040,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_STRING    0xA0  // Are stored with null termination",
        "name": "BINN_STORAGE_STRING",
        "line": 90,
        "start_line": 90,
        "end_line": 91,
        "start_byte": 2040,
        "end_byte": 2113,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_BLOB      0xC0",
        "name": "BINN_STORAGE_BLOB",
        "line": 91,
        "start_line": 91,
        "end_line": 92,
        "start_byte": 2113,
        "end_byte": 2149,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_CONTAINER 0xE0",
        "name": "BINN_STORAGE_CONTAINER",
        "line": 92,
        "start_line": 92,
        "end_line": 93,
        "start_byte": 2149,
        "end_byte": 2185,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_VIRTUAL   0x80000",
        "name": "BINN_STORAGE_VIRTUAL",
        "line": 93,
        "start_line": 93,
        "end_line": 94,
        "start_byte": 2185,
        "end_byte": 2224,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_MIN       BINN_STORAGE_NOBYTES",
        "name": "BINN_STORAGE_MIN",
        "line": 95,
        "start_line": 95,
        "end_line": 96,
        "start_byte": 2225,
        "end_byte": 2277,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_MAX       BINN_STORAGE_CONTAINER",
        "name": "BINN_STORAGE_MAX",
        "line": 96,
        "start_line": 96,
        "end_line": 97,
        "start_byte": 2277,
        "end_byte": 2331,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_MASK      0xE0",
        "name": "BINN_STORAGE_MASK",
        "line": 98,
        "start_line": 98,
        "end_line": 99,
        "start_byte": 2332,
        "end_byte": 2368,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_MASK16    0xE000",
        "name": "BINN_STORAGE_MASK16",
        "line": 99,
        "start_line": 99,
        "end_line": 100,
        "start_byte": 2368,
        "end_byte": 2406,
        "comment": ""
      },
      {
        "text": "#define BINN_STORAGE_HAS_MORE  0x10",
        "name": "BINN_STORAGE_HAS_MORE",
        "line": 100,
        "start_line": 100,
        "end_line": 101,
        "start_byte": 2406,
        "end_byte": 2442,
        "comment": ""
      },
      {
        "text": "#define BINN_TYPE_MASK         0x0F",
        "name": "BINN_TYPE_MASK",
        "line": 101,
        "start_line": 101,
        "end_line": 102,
        "start_byte": 2442,
        "end_byte": 2478,
        "comment": ""
      },
      {
        "text": "#define BINN_TYPE_MASK16       0x0FFF",
        "name": "BINN_TYPE_MASK16",
        "line": 102,
        "start_line": 102,
        "end_line": 103,
        "start_byte": 2478,
        "end_byte": 2516,
        "comment": ""
      },
      {
        "text": "#define BINN_MAX_VALUE_MASK    0xFFFFF",
        "name": "BINN_MAX_VALUE_MASK",
        "line": 104,
        "start_line": 104,
        "end_line": 105,
        "start_byte": 2517,
        "end_byte": 2556,
        "comment": ""
      },
      {
        "text": "#define BINN_LIST      0xE0",
        "name": "BINN_LIST",
        "line": 109,
        "start_line": 109,
        "end_line": 110,
        "start_byte": 2619,
        "end_byte": 2647,
        "comment": "Data Formats  ------------------------------------------"
      },
      {
        "text": "#define BINN_MAP       0xE1",
        "name": "BINN_MAP",
        "line": 110,
        "start_line": 110,
        "end_line": 111,
        "start_byte": 2647,
        "end_byte": 2675,
        "comment": "Data Formats  ------------------------------------------"
      },
      {
        "text": "#define BINN_OBJECT    0xE2",
        "name": "BINN_OBJECT",
        "line": 111,
        "start_line": 111,
        "end_line": 112,
        "start_byte": 2675,
        "end_byte": 2703,
        "comment": ""
      },
      {
        "text": "#define BINN_NULL      0x00",
        "name": "BINN_NULL",
        "line": 113,
        "start_line": 113,
        "end_line": 114,
        "start_byte": 2704,
        "end_byte": 2732,
        "comment": ""
      },
      {
        "text": "#define BINN_TRUE      0x01",
        "name": "BINN_TRUE",
        "line": 114,
        "start_line": 114,
        "end_line": 115,
        "start_byte": 2732,
        "end_byte": 2760,
        "comment": ""
      },
      {
        "text": "#define BINN_FALSE     0x02",
        "name": "BINN_FALSE",
        "line": 115,
        "start_line": 115,
        "end_line": 116,
        "start_byte": 2760,
        "end_byte": 2788,
        "comment": ""
      },
      {
        "text": "#define BINN_UINT8     0x20  // (BYTE) (unsigned byte) Is the default format for the BYTE type",
        "name": "BINN_UINT8",
        "line": 117,
        "start_line": 117,
        "end_line": 118,
        "start_byte": 2789,
        "end_byte": 2884,
        "comment": ""
      },
      {
        "text": "#define BINN_INT8      0x21  // (BYTE) (signed byte, from -128 to +127. The 0x80 is the sign bit, so the range in hex is from 0x80 [-128] to 0x7F [127], being 0x00 = 0 and 0xFF = -1)",
        "name": "BINN_INT8",
        "line": 118,
        "start_line": 118,
        "end_line": 119,
        "start_byte": 2884,
        "end_byte": 3067,
        "comment": ""
      },
      {
        "text": "#define BINN_UINT16    0x40  // (WORD) (unsigned integer) Is the default format for the WORD type",
        "name": "BINN_UINT16",
        "line": 119,
        "start_line": 119,
        "end_line": 120,
        "start_byte": 3067,
        "end_byte": 3165,
        "comment": ""
      },
      {
        "text": "#define BINN_INT16     0x41  // (WORD) (signed integer)",
        "name": "BINN_INT16",
        "line": 120,
        "start_line": 120,
        "end_line": 121,
        "start_byte": 3165,
        "end_byte": 3221,
        "comment": ""
      },
      {
        "text": "#define BINN_UINT32    0x60  // (DWORD) (unsigned integer) Is the default format for the DWORD type",
        "name": "BINN_UINT32",
        "line": 121,
        "start_line": 121,
        "end_line": 122,
        "start_byte": 3221,
        "end_byte": 3321,
        "comment": ""
      },
      {
        "text": "#define BINN_INT32     0x61  // (DWORD) (signed integer)",
        "name": "BINN_INT32",
        "line": 122,
        "start_line": 122,
        "end_line": 123,
        "start_byte": 3321,
        "end_byte": 3378,
        "comment": ""
      },
      {
        "text": "#define BINN_UINT64    0x80  // (QWORD) (unsigned integer) Is the default format for the QWORD type",
        "name": "BINN_UINT64",
        "line": 123,
        "start_line": 123,
        "end_line": 124,
        "start_byte": 3378,
        "end_byte": 3478,
        "comment": ""
      },
      {
        "text": "#define BINN_INT64     0x81  // (QWORD) (signed integer)",
        "name": "BINN_INT64",
        "line": 124,
        "start_line": 124,
        "end_line": 125,
        "start_byte": 3478,
        "end_byte": 3535,
        "comment": ""
      },
      {
        "text": "#define BINN_SCHAR     BINN_INT8",
        "name": "BINN_SCHAR",
        "line": 126,
        "start_line": 126,
        "end_line": 127,
        "start_byte": 3536,
        "end_byte": 3569,
        "comment": ""
      },
      {
        "text": "#define BINN_UCHAR     BINN_UINT8",
        "name": "BINN_UCHAR",
        "line": 127,
        "start_line": 127,
        "end_line": 128,
        "start_byte": 3569,
        "end_byte": 3603,
        "comment": ""
      },
      {
        "text": "#define BINN_STRING    0xA0  // (STRING) Raw String",
        "name": "BINN_STRING",
        "line": 129,
        "start_line": 129,
        "end_line": 130,
        "start_byte": 3604,
        "end_byte": 3656,
        "comment": ""
      },
      {
        "text": "#define BINN_DATETIME  0xA1  // (STRING) iso8601 format -- YYYY-MM-DD HH:MM:SS",
        "name": "BINN_DATETIME",
        "line": 130,
        "start_line": 130,
        "end_line": 131,
        "start_byte": 3656,
        "end_byte": 3735,
        "comment": ""
      },
      {
        "text": "#define BINN_DATE      0xA2  // (STRING) iso8601 format -- YYYY-MM-DD",
        "name": "BINN_DATE",
        "line": 131,
        "start_line": 131,
        "end_line": 132,
        "start_byte": 3735,
        "end_byte": 3805,
        "comment": ""
      },
      {
        "text": "#define BINN_TIME      0xA3  // (STRING) iso8601 format -- HH:MM:SS",
        "name": "BINN_TIME",
        "line": 132,
        "start_line": 132,
        "end_line": 133,
        "start_byte": 3805,
        "end_byte": 3873,
        "comment": ""
      },
      {
        "text": "#define BINN_DECIMAL   0xA4  // (STRING) High precision number - used for generic decimal values and for those ones that cannot be represented in the float64 format.",
        "name": "BINN_DECIMAL",
        "line": 133,
        "start_line": 133,
        "end_line": 134,
        "start_byte": 3873,
        "end_byte": 4039,
        "comment": ""
      },
      {
        "text": "#define BINN_CURRENCYSTR  0xA5  // (STRING) With currency unit/symbol - check for some iso standard format",
        "name": "BINN_CURRENCYSTR",
        "line": 134,
        "start_line": 134,
        "end_line": 135,
        "start_byte": 4039,
        "end_byte": 4146,
        "comment": ""
      },
      {
        "text": "#define BINN_SINGLE_STR   0xA6  // (STRING) Can be restored to float32",
        "name": "BINN_SINGLE_STR",
        "line": 135,
        "start_line": 135,
        "end_line": 136,
        "start_byte": 4146,
        "end_byte": 4217,
        "comment": ""
      },
      {
        "text": "#define BINN_DOUBLE_STR   0xA7  // (STRING) May be restored to float64",
        "name": "BINN_DOUBLE_STR",
        "line": 136,
        "start_line": 136,
        "end_line": 137,
        "start_byte": 4217,
        "end_byte": 4288,
        "comment": ""
      },
      {
        "text": "#define BINN_FLOAT32   0x62  // (DWORD)",
        "name": "BINN_FLOAT32",
        "line": 138,
        "start_line": 138,
        "end_line": 139,
        "start_byte": 4289,
        "end_byte": 4330,
        "comment": ""
      },
      {
        "text": "#define BINN_FLOAT64   0x82  // (QWORD)",
        "name": "BINN_FLOAT64",
        "line": 139,
        "start_line": 139,
        "end_line": 140,
        "start_byte": 4330,
        "end_byte": 4371,
        "comment": ""
      },
      {
        "text": "#define BINN_FLOAT     BINN_FLOAT32",
        "name": "BINN_FLOAT",
        "line": 140,
        "start_line": 140,
        "end_line": 141,
        "start_byte": 4371,
        "end_byte": 4407,
        "comment": ""
      },
      {
        "text": "#define BINN_SINGLE    BINN_FLOAT32",
        "name": "BINN_SINGLE",
        "line": 141,
        "start_line": 141,
        "end_line": 142,
        "start_byte": 4407,
        "end_byte": 4443,
        "comment": ""
      },
      {
        "text": "#define BINN_DOUBLE    BINN_FLOAT64",
        "name": "BINN_DOUBLE",
        "line": 142,
        "start_line": 142,
        "end_line": 143,
        "start_byte": 4443,
        "end_byte": 4479,
        "comment": ""
      },
      {
        "text": "#define BINN_CURRENCY  0x83  // (QWORD)",
        "name": "BINN_CURRENCY",
        "line": 144,
        "start_line": 144,
        "end_line": 145,
        "start_byte": 4480,
        "end_byte": 4520,
        "comment": ""
      },
      {
        "text": "#define BINN_BLOB      0xC0  // (BLOB) Raw Blob",
        "name": "BINN_BLOB",
        "line": 146,
        "start_line": 146,
        "end_line": 147,
        "start_byte": 4521,
        "end_byte": 4569,
        "comment": ""
      },
      {
        "text": "#define BINN_BOOL      0x80061  // (DWORD) The value may be 0 or 1",
        "name": "BINN_BOOL",
        "line": 151,
        "start_line": 151,
        "end_line": 152,
        "start_byte": 4590,
        "end_byte": 4657,
        "comment": "virtual types:"
      },
      {
        "text": "#define BINN_HTML      0xB001",
        "name": "BINN_HTML",
        "line": 166,
        "start_line": 166,
        "end_line": 167,
        "start_byte": 5011,
        "end_byte": 5041,
        "comment": "strings:"
      },
      {
        "text": "#define BINN_XML       0xB002",
        "name": "BINN_XML",
        "line": 167,
        "start_line": 167,
        "end_line": 168,
        "start_byte": 5041,
        "end_byte": 5071,
        "comment": "strings:"
      },
      {
        "text": "#define BINN_JSON      0xB003",
        "name": "BINN_JSON",
        "line": 168,
        "start_line": 168,
        "end_line": 169,
        "start_byte": 5071,
        "end_byte": 5101,
        "comment": ""
      },
      {
        "text": "#define BINN_JAVASCRIPT 0xB004",
        "name": "BINN_JAVASCRIPT",
        "line": 169,
        "start_line": 169,
        "end_line": 170,
        "start_byte": 5101,
        "end_byte": 5132,
        "comment": ""
      },
      {
        "text": "#define BINN_CSS       0xB005",
        "name": "BINN_CSS",
        "line": 170,
        "start_line": 170,
        "end_line": 171,
        "start_byte": 5132,
        "end_byte": 5162,
        "comment": ""
      },
      {
        "text": "#define BINN_JPEG      0xD001",
        "name": "BINN_JPEG",
        "line": 174,
        "start_line": 174,
        "end_line": 175,
        "start_byte": 5174,
        "end_byte": 5204,
        "comment": "blobs:"
      },
      {
        "text": "#define BINN_GIF       0xD002",
        "name": "BINN_GIF",
        "line": 175,
        "start_line": 175,
        "end_line": 176,
        "start_byte": 5204,
        "end_byte": 5234,
        "comment": "blobs:"
      },
      {
        "text": "#define BINN_PNG       0xD003",
        "name": "BINN_PNG",
        "line": 176,
        "start_line": 176,
        "end_line": 177,
        "start_byte": 5234,
        "end_byte": 5264,
        "comment": ""
      },
      {
        "text": "#define BINN_BMP       0xD004",
        "name": "BINN_BMP",
        "line": 177,
        "start_line": 177,
        "end_line": 178,
        "start_byte": 5264,
        "end_byte": 5294,
        "comment": ""
      },
      {
        "text": "#define BINN_FAMILY_NONE   0x00",
        "name": "BINN_FAMILY_NONE",
        "line": 181,
        "start_line": 181,
        "end_line": 182,
        "start_byte": 5313,
        "end_byte": 5345,
        "comment": "type families"
      },
      {
        "text": "#define BINN_FAMILY_NULL   0xf1",
        "name": "BINN_FAMILY_NULL",
        "line": 182,
        "start_line": 182,
        "end_line": 183,
        "start_byte": 5345,
        "end_byte": 5377,
        "comment": "type families"
      },
      {
        "text": "#define BINN_FAMILY_INT    0xf2",
        "name": "BINN_FAMILY_INT",
        "line": 183,
        "start_line": 183,
        "end_line": 184,
        "start_byte": 5377,
        "end_byte": 5409,
        "comment": "type families"
      },
      {
        "text": "#define BINN_FAMILY_FLOAT  0xf3",
        "name": "BINN_FAMILY_FLOAT",
        "line": 184,
        "start_line": 184,
        "end_line": 185,
        "start_byte": 5409,
        "end_byte": 5441,
        "comment": ""
      },
      {
        "text": "#define BINN_FAMILY_STRING 0xf4",
        "name": "BINN_FAMILY_STRING",
        "line": 185,
        "start_line": 185,
        "end_line": 186,
        "start_byte": 5441,
        "end_byte": 5473,
        "comment": ""
      },
      {
        "text": "#define BINN_FAMILY_BLOB   0xf5",
        "name": "BINN_FAMILY_BLOB",
        "line": 186,
        "start_line": 186,
        "end_line": 187,
        "start_byte": 5473,
        "end_byte": 5505,
        "comment": ""
      },
      {
        "text": "#define BINN_FAMILY_BOOL   0xf6",
        "name": "BINN_FAMILY_BOOL",
        "line": 187,
        "start_line": 187,
        "end_line": 188,
        "start_byte": 5505,
        "end_byte": 5537,
        "comment": ""
      },
      {
        "text": "#define BINN_FAMILY_BINN   0xf7",
        "name": "BINN_FAMILY_BINN",
        "line": 188,
        "start_line": 188,
        "end_line": 189,
        "start_byte": 5537,
        "end_byte": 5569,
        "comment": ""
      },
      {
        "text": "#define BINN_SIGNED_INT     11",
        "name": "BINN_SIGNED_INT",
        "line": 191,
        "start_line": 191,
        "end_line": 192,
        "start_byte": 5605,
        "end_byte": 5636,
        "comment": "integer types related to signal"
      },
      {
        "text": "#define BINN_UNSIGNED_INT   22",
        "name": "BINN_UNSIGNED_INT",
        "line": 192,
        "start_line": 192,
        "end_line": 193,
        "start_byte": 5636,
        "end_byte": 5667,
        "comment": "integer types related to signal"
      },
      {
        "text": "#define BINN_STATIC      ((binn_mem_free)0)",
        "name": "BINN_STATIC",
        "line": 196,
        "start_line": 196,
        "end_line": 197,
        "start_byte": 5707,
        "end_byte": 5751,
        "comment": ""
      },
      {
        "text": "#define BINN_TRANSIENT   ((binn_mem_free)-1)",
        "name": "BINN_TRANSIENT",
        "line": 197,
        "start_line": 197,
        "end_line": 198,
        "start_byte": 5751,
        "end_byte": 5796,
        "comment": ""
      },
      {
        "text": "#define binn_is_writable(item) (item)->writable;",
        "name": "binn_is_writable",
        "line": 520,
        "start_line": 520,
        "end_line": 521,
        "start_byte": 19950,
        "end_byte": 19999,
        "comment": "--- MACROS ------------------------------------------------------------"
      },
      {
        "text": "#define binn_set_null(item)         do { (item)->type = BINN_NULL; } while (0)",
        "name": "binn_set_null",
        "line": 525,
        "start_line": 525,
        "end_line": 526,
        "start_byte": 20051,
        "end_byte": 20130,
        "comment": "set values on stack allocated binn structures"
      },
      {
        "text": "#define binn_set_bool(item,value)   do { (item)->type = BINN_BOOL; (item)->vbool = value; (item)->ptr = &((item)->vbool); } while (0)",
        "name": "binn_set_bool",
        "line": 527,
        "start_line": 527,
        "end_line": 528,
        "start_byte": 20131,
        "end_byte": 20265,
        "comment": ""
      },
      {
        "text": "#define binn_set_int(item,value)    do { (item)->type = BINN_INT32; (item)->vint32 = value; (item)->ptr = &((item)->vint32); } while (0)",
        "name": "binn_set_int",
        "line": 529,
        "start_line": 529,
        "end_line": 530,
        "start_byte": 20266,
        "end_byte": 20403,
        "comment": ""
      },
      {
        "text": "#define binn_set_int64(item,value)  do { (item)->type = BINN_INT64; (item)->vint64 = value; (item)->ptr = &((item)->vint64); } while (0)",
        "name": "binn_set_int64",
        "line": 530,
        "start_line": 530,
        "end_line": 531,
        "start_byte": 20403,
        "end_byte": 20540,
        "comment": ""
      },
      {
        "text": "#define binn_set_uint(item,value)   do { (item)->type = BINN_UINT32; (item)->vuint32 = value; (item)->ptr = &((item)->vuint32); } while (0)",
        "name": "binn_set_uint",
        "line": 532,
        "start_line": 532,
        "end_line": 533,
        "start_byte": 20541,
        "end_byte": 20681,
        "comment": ""
      },
      {
        "text": "#define binn_set_uint64(item,value) do { (item)->type = BINN_UINT64; (item)->vuint64 = value; (item)->ptr = &((item)->vuint64); } while (0)",
        "name": "binn_set_uint64",
        "line": 533,
        "start_line": 533,
        "end_line": 534,
        "start_byte": 20681,
        "end_byte": 20821,
        "comment": ""
      },
      {
        "text": "#define binn_set_float(item,value)  do { (item)->type = BINN_FLOAT;  (item)->vfloat  = value; (item)->ptr = &((item)->vfloat); } while (0)",
        "name": "binn_set_float",
        "line": 535,
        "start_line": 535,
        "end_line": 536,
        "start_byte": 20822,
        "end_byte": 20961,
        "comment": ""
      },
      {
        "text": "#define binn_set_double(item,value) do { (item)->type = BINN_DOUBLE; (item)->vdouble = value; (item)->ptr = &((item)->vdouble); } while (0)",
        "name": "binn_set_double",
        "line": 536,
        "start_line": 536,
        "end_line": 537,
        "start_byte": 20961,
        "end_byte": 21101,
        "comment": ""
      },
      {
        "text": "#define binn_object_foreach(object, key, value)   \\\n    binn_iter_init(&iter, object, BINN_OBJECT);   \\\n    while (binn_object_next(&iter, key, &value))",
        "name": "binn_object_foreach",
        "line": 558,
        "start_line": 558,
        "end_line": 561,
        "start_byte": 21914,
        "end_byte": 22067,
        "comment": "char key[256];  // only for objects int  id;        // only for maps"
      },
      {
        "text": "#define binn_map_foreach(map, id, value)          \\\n    binn_iter_init(&iter, map, BINN_MAP);         \\\n    while (binn_map_next(&iter, &id, &value))",
        "name": "binn_map_foreach",
        "line": 562,
        "start_line": 562,
        "end_line": 565,
        "start_byte": 22068,
        "end_byte": 22218,
        "comment": ""
      },
      {
        "text": "#define binn_list_foreach(list, value)            \\\n    binn_iter_init(&iter, list, BINN_LIST);       \\\n    while (binn_list_next(&iter, &value))",
        "name": "binn_list_foreach",
        "line": 566,
        "start_line": 566,
        "end_line": 569,
        "start_byte": 22219,
        "end_byte": 22365,
        "comment": ""
      },
      {
        "text": "#define binn_object_foreach2(object, key, value)   \\\n    binn_iter_init(&iter2, object, BINN_OBJECT);   \\\n    while (binn_object_next(&iter2, key, &value))",
        "name": "binn_object_foreach2",
        "line": 576,
        "start_line": 576,
        "end_line": 579,
        "start_byte": 22615,
        "end_byte": 22771,
        "comment": "binn_iter iter, iter2;"
      },
      {
        "text": "#define binn_map_foreach2(map, id, value)          \\\n    binn_iter_init(&iter2, map, BINN_MAP);         \\\n    while (binn_map_next(&iter2, &id, &value))",
        "name": "binn_map_foreach2",
        "line": 580,
        "start_line": 580,
        "end_line": 583,
        "start_byte": 22772,
        "end_byte": 22925,
        "comment": ""
      },
      {
        "text": "#define binn_list_foreach2(list, value)            \\\n    binn_iter_init(&iter2, list, BINN_LIST);       \\\n    while (binn_list_next(&iter2, &value))",
        "name": "binn_list_foreach2",
        "line": 584,
        "start_line": 584,
        "end_line": 587,
        "start_byte": 22926,
        "end_byte": 23075,
        "comment": ""
      }
    ],
    "enums": [],
    "total_nodes": 9393,
    "file_size": 39160
  }
}